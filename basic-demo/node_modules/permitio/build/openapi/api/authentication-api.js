"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/openapi/api/authentication-api.ts
var authentication_api_exports = {};
__export(authentication_api_exports, {
  AuthenticationApi: () => AuthenticationApi,
  AuthenticationApiAxiosParamCreator: () => AuthenticationApiAxiosParamCreator,
  AuthenticationApiFactory: () => AuthenticationApiFactory,
  AuthenticationApiFp: () => AuthenticationApiFp
});
module.exports = __toCommonJS(authentication_api_exports);
var import_axios2 = __toESM(require("axios"));

// src/openapi/base.ts
var import_axios = __toESM(require("axios"));
var BASE_PATH = "http://localhost".replace(/\/+$/, "");
var BaseAPI = class {
  constructor(configuration, basePath = BASE_PATH, axios = import_axios.default) {
    this.basePath = basePath;
    this.axios = axios;
    if (configuration) {
      this.configuration = configuration;
      this.basePath = configuration.basePath || this.basePath;
    }
  }
};
var RequiredError = class extends Error {
  constructor(field, msg) {
    super(msg);
    this.field = field;
    this.name = "RequiredError";
  }
};

// src/openapi/common.ts
var DUMMY_BASE_URL = "https://example.com";
var assertParamExists = function(functionName, paramName, paramValue) {
  if (paramValue === null || paramValue === void 0) {
    throw new RequiredError(
      paramName,
      `Required parameter ${paramName} was null or undefined when calling ${functionName}.`
    );
  }
};
var setBearerAuthToObject = async function(object, configuration) {
  if (configuration && configuration.accessToken) {
    const accessToken = typeof configuration.accessToken === "function" ? await configuration.accessToken() : await configuration.accessToken;
    object["Authorization"] = "Bearer " + accessToken;
  }
};
function setFlattenedQueryParams(urlSearchParams, parameter, key = "") {
  if (typeof parameter === "object") {
    if (Array.isArray(parameter)) {
      parameter.forEach((item) => setFlattenedQueryParams(urlSearchParams, item, key));
    } else {
      Object.keys(parameter).forEach(
        (currentKey) => setFlattenedQueryParams(
          urlSearchParams,
          parameter[currentKey],
          `${key}${key !== "" ? "." : ""}${currentKey}`
        )
      );
    }
  } else {
    if (urlSearchParams.has(key)) {
      urlSearchParams.append(key, parameter);
    } else {
      urlSearchParams.set(key, parameter);
    }
  }
}
var setSearchParams = function(url, ...objects) {
  const searchParams = new URLSearchParams(url.search);
  setFlattenedQueryParams(searchParams, objects);
  url.search = searchParams.toString();
};
var serializeDataIfNeeded = function(value, requestOptions, configuration) {
  const nonString = typeof value !== "string";
  const needsSerialization = nonString && configuration && configuration.isJsonMime ? configuration.isJsonMime(requestOptions.headers["Content-Type"]) : nonString;
  return needsSerialization ? JSON.stringify(value !== void 0 ? value : {}) : value || "";
};
var toPathString = function(url) {
  return url.pathname + url.search + url.hash;
};
var createRequestFunction = function(axiosArgs, globalAxios3, BASE_PATH2, configuration) {
  return (axios = globalAxios3, basePath = BASE_PATH2) => {
    const axiosRequestArgs = {
      ...axiosArgs.options,
      url: ((configuration == null ? void 0 : configuration.basePath) || basePath) + axiosArgs.url
    };
    return axios.request(axiosRequestArgs);
  };
};

// src/openapi/api/authentication-api.ts
var AuthenticationApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * The dev-login endpoints allows a developer inside permit.io to log in with an email address.  THIS IS ONLY AVAILABLE IN DEV MODE.
     * @summary (DEV MODE) Login
     * @param {DevLogin} devLogin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    devLogin: async (devLogin, options = {}) => {
      assertParamExists("devLogin", "devLogin", devLogin);
      const localVarPath = `/v2/auth/devlogin`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        devLogin,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Elements Fe Login As
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {UserFELoginRequestInput} userFELoginRequestInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    elementsFeLoginAs: async (envId, userFELoginRequestInput, options = {}) => {
      assertParamExists("elementsFeLoginAs", "envId", envId);
      assertParamExists("elementsFeLoginAs", "userFELoginRequestInput", userFELoginRequestInput);
      const localVarPath = `/v2/auth/{env_id}/elements_fe_login_as`.replace(
        `{${"env_id"}}`,
        encodeURIComponent(String(envId))
      );
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userFELoginRequestInput,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Elements Login As
     * @param {UserLoginRequestInput} userLoginRequestInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    elementsLoginAs: async (userLoginRequestInput, options = {}) => {
      assertParamExists("elementsLoginAs", "userLoginRequestInput", userLoginRequestInput);
      const localVarPath = `/v2/auth/elements_login_as`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userLoginRequestInput,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * The login endpoint allows the frontend app to exchange a user JWT with a user session. The user session is stored on an httpOnly + secure cookie.
     * @summary Login
     * @param {string} [inviteCode] An optional invite code to an existing organization. If the invite code is provided and is valid, the member will gain access to that organization.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    login: async (inviteCode, options = {}) => {
      const localVarPath = `/v2/auth/login`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (inviteCode !== void 0) {
        localVarQueryParameter["invite_code"] = inviteCode;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * The login endpoint allows the frontend app to exchange a user JWT with a user session. The user session is stored on an httpOnly + secure cookie.
     * @summary Login Elements
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    loginElements: async (token, options = {}) => {
      assertParamExists("loginElements", "token", token);
      const localVarPath = `/v2/auth/login_elements`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      if (token !== void 0) {
        localVarQueryParameter["token"] = token;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * The logout endpoint deletes the session cookie of a logged in user and invalidates cached VCs.
     * @summary Logout Get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logoutGet: async (options = {}) => {
      const localVarPath = `/v2/auth/logout`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * The logout endpoint deletes the session cookie of a logged in user and invalidates cached VCs.
     * @summary Logout Post
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logoutPost: async (options = {}) => {
      const localVarPath = `/v2/auth/logout`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Me
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    me: async (options = {}) => {
      const localVarPath = `/v2/auth/me`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Allows the user to switch his active organization (manipulates the user\'s login session).  This route will return a new login cookie to the user.
     * @summary Switch Organization
     * @param {string} orgId the organization id the user wishes to switch to as the active org on the session
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    switchOrganization: async (orgId, options = {}) => {
      assertParamExists("switchOrganization", "orgId", orgId);
      const localVarPath = `/v2/auth/switch_org/{org_id}`.replace(
        `{${"org_id"}}`,
        encodeURIComponent(String(orgId))
      );
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var AuthenticationApiFp = function(configuration) {
  const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration);
  return {
    /**
     * The dev-login endpoints allows a developer inside permit.io to log in with an email address.  THIS IS ONLY AVAILABLE IN DEV MODE.
     * @summary (DEV MODE) Login
     * @param {DevLogin} devLogin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async devLogin(devLogin, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.devLogin(devLogin, options);
      return createRequestFunction(localVarAxiosArgs, import_axios2.default, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Elements Fe Login As
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {UserFELoginRequestInput} userFELoginRequestInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async elementsFeLoginAs(envId, userFELoginRequestInput, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.elementsFeLoginAs(
        envId,
        userFELoginRequestInput,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios2.default, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Elements Login As
     * @param {UserLoginRequestInput} userLoginRequestInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async elementsLoginAs(userLoginRequestInput, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.elementsLoginAs(
        userLoginRequestInput,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios2.default, BASE_PATH, configuration);
    },
    /**
     * The login endpoint allows the frontend app to exchange a user JWT with a user session. The user session is stored on an httpOnly + secure cookie.
     * @summary Login
     * @param {string} [inviteCode] An optional invite code to an existing organization. If the invite code is provided and is valid, the member will gain access to that organization.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async login(inviteCode, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.login(inviteCode, options);
      return createRequestFunction(localVarAxiosArgs, import_axios2.default, BASE_PATH, configuration);
    },
    /**
     * The login endpoint allows the frontend app to exchange a user JWT with a user session. The user session is stored on an httpOnly + secure cookie.
     * @summary Login Elements
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async loginElements(token, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.loginElements(token, options);
      return createRequestFunction(localVarAxiosArgs, import_axios2.default, BASE_PATH, configuration);
    },
    /**
     * The logout endpoint deletes the session cookie of a logged in user and invalidates cached VCs.
     * @summary Logout Get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async logoutGet(options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.logoutGet(options);
      return createRequestFunction(localVarAxiosArgs, import_axios2.default, BASE_PATH, configuration);
    },
    /**
     * The logout endpoint deletes the session cookie of a logged in user and invalidates cached VCs.
     * @summary Logout Post
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async logoutPost(options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.logoutPost(options);
      return createRequestFunction(localVarAxiosArgs, import_axios2.default, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Me
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async me(options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.me(options);
      return createRequestFunction(localVarAxiosArgs, import_axios2.default, BASE_PATH, configuration);
    },
    /**
     * Allows the user to switch his active organization (manipulates the user\'s login session).  This route will return a new login cookie to the user.
     * @summary Switch Organization
     * @param {string} orgId the organization id the user wishes to switch to as the active org on the session
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async switchOrganization(orgId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.switchOrganization(orgId, options);
      return createRequestFunction(localVarAxiosArgs, import_axios2.default, BASE_PATH, configuration);
    }
  };
};
var AuthenticationApiFactory = function(configuration, basePath, axios) {
  const localVarFp = AuthenticationApiFp(configuration);
  return {
    /**
     * The dev-login endpoints allows a developer inside permit.io to log in with an email address.  THIS IS ONLY AVAILABLE IN DEV MODE.
     * @summary (DEV MODE) Login
     * @param {DevLogin} devLogin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    devLogin(devLogin, options) {
      return localVarFp.devLogin(devLogin, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Elements Fe Login As
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {UserFELoginRequestInput} userFELoginRequestInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    elementsFeLoginAs(envId, userFELoginRequestInput, options) {
      return localVarFp.elementsFeLoginAs(envId, userFELoginRequestInput, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Elements Login As
     * @param {UserLoginRequestInput} userLoginRequestInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    elementsLoginAs(userLoginRequestInput, options) {
      return localVarFp.elementsLoginAs(userLoginRequestInput, options).then((request) => request(axios, basePath));
    },
    /**
     * The login endpoint allows the frontend app to exchange a user JWT with a user session. The user session is stored on an httpOnly + secure cookie.
     * @summary Login
     * @param {string} [inviteCode] An optional invite code to an existing organization. If the invite code is provided and is valid, the member will gain access to that organization.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    login(inviteCode, options) {
      return localVarFp.login(inviteCode, options).then((request) => request(axios, basePath));
    },
    /**
     * The login endpoint allows the frontend app to exchange a user JWT with a user session. The user session is stored on an httpOnly + secure cookie.
     * @summary Login Elements
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    loginElements(token, options) {
      return localVarFp.loginElements(token, options).then((request) => request(axios, basePath));
    },
    /**
     * The logout endpoint deletes the session cookie of a logged in user and invalidates cached VCs.
     * @summary Logout Get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logoutGet(options) {
      return localVarFp.logoutGet(options).then((request) => request(axios, basePath));
    },
    /**
     * The logout endpoint deletes the session cookie of a logged in user and invalidates cached VCs.
     * @summary Logout Post
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logoutPost(options) {
      return localVarFp.logoutPost(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Me
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    me(options) {
      return localVarFp.me(options).then((request) => request(axios, basePath));
    },
    /**
     * Allows the user to switch his active organization (manipulates the user\'s login session).  This route will return a new login cookie to the user.
     * @summary Switch Organization
     * @param {string} orgId the organization id the user wishes to switch to as the active org on the session
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    switchOrganization(orgId, options) {
      return localVarFp.switchOrganization(orgId, options).then((request) => request(axios, basePath));
    }
  };
};
var AuthenticationApi = class extends BaseAPI {
  /**
   * The dev-login endpoints allows a developer inside permit.io to log in with an email address.  THIS IS ONLY AVAILABLE IN DEV MODE.
   * @summary (DEV MODE) Login
   * @param {AuthenticationApiDevLoginRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationApi
   */
  devLogin(requestParameters, options) {
    return AuthenticationApiFp(this.configuration).devLogin(requestParameters.devLogin, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Elements Fe Login As
   * @param {AuthenticationApiElementsFeLoginAsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationApi
   */
  elementsFeLoginAs(requestParameters, options) {
    return AuthenticationApiFp(this.configuration).elementsFeLoginAs(
      requestParameters.envId,
      requestParameters.userFELoginRequestInput,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Elements Login As
   * @param {AuthenticationApiElementsLoginAsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationApi
   */
  elementsLoginAs(requestParameters, options) {
    return AuthenticationApiFp(this.configuration).elementsLoginAs(requestParameters.userLoginRequestInput, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * The login endpoint allows the frontend app to exchange a user JWT with a user session. The user session is stored on an httpOnly + secure cookie.
   * @summary Login
   * @param {AuthenticationApiLoginRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationApi
   */
  login(requestParameters = {}, options) {
    return AuthenticationApiFp(this.configuration).login(requestParameters.inviteCode, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * The login endpoint allows the frontend app to exchange a user JWT with a user session. The user session is stored on an httpOnly + secure cookie.
   * @summary Login Elements
   * @param {AuthenticationApiLoginElementsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationApi
   */
  loginElements(requestParameters, options) {
    return AuthenticationApiFp(this.configuration).loginElements(requestParameters.token, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * The logout endpoint deletes the session cookie of a logged in user and invalidates cached VCs.
   * @summary Logout Get
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationApi
   */
  logoutGet(options) {
    return AuthenticationApiFp(this.configuration).logoutGet(options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * The logout endpoint deletes the session cookie of a logged in user and invalidates cached VCs.
   * @summary Logout Post
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationApi
   */
  logoutPost(options) {
    return AuthenticationApiFp(this.configuration).logoutPost(options).then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Me
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationApi
   */
  me(options) {
    return AuthenticationApiFp(this.configuration).me(options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Allows the user to switch his active organization (manipulates the user\'s login session).  This route will return a new login cookie to the user.
   * @summary Switch Organization
   * @param {AuthenticationApiSwitchOrganizationRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationApi
   */
  switchOrganization(requestParameters, options) {
    return AuthenticationApiFp(this.configuration).switchOrganization(requestParameters.orgId, options).then((request) => request(this.axios, this.basePath));
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AuthenticationApi,
  AuthenticationApiAxiosParamCreator,
  AuthenticationApiFactory,
  AuthenticationApiFp
});
//# sourceMappingURL=authentication-api.js.map