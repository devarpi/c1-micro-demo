// src/openapi/api/apikeys-api.ts
import globalAxios2 from "axios";

// src/openapi/base.ts
import globalAxios from "axios";
var BASE_PATH = "http://localhost".replace(/\/+$/, "");
var BaseAPI = class {
  constructor(configuration, basePath = BASE_PATH, axios = globalAxios) {
    this.basePath = basePath;
    this.axios = axios;
    if (configuration) {
      this.configuration = configuration;
      this.basePath = configuration.basePath || this.basePath;
    }
  }
};
var RequiredError = class extends Error {
  constructor(field, msg) {
    super(msg);
    this.field = field;
    this.name = "RequiredError";
  }
};

// src/openapi/common.ts
var DUMMY_BASE_URL = "https://example.com";
var assertParamExists = function(functionName, paramName, paramValue) {
  if (paramValue === null || paramValue === void 0) {
    throw new RequiredError(
      paramName,
      `Required parameter ${paramName} was null or undefined when calling ${functionName}.`
    );
  }
};
var setBearerAuthToObject = async function(object, configuration) {
  if (configuration && configuration.accessToken) {
    const accessToken = typeof configuration.accessToken === "function" ? await configuration.accessToken() : await configuration.accessToken;
    object["Authorization"] = "Bearer " + accessToken;
  }
};
function setFlattenedQueryParams(urlSearchParams, parameter, key = "") {
  if (typeof parameter === "object") {
    if (Array.isArray(parameter)) {
      parameter.forEach((item) => setFlattenedQueryParams(urlSearchParams, item, key));
    } else {
      Object.keys(parameter).forEach(
        (currentKey) => setFlattenedQueryParams(
          urlSearchParams,
          parameter[currentKey],
          `${key}${key !== "" ? "." : ""}${currentKey}`
        )
      );
    }
  } else {
    if (urlSearchParams.has(key)) {
      urlSearchParams.append(key, parameter);
    } else {
      urlSearchParams.set(key, parameter);
    }
  }
}
var setSearchParams = function(url, ...objects) {
  const searchParams = new URLSearchParams(url.search);
  setFlattenedQueryParams(searchParams, objects);
  url.search = searchParams.toString();
};
var serializeDataIfNeeded = function(value, requestOptions, configuration) {
  const nonString = typeof value !== "string";
  const needsSerialization = nonString && configuration && configuration.isJsonMime ? configuration.isJsonMime(requestOptions.headers["Content-Type"]) : nonString;
  return needsSerialization ? JSON.stringify(value !== void 0 ? value : {}) : value || "";
};
var toPathString = function(url) {
  return url.pathname + url.search + url.hash;
};
var createRequestFunction = function(axiosArgs, globalAxios37, BASE_PATH2, configuration) {
  return (axios = globalAxios37, basePath = BASE_PATH2) => {
    const axiosRequestArgs = {
      ...axiosArgs.options,
      url: ((configuration == null ? void 0 : configuration.basePath) || basePath) + axiosArgs.url
    };
    return axios.request(axiosRequestArgs);
  };
};

// src/openapi/api/apikeys-api.ts
var APIKeysApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * Creates a new api_key under the active organization.
     * @summary Create Api Key
     * @param {APIKeyCreate} aPIKeyCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createApiKey: async (aPIKeyCreate, options = {}) => {
      assertParamExists("createApiKey", "aPIKeyCreate", aPIKeyCreate);
      const localVarPath = `/v2/api-key`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        aPIKeyCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes the api_key and all its related data.
     * @summary Delete Api Key
     * @param {string} apiKeyId The unique id of the API key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteApiKey: async (apiKeyId, options = {}) => {
      assertParamExists("deleteApiKey", "apiKeyId", apiKeyId);
      const localVarPath = `/v2/api-key/{api_key_id}`.replace(
        `{${"api_key_id"}}`,
        encodeURIComponent(String(apiKeyId))
      );
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Gets a single api_key matching the given api_key_id, if such api_key exists.
     * @summary Get Api Key
     * @param {string} apiKeyId The unique id of the API key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getApiKey: async (apiKeyId, options = {}) => {
      assertParamExists("getApiKey", "apiKeyId", apiKeyId);
      const localVarPath = `/v2/api-key/{api_key_id}`.replace(
        `{${"api_key_id"}}`,
        encodeURIComponent(String(apiKeyId))
      );
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Get Api Key Scope
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getApiKeyScope: async (options = {}) => {
      const localVarPath = `/v2/api-key/scope`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Get Environment Api Key
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEnvironmentApiKey: async (projId, envId, options = {}) => {
      assertParamExists("getEnvironmentApiKey", "projId", projId);
      assertParamExists("getEnvironmentApiKey", "envId", envId);
      const localVarPath = `/v2/api-key/{proj_id}/{env_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Lists all the api_keys under the active organization.
     * @summary List Api Keys
     * @param {MemberAccessObj} [objectType]
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listApiKeys: async (objectType, page, perPage, options = {}) => {
      const localVarPath = `/v2/api-key`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (objectType !== void 0) {
        localVarQueryParameter["object_type"] = objectType;
      }
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Rotates the API key of the PDP container with id `pdp_id`.  The rotation of the API key revokes the old API key and issues a new API key to the PDP.
     * @summary Rotate API Key
     * @param {string} apiKeyId The unique id of the API key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rotateApiKey: async (apiKeyId, options = {}) => {
      assertParamExists("rotateApiKey", "apiKeyId", apiKeyId);
      const localVarPath = `/v2/api-key/{api_key_id}/rotate-secret`.replace(
        `{${"api_key_id"}}`,
        encodeURIComponent(String(apiKeyId))
      );
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var APIKeysApiFp = function(configuration) {
  const localVarAxiosParamCreator = APIKeysApiAxiosParamCreator(configuration);
  return {
    /**
     * Creates a new api_key under the active organization.
     * @summary Create Api Key
     * @param {APIKeyCreate} aPIKeyCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createApiKey(aPIKeyCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createApiKey(aPIKeyCreate, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * Deletes the api_key and all its related data.
     * @summary Delete Api Key
     * @param {string} apiKeyId The unique id of the API key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteApiKey(apiKeyId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApiKey(apiKeyId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * Gets a single api_key matching the given api_key_id, if such api_key exists.
     * @summary Get Api Key
     * @param {string} apiKeyId The unique id of the API key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getApiKey(apiKeyId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getApiKey(apiKeyId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get Api Key Scope
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getApiKeyScope(options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getApiKeyScope(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get Environment Api Key
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEnvironmentApiKey(projId, envId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getEnvironmentApiKey(
        projId,
        envId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * Lists all the api_keys under the active organization.
     * @summary List Api Keys
     * @param {MemberAccessObj} [objectType]
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listApiKeys(objectType, page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listApiKeys(
        objectType,
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * Rotates the API key of the PDP container with id `pdp_id`.  The rotation of the API key revokes the old API key and issues a new API key to the PDP.
     * @summary Rotate API Key
     * @param {string} apiKeyId The unique id of the API key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async rotateApiKey(apiKeyId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.rotateApiKey(apiKeyId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    }
  };
};
var APIKeysApiFactory = function(configuration, basePath, axios) {
  const localVarFp = APIKeysApiFp(configuration);
  return {
    /**
     * Creates a new api_key under the active organization.
     * @summary Create Api Key
     * @param {APIKeyCreate} aPIKeyCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createApiKey(aPIKeyCreate, options) {
      return localVarFp.createApiKey(aPIKeyCreate, options).then((request) => request(axios, basePath));
    },
    /**
     * Deletes the api_key and all its related data.
     * @summary Delete Api Key
     * @param {string} apiKeyId The unique id of the API key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteApiKey(apiKeyId, options) {
      return localVarFp.deleteApiKey(apiKeyId, options).then((request) => request(axios, basePath));
    },
    /**
     * Gets a single api_key matching the given api_key_id, if such api_key exists.
     * @summary Get Api Key
     * @param {string} apiKeyId The unique id of the API key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getApiKey(apiKeyId, options) {
      return localVarFp.getApiKey(apiKeyId, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get Api Key Scope
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getApiKeyScope(options) {
      return localVarFp.getApiKeyScope(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get Environment Api Key
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEnvironmentApiKey(projId, envId, options) {
      return localVarFp.getEnvironmentApiKey(projId, envId, options).then((request) => request(axios, basePath));
    },
    /**
     * Lists all the api_keys under the active organization.
     * @summary List Api Keys
     * @param {MemberAccessObj} [objectType]
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listApiKeys(objectType, page, perPage, options) {
      return localVarFp.listApiKeys(objectType, page, perPage, options).then((request) => request(axios, basePath));
    },
    /**
     * Rotates the API key of the PDP container with id `pdp_id`.  The rotation of the API key revokes the old API key and issues a new API key to the PDP.
     * @summary Rotate API Key
     * @param {string} apiKeyId The unique id of the API key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rotateApiKey(apiKeyId, options) {
      return localVarFp.rotateApiKey(apiKeyId, options).then((request) => request(axios, basePath));
    }
  };
};
var APIKeysApi = class extends BaseAPI {
  /**
   * Creates a new api_key under the active organization.
   * @summary Create Api Key
   * @param {APIKeysApiCreateApiKeyRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIKeysApi
   */
  createApiKey(requestParameters, options) {
    return APIKeysApiFp(this.configuration).createApiKey(requestParameters.aPIKeyCreate, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Deletes the api_key and all its related data.
   * @summary Delete Api Key
   * @param {APIKeysApiDeleteApiKeyRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIKeysApi
   */
  deleteApiKey(requestParameters, options) {
    return APIKeysApiFp(this.configuration).deleteApiKey(requestParameters.apiKeyId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Gets a single api_key matching the given api_key_id, if such api_key exists.
   * @summary Get Api Key
   * @param {APIKeysApiGetApiKeyRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIKeysApi
   */
  getApiKey(requestParameters, options) {
    return APIKeysApiFp(this.configuration).getApiKey(requestParameters.apiKeyId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Get Api Key Scope
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIKeysApi
   */
  getApiKeyScope(options) {
    return APIKeysApiFp(this.configuration).getApiKeyScope(options).then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Get Environment Api Key
   * @param {APIKeysApiGetEnvironmentApiKeyRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIKeysApi
   */
  getEnvironmentApiKey(requestParameters, options) {
    return APIKeysApiFp(this.configuration).getEnvironmentApiKey(requestParameters.projId, requestParameters.envId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Lists all the api_keys under the active organization.
   * @summary List Api Keys
   * @param {APIKeysApiListApiKeysRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIKeysApi
   */
  listApiKeys(requestParameters = {}, options) {
    return APIKeysApiFp(this.configuration).listApiKeys(
      requestParameters.objectType,
      requestParameters.page,
      requestParameters.perPage,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Rotates the API key of the PDP container with id `pdp_id`.  The rotation of the API key revokes the old API key and issues a new API key to the PDP.
   * @summary Rotate API Key
   * @param {APIKeysApiRotateApiKeyRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIKeysApi
   */
  rotateApiKey(requestParameters, options) {
    return APIKeysApiFp(this.configuration).rotateApiKey(requestParameters.apiKeyId, options).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/audit-elements-data-api.ts
import globalAxios3 from "axios";
var AuditElementsDataApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * Lists audit logs for for specific elements config (tenant scope)
     * @summary List audit logs
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} elementsConfigId Either the unique id of the elements_config, or the URL-friendly key of the elements_config (i.e: the \&quot;slug\&quot;).
     * @param {string} [search] Text search for the email field
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    elementsListAuditLogs: async (projId, envId, elementsConfigId, search, page, perPage, options = {}) => {
      assertParamExists("elementsListAuditLogs", "projId", projId);
      assertParamExists("elementsListAuditLogs", "envId", envId);
      assertParamExists("elementsListAuditLogs", "elementsConfigId", elementsConfigId);
      const localVarPath = `/v2/elements/{proj_id}/{env_id}/config/{elements_config_id}/data/audit_logs`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"elements_config_id"}}`, encodeURIComponent(String(elementsConfigId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (search !== void 0) {
        localVarQueryParameter["search"] = search;
      }
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var AuditElementsDataApiFp = function(configuration) {
  const localVarAxiosParamCreator = AuditElementsDataApiAxiosParamCreator(configuration);
  return {
    /**
     * Lists audit logs for for specific elements config (tenant scope)
     * @summary List audit logs
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} elementsConfigId Either the unique id of the elements_config, or the URL-friendly key of the elements_config (i.e: the \&quot;slug\&quot;).
     * @param {string} [search] Text search for the email field
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async elementsListAuditLogs(projId, envId, elementsConfigId, search, page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.elementsListAuditLogs(
        projId,
        envId,
        elementsConfigId,
        search,
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios3, BASE_PATH, configuration);
    }
  };
};
var AuditElementsDataApiFactory = function(configuration, basePath, axios) {
  const localVarFp = AuditElementsDataApiFp(configuration);
  return {
    /**
     * Lists audit logs for for specific elements config (tenant scope)
     * @summary List audit logs
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} elementsConfigId Either the unique id of the elements_config, or the URL-friendly key of the elements_config (i.e: the \&quot;slug\&quot;).
     * @param {string} [search] Text search for the email field
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    elementsListAuditLogs(projId, envId, elementsConfigId, search, page, perPage, options) {
      return localVarFp.elementsListAuditLogs(projId, envId, elementsConfigId, search, page, perPage, options).then((request) => request(axios, basePath));
    }
  };
};
var AuditElementsDataApi = class extends BaseAPI {
  /**
   * Lists audit logs for for specific elements config (tenant scope)
   * @summary List audit logs
   * @param {AuditElementsDataApiElementsListAuditLogsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuditElementsDataApi
   */
  elementsListAuditLogs(requestParameters, options) {
    return AuditElementsDataApiFp(this.configuration).elementsListAuditLogs(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.elementsConfigId,
      requestParameters.search,
      requestParameters.page,
      requestParameters.perPage,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/audit-logs-api.ts
import globalAxios4 from "axios";
var AuditLogsApiAxiosParamCreator = function(configuration) {
  return {
    /**
     *
     * @summary Get detailed audit log
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} logId The unique id of the audit log
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDetailedAuditLog: async (projId, envId, logId, options = {}) => {
      assertParamExists("getDetailedAuditLog", "projId", projId);
      assertParamExists("getDetailedAuditLog", "envId", envId);
      assertParamExists("getDetailedAuditLog", "logId", logId);
      const localVarPath = `/v2/pdps/{proj_id}/{env_id}/audit_logs/{log_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"log_id"}}`, encodeURIComponent(String(logId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary List Audit Logs
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} [pdpId] Filter by pdp config id
     * @param {Array<string>} [users] List of user keys or emails to filter by
     * @param {boolean} [decision] Filter by decision result
     * @param {Array<string>} [resources] Filter by resources
     * @param {string} [tenant] Filter by tenant
     * @param {string} [action] Filter by action
     * @param {number} [timestampFrom] Filter by timestamp from
     * @param {number} [timestampTo] Filter by timestamp to
     * @param {AuditLogSortKey} [sortBy] Sort by column
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAuditLogs: async (projId, envId, pdpId, users, decision, resources, tenant, action, timestampFrom, timestampTo, sortBy, page, perPage, options = {}) => {
      assertParamExists("listAuditLogs", "projId", projId);
      assertParamExists("listAuditLogs", "envId", envId);
      const localVarPath = `/v2/pdps/{proj_id}/{env_id}/audit_logs`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (pdpId !== void 0) {
        localVarQueryParameter["pdp_id"] = pdpId;
      }
      if (users) {
        localVarQueryParameter["users"] = users;
      }
      if (decision !== void 0) {
        localVarQueryParameter["decision"] = decision;
      }
      if (resources) {
        localVarQueryParameter["resources"] = resources;
      }
      if (tenant !== void 0) {
        localVarQueryParameter["tenant"] = tenant;
      }
      if (action !== void 0) {
        localVarQueryParameter["action"] = action;
      }
      if (timestampFrom !== void 0) {
        localVarQueryParameter["timestamp_from"] = timestampFrom;
      }
      if (timestampTo !== void 0) {
        localVarQueryParameter["timestamp_to"] = timestampTo;
      }
      if (sortBy !== void 0) {
        localVarQueryParameter["sort_by"] = sortBy;
      }
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var AuditLogsApiFp = function(configuration) {
  const localVarAxiosParamCreator = AuditLogsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Get detailed audit log
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} logId The unique id of the audit log
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDetailedAuditLog(projId, envId, logId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getDetailedAuditLog(
        projId,
        envId,
        logId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios4, BASE_PATH, configuration);
    },
    /**
     *
     * @summary List Audit Logs
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} [pdpId] Filter by pdp config id
     * @param {Array<string>} [users] List of user keys or emails to filter by
     * @param {boolean} [decision] Filter by decision result
     * @param {Array<string>} [resources] Filter by resources
     * @param {string} [tenant] Filter by tenant
     * @param {string} [action] Filter by action
     * @param {number} [timestampFrom] Filter by timestamp from
     * @param {number} [timestampTo] Filter by timestamp to
     * @param {AuditLogSortKey} [sortBy] Sort by column
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listAuditLogs(projId, envId, pdpId, users, decision, resources, tenant, action, timestampFrom, timestampTo, sortBy, page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listAuditLogs(
        projId,
        envId,
        pdpId,
        users,
        decision,
        resources,
        tenant,
        action,
        timestampFrom,
        timestampTo,
        sortBy,
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios4, BASE_PATH, configuration);
    }
  };
};
var AuditLogsApiFactory = function(configuration, basePath, axios) {
  const localVarFp = AuditLogsApiFp(configuration);
  return {
    /**
     *
     * @summary Get detailed audit log
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} logId The unique id of the audit log
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDetailedAuditLog(projId, envId, logId, options) {
      return localVarFp.getDetailedAuditLog(projId, envId, logId, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary List Audit Logs
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} [pdpId] Filter by pdp config id
     * @param {Array<string>} [users] List of user keys or emails to filter by
     * @param {boolean} [decision] Filter by decision result
     * @param {Array<string>} [resources] Filter by resources
     * @param {string} [tenant] Filter by tenant
     * @param {string} [action] Filter by action
     * @param {number} [timestampFrom] Filter by timestamp from
     * @param {number} [timestampTo] Filter by timestamp to
     * @param {AuditLogSortKey} [sortBy] Sort by column
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAuditLogs(projId, envId, pdpId, users, decision, resources, tenant, action, timestampFrom, timestampTo, sortBy, page, perPage, options) {
      return localVarFp.listAuditLogs(
        projId,
        envId,
        pdpId,
        users,
        decision,
        resources,
        tenant,
        action,
        timestampFrom,
        timestampTo,
        sortBy,
        page,
        perPage,
        options
      ).then((request) => request(axios, basePath));
    }
  };
};
var AuditLogsApi = class extends BaseAPI {
  /**
   *
   * @summary Get detailed audit log
   * @param {AuditLogsApiGetDetailedAuditLogRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuditLogsApi
   */
  getDetailedAuditLog(requestParameters, options) {
    return AuditLogsApiFp(this.configuration).getDetailedAuditLog(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.logId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary List Audit Logs
   * @param {AuditLogsApiListAuditLogsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuditLogsApi
   */
  listAuditLogs(requestParameters, options) {
    return AuditLogsApiFp(this.configuration).listAuditLogs(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.pdpId,
      requestParameters.users,
      requestParameters.decision,
      requestParameters.resources,
      requestParameters.tenant,
      requestParameters.action,
      requestParameters.timestampFrom,
      requestParameters.timestampTo,
      requestParameters.sortBy,
      requestParameters.page,
      requestParameters.perPage,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/authentication-api.ts
import globalAxios5 from "axios";
var AuthenticationApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * The dev-login endpoints allows a developer inside permit.io to log in with an email address.  THIS IS ONLY AVAILABLE IN DEV MODE.
     * @summary (DEV MODE) Login
     * @param {DevLogin} devLogin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    devLogin: async (devLogin, options = {}) => {
      assertParamExists("devLogin", "devLogin", devLogin);
      const localVarPath = `/v2/auth/devlogin`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        devLogin,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Elements Fe Login As
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {UserFELoginRequestInput} userFELoginRequestInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    elementsFeLoginAs: async (envId, userFELoginRequestInput, options = {}) => {
      assertParamExists("elementsFeLoginAs", "envId", envId);
      assertParamExists("elementsFeLoginAs", "userFELoginRequestInput", userFELoginRequestInput);
      const localVarPath = `/v2/auth/{env_id}/elements_fe_login_as`.replace(
        `{${"env_id"}}`,
        encodeURIComponent(String(envId))
      );
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userFELoginRequestInput,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Elements Login As
     * @param {UserLoginRequestInput} userLoginRequestInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    elementsLoginAs: async (userLoginRequestInput, options = {}) => {
      assertParamExists("elementsLoginAs", "userLoginRequestInput", userLoginRequestInput);
      const localVarPath = `/v2/auth/elements_login_as`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userLoginRequestInput,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * The login endpoint allows the frontend app to exchange a user JWT with a user session. The user session is stored on an httpOnly + secure cookie.
     * @summary Login
     * @param {string} [inviteCode] An optional invite code to an existing organization. If the invite code is provided and is valid, the member will gain access to that organization.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    login: async (inviteCode, options = {}) => {
      const localVarPath = `/v2/auth/login`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (inviteCode !== void 0) {
        localVarQueryParameter["invite_code"] = inviteCode;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * The login endpoint allows the frontend app to exchange a user JWT with a user session. The user session is stored on an httpOnly + secure cookie.
     * @summary Login Elements
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    loginElements: async (token, options = {}) => {
      assertParamExists("loginElements", "token", token);
      const localVarPath = `/v2/auth/login_elements`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      if (token !== void 0) {
        localVarQueryParameter["token"] = token;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * The logout endpoint deletes the session cookie of a logged in user and invalidates cached VCs.
     * @summary Logout Get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logoutGet: async (options = {}) => {
      const localVarPath = `/v2/auth/logout`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * The logout endpoint deletes the session cookie of a logged in user and invalidates cached VCs.
     * @summary Logout Post
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logoutPost: async (options = {}) => {
      const localVarPath = `/v2/auth/logout`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Me
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    me: async (options = {}) => {
      const localVarPath = `/v2/auth/me`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Allows the user to switch his active organization (manipulates the user\'s login session).  This route will return a new login cookie to the user.
     * @summary Switch Organization
     * @param {string} orgId the organization id the user wishes to switch to as the active org on the session
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    switchOrganization: async (orgId, options = {}) => {
      assertParamExists("switchOrganization", "orgId", orgId);
      const localVarPath = `/v2/auth/switch_org/{org_id}`.replace(
        `{${"org_id"}}`,
        encodeURIComponent(String(orgId))
      );
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var AuthenticationApiFp = function(configuration) {
  const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration);
  return {
    /**
     * The dev-login endpoints allows a developer inside permit.io to log in with an email address.  THIS IS ONLY AVAILABLE IN DEV MODE.
     * @summary (DEV MODE) Login
     * @param {DevLogin} devLogin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async devLogin(devLogin, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.devLogin(devLogin, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios5, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Elements Fe Login As
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {UserFELoginRequestInput} userFELoginRequestInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async elementsFeLoginAs(envId, userFELoginRequestInput, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.elementsFeLoginAs(
        envId,
        userFELoginRequestInput,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios5, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Elements Login As
     * @param {UserLoginRequestInput} userLoginRequestInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async elementsLoginAs(userLoginRequestInput, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.elementsLoginAs(
        userLoginRequestInput,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios5, BASE_PATH, configuration);
    },
    /**
     * The login endpoint allows the frontend app to exchange a user JWT with a user session. The user session is stored on an httpOnly + secure cookie.
     * @summary Login
     * @param {string} [inviteCode] An optional invite code to an existing organization. If the invite code is provided and is valid, the member will gain access to that organization.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async login(inviteCode, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.login(inviteCode, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios5, BASE_PATH, configuration);
    },
    /**
     * The login endpoint allows the frontend app to exchange a user JWT with a user session. The user session is stored on an httpOnly + secure cookie.
     * @summary Login Elements
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async loginElements(token, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.loginElements(token, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios5, BASE_PATH, configuration);
    },
    /**
     * The logout endpoint deletes the session cookie of a logged in user and invalidates cached VCs.
     * @summary Logout Get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async logoutGet(options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.logoutGet(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios5, BASE_PATH, configuration);
    },
    /**
     * The logout endpoint deletes the session cookie of a logged in user and invalidates cached VCs.
     * @summary Logout Post
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async logoutPost(options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.logoutPost(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios5, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Me
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async me(options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.me(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios5, BASE_PATH, configuration);
    },
    /**
     * Allows the user to switch his active organization (manipulates the user\'s login session).  This route will return a new login cookie to the user.
     * @summary Switch Organization
     * @param {string} orgId the organization id the user wishes to switch to as the active org on the session
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async switchOrganization(orgId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.switchOrganization(orgId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios5, BASE_PATH, configuration);
    }
  };
};
var AuthenticationApiFactory = function(configuration, basePath, axios) {
  const localVarFp = AuthenticationApiFp(configuration);
  return {
    /**
     * The dev-login endpoints allows a developer inside permit.io to log in with an email address.  THIS IS ONLY AVAILABLE IN DEV MODE.
     * @summary (DEV MODE) Login
     * @param {DevLogin} devLogin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    devLogin(devLogin, options) {
      return localVarFp.devLogin(devLogin, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Elements Fe Login As
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {UserFELoginRequestInput} userFELoginRequestInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    elementsFeLoginAs(envId, userFELoginRequestInput, options) {
      return localVarFp.elementsFeLoginAs(envId, userFELoginRequestInput, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Elements Login As
     * @param {UserLoginRequestInput} userLoginRequestInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    elementsLoginAs(userLoginRequestInput, options) {
      return localVarFp.elementsLoginAs(userLoginRequestInput, options).then((request) => request(axios, basePath));
    },
    /**
     * The login endpoint allows the frontend app to exchange a user JWT with a user session. The user session is stored on an httpOnly + secure cookie.
     * @summary Login
     * @param {string} [inviteCode] An optional invite code to an existing organization. If the invite code is provided and is valid, the member will gain access to that organization.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    login(inviteCode, options) {
      return localVarFp.login(inviteCode, options).then((request) => request(axios, basePath));
    },
    /**
     * The login endpoint allows the frontend app to exchange a user JWT with a user session. The user session is stored on an httpOnly + secure cookie.
     * @summary Login Elements
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    loginElements(token, options) {
      return localVarFp.loginElements(token, options).then((request) => request(axios, basePath));
    },
    /**
     * The logout endpoint deletes the session cookie of a logged in user and invalidates cached VCs.
     * @summary Logout Get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logoutGet(options) {
      return localVarFp.logoutGet(options).then((request) => request(axios, basePath));
    },
    /**
     * The logout endpoint deletes the session cookie of a logged in user and invalidates cached VCs.
     * @summary Logout Post
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logoutPost(options) {
      return localVarFp.logoutPost(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Me
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    me(options) {
      return localVarFp.me(options).then((request) => request(axios, basePath));
    },
    /**
     * Allows the user to switch his active organization (manipulates the user\'s login session).  This route will return a new login cookie to the user.
     * @summary Switch Organization
     * @param {string} orgId the organization id the user wishes to switch to as the active org on the session
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    switchOrganization(orgId, options) {
      return localVarFp.switchOrganization(orgId, options).then((request) => request(axios, basePath));
    }
  };
};
var AuthenticationApi = class extends BaseAPI {
  /**
   * The dev-login endpoints allows a developer inside permit.io to log in with an email address.  THIS IS ONLY AVAILABLE IN DEV MODE.
   * @summary (DEV MODE) Login
   * @param {AuthenticationApiDevLoginRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationApi
   */
  devLogin(requestParameters, options) {
    return AuthenticationApiFp(this.configuration).devLogin(requestParameters.devLogin, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Elements Fe Login As
   * @param {AuthenticationApiElementsFeLoginAsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationApi
   */
  elementsFeLoginAs(requestParameters, options) {
    return AuthenticationApiFp(this.configuration).elementsFeLoginAs(
      requestParameters.envId,
      requestParameters.userFELoginRequestInput,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Elements Login As
   * @param {AuthenticationApiElementsLoginAsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationApi
   */
  elementsLoginAs(requestParameters, options) {
    return AuthenticationApiFp(this.configuration).elementsLoginAs(requestParameters.userLoginRequestInput, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * The login endpoint allows the frontend app to exchange a user JWT with a user session. The user session is stored on an httpOnly + secure cookie.
   * @summary Login
   * @param {AuthenticationApiLoginRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationApi
   */
  login(requestParameters = {}, options) {
    return AuthenticationApiFp(this.configuration).login(requestParameters.inviteCode, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * The login endpoint allows the frontend app to exchange a user JWT with a user session. The user session is stored on an httpOnly + secure cookie.
   * @summary Login Elements
   * @param {AuthenticationApiLoginElementsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationApi
   */
  loginElements(requestParameters, options) {
    return AuthenticationApiFp(this.configuration).loginElements(requestParameters.token, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * The logout endpoint deletes the session cookie of a logged in user and invalidates cached VCs.
   * @summary Logout Get
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationApi
   */
  logoutGet(options) {
    return AuthenticationApiFp(this.configuration).logoutGet(options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * The logout endpoint deletes the session cookie of a logged in user and invalidates cached VCs.
   * @summary Logout Post
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationApi
   */
  logoutPost(options) {
    return AuthenticationApiFp(this.configuration).logoutPost(options).then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Me
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationApi
   */
  me(options) {
    return AuthenticationApiFp(this.configuration).me(options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Allows the user to switch his active organization (manipulates the user\'s login session).  This route will return a new login cookie to the user.
   * @summary Switch Organization
   * @param {AuthenticationApiSwitchOrganizationRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationApi
   */
  switchOrganization(requestParameters, options) {
    return AuthenticationApiFp(this.configuration).switchOrganization(requestParameters.orgId, options).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/condition-set-rules-api.ts
import globalAxios6 from "axios";
var ConditionSetRulesApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * Grant permissions to a user set *on* a resource set.  If the permission is already granted, it is skipped.
     * @summary Assign Set Permissions
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ConditionSetRuleCreate} conditionSetRuleCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    assignSetPermissions: async (projId, envId, conditionSetRuleCreate, options = {}) => {
      assertParamExists("assignSetPermissions", "projId", projId);
      assertParamExists("assignSetPermissions", "envId", envId);
      assertParamExists("assignSetPermissions", "conditionSetRuleCreate", conditionSetRuleCreate);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/set_rules`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        conditionSetRuleCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Lists the condition set rules matching the filter. - If the `user_set` filter is present, will only return the permissions set of that user set. - If the `permission` filter is present, will only return the permissions sets that equals to the queried permission. - If the `resource_set` filter is present, will only return the permissions set of that resource set.
     * @summary List Set Permissions
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} [userSet] optional user set filter, will only return rules where the permission is granted to this user set
     * @param {string} [permission] optional permission filter, will only return condition set rules granting this permission
     * @param {string} [resourceSet] optional resource set filter, will only return rules where the permission is granted on this resource set
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listSetPermissions: async (projId, envId, userSet, permission, resourceSet, page, perPage, options = {}) => {
      assertParamExists("listSetPermissions", "projId", projId);
      assertParamExists("listSetPermissions", "envId", envId);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/set_rules`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (userSet !== void 0) {
        localVarQueryParameter["user_set"] = userSet;
      }
      if (permission !== void 0) {
        localVarQueryParameter["permission"] = permission;
      }
      if (resourceSet !== void 0) {
        localVarQueryParameter["resource_set"] = resourceSet;
      }
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Revokes permissions to a user set *on* a resource set.  If the permission is not granted, it is skipped.
     * @summary Unassign Set Permissions
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ConditionSetRuleRemove} conditionSetRuleRemove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unassignSetPermissions: async (projId, envId, conditionSetRuleRemove, options = {}) => {
      assertParamExists("unassignSetPermissions", "projId", projId);
      assertParamExists("unassignSetPermissions", "envId", envId);
      assertParamExists("unassignSetPermissions", "conditionSetRuleRemove", conditionSetRuleRemove);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/set_rules`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        conditionSetRuleRemove,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var ConditionSetRulesApiFp = function(configuration) {
  const localVarAxiosParamCreator = ConditionSetRulesApiAxiosParamCreator(configuration);
  return {
    /**
     * Grant permissions to a user set *on* a resource set.  If the permission is already granted, it is skipped.
     * @summary Assign Set Permissions
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ConditionSetRuleCreate} conditionSetRuleCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async assignSetPermissions(projId, envId, conditionSetRuleCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.assignSetPermissions(
        projId,
        envId,
        conditionSetRuleCreate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios6, BASE_PATH, configuration);
    },
    /**
     * Lists the condition set rules matching the filter. - If the `user_set` filter is present, will only return the permissions set of that user set. - If the `permission` filter is present, will only return the permissions sets that equals to the queried permission. - If the `resource_set` filter is present, will only return the permissions set of that resource set.
     * @summary List Set Permissions
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} [userSet] optional user set filter, will only return rules where the permission is granted to this user set
     * @param {string} [permission] optional permission filter, will only return condition set rules granting this permission
     * @param {string} [resourceSet] optional resource set filter, will only return rules where the permission is granted on this resource set
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listSetPermissions(projId, envId, userSet, permission, resourceSet, page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listSetPermissions(
        projId,
        envId,
        userSet,
        permission,
        resourceSet,
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios6, BASE_PATH, configuration);
    },
    /**
     * Revokes permissions to a user set *on* a resource set.  If the permission is not granted, it is skipped.
     * @summary Unassign Set Permissions
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ConditionSetRuleRemove} conditionSetRuleRemove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async unassignSetPermissions(projId, envId, conditionSetRuleRemove, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.unassignSetPermissions(
        projId,
        envId,
        conditionSetRuleRemove,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios6, BASE_PATH, configuration);
    }
  };
};
var ConditionSetRulesApiFactory = function(configuration, basePath, axios) {
  const localVarFp = ConditionSetRulesApiFp(configuration);
  return {
    /**
     * Grant permissions to a user set *on* a resource set.  If the permission is already granted, it is skipped.
     * @summary Assign Set Permissions
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ConditionSetRuleCreate} conditionSetRuleCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    assignSetPermissions(projId, envId, conditionSetRuleCreate, options) {
      return localVarFp.assignSetPermissions(projId, envId, conditionSetRuleCreate, options).then((request) => request(axios, basePath));
    },
    /**
     * Lists the condition set rules matching the filter. - If the `user_set` filter is present, will only return the permissions set of that user set. - If the `permission` filter is present, will only return the permissions sets that equals to the queried permission. - If the `resource_set` filter is present, will only return the permissions set of that resource set.
     * @summary List Set Permissions
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} [userSet] optional user set filter, will only return rules where the permission is granted to this user set
     * @param {string} [permission] optional permission filter, will only return condition set rules granting this permission
     * @param {string} [resourceSet] optional resource set filter, will only return rules where the permission is granted on this resource set
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listSetPermissions(projId, envId, userSet, permission, resourceSet, page, perPage, options) {
      return localVarFp.listSetPermissions(projId, envId, userSet, permission, resourceSet, page, perPage, options).then((request) => request(axios, basePath));
    },
    /**
     * Revokes permissions to a user set *on* a resource set.  If the permission is not granted, it is skipped.
     * @summary Unassign Set Permissions
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ConditionSetRuleRemove} conditionSetRuleRemove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unassignSetPermissions(projId, envId, conditionSetRuleRemove, options) {
      return localVarFp.unassignSetPermissions(projId, envId, conditionSetRuleRemove, options).then((request) => request(axios, basePath));
    }
  };
};
var ConditionSetRulesApi = class extends BaseAPI {
  /**
   * Grant permissions to a user set *on* a resource set.  If the permission is already granted, it is skipped.
   * @summary Assign Set Permissions
   * @param {ConditionSetRulesApiAssignSetPermissionsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConditionSetRulesApi
   */
  assignSetPermissions(requestParameters, options) {
    return ConditionSetRulesApiFp(this.configuration).assignSetPermissions(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.conditionSetRuleCreate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Lists the condition set rules matching the filter. - If the `user_set` filter is present, will only return the permissions set of that user set. - If the `permission` filter is present, will only return the permissions sets that equals to the queried permission. - If the `resource_set` filter is present, will only return the permissions set of that resource set.
   * @summary List Set Permissions
   * @param {ConditionSetRulesApiListSetPermissionsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConditionSetRulesApi
   */
  listSetPermissions(requestParameters, options) {
    return ConditionSetRulesApiFp(this.configuration).listSetPermissions(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.userSet,
      requestParameters.permission,
      requestParameters.resourceSet,
      requestParameters.page,
      requestParameters.perPage,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Revokes permissions to a user set *on* a resource set.  If the permission is not granted, it is skipped.
   * @summary Unassign Set Permissions
   * @param {ConditionSetRulesApiUnassignSetPermissionsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConditionSetRulesApi
   */
  unassignSetPermissions(requestParameters, options) {
    return ConditionSetRulesApiFp(this.configuration).unassignSetPermissions(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.conditionSetRuleRemove,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/condition-sets-api.ts
import globalAxios7 from "axios";
var ConditionSetsApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * Creates a new condition set (can be either a user set or a resource set).
     * @summary Create Condition Set
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ConditionSetCreate} conditionSetCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createConditionSet: async (projId, envId, conditionSetCreate, options = {}) => {
      assertParamExists("createConditionSet", "projId", projId);
      assertParamExists("createConditionSet", "envId", envId);
      assertParamExists("createConditionSet", "conditionSetCreate", conditionSetCreate);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/condition_sets`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        conditionSetCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes a condition set and all its related data. This includes any permissions granted to said condition set (i.e: any matching condition set rules).
     * @summary Delete Condition Set
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} conditionSetId Either the unique id of the condition set, or the URL-friendly key of the condition set (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteConditionSet: async (projId, envId, conditionSetId, options = {}) => {
      assertParamExists("deleteConditionSet", "projId", projId);
      assertParamExists("deleteConditionSet", "envId", envId);
      assertParamExists("deleteConditionSet", "conditionSetId", conditionSetId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/condition_sets/{condition_set_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"condition_set_id"}}`, encodeURIComponent(String(conditionSetId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Gets a single condition set, if such condition set exists.
     * @summary Get Condition Set
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} conditionSetId Either the unique id of the condition set, or the URL-friendly key of the condition set (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConditionSet: async (projId, envId, conditionSetId, options = {}) => {
      assertParamExists("getConditionSet", "projId", projId);
      assertParamExists("getConditionSet", "envId", envId);
      assertParamExists("getConditionSet", "conditionSetId", conditionSetId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/condition_sets/{condition_set_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"condition_set_id"}}`, encodeURIComponent(String(conditionSetId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Gets all ancestors (parent, parent of parent, and so on)
     * @summary Get Condition Set Ancestors
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} conditionSetId Either the unique id of the condition set, or the URL-friendly key of the condition set (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConditionSetAncestors: async (projId, envId, conditionSetId, page, perPage, options = {}) => {
      assertParamExists("getConditionSetAncestors", "projId", projId);
      assertParamExists("getConditionSetAncestors", "envId", envId);
      assertParamExists("getConditionSetAncestors", "conditionSetId", conditionSetId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/condition_sets/{condition_set_id}/ancestors`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"condition_set_id"}}`, encodeURIComponent(String(conditionSetId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Gets all descendants (children, children of children, and so on)
     * @summary Get Condition Set Descendants
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} conditionSetId Either the unique id of the condition set, or the URL-friendly key of the condition set (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConditionSetDescendants: async (projId, envId, conditionSetId, page, perPage, options = {}) => {
      assertParamExists("getConditionSetDescendants", "projId", projId);
      assertParamExists("getConditionSetDescendants", "envId", envId);
      assertParamExists("getConditionSetDescendants", "conditionSetId", conditionSetId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/condition_sets/{condition_set_id}/descendants`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"condition_set_id"}}`, encodeURIComponent(String(conditionSetId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Get Condition Set Possible Parents
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} conditionSetId Either the unique id of the condition set, or the URL-friendly key of the condition set (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConditionSetPossibleParents: async (projId, envId, conditionSetId, page, perPage, options = {}) => {
      assertParamExists("getConditionSetPossibleParents", "projId", projId);
      assertParamExists("getConditionSetPossibleParents", "envId", envId);
      assertParamExists("getConditionSetPossibleParents", "conditionSetId", conditionSetId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/condition_sets/{condition_set_id}/possible_parents`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"condition_set_id"}}`, encodeURIComponent(String(conditionSetId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Lists all condition sets matching a filter.
     * @summary List Condition Sets
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ConditionSetType} [type] if provided, will return only the condition sets of the specified type. e.g: only user sets.
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listConditionSets: async (projId, envId, type, page, perPage, options = {}) => {
      assertParamExists("listConditionSets", "projId", projId);
      assertParamExists("listConditionSets", "envId", envId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/condition_sets`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (type !== void 0) {
        localVarQueryParameter["type"] = type;
      }
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Partially updates a condition set. Fields that will be provided will be completely overwritten.
     * @summary Update Condition Set
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} conditionSetId Either the unique id of the condition set, or the URL-friendly key of the condition set (i.e: the \&quot;slug\&quot;).
     * @param {ConditionSetUpdate} conditionSetUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateConditionSet: async (projId, envId, conditionSetId, conditionSetUpdate, options = {}) => {
      assertParamExists("updateConditionSet", "projId", projId);
      assertParamExists("updateConditionSet", "envId", envId);
      assertParamExists("updateConditionSet", "conditionSetId", conditionSetId);
      assertParamExists("updateConditionSet", "conditionSetUpdate", conditionSetUpdate);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/condition_sets/{condition_set_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"condition_set_id"}}`, encodeURIComponent(String(conditionSetId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        conditionSetUpdate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var ConditionSetsApiFp = function(configuration) {
  const localVarAxiosParamCreator = ConditionSetsApiAxiosParamCreator(configuration);
  return {
    /**
     * Creates a new condition set (can be either a user set or a resource set).
     * @summary Create Condition Set
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ConditionSetCreate} conditionSetCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createConditionSet(projId, envId, conditionSetCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createConditionSet(
        projId,
        envId,
        conditionSetCreate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios7, BASE_PATH, configuration);
    },
    /**
     * Deletes a condition set and all its related data. This includes any permissions granted to said condition set (i.e: any matching condition set rules).
     * @summary Delete Condition Set
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} conditionSetId Either the unique id of the condition set, or the URL-friendly key of the condition set (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteConditionSet(projId, envId, conditionSetId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteConditionSet(
        projId,
        envId,
        conditionSetId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios7, BASE_PATH, configuration);
    },
    /**
     * Gets a single condition set, if such condition set exists.
     * @summary Get Condition Set
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} conditionSetId Either the unique id of the condition set, or the URL-friendly key of the condition set (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getConditionSet(projId, envId, conditionSetId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getConditionSet(
        projId,
        envId,
        conditionSetId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios7, BASE_PATH, configuration);
    },
    /**
     * Gets all ancestors (parent, parent of parent, and so on)
     * @summary Get Condition Set Ancestors
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} conditionSetId Either the unique id of the condition set, or the URL-friendly key of the condition set (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getConditionSetAncestors(projId, envId, conditionSetId, page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getConditionSetAncestors(
        projId,
        envId,
        conditionSetId,
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios7, BASE_PATH, configuration);
    },
    /**
     * Gets all descendants (children, children of children, and so on)
     * @summary Get Condition Set Descendants
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} conditionSetId Either the unique id of the condition set, or the URL-friendly key of the condition set (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getConditionSetDescendants(projId, envId, conditionSetId, page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getConditionSetDescendants(
        projId,
        envId,
        conditionSetId,
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios7, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get Condition Set Possible Parents
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} conditionSetId Either the unique id of the condition set, or the URL-friendly key of the condition set (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getConditionSetPossibleParents(projId, envId, conditionSetId, page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getConditionSetPossibleParents(
        projId,
        envId,
        conditionSetId,
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios7, BASE_PATH, configuration);
    },
    /**
     * Lists all condition sets matching a filter.
     * @summary List Condition Sets
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ConditionSetType} [type] if provided, will return only the condition sets of the specified type. e.g: only user sets.
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listConditionSets(projId, envId, type, page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listConditionSets(
        projId,
        envId,
        type,
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios7, BASE_PATH, configuration);
    },
    /**
     * Partially updates a condition set. Fields that will be provided will be completely overwritten.
     * @summary Update Condition Set
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} conditionSetId Either the unique id of the condition set, or the URL-friendly key of the condition set (i.e: the \&quot;slug\&quot;).
     * @param {ConditionSetUpdate} conditionSetUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateConditionSet(projId, envId, conditionSetId, conditionSetUpdate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateConditionSet(
        projId,
        envId,
        conditionSetId,
        conditionSetUpdate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios7, BASE_PATH, configuration);
    }
  };
};
var ConditionSetsApiFactory = function(configuration, basePath, axios) {
  const localVarFp = ConditionSetsApiFp(configuration);
  return {
    /**
     * Creates a new condition set (can be either a user set or a resource set).
     * @summary Create Condition Set
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ConditionSetCreate} conditionSetCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createConditionSet(projId, envId, conditionSetCreate, options) {
      return localVarFp.createConditionSet(projId, envId, conditionSetCreate, options).then((request) => request(axios, basePath));
    },
    /**
     * Deletes a condition set and all its related data. This includes any permissions granted to said condition set (i.e: any matching condition set rules).
     * @summary Delete Condition Set
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} conditionSetId Either the unique id of the condition set, or the URL-friendly key of the condition set (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteConditionSet(projId, envId, conditionSetId, options) {
      return localVarFp.deleteConditionSet(projId, envId, conditionSetId, options).then((request) => request(axios, basePath));
    },
    /**
     * Gets a single condition set, if such condition set exists.
     * @summary Get Condition Set
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} conditionSetId Either the unique id of the condition set, or the URL-friendly key of the condition set (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConditionSet(projId, envId, conditionSetId, options) {
      return localVarFp.getConditionSet(projId, envId, conditionSetId, options).then((request) => request(axios, basePath));
    },
    /**
     * Gets all ancestors (parent, parent of parent, and so on)
     * @summary Get Condition Set Ancestors
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} conditionSetId Either the unique id of the condition set, or the URL-friendly key of the condition set (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConditionSetAncestors(projId, envId, conditionSetId, page, perPage, options) {
      return localVarFp.getConditionSetAncestors(projId, envId, conditionSetId, page, perPage, options).then((request) => request(axios, basePath));
    },
    /**
     * Gets all descendants (children, children of children, and so on)
     * @summary Get Condition Set Descendants
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} conditionSetId Either the unique id of the condition set, or the URL-friendly key of the condition set (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConditionSetDescendants(projId, envId, conditionSetId, page, perPage, options) {
      return localVarFp.getConditionSetDescendants(projId, envId, conditionSetId, page, perPage, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get Condition Set Possible Parents
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} conditionSetId Either the unique id of the condition set, or the URL-friendly key of the condition set (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConditionSetPossibleParents(projId, envId, conditionSetId, page, perPage, options) {
      return localVarFp.getConditionSetPossibleParents(projId, envId, conditionSetId, page, perPage, options).then((request) => request(axios, basePath));
    },
    /**
     * Lists all condition sets matching a filter.
     * @summary List Condition Sets
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ConditionSetType} [type] if provided, will return only the condition sets of the specified type. e.g: only user sets.
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listConditionSets(projId, envId, type, page, perPage, options) {
      return localVarFp.listConditionSets(projId, envId, type, page, perPage, options).then((request) => request(axios, basePath));
    },
    /**
     * Partially updates a condition set. Fields that will be provided will be completely overwritten.
     * @summary Update Condition Set
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} conditionSetId Either the unique id of the condition set, or the URL-friendly key of the condition set (i.e: the \&quot;slug\&quot;).
     * @param {ConditionSetUpdate} conditionSetUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateConditionSet(projId, envId, conditionSetId, conditionSetUpdate, options) {
      return localVarFp.updateConditionSet(projId, envId, conditionSetId, conditionSetUpdate, options).then((request) => request(axios, basePath));
    }
  };
};
var ConditionSetsApi = class extends BaseAPI {
  /**
   * Creates a new condition set (can be either a user set or a resource set).
   * @summary Create Condition Set
   * @param {ConditionSetsApiCreateConditionSetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConditionSetsApi
   */
  createConditionSet(requestParameters, options) {
    return ConditionSetsApiFp(this.configuration).createConditionSet(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.conditionSetCreate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Deletes a condition set and all its related data. This includes any permissions granted to said condition set (i.e: any matching condition set rules).
   * @summary Delete Condition Set
   * @param {ConditionSetsApiDeleteConditionSetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConditionSetsApi
   */
  deleteConditionSet(requestParameters, options) {
    return ConditionSetsApiFp(this.configuration).deleteConditionSet(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.conditionSetId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Gets a single condition set, if such condition set exists.
   * @summary Get Condition Set
   * @param {ConditionSetsApiGetConditionSetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConditionSetsApi
   */
  getConditionSet(requestParameters, options) {
    return ConditionSetsApiFp(this.configuration).getConditionSet(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.conditionSetId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Gets all ancestors (parent, parent of parent, and so on)
   * @summary Get Condition Set Ancestors
   * @param {ConditionSetsApiGetConditionSetAncestorsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConditionSetsApi
   */
  getConditionSetAncestors(requestParameters, options) {
    return ConditionSetsApiFp(this.configuration).getConditionSetAncestors(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.conditionSetId,
      requestParameters.page,
      requestParameters.perPage,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Gets all descendants (children, children of children, and so on)
   * @summary Get Condition Set Descendants
   * @param {ConditionSetsApiGetConditionSetDescendantsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConditionSetsApi
   */
  getConditionSetDescendants(requestParameters, options) {
    return ConditionSetsApiFp(this.configuration).getConditionSetDescendants(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.conditionSetId,
      requestParameters.page,
      requestParameters.perPage,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Get Condition Set Possible Parents
   * @param {ConditionSetsApiGetConditionSetPossibleParentsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConditionSetsApi
   */
  getConditionSetPossibleParents(requestParameters, options) {
    return ConditionSetsApiFp(this.configuration).getConditionSetPossibleParents(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.conditionSetId,
      requestParameters.page,
      requestParameters.perPage,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Lists all condition sets matching a filter.
   * @summary List Condition Sets
   * @param {ConditionSetsApiListConditionSetsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConditionSetsApi
   */
  listConditionSets(requestParameters, options) {
    return ConditionSetsApiFp(this.configuration).listConditionSets(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.type,
      requestParameters.page,
      requestParameters.perPage,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Partially updates a condition set. Fields that will be provided will be completely overwritten.
   * @summary Update Condition Set
   * @param {ConditionSetsApiUpdateConditionSetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConditionSetsApi
   */
  updateConditionSet(requestParameters, options) {
    return ConditionSetsApiFp(this.configuration).updateConditionSet(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.conditionSetId,
      requestParameters.conditionSetUpdate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/decision-logs-api.ts
import globalAxios8 from "axios";
var DecisionLogsApiAxiosParamCreator = function(configuration) {
  return {
    /**
     *
     * @summary List PDP Decisions
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} pdpId The unique id of the pdp
     * @param {Array<string>} [users] List of user IDs to filter by
     * @param {boolean} [approved] Filter by approved decisions
     * @param {Array<string>} [resources] Filter by resources
     * @param {number} [timestampFrom] Filter by timestamp from
     * @param {number} [timestampTo] Filter by timestamp to
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPdpDecisionLogs: async (projId, envId, pdpId, users, approved, resources, timestampFrom, timestampTo, page, perPage, options = {}) => {
      assertParamExists("listPdpDecisionLogs", "projId", projId);
      assertParamExists("listPdpDecisionLogs", "envId", envId);
      assertParamExists("listPdpDecisionLogs", "pdpId", pdpId);
      const localVarPath = `/v2/pdps/{proj_id}/{env_id}/decision-logs/{pdp_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"pdp_id"}}`, encodeURIComponent(String(pdpId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (users) {
        localVarQueryParameter["users"] = users;
      }
      if (approved !== void 0) {
        localVarQueryParameter["approved"] = approved;
      }
      if (resources) {
        localVarQueryParameter["resources"] = resources;
      }
      if (timestampFrom !== void 0) {
        localVarQueryParameter["timestamp_from"] = timestampFrom;
      }
      if (timestampTo !== void 0) {
        localVarQueryParameter["timestamp_to"] = timestampTo;
      }
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var DecisionLogsApiFp = function(configuration) {
  const localVarAxiosParamCreator = DecisionLogsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary List PDP Decisions
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} pdpId The unique id of the pdp
     * @param {Array<string>} [users] List of user IDs to filter by
     * @param {boolean} [approved] Filter by approved decisions
     * @param {Array<string>} [resources] Filter by resources
     * @param {number} [timestampFrom] Filter by timestamp from
     * @param {number} [timestampTo] Filter by timestamp to
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listPdpDecisionLogs(projId, envId, pdpId, users, approved, resources, timestampFrom, timestampTo, page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listPdpDecisionLogs(
        projId,
        envId,
        pdpId,
        users,
        approved,
        resources,
        timestampFrom,
        timestampTo,
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios8, BASE_PATH, configuration);
    }
  };
};
var DecisionLogsApiFactory = function(configuration, basePath, axios) {
  const localVarFp = DecisionLogsApiFp(configuration);
  return {
    /**
     *
     * @summary List PDP Decisions
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} pdpId The unique id of the pdp
     * @param {Array<string>} [users] List of user IDs to filter by
     * @param {boolean} [approved] Filter by approved decisions
     * @param {Array<string>} [resources] Filter by resources
     * @param {number} [timestampFrom] Filter by timestamp from
     * @param {number} [timestampTo] Filter by timestamp to
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPdpDecisionLogs(projId, envId, pdpId, users, approved, resources, timestampFrom, timestampTo, page, perPage, options) {
      return localVarFp.listPdpDecisionLogs(
        projId,
        envId,
        pdpId,
        users,
        approved,
        resources,
        timestampFrom,
        timestampTo,
        page,
        perPage,
        options
      ).then((request) => request(axios, basePath));
    }
  };
};
var DecisionLogsApi = class extends BaseAPI {
  /**
   *
   * @summary List PDP Decisions
   * @param {DecisionLogsApiListPdpDecisionLogsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DecisionLogsApi
   */
  listPdpDecisionLogs(requestParameters, options) {
    return DecisionLogsApiFp(this.configuration).listPdpDecisionLogs(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.pdpId,
      requestParameters.users,
      requestParameters.approved,
      requestParameters.resources,
      requestParameters.timestampFrom,
      requestParameters.timestampTo,
      requestParameters.page,
      requestParameters.perPage,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/decision-logs-ingress-api.ts
import globalAxios9 from "axios";
var DecisionLogsIngressApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * This ingress endpoint captures OPA decision logs.
     * @summary OPA Decision Logs Ingress
     * @param {Array<object>} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    insertOpaDecisionLogs: async (requestBody, options = {}) => {
      assertParamExists("insertOpaDecisionLogs", "requestBody", requestBody);
      const localVarPath = `/v2/decision-logs/ingress`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBody,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var DecisionLogsIngressApiFp = function(configuration) {
  const localVarAxiosParamCreator = DecisionLogsIngressApiAxiosParamCreator(configuration);
  return {
    /**
     * This ingress endpoint captures OPA decision logs.
     * @summary OPA Decision Logs Ingress
     * @param {Array<object>} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async insertOpaDecisionLogs(requestBody, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.insertOpaDecisionLogs(
        requestBody,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios9, BASE_PATH, configuration);
    }
  };
};
var DecisionLogsIngressApiFactory = function(configuration, basePath, axios) {
  const localVarFp = DecisionLogsIngressApiFp(configuration);
  return {
    /**
     * This ingress endpoint captures OPA decision logs.
     * @summary OPA Decision Logs Ingress
     * @param {Array<object>} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    insertOpaDecisionLogs(requestBody, options) {
      return localVarFp.insertOpaDecisionLogs(requestBody, options).then((request) => request(axios, basePath));
    }
  };
};
var DecisionLogsIngressApi = class extends BaseAPI {
  /**
   * This ingress endpoint captures OPA decision logs.
   * @summary OPA Decision Logs Ingress
   * @param {DecisionLogsIngressApiInsertOpaDecisionLogsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DecisionLogsIngressApi
   */
  insertOpaDecisionLogs(requestParameters, options) {
    return DecisionLogsIngressApiFp(this.configuration).insertOpaDecisionLogs(requestParameters.requestBody, options).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/default-api.ts
import globalAxios10 from "axios";
var DefaultApiAxiosParamCreator = function(configuration) {
  return {
    /**
     *
     * @summary Dummy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    dummy: async (options = {}) => {
      const localVarPath = `/v2/stress/dummy`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Dummy Db
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    dummyDb: async (options = {}) => {
      const localVarPath = `/v2/stress/db/dummy`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Get Organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrganizationV2StressDbOrganizationGet: async (options = {}) => {
      const localVarPath = `/v2/stress/db/organization`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Get Organization With Authn
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrganizationWithAuthn: async (options = {}) => {
      const localVarPath = `/v2/stress/db/organization_auth`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Get Organization With Authz
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrganizationWithAuthz: async (options = {}) => {
      const localVarPath = `/v2/stress/db/organization_authz`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var DefaultApiFp = function(configuration) {
  const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Dummy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async dummy(options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.dummy(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios10, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Dummy Db
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async dummyDb(options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.dummyDb(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios10, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get Organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getOrganizationV2StressDbOrganizationGet(options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationV2StressDbOrganizationGet(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios10, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get Organization With Authn
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getOrganizationWithAuthn(options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationWithAuthn(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios10, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get Organization With Authz
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getOrganizationWithAuthz(options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationWithAuthz(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios10, BASE_PATH, configuration);
    }
  };
};
var DefaultApiFactory = function(configuration, basePath, axios) {
  const localVarFp = DefaultApiFp(configuration);
  return {
    /**
     *
     * @summary Dummy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    dummy(options) {
      return localVarFp.dummy(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Dummy Db
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    dummyDb(options) {
      return localVarFp.dummyDb(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get Organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrganizationV2StressDbOrganizationGet(options) {
      return localVarFp.getOrganizationV2StressDbOrganizationGet(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get Organization With Authn
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrganizationWithAuthn(options) {
      return localVarFp.getOrganizationWithAuthn(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get Organization With Authz
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrganizationWithAuthz(options) {
      return localVarFp.getOrganizationWithAuthz(options).then((request) => request(axios, basePath));
    }
  };
};
var DefaultApi = class extends BaseAPI {
  /**
   *
   * @summary Dummy
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  dummy(options) {
    return DefaultApiFp(this.configuration).dummy(options).then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Dummy Db
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  dummyDb(options) {
    return DefaultApiFp(this.configuration).dummyDb(options).then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Get Organization
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  getOrganizationV2StressDbOrganizationGet(options) {
    return DefaultApiFp(this.configuration).getOrganizationV2StressDbOrganizationGet(options).then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Get Organization With Authn
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  getOrganizationWithAuthn(options) {
    return DefaultApiFp(this.configuration).getOrganizationWithAuthn(options).then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Get Organization With Authz
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  getOrganizationWithAuthz(options) {
    return DefaultApiFp(this.configuration).getOrganizationWithAuthz(options).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/elements-configs-api.ts
import globalAxios11 from "axios";
var ElementsConfigsApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * Creates a new elements_config under the active organization.
     * @summary Create Elements Config
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ElementsConfigCreate} elementsConfigCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createElementsConfig: async (projId, envId, elementsConfigCreate, options = {}) => {
      assertParamExists("createElementsConfig", "projId", projId);
      assertParamExists("createElementsConfig", "envId", envId);
      assertParamExists("createElementsConfig", "elementsConfigCreate", elementsConfigCreate);
      const localVarPath = `/v2/elements/{proj_id}/{env_id}/config`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        elementsConfigCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes the elements_config and all its related data.
     * @summary Delete Elements Config
     * @param {string} elementsConfigId Either the unique id of the elements_config, or the URL-friendly key of the elements_config (i.e: the \&quot;slug\&quot;).
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteElementsConfig: async (elementsConfigId, projId, envId, options = {}) => {
      assertParamExists("deleteElementsConfig", "elementsConfigId", elementsConfigId);
      assertParamExists("deleteElementsConfig", "projId", projId);
      assertParamExists("deleteElementsConfig", "envId", envId);
      const localVarPath = `/v2/elements/{proj_id}/{env_id}/{elements_config_id}`.replace(`{${"elements_config_id"}}`, encodeURIComponent(String(elementsConfigId))).replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Gets a single elements_config matching the given elements_config_id, if such elements_config exists.
     * @summary Get Elements Config
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} elementsConfigId Either the unique id of the elements_config, or the URL-friendly key of the elements_config (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getElementsConfig: async (projId, envId, elementsConfigId, options = {}) => {
      assertParamExists("getElementsConfig", "projId", projId);
      assertParamExists("getElementsConfig", "envId", envId);
      assertParamExists("getElementsConfig", "elementsConfigId", elementsConfigId);
      const localVarPath = `/v2/elements/{proj_id}/{env_id}/config/{elements_config_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"elements_config_id"}}`, encodeURIComponent(String(elementsConfigId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Gets a single elements_config matching the given elements_config_id, if such elements_config exists.
     * @summary Get Elements Config Runtime
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} elementsConfigId Either the unique id of the elements_config, or the URL-friendly key of the elements_config (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getElementsConfigRuntime: async (projId, envId, elementsConfigId, options = {}) => {
      assertParamExists("getElementsConfigRuntime", "projId", projId);
      assertParamExists("getElementsConfigRuntime", "envId", envId);
      assertParamExists("getElementsConfigRuntime", "elementsConfigId", elementsConfigId);
      const localVarPath = `/v2/elements/{proj_id}/{env_id}/config/{elements_config_id}/runtime`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"elements_config_id"}}`, encodeURIComponent(String(elementsConfigId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Get Elements Type Config
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ElementsType} elementType Either the unique id of the elements_type, or the URL-friendly key of the elements_type (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getElementsTypeConfig: async (projId, envId, elementType, options = {}) => {
      assertParamExists("getElementsTypeConfig", "projId", projId);
      assertParamExists("getElementsTypeConfig", "envId", envId);
      assertParamExists("getElementsTypeConfig", "elementType", elementType);
      const localVarPath = `/v2/elements/{proj_id}/{env_id}/{element_type}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"element_type"}}`, encodeURIComponent(String(elementType)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Lists all the elements_configs under the active organization.
     * @summary List Elements Configs
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listElementsConfigs: async (projId, envId, page, perPage, options = {}) => {
      assertParamExists("listElementsConfigs", "projId", projId);
      assertParamExists("listElementsConfigs", "envId", envId);
      const localVarPath = `/v2/elements/{proj_id}/{env_id}/config`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Updates the elements_config.
     * @summary Update Elements Config
     * @param {string} elementsConfigId Either the unique id of the elements_config, or the URL-friendly key of the elements_config (i.e: the \&quot;slug\&quot;).
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ElementsConfigUpdate} elementsConfigUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateElementsConfig: async (elementsConfigId, projId, envId, elementsConfigUpdate, options = {}) => {
      assertParamExists("updateElementsConfig", "elementsConfigId", elementsConfigId);
      assertParamExists("updateElementsConfig", "projId", projId);
      assertParamExists("updateElementsConfig", "envId", envId);
      assertParamExists("updateElementsConfig", "elementsConfigUpdate", elementsConfigUpdate);
      const localVarPath = `/v2/elements/{proj_id}/{env_id}/config/{elements_config_id}`.replace(`{${"elements_config_id"}}`, encodeURIComponent(String(elementsConfigId))).replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        elementsConfigUpdate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Update Elements Type Permissions
     * @param {ElementsType} elementType Either the unique id of the elements_type, or the URL-friendly key of the elements_type (i.e: the \&quot;slug\&quot;).
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ElementsEnvTypeUpdate} elementsEnvTypeUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateElementsTypePermissions: async (elementType, projId, envId, elementsEnvTypeUpdate, options = {}) => {
      assertParamExists("updateElementsTypePermissions", "elementType", elementType);
      assertParamExists("updateElementsTypePermissions", "projId", projId);
      assertParamExists("updateElementsTypePermissions", "envId", envId);
      assertParamExists(
        "updateElementsTypePermissions",
        "elementsEnvTypeUpdate",
        elementsEnvTypeUpdate
      );
      const localVarPath = `/v2/elements/{proj_id}/{env_id}/{element_type}`.replace(`{${"element_type"}}`, encodeURIComponent(String(elementType))).replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        elementsEnvTypeUpdate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var ElementsConfigsApiFp = function(configuration) {
  const localVarAxiosParamCreator = ElementsConfigsApiAxiosParamCreator(configuration);
  return {
    /**
     * Creates a new elements_config under the active organization.
     * @summary Create Elements Config
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ElementsConfigCreate} elementsConfigCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createElementsConfig(projId, envId, elementsConfigCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createElementsConfig(
        projId,
        envId,
        elementsConfigCreate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios11, BASE_PATH, configuration);
    },
    /**
     * Deletes the elements_config and all its related data.
     * @summary Delete Elements Config
     * @param {string} elementsConfigId Either the unique id of the elements_config, or the URL-friendly key of the elements_config (i.e: the \&quot;slug\&quot;).
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteElementsConfig(elementsConfigId, projId, envId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteElementsConfig(
        elementsConfigId,
        projId,
        envId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios11, BASE_PATH, configuration);
    },
    /**
     * Gets a single elements_config matching the given elements_config_id, if such elements_config exists.
     * @summary Get Elements Config
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} elementsConfigId Either the unique id of the elements_config, or the URL-friendly key of the elements_config (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getElementsConfig(projId, envId, elementsConfigId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getElementsConfig(
        projId,
        envId,
        elementsConfigId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios11, BASE_PATH, configuration);
    },
    /**
     * Gets a single elements_config matching the given elements_config_id, if such elements_config exists.
     * @summary Get Elements Config Runtime
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} elementsConfigId Either the unique id of the elements_config, or the URL-friendly key of the elements_config (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getElementsConfigRuntime(projId, envId, elementsConfigId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getElementsConfigRuntime(
        projId,
        envId,
        elementsConfigId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios11, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get Elements Type Config
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ElementsType} elementType Either the unique id of the elements_type, or the URL-friendly key of the elements_type (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getElementsTypeConfig(projId, envId, elementType, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getElementsTypeConfig(
        projId,
        envId,
        elementType,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios11, BASE_PATH, configuration);
    },
    /**
     * Lists all the elements_configs under the active organization.
     * @summary List Elements Configs
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listElementsConfigs(projId, envId, page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listElementsConfigs(
        projId,
        envId,
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios11, BASE_PATH, configuration);
    },
    /**
     * Updates the elements_config.
     * @summary Update Elements Config
     * @param {string} elementsConfigId Either the unique id of the elements_config, or the URL-friendly key of the elements_config (i.e: the \&quot;slug\&quot;).
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ElementsConfigUpdate} elementsConfigUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateElementsConfig(elementsConfigId, projId, envId, elementsConfigUpdate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateElementsConfig(
        elementsConfigId,
        projId,
        envId,
        elementsConfigUpdate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios11, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Update Elements Type Permissions
     * @param {ElementsType} elementType Either the unique id of the elements_type, or the URL-friendly key of the elements_type (i.e: the \&quot;slug\&quot;).
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ElementsEnvTypeUpdate} elementsEnvTypeUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateElementsTypePermissions(elementType, projId, envId, elementsEnvTypeUpdate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateElementsTypePermissions(
        elementType,
        projId,
        envId,
        elementsEnvTypeUpdate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios11, BASE_PATH, configuration);
    }
  };
};
var ElementsConfigsApiFactory = function(configuration, basePath, axios) {
  const localVarFp = ElementsConfigsApiFp(configuration);
  return {
    /**
     * Creates a new elements_config under the active organization.
     * @summary Create Elements Config
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ElementsConfigCreate} elementsConfigCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createElementsConfig(projId, envId, elementsConfigCreate, options) {
      return localVarFp.createElementsConfig(projId, envId, elementsConfigCreate, options).then((request) => request(axios, basePath));
    },
    /**
     * Deletes the elements_config and all its related data.
     * @summary Delete Elements Config
     * @param {string} elementsConfigId Either the unique id of the elements_config, or the URL-friendly key of the elements_config (i.e: the \&quot;slug\&quot;).
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteElementsConfig(elementsConfigId, projId, envId, options) {
      return localVarFp.deleteElementsConfig(elementsConfigId, projId, envId, options).then((request) => request(axios, basePath));
    },
    /**
     * Gets a single elements_config matching the given elements_config_id, if such elements_config exists.
     * @summary Get Elements Config
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} elementsConfigId Either the unique id of the elements_config, or the URL-friendly key of the elements_config (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getElementsConfig(projId, envId, elementsConfigId, options) {
      return localVarFp.getElementsConfig(projId, envId, elementsConfigId, options).then((request) => request(axios, basePath));
    },
    /**
     * Gets a single elements_config matching the given elements_config_id, if such elements_config exists.
     * @summary Get Elements Config Runtime
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} elementsConfigId Either the unique id of the elements_config, or the URL-friendly key of the elements_config (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getElementsConfigRuntime(projId, envId, elementsConfigId, options) {
      return localVarFp.getElementsConfigRuntime(projId, envId, elementsConfigId, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get Elements Type Config
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ElementsType} elementType Either the unique id of the elements_type, or the URL-friendly key of the elements_type (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getElementsTypeConfig(projId, envId, elementType, options) {
      return localVarFp.getElementsTypeConfig(projId, envId, elementType, options).then((request) => request(axios, basePath));
    },
    /**
     * Lists all the elements_configs under the active organization.
     * @summary List Elements Configs
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listElementsConfigs(projId, envId, page, perPage, options) {
      return localVarFp.listElementsConfigs(projId, envId, page, perPage, options).then((request) => request(axios, basePath));
    },
    /**
     * Updates the elements_config.
     * @summary Update Elements Config
     * @param {string} elementsConfigId Either the unique id of the elements_config, or the URL-friendly key of the elements_config (i.e: the \&quot;slug\&quot;).
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ElementsConfigUpdate} elementsConfigUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateElementsConfig(elementsConfigId, projId, envId, elementsConfigUpdate, options) {
      return localVarFp.updateElementsConfig(elementsConfigId, projId, envId, elementsConfigUpdate, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update Elements Type Permissions
     * @param {ElementsType} elementType Either the unique id of the elements_type, or the URL-friendly key of the elements_type (i.e: the \&quot;slug\&quot;).
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ElementsEnvTypeUpdate} elementsEnvTypeUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateElementsTypePermissions(elementType, projId, envId, elementsEnvTypeUpdate, options) {
      return localVarFp.updateElementsTypePermissions(elementType, projId, envId, elementsEnvTypeUpdate, options).then((request) => request(axios, basePath));
    }
  };
};
var ElementsConfigsApi = class extends BaseAPI {
  /**
   * Creates a new elements_config under the active organization.
   * @summary Create Elements Config
   * @param {ElementsConfigsApiCreateElementsConfigRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ElementsConfigsApi
   */
  createElementsConfig(requestParameters, options) {
    return ElementsConfigsApiFp(this.configuration).createElementsConfig(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.elementsConfigCreate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Deletes the elements_config and all its related data.
   * @summary Delete Elements Config
   * @param {ElementsConfigsApiDeleteElementsConfigRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ElementsConfigsApi
   */
  deleteElementsConfig(requestParameters, options) {
    return ElementsConfigsApiFp(this.configuration).deleteElementsConfig(
      requestParameters.elementsConfigId,
      requestParameters.projId,
      requestParameters.envId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Gets a single elements_config matching the given elements_config_id, if such elements_config exists.
   * @summary Get Elements Config
   * @param {ElementsConfigsApiGetElementsConfigRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ElementsConfigsApi
   */
  getElementsConfig(requestParameters, options) {
    return ElementsConfigsApiFp(this.configuration).getElementsConfig(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.elementsConfigId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Gets a single elements_config matching the given elements_config_id, if such elements_config exists.
   * @summary Get Elements Config Runtime
   * @param {ElementsConfigsApiGetElementsConfigRuntimeRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ElementsConfigsApi
   */
  getElementsConfigRuntime(requestParameters, options) {
    return ElementsConfigsApiFp(this.configuration).getElementsConfigRuntime(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.elementsConfigId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Get Elements Type Config
   * @param {ElementsConfigsApiGetElementsTypeConfigRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ElementsConfigsApi
   */
  getElementsTypeConfig(requestParameters, options) {
    return ElementsConfigsApiFp(this.configuration).getElementsTypeConfig(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.elementType,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Lists all the elements_configs under the active organization.
   * @summary List Elements Configs
   * @param {ElementsConfigsApiListElementsConfigsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ElementsConfigsApi
   */
  listElementsConfigs(requestParameters, options) {
    return ElementsConfigsApiFp(this.configuration).listElementsConfigs(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.page,
      requestParameters.perPage,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Updates the elements_config.
   * @summary Update Elements Config
   * @param {ElementsConfigsApiUpdateElementsConfigRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ElementsConfigsApi
   */
  updateElementsConfig(requestParameters, options) {
    return ElementsConfigsApiFp(this.configuration).updateElementsConfig(
      requestParameters.elementsConfigId,
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.elementsConfigUpdate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Update Elements Type Permissions
   * @param {ElementsConfigsApiUpdateElementsTypePermissionsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ElementsConfigsApi
   */
  updateElementsTypePermissions(requestParameters, options) {
    return ElementsConfigsApiFp(this.configuration).updateElementsTypePermissions(
      requestParameters.elementType,
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.elementsEnvTypeUpdate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/environments-api.ts
import globalAxios12 from "axios";
var EnvironmentsApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * Copy environment  This endpoint either duplicates an existing environment to a new environment in the same project, or copies from an existing environment to another existing environment.  The `scope` object controls which objects will be copied to the target environment.  To clone to a new environment, the user must have write permissions to the containing project. To clone into an existing environment, the user must have write permissions to the target environment.  Copying environments across projects or organizations is not allowed.
     * @summary Copy Environment
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {EnvironmentCopy} environmentCopy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    copyEnvironment: async (projId, envId, environmentCopy, options = {}) => {
      assertParamExists("copyEnvironment", "projId", projId);
      assertParamExists("copyEnvironment", "envId", envId);
      assertParamExists("copyEnvironment", "environmentCopy", environmentCopy);
      const localVarPath = `/v2/projects/{proj_id}/envs/{env_id}/copy`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        environmentCopy,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Creates a new environment under a given project.
     * @summary Create Environment
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {EnvironmentCreate} environmentCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createEnvironment: async (projId, environmentCreate, options = {}) => {
      assertParamExists("createEnvironment", "projId", projId);
      assertParamExists("createEnvironment", "environmentCreate", environmentCreate);
      const localVarPath = `/v2/projects/{proj_id}/envs`.replace(
        `{${"proj_id"}}`,
        encodeURIComponent(String(projId))
      );
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        environmentCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes an environment and all its related data.
     * @summary Delete Environment
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteEnvironment: async (projId, envId, options = {}) => {
      assertParamExists("deleteEnvironment", "projId", projId);
      assertParamExists("deleteEnvironment", "envId", envId);
      const localVarPath = `/v2/projects/{proj_id}/envs/{env_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Gets a single environment matching the given env_id, if such environment exists.
     * @summary Get Environment
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEnvironment: async (projId, envId, options = {}) => {
      assertParamExists("getEnvironment", "projId", projId);
      assertParamExists("getEnvironment", "envId", envId);
      const localVarPath = `/v2/projects/{proj_id}/envs/{env_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Lists all the environments under a given project.
     * @summary List Environments
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listEnvironments: async (projId, page, perPage, options = {}) => {
      assertParamExists("listEnvironments", "projId", projId);
      const localVarPath = `/v2/projects/{proj_id}/envs`.replace(
        `{${"proj_id"}}`,
        encodeURIComponent(String(projId))
      );
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Stats Environments
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    statsEnvironments: async (projId, envId, options = {}) => {
      assertParamExists("statsEnvironments", "projId", projId);
      assertParamExists("statsEnvironments", "envId", envId);
      const localVarPath = `/v2/projects/{proj_id}/envs/{env_id}/stats`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Updates the environment.
     * @summary Update Environment
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {EnvironmentUpdate} environmentUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateEnvironment: async (projId, envId, environmentUpdate, options = {}) => {
      assertParamExists("updateEnvironment", "projId", projId);
      assertParamExists("updateEnvironment", "envId", envId);
      assertParamExists("updateEnvironment", "environmentUpdate", environmentUpdate);
      const localVarPath = `/v2/projects/{proj_id}/envs/{env_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        environmentUpdate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var EnvironmentsApiFp = function(configuration) {
  const localVarAxiosParamCreator = EnvironmentsApiAxiosParamCreator(configuration);
  return {
    /**
     * Copy environment  This endpoint either duplicates an existing environment to a new environment in the same project, or copies from an existing environment to another existing environment.  The `scope` object controls which objects will be copied to the target environment.  To clone to a new environment, the user must have write permissions to the containing project. To clone into an existing environment, the user must have write permissions to the target environment.  Copying environments across projects or organizations is not allowed.
     * @summary Copy Environment
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {EnvironmentCopy} environmentCopy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async copyEnvironment(projId, envId, environmentCopy, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.copyEnvironment(
        projId,
        envId,
        environmentCopy,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios12, BASE_PATH, configuration);
    },
    /**
     * Creates a new environment under a given project.
     * @summary Create Environment
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {EnvironmentCreate} environmentCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createEnvironment(projId, environmentCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createEnvironment(
        projId,
        environmentCreate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios12, BASE_PATH, configuration);
    },
    /**
     * Deletes an environment and all its related data.
     * @summary Delete Environment
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteEnvironment(projId, envId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEnvironment(
        projId,
        envId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios12, BASE_PATH, configuration);
    },
    /**
     * Gets a single environment matching the given env_id, if such environment exists.
     * @summary Get Environment
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEnvironment(projId, envId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getEnvironment(
        projId,
        envId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios12, BASE_PATH, configuration);
    },
    /**
     * Lists all the environments under a given project.
     * @summary List Environments
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listEnvironments(projId, page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listEnvironments(
        projId,
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios12, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Stats Environments
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async statsEnvironments(projId, envId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.statsEnvironments(
        projId,
        envId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios12, BASE_PATH, configuration);
    },
    /**
     * Updates the environment.
     * @summary Update Environment
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {EnvironmentUpdate} environmentUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateEnvironment(projId, envId, environmentUpdate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateEnvironment(
        projId,
        envId,
        environmentUpdate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios12, BASE_PATH, configuration);
    }
  };
};
var EnvironmentsApiFactory = function(configuration, basePath, axios) {
  const localVarFp = EnvironmentsApiFp(configuration);
  return {
    /**
     * Copy environment  This endpoint either duplicates an existing environment to a new environment in the same project, or copies from an existing environment to another existing environment.  The `scope` object controls which objects will be copied to the target environment.  To clone to a new environment, the user must have write permissions to the containing project. To clone into an existing environment, the user must have write permissions to the target environment.  Copying environments across projects or organizations is not allowed.
     * @summary Copy Environment
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {EnvironmentCopy} environmentCopy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    copyEnvironment(projId, envId, environmentCopy, options) {
      return localVarFp.copyEnvironment(projId, envId, environmentCopy, options).then((request) => request(axios, basePath));
    },
    /**
     * Creates a new environment under a given project.
     * @summary Create Environment
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {EnvironmentCreate} environmentCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createEnvironment(projId, environmentCreate, options) {
      return localVarFp.createEnvironment(projId, environmentCreate, options).then((request) => request(axios, basePath));
    },
    /**
     * Deletes an environment and all its related data.
     * @summary Delete Environment
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteEnvironment(projId, envId, options) {
      return localVarFp.deleteEnvironment(projId, envId, options).then((request) => request(axios, basePath));
    },
    /**
     * Gets a single environment matching the given env_id, if such environment exists.
     * @summary Get Environment
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEnvironment(projId, envId, options) {
      return localVarFp.getEnvironment(projId, envId, options).then((request) => request(axios, basePath));
    },
    /**
     * Lists all the environments under a given project.
     * @summary List Environments
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listEnvironments(projId, page, perPage, options) {
      return localVarFp.listEnvironments(projId, page, perPage, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Stats Environments
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    statsEnvironments(projId, envId, options) {
      return localVarFp.statsEnvironments(projId, envId, options).then((request) => request(axios, basePath));
    },
    /**
     * Updates the environment.
     * @summary Update Environment
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {EnvironmentUpdate} environmentUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateEnvironment(projId, envId, environmentUpdate, options) {
      return localVarFp.updateEnvironment(projId, envId, environmentUpdate, options).then((request) => request(axios, basePath));
    }
  };
};
var EnvironmentsApi = class extends BaseAPI {
  /**
   * Copy environment  This endpoint either duplicates an existing environment to a new environment in the same project, or copies from an existing environment to another existing environment.  The `scope` object controls which objects will be copied to the target environment.  To clone to a new environment, the user must have write permissions to the containing project. To clone into an existing environment, the user must have write permissions to the target environment.  Copying environments across projects or organizations is not allowed.
   * @summary Copy Environment
   * @param {EnvironmentsApiCopyEnvironmentRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EnvironmentsApi
   */
  copyEnvironment(requestParameters, options) {
    return EnvironmentsApiFp(this.configuration).copyEnvironment(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.environmentCopy,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Creates a new environment under a given project.
   * @summary Create Environment
   * @param {EnvironmentsApiCreateEnvironmentRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EnvironmentsApi
   */
  createEnvironment(requestParameters, options) {
    return EnvironmentsApiFp(this.configuration).createEnvironment(requestParameters.projId, requestParameters.environmentCreate, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Deletes an environment and all its related data.
   * @summary Delete Environment
   * @param {EnvironmentsApiDeleteEnvironmentRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EnvironmentsApi
   */
  deleteEnvironment(requestParameters, options) {
    return EnvironmentsApiFp(this.configuration).deleteEnvironment(requestParameters.projId, requestParameters.envId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Gets a single environment matching the given env_id, if such environment exists.
   * @summary Get Environment
   * @param {EnvironmentsApiGetEnvironmentRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EnvironmentsApi
   */
  getEnvironment(requestParameters, options) {
    return EnvironmentsApiFp(this.configuration).getEnvironment(requestParameters.projId, requestParameters.envId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Lists all the environments under a given project.
   * @summary List Environments
   * @param {EnvironmentsApiListEnvironmentsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EnvironmentsApi
   */
  listEnvironments(requestParameters, options) {
    return EnvironmentsApiFp(this.configuration).listEnvironments(
      requestParameters.projId,
      requestParameters.page,
      requestParameters.perPage,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Stats Environments
   * @param {EnvironmentsApiStatsEnvironmentsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EnvironmentsApi
   */
  statsEnvironments(requestParameters, options) {
    return EnvironmentsApiFp(this.configuration).statsEnvironments(requestParameters.projId, requestParameters.envId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Updates the environment.
   * @summary Update Environment
   * @param {EnvironmentsApiUpdateEnvironmentRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EnvironmentsApi
   */
  updateEnvironment(requestParameters, options) {
    return EnvironmentsApiFp(this.configuration).updateEnvironment(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.environmentUpdate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/implicit-grants-api.ts
import globalAxios13 from "axios";
var ImplicitGrantsApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * Creates an implicit grant on a given role
     * @summary Create Implicit Grant
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {DerivedRoleRuleCreate} derivedRoleRuleCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createImplicitGrant: async (projId, envId, resourceId, roleId, derivedRoleRuleCreate, options = {}) => {
      assertParamExists("createImplicitGrant", "projId", projId);
      assertParamExists("createImplicitGrant", "envId", envId);
      assertParamExists("createImplicitGrant", "resourceId", resourceId);
      assertParamExists("createImplicitGrant", "roleId", roleId);
      assertParamExists("createImplicitGrant", "derivedRoleRuleCreate", derivedRoleRuleCreate);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/roles/{role_id}/implicit_grants`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId))).replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        derivedRoleRuleCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes an implicit grant on a given role
     * @summary Delete Implicit Grant
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {DerivedRoleRuleDelete} derivedRoleRuleDelete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteImplicitGrant: async (projId, envId, roleId, resourceId, derivedRoleRuleDelete, options = {}) => {
      assertParamExists("deleteImplicitGrant", "projId", projId);
      assertParamExists("deleteImplicitGrant", "envId", envId);
      assertParamExists("deleteImplicitGrant", "roleId", roleId);
      assertParamExists("deleteImplicitGrant", "resourceId", resourceId);
      assertParamExists("deleteImplicitGrant", "derivedRoleRuleDelete", derivedRoleRuleDelete);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/roles/{role_id}/implicit_grants`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"role_id"}}`, encodeURIComponent(String(roleId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        derivedRoleRuleDelete,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Update the `when` for implicit grants on a given role
     * @summary Update Implicit Grants Conditions
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {PermitBackendSchemasSchemaDerivedRoleDerivedRoleSettings} permitBackendSchemasSchemaDerivedRoleDerivedRoleSettings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateImplicitGrantsConditions: async (projId, envId, resourceId, roleId, permitBackendSchemasSchemaDerivedRoleDerivedRoleSettings, options = {}) => {
      assertParamExists("updateImplicitGrantsConditions", "projId", projId);
      assertParamExists("updateImplicitGrantsConditions", "envId", envId);
      assertParamExists("updateImplicitGrantsConditions", "resourceId", resourceId);
      assertParamExists("updateImplicitGrantsConditions", "roleId", roleId);
      assertParamExists(
        "updateImplicitGrantsConditions",
        "permitBackendSchemasSchemaDerivedRoleDerivedRoleSettings",
        permitBackendSchemasSchemaDerivedRoleDerivedRoleSettings
      );
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/roles/{role_id}/implicit_grants/conditions`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId))).replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        permitBackendSchemasSchemaDerivedRoleDerivedRoleSettings,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var ImplicitGrantsApiFp = function(configuration) {
  const localVarAxiosParamCreator = ImplicitGrantsApiAxiosParamCreator(configuration);
  return {
    /**
     * Creates an implicit grant on a given role
     * @summary Create Implicit Grant
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {DerivedRoleRuleCreate} derivedRoleRuleCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createImplicitGrant(projId, envId, resourceId, roleId, derivedRoleRuleCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createImplicitGrant(
        projId,
        envId,
        resourceId,
        roleId,
        derivedRoleRuleCreate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios13, BASE_PATH, configuration);
    },
    /**
     * Deletes an implicit grant on a given role
     * @summary Delete Implicit Grant
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {DerivedRoleRuleDelete} derivedRoleRuleDelete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteImplicitGrant(projId, envId, roleId, resourceId, derivedRoleRuleDelete, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteImplicitGrant(
        projId,
        envId,
        roleId,
        resourceId,
        derivedRoleRuleDelete,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios13, BASE_PATH, configuration);
    },
    /**
     * Update the `when` for implicit grants on a given role
     * @summary Update Implicit Grants Conditions
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {PermitBackendSchemasSchemaDerivedRoleDerivedRoleSettings} permitBackendSchemasSchemaDerivedRoleDerivedRoleSettings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateImplicitGrantsConditions(projId, envId, resourceId, roleId, permitBackendSchemasSchemaDerivedRoleDerivedRoleSettings, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateImplicitGrantsConditions(
        projId,
        envId,
        resourceId,
        roleId,
        permitBackendSchemasSchemaDerivedRoleDerivedRoleSettings,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios13, BASE_PATH, configuration);
    }
  };
};
var ImplicitGrantsApiFactory = function(configuration, basePath, axios) {
  const localVarFp = ImplicitGrantsApiFp(configuration);
  return {
    /**
     * Creates an implicit grant on a given role
     * @summary Create Implicit Grant
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {DerivedRoleRuleCreate} derivedRoleRuleCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createImplicitGrant(projId, envId, resourceId, roleId, derivedRoleRuleCreate, options) {
      return localVarFp.createImplicitGrant(projId, envId, resourceId, roleId, derivedRoleRuleCreate, options).then((request) => request(axios, basePath));
    },
    /**
     * Deletes an implicit grant on a given role
     * @summary Delete Implicit Grant
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {DerivedRoleRuleDelete} derivedRoleRuleDelete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteImplicitGrant(projId, envId, roleId, resourceId, derivedRoleRuleDelete, options) {
      return localVarFp.deleteImplicitGrant(projId, envId, roleId, resourceId, derivedRoleRuleDelete, options).then((request) => request(axios, basePath));
    },
    /**
     * Update the `when` for implicit grants on a given role
     * @summary Update Implicit Grants Conditions
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {PermitBackendSchemasSchemaDerivedRoleDerivedRoleSettings} permitBackendSchemasSchemaDerivedRoleDerivedRoleSettings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateImplicitGrantsConditions(projId, envId, resourceId, roleId, permitBackendSchemasSchemaDerivedRoleDerivedRoleSettings, options) {
      return localVarFp.updateImplicitGrantsConditions(
        projId,
        envId,
        resourceId,
        roleId,
        permitBackendSchemasSchemaDerivedRoleDerivedRoleSettings,
        options
      ).then((request) => request(axios, basePath));
    }
  };
};
var ImplicitGrantsApi = class extends BaseAPI {
  /**
   * Creates an implicit grant on a given role
   * @summary Create Implicit Grant
   * @param {ImplicitGrantsApiCreateImplicitGrantRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ImplicitGrantsApi
   */
  createImplicitGrant(requestParameters, options) {
    return ImplicitGrantsApiFp(this.configuration).createImplicitGrant(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.roleId,
      requestParameters.derivedRoleRuleCreate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Deletes an implicit grant on a given role
   * @summary Delete Implicit Grant
   * @param {ImplicitGrantsApiDeleteImplicitGrantRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ImplicitGrantsApi
   */
  deleteImplicitGrant(requestParameters, options) {
    return ImplicitGrantsApiFp(this.configuration).deleteImplicitGrant(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.roleId,
      requestParameters.resourceId,
      requestParameters.derivedRoleRuleDelete,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Update the `when` for implicit grants on a given role
   * @summary Update Implicit Grants Conditions
   * @param {ImplicitGrantsApiUpdateImplicitGrantsConditionsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ImplicitGrantsApi
   */
  updateImplicitGrantsConditions(requestParameters, options) {
    return ImplicitGrantsApiFp(this.configuration).updateImplicitGrantsConditions(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.roleId,
      requestParameters.permitBackendSchemasSchemaDerivedRoleDerivedRoleSettings,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/instructions-api.ts
import globalAxios14 from "axios";
var InstructionsApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * Lists pending organization invites
     * @summary List Language Instructions
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listLanguageInstructions: async (projId, envId, options = {}) => {
      assertParamExists("listLanguageInstructions", "projId", projId);
      assertParamExists("listLanguageInstructions", "envId", envId);
      const localVarPath = `/v2/{proj_id}/{env_id}/get_instructions`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var InstructionsApiFp = function(configuration) {
  const localVarAxiosParamCreator = InstructionsApiAxiosParamCreator(configuration);
  return {
    /**
     * Lists pending organization invites
     * @summary List Language Instructions
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listLanguageInstructions(projId, envId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listLanguageInstructions(
        projId,
        envId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios14, BASE_PATH, configuration);
    }
  };
};
var InstructionsApiFactory = function(configuration, basePath, axios) {
  const localVarFp = InstructionsApiFp(configuration);
  return {
    /**
     * Lists pending organization invites
     * @summary List Language Instructions
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listLanguageInstructions(projId, envId, options) {
      return localVarFp.listLanguageInstructions(projId, envId, options).then((request) => request(axios, basePath));
    }
  };
};
var InstructionsApi = class extends BaseAPI {
  /**
   * Lists pending organization invites
   * @summary List Language Instructions
   * @param {InstructionsApiListLanguageInstructionsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstructionsApi
   */
  listLanguageInstructions(requestParameters, options) {
    return InstructionsApiFp(this.configuration).listLanguageInstructions(requestParameters.projId, requestParameters.envId, options).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/members-api.ts
import globalAxios15 from "axios";
var MembersApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * Create an organization member if needed, and grant it permissions.  The member can be specified either by ID (for an existing member), or by email (for either an existing member or a new one).  For a new member, an invite will be sent.
     * @summary Create Organization Members
     * @param {OrgMemberCreate} orgMemberCreate
     * @param {string} [inviterName]
     * @param {string} [inviterEmail]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createOrganizationMembers: async (orgMemberCreate, inviterName, inviterEmail, options = {}) => {
      assertParamExists("createOrganizationMembers", "orgMemberCreate", orgMemberCreate);
      const localVarPath = `/v2/members`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (inviterName !== void 0) {
        localVarQueryParameter["inviter_name"] = inviterName;
      }
      if (inviterEmail !== void 0) {
        localVarQueryParameter["inviter_email"] = inviterEmail;
      }
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        orgMemberCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes an account member matching the given id or email address. The member will be removed from the active account in permit.io.  If the member is the only member in its account (organization), returns 400 (bad request), due to nobody remains with access to the account, meaning deletion of the entire account (org). To completely remove an account, call DELETE `/orgs/{org}`.
     * @summary Delete Organization Member
     * @param {string} memberId Either the unique id (UUID) of the account member, or the email address of the account member.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteOrganizationMember: async (memberId, options = {}) => {
      assertParamExists("deleteOrganizationMember", "memberId", memberId);
      const localVarPath = `/v2/members/{member_id}`.replace(
        `{${"member_id"}}`,
        encodeURIComponent(String(memberId))
      );
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Remove permissions from a member. If the last permissions a member has are removed, the member is also deleted.
     * @summary Delete Organization Permissions
     * @param {OrgMemberRemovePermissions} orgMemberRemovePermissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteOrganizationPermissions: async (orgMemberRemovePermissions, options = {}) => {
      assertParamExists(
        "deleteOrganizationPermissions",
        "orgMemberRemovePermissions",
        orgMemberRemovePermissions
      );
      const localVarPath = `/v2/members`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        orgMemberRemovePermissions,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Gets the authenticated account member\'s details.
     * @summary Get the authenticated account member
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAuthenticatedMember: async (options = {}) => {
      const localVarPath = `/v2/members/me`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Gets a single account member by its id or email address. matching the given member, if no such member exists under the current active account (organization), returns 404.
     * @summary Get Organization Member
     * @param {string} memberId Either the unique id (UUID) of the account member, or the email address of the account member.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrganizationMember: async (memberId, options = {}) => {
      assertParamExists("getOrganizationMember", "memberId", memberId);
      const localVarPath = `/v2/members/{member_id}`.replace(
        `{${"member_id"}}`,
        encodeURIComponent(String(memberId))
      );
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Lists all the account members that current active account has access to, optionally filtering by project or environment. The active account/organization is determined by the API Key used or by the authenticated session id.
     * @summary List Organization Members
     * @param {string} [projectId]
     * @param {string} [envId]
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listOrganizationMembers: async (projectId, envId, page, perPage, options = {}) => {
      const localVarPath = `/v2/members`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (projectId !== void 0) {
        localVarQueryParameter["project_id"] = projectId;
      }
      if (envId !== void 0) {
        localVarQueryParameter["env_id"] = envId;
      }
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Updates an account member\'s settings.
     * @summary Update Organization Member
     * @param {string} memberId Either the unique id (UUID) of the account member, or the email address of the account member.
     * @param {OrgMemberUpdate} orgMemberUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateOrganizationMember: async (memberId, orgMemberUpdate, options = {}) => {
      assertParamExists("updateOrganizationMember", "memberId", memberId);
      assertParamExists("updateOrganizationMember", "orgMemberUpdate", orgMemberUpdate);
      const localVarPath = `/v2/members/{member_id}`.replace(
        `{${"member_id"}}`,
        encodeURIComponent(String(memberId))
      );
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        orgMemberUpdate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var MembersApiFp = function(configuration) {
  const localVarAxiosParamCreator = MembersApiAxiosParamCreator(configuration);
  return {
    /**
     * Create an organization member if needed, and grant it permissions.  The member can be specified either by ID (for an existing member), or by email (for either an existing member or a new one).  For a new member, an invite will be sent.
     * @summary Create Organization Members
     * @param {OrgMemberCreate} orgMemberCreate
     * @param {string} [inviterName]
     * @param {string} [inviterEmail]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createOrganizationMembers(orgMemberCreate, inviterName, inviterEmail, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createOrganizationMembers(
        orgMemberCreate,
        inviterName,
        inviterEmail,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios15, BASE_PATH, configuration);
    },
    /**
     * Deletes an account member matching the given id or email address. The member will be removed from the active account in permit.io.  If the member is the only member in its account (organization), returns 400 (bad request), due to nobody remains with access to the account, meaning deletion of the entire account (org). To completely remove an account, call DELETE `/orgs/{org}`.
     * @summary Delete Organization Member
     * @param {string} memberId Either the unique id (UUID) of the account member, or the email address of the account member.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteOrganizationMember(memberId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrganizationMember(
        memberId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios15, BASE_PATH, configuration);
    },
    /**
     * Remove permissions from a member. If the last permissions a member has are removed, the member is also deleted.
     * @summary Delete Organization Permissions
     * @param {OrgMemberRemovePermissions} orgMemberRemovePermissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteOrganizationPermissions(orgMemberRemovePermissions, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrganizationPermissions(
        orgMemberRemovePermissions,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios15, BASE_PATH, configuration);
    },
    /**
     * Gets the authenticated account member\'s details.
     * @summary Get the authenticated account member
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAuthenticatedMember(options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAuthenticatedMember(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios15, BASE_PATH, configuration);
    },
    /**
     * Gets a single account member by its id or email address. matching the given member, if no such member exists under the current active account (organization), returns 404.
     * @summary Get Organization Member
     * @param {string} memberId Either the unique id (UUID) of the account member, or the email address of the account member.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getOrganizationMember(memberId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationMember(
        memberId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios15, BASE_PATH, configuration);
    },
    /**
     * Lists all the account members that current active account has access to, optionally filtering by project or environment. The active account/organization is determined by the API Key used or by the authenticated session id.
     * @summary List Organization Members
     * @param {string} [projectId]
     * @param {string} [envId]
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listOrganizationMembers(projectId, envId, page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listOrganizationMembers(
        projectId,
        envId,
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios15, BASE_PATH, configuration);
    },
    /**
     * Updates an account member\'s settings.
     * @summary Update Organization Member
     * @param {string} memberId Either the unique id (UUID) of the account member, or the email address of the account member.
     * @param {OrgMemberUpdate} orgMemberUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateOrganizationMember(memberId, orgMemberUpdate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateOrganizationMember(
        memberId,
        orgMemberUpdate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios15, BASE_PATH, configuration);
    }
  };
};
var MembersApiFactory = function(configuration, basePath, axios) {
  const localVarFp = MembersApiFp(configuration);
  return {
    /**
     * Create an organization member if needed, and grant it permissions.  The member can be specified either by ID (for an existing member), or by email (for either an existing member or a new one).  For a new member, an invite will be sent.
     * @summary Create Organization Members
     * @param {OrgMemberCreate} orgMemberCreate
     * @param {string} [inviterName]
     * @param {string} [inviterEmail]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createOrganizationMembers(orgMemberCreate, inviterName, inviterEmail, options) {
      return localVarFp.createOrganizationMembers(orgMemberCreate, inviterName, inviterEmail, options).then((request) => request(axios, basePath));
    },
    /**
     * Deletes an account member matching the given id or email address. The member will be removed from the active account in permit.io.  If the member is the only member in its account (organization), returns 400 (bad request), due to nobody remains with access to the account, meaning deletion of the entire account (org). To completely remove an account, call DELETE `/orgs/{org}`.
     * @summary Delete Organization Member
     * @param {string} memberId Either the unique id (UUID) of the account member, or the email address of the account member.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteOrganizationMember(memberId, options) {
      return localVarFp.deleteOrganizationMember(memberId, options).then((request) => request(axios, basePath));
    },
    /**
     * Remove permissions from a member. If the last permissions a member has are removed, the member is also deleted.
     * @summary Delete Organization Permissions
     * @param {OrgMemberRemovePermissions} orgMemberRemovePermissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteOrganizationPermissions(orgMemberRemovePermissions, options) {
      return localVarFp.deleteOrganizationPermissions(orgMemberRemovePermissions, options).then((request) => request(axios, basePath));
    },
    /**
     * Gets the authenticated account member\'s details.
     * @summary Get the authenticated account member
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAuthenticatedMember(options) {
      return localVarFp.getAuthenticatedMember(options).then((request) => request(axios, basePath));
    },
    /**
     * Gets a single account member by its id or email address. matching the given member, if no such member exists under the current active account (organization), returns 404.
     * @summary Get Organization Member
     * @param {string} memberId Either the unique id (UUID) of the account member, or the email address of the account member.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrganizationMember(memberId, options) {
      return localVarFp.getOrganizationMember(memberId, options).then((request) => request(axios, basePath));
    },
    /**
     * Lists all the account members that current active account has access to, optionally filtering by project or environment. The active account/organization is determined by the API Key used or by the authenticated session id.
     * @summary List Organization Members
     * @param {string} [projectId]
     * @param {string} [envId]
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listOrganizationMembers(projectId, envId, page, perPage, options) {
      return localVarFp.listOrganizationMembers(projectId, envId, page, perPage, options).then((request) => request(axios, basePath));
    },
    /**
     * Updates an account member\'s settings.
     * @summary Update Organization Member
     * @param {string} memberId Either the unique id (UUID) of the account member, or the email address of the account member.
     * @param {OrgMemberUpdate} orgMemberUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateOrganizationMember(memberId, orgMemberUpdate, options) {
      return localVarFp.updateOrganizationMember(memberId, orgMemberUpdate, options).then((request) => request(axios, basePath));
    }
  };
};
var MembersApi = class extends BaseAPI {
  /**
   * Create an organization member if needed, and grant it permissions.  The member can be specified either by ID (for an existing member), or by email (for either an existing member or a new one).  For a new member, an invite will be sent.
   * @summary Create Organization Members
   * @param {MembersApiCreateOrganizationMembersRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MembersApi
   */
  createOrganizationMembers(requestParameters, options) {
    return MembersApiFp(this.configuration).createOrganizationMembers(
      requestParameters.orgMemberCreate,
      requestParameters.inviterName,
      requestParameters.inviterEmail,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Deletes an account member matching the given id or email address. The member will be removed from the active account in permit.io.  If the member is the only member in its account (organization), returns 400 (bad request), due to nobody remains with access to the account, meaning deletion of the entire account (org). To completely remove an account, call DELETE `/orgs/{org}`.
   * @summary Delete Organization Member
   * @param {MembersApiDeleteOrganizationMemberRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MembersApi
   */
  deleteOrganizationMember(requestParameters, options) {
    return MembersApiFp(this.configuration).deleteOrganizationMember(requestParameters.memberId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Remove permissions from a member. If the last permissions a member has are removed, the member is also deleted.
   * @summary Delete Organization Permissions
   * @param {MembersApiDeleteOrganizationPermissionsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MembersApi
   */
  deleteOrganizationPermissions(requestParameters, options) {
    return MembersApiFp(this.configuration).deleteOrganizationPermissions(requestParameters.orgMemberRemovePermissions, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Gets the authenticated account member\'s details.
   * @summary Get the authenticated account member
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MembersApi
   */
  getAuthenticatedMember(options) {
    return MembersApiFp(this.configuration).getAuthenticatedMember(options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Gets a single account member by its id or email address. matching the given member, if no such member exists under the current active account (organization), returns 404.
   * @summary Get Organization Member
   * @param {MembersApiGetOrganizationMemberRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MembersApi
   */
  getOrganizationMember(requestParameters, options) {
    return MembersApiFp(this.configuration).getOrganizationMember(requestParameters.memberId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Lists all the account members that current active account has access to, optionally filtering by project or environment. The active account/organization is determined by the API Key used or by the authenticated session id.
   * @summary List Organization Members
   * @param {MembersApiListOrganizationMembersRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MembersApi
   */
  listOrganizationMembers(requestParameters = {}, options) {
    return MembersApiFp(this.configuration).listOrganizationMembers(
      requestParameters.projectId,
      requestParameters.envId,
      requestParameters.page,
      requestParameters.perPage,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Updates an account member\'s settings.
   * @summary Update Organization Member
   * @param {MembersApiUpdateOrganizationMemberRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MembersApi
   */
  updateOrganizationMember(requestParameters, options) {
    return MembersApiFp(this.configuration).updateOrganizationMember(
      requestParameters.memberId,
      requestParameters.orgMemberUpdate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/opaldata-api.ts
import globalAxios16 from "axios";
var OPALDataApiAxiosParamCreator = function(configuration) {
  return {
    /**
     *
     * @summary Get All Data
     * @param {string} orgId Either the unique id of the organization, or the URL-friendly key of the organization (i.e: the \&quot;slug\&quot;).
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {boolean} [internalUpdateCache]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllData: async (orgId, projId, envId, internalUpdateCache, options = {}) => {
      assertParamExists("getAllData", "orgId", orgId);
      assertParamExists("getAllData", "projId", projId);
      assertParamExists("getAllData", "envId", envId);
      const localVarPath = `/v2/internal/opal_data/{org_id}/{proj_id}/{env_id}`.replace(`{${"org_id"}}`, encodeURIComponent(String(orgId))).replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (internalUpdateCache !== void 0) {
        localVarQueryParameter["__internal_update_cache"] = internalUpdateCache;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Get Data For Condition Set
     * @param {string} orgId Either the unique id of the organization, or the URL-friendly key of the organization (i.e: the \&quot;slug\&quot;).
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} conditionSetId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDataForConditionSet: async (orgId, projId, envId, conditionSetId, options = {}) => {
      assertParamExists("getDataForConditionSet", "orgId", orgId);
      assertParamExists("getDataForConditionSet", "projId", projId);
      assertParamExists("getDataForConditionSet", "envId", envId);
      assertParamExists("getDataForConditionSet", "conditionSetId", conditionSetId);
      const localVarPath = `/v2/internal/opal_data/{org_id}/{proj_id}/{env_id}/condition_sets/{condition_set_id}`.replace(`{${"org_id"}}`, encodeURIComponent(String(orgId))).replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"condition_set_id"}}`, encodeURIComponent(String(conditionSetId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Get Data For Resource
     * @param {string} orgId Either the unique id of the organization, or the URL-friendly key of the organization (i.e: the \&quot;slug\&quot;).
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDataForResource: async (orgId, projId, envId, resourceId, options = {}) => {
      assertParamExists("getDataForResource", "orgId", orgId);
      assertParamExists("getDataForResource", "projId", projId);
      assertParamExists("getDataForResource", "envId", envId);
      assertParamExists("getDataForResource", "resourceId", resourceId);
      const localVarPath = `/v2/internal/opal_data/{org_id}/{proj_id}/{env_id}/resource_types/{resource_id}`.replace(`{${"org_id"}}`, encodeURIComponent(String(orgId))).replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Get Data For Role
     * @param {string} orgId Either the unique id of the organization, or the URL-friendly key of the organization (i.e: the \&quot;slug\&quot;).
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDataForRole: async (orgId, projId, envId, roleId, options = {}) => {
      assertParamExists("getDataForRole", "orgId", orgId);
      assertParamExists("getDataForRole", "projId", projId);
      assertParamExists("getDataForRole", "envId", envId);
      assertParamExists("getDataForRole", "roleId", roleId);
      const localVarPath = `/v2/internal/opal_data/{org_id}/{proj_id}/{env_id}/roles/{role_id}`.replace(`{${"org_id"}}`, encodeURIComponent(String(orgId))).replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * return permission assignment data between user sets and resource sets (i.e: condition set rules data)
     * @summary Get Data For Set Rule
     * @param {string} orgId Either the unique id of the organization, or the URL-friendly key of the organization (i.e: the \&quot;slug\&quot;).
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} userSetId
     * @param {string} resourceSetId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDataForSetRule: async (orgId, projId, envId, userSetId, resourceSetId, options = {}) => {
      assertParamExists("getDataForSetRule", "orgId", orgId);
      assertParamExists("getDataForSetRule", "projId", projId);
      assertParamExists("getDataForSetRule", "envId", envId);
      assertParamExists("getDataForSetRule", "userSetId", userSetId);
      assertParamExists("getDataForSetRule", "resourceSetId", resourceSetId);
      const localVarPath = `/v2/internal/opal_data/{org_id}/{proj_id}/{env_id}/condition_set_rules/{user_set_id}/{resource_set_id}`.replace(`{${"org_id"}}`, encodeURIComponent(String(orgId))).replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"user_set_id"}}`, encodeURIComponent(String(userSetId))).replace(`{${"resource_set_id"}}`, encodeURIComponent(String(resourceSetId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Get Data For Tenant
     * @param {string} orgId Either the unique id of the organization, or the URL-friendly key of the organization (i.e: the \&quot;slug\&quot;).
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} tenantId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDataForTenant: async (orgId, projId, envId, tenantId, options = {}) => {
      assertParamExists("getDataForTenant", "orgId", orgId);
      assertParamExists("getDataForTenant", "projId", projId);
      assertParamExists("getDataForTenant", "envId", envId);
      assertParamExists("getDataForTenant", "tenantId", tenantId);
      const localVarPath = `/v2/internal/opal_data/{org_id}/{proj_id}/{env_id}/tenants/{tenant_id}`.replace(`{${"org_id"}}`, encodeURIComponent(String(orgId))).replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"tenant_id"}}`, encodeURIComponent(String(tenantId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Get Data For User
     * @param {string} orgId Either the unique id of the organization, or the URL-friendly key of the organization (i.e: the \&quot;slug\&quot;).
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDataForUser: async (orgId, projId, envId, userId, options = {}) => {
      assertParamExists("getDataForUser", "orgId", orgId);
      assertParamExists("getDataForUser", "projId", projId);
      assertParamExists("getDataForUser", "envId", envId);
      assertParamExists("getDataForUser", "userId", userId);
      const localVarPath = `/v2/internal/opal_data/{org_id}/{proj_id}/{env_id}/users/{user_id}`.replace(`{${"org_id"}}`, encodeURIComponent(String(orgId))).replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var OPALDataApiFp = function(configuration) {
  const localVarAxiosParamCreator = OPALDataApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Get All Data
     * @param {string} orgId Either the unique id of the organization, or the URL-friendly key of the organization (i.e: the \&quot;slug\&quot;).
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {boolean} [internalUpdateCache]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllData(orgId, projId, envId, internalUpdateCache, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAllData(
        orgId,
        projId,
        envId,
        internalUpdateCache,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios16, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get Data For Condition Set
     * @param {string} orgId Either the unique id of the organization, or the URL-friendly key of the organization (i.e: the \&quot;slug\&quot;).
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} conditionSetId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDataForConditionSet(orgId, projId, envId, conditionSetId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getDataForConditionSet(
        orgId,
        projId,
        envId,
        conditionSetId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios16, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get Data For Resource
     * @param {string} orgId Either the unique id of the organization, or the URL-friendly key of the organization (i.e: the \&quot;slug\&quot;).
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDataForResource(orgId, projId, envId, resourceId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getDataForResource(
        orgId,
        projId,
        envId,
        resourceId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios16, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get Data For Role
     * @param {string} orgId Either the unique id of the organization, or the URL-friendly key of the organization (i.e: the \&quot;slug\&quot;).
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDataForRole(orgId, projId, envId, roleId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getDataForRole(
        orgId,
        projId,
        envId,
        roleId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios16, BASE_PATH, configuration);
    },
    /**
     * return permission assignment data between user sets and resource sets (i.e: condition set rules data)
     * @summary Get Data For Set Rule
     * @param {string} orgId Either the unique id of the organization, or the URL-friendly key of the organization (i.e: the \&quot;slug\&quot;).
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} userSetId
     * @param {string} resourceSetId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDataForSetRule(orgId, projId, envId, userSetId, resourceSetId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getDataForSetRule(
        orgId,
        projId,
        envId,
        userSetId,
        resourceSetId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios16, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get Data For Tenant
     * @param {string} orgId Either the unique id of the organization, or the URL-friendly key of the organization (i.e: the \&quot;slug\&quot;).
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} tenantId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDataForTenant(orgId, projId, envId, tenantId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getDataForTenant(
        orgId,
        projId,
        envId,
        tenantId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios16, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get Data For User
     * @param {string} orgId Either the unique id of the organization, or the URL-friendly key of the organization (i.e: the \&quot;slug\&quot;).
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDataForUser(orgId, projId, envId, userId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getDataForUser(
        orgId,
        projId,
        envId,
        userId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios16, BASE_PATH, configuration);
    }
  };
};
var OPALDataApiFactory = function(configuration, basePath, axios) {
  const localVarFp = OPALDataApiFp(configuration);
  return {
    /**
     *
     * @summary Get All Data
     * @param {string} orgId Either the unique id of the organization, or the URL-friendly key of the organization (i.e: the \&quot;slug\&quot;).
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {boolean} [internalUpdateCache]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllData(orgId, projId, envId, internalUpdateCache, options) {
      return localVarFp.getAllData(orgId, projId, envId, internalUpdateCache, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get Data For Condition Set
     * @param {string} orgId Either the unique id of the organization, or the URL-friendly key of the organization (i.e: the \&quot;slug\&quot;).
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} conditionSetId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDataForConditionSet(orgId, projId, envId, conditionSetId, options) {
      return localVarFp.getDataForConditionSet(orgId, projId, envId, conditionSetId, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get Data For Resource
     * @param {string} orgId Either the unique id of the organization, or the URL-friendly key of the organization (i.e: the \&quot;slug\&quot;).
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDataForResource(orgId, projId, envId, resourceId, options) {
      return localVarFp.getDataForResource(orgId, projId, envId, resourceId, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get Data For Role
     * @param {string} orgId Either the unique id of the organization, or the URL-friendly key of the organization (i.e: the \&quot;slug\&quot;).
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDataForRole(orgId, projId, envId, roleId, options) {
      return localVarFp.getDataForRole(orgId, projId, envId, roleId, options).then((request) => request(axios, basePath));
    },
    /**
     * return permission assignment data between user sets and resource sets (i.e: condition set rules data)
     * @summary Get Data For Set Rule
     * @param {string} orgId Either the unique id of the organization, or the URL-friendly key of the organization (i.e: the \&quot;slug\&quot;).
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} userSetId
     * @param {string} resourceSetId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDataForSetRule(orgId, projId, envId, userSetId, resourceSetId, options) {
      return localVarFp.getDataForSetRule(orgId, projId, envId, userSetId, resourceSetId, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get Data For Tenant
     * @param {string} orgId Either the unique id of the organization, or the URL-friendly key of the organization (i.e: the \&quot;slug\&quot;).
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} tenantId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDataForTenant(orgId, projId, envId, tenantId, options) {
      return localVarFp.getDataForTenant(orgId, projId, envId, tenantId, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get Data For User
     * @param {string} orgId Either the unique id of the organization, or the URL-friendly key of the organization (i.e: the \&quot;slug\&quot;).
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDataForUser(orgId, projId, envId, userId, options) {
      return localVarFp.getDataForUser(orgId, projId, envId, userId, options).then((request) => request(axios, basePath));
    }
  };
};
var OPALDataApi = class extends BaseAPI {
  /**
   *
   * @summary Get All Data
   * @param {OPALDataApiGetAllDataRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OPALDataApi
   */
  getAllData(requestParameters, options) {
    return OPALDataApiFp(this.configuration).getAllData(
      requestParameters.orgId,
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.internalUpdateCache,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Get Data For Condition Set
   * @param {OPALDataApiGetDataForConditionSetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OPALDataApi
   */
  getDataForConditionSet(requestParameters, options) {
    return OPALDataApiFp(this.configuration).getDataForConditionSet(
      requestParameters.orgId,
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.conditionSetId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Get Data For Resource
   * @param {OPALDataApiGetDataForResourceRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OPALDataApi
   */
  getDataForResource(requestParameters, options) {
    return OPALDataApiFp(this.configuration).getDataForResource(
      requestParameters.orgId,
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Get Data For Role
   * @param {OPALDataApiGetDataForRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OPALDataApi
   */
  getDataForRole(requestParameters, options) {
    return OPALDataApiFp(this.configuration).getDataForRole(
      requestParameters.orgId,
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.roleId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * return permission assignment data between user sets and resource sets (i.e: condition set rules data)
   * @summary Get Data For Set Rule
   * @param {OPALDataApiGetDataForSetRuleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OPALDataApi
   */
  getDataForSetRule(requestParameters, options) {
    return OPALDataApiFp(this.configuration).getDataForSetRule(
      requestParameters.orgId,
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.userSetId,
      requestParameters.resourceSetId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Get Data For Tenant
   * @param {OPALDataApiGetDataForTenantRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OPALDataApi
   */
  getDataForTenant(requestParameters, options) {
    return OPALDataApiFp(this.configuration).getDataForTenant(
      requestParameters.orgId,
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.tenantId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Get Data For User
   * @param {OPALDataApiGetDataForUserRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OPALDataApi
   */
  getDataForUser(requestParameters, options) {
    return OPALDataApiFp(this.configuration).getDataForUser(
      requestParameters.orgId,
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.userId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/organizations-api.ts
import globalAxios17 from "axios";
var OrganizationsApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * Cancels an invite that was sent to a new member.
     * @summary Cancel Invite
     * @param {string} orgId Either the unique id of the organization, or the URL-friendly key of the organization (i.e: the \&quot;slug\&quot;).
     * @param {string} inviteId Id of the invite to cancel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelInvite: async (orgId, inviteId, options = {}) => {
      assertParamExists("cancelInvite", "orgId", orgId);
      assertParamExists("cancelInvite", "inviteId", inviteId);
      const localVarPath = `/v2/orgs/{org_id}/invites/{invite_id}`.replace(`{${"org_id"}}`, encodeURIComponent(String(orgId))).replace(`{${"invite_id"}}`, encodeURIComponent(String(inviteId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Creates a new organization that will be owned by the authenticated actor (i.e: human team member or api key).
     * @summary Create Organization
     * @param {OrganizationCreate} organizationCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createOrganization: async (organizationCreate, options = {}) => {
      assertParamExists("createOrganization", "organizationCreate", organizationCreate);
      const localVarPath = `/v2/orgs`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        organizationCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes an organization (Permit.io account) and all its related data.
     * @summary Delete Organization
     * @param {string} orgId Either the unique id of the organization, or the URL-friendly key of the organization (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteOrganization: async (orgId, options = {}) => {
      assertParamExists("deleteOrganization", "orgId", orgId);
      const localVarPath = `/v2/orgs/{org_id}`.replace(
        `{${"org_id"}}`,
        encodeURIComponent(String(orgId))
      );
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Gets a single organization (Permit.io account) matching the given org_id, if such org exists and can be accessed by the authenticated actor.
     * @summary Get Active Organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getActiveOrganization: async (options = {}) => {
      const localVarPath = `/v2/orgs/active/org`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Gets a single organization (Permit.io account) matching the given org_id, if such org exists and can be accessed by the authenticated actor.
     * @summary Get Organization
     * @param {string} orgId Either the unique id of the organization, or the URL-friendly key of the organization (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrganization: async (orgId, options = {}) => {
      assertParamExists("getOrganization", "orgId", orgId);
      const localVarPath = `/v2/orgs/{org_id}`.replace(
        `{${"org_id"}}`,
        encodeURIComponent(String(orgId))
      );
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Invite new members into the organization.
     * @summary Invite Members To Organization
     * @param {string} orgId Either the unique id of the organization, or the URL-friendly key of the organization (i.e: the \&quot;slug\&quot;).
     * @param {Array<InviteCreate>} inviteCreate
     * @param {string} [inviterName]
     * @param {string} [inviterEmail]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    inviteMembersToOrganization: async (orgId, inviteCreate, inviterName, inviterEmail, options = {}) => {
      assertParamExists("inviteMembersToOrganization", "orgId", orgId);
      assertParamExists("inviteMembersToOrganization", "inviteCreate", inviteCreate);
      const localVarPath = `/v2/orgs/{org_id}/invites`.replace(
        `{${"org_id"}}`,
        encodeURIComponent(String(orgId))
      );
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (inviterName !== void 0) {
        localVarQueryParameter["inviter_name"] = inviterName;
      }
      if (inviterEmail !== void 0) {
        localVarQueryParameter["inviter_email"] = inviterEmail;
      }
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        inviteCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Lists pending organization invites
     * @summary List Organization Invites
     * @param {string} orgId Either the unique id of the organization, or the URL-friendly key of the organization (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listOrganizationInvites: async (orgId, page, perPage, options = {}) => {
      assertParamExists("listOrganizationInvites", "orgId", orgId);
      const localVarPath = `/v2/orgs/{org_id}/invites`.replace(
        `{${"org_id"}}`,
        encodeURIComponent(String(orgId))
      );
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Lists all the organizations that can be accessed by the authenticated actor (i.e: human team member or api key).
     * @summary List Organizations
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listOrganizations: async (page, perPage, options = {}) => {
      const localVarPath = `/v2/orgs`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Updates the organization\'s profile.
     * @summary Update Organization
     * @param {string} orgId Either the unique id of the organization, or the URL-friendly key of the organization (i.e: the \&quot;slug\&quot;).
     * @param {OrganizationUpdate} organizationUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateOrganization: async (orgId, organizationUpdate, options = {}) => {
      assertParamExists("updateOrganization", "orgId", orgId);
      assertParamExists("updateOrganization", "organizationUpdate", organizationUpdate);
      const localVarPath = `/v2/orgs/{org_id}`.replace(
        `{${"org_id"}}`,
        encodeURIComponent(String(orgId))
      );
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        organizationUpdate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var OrganizationsApiFp = function(configuration) {
  const localVarAxiosParamCreator = OrganizationsApiAxiosParamCreator(configuration);
  return {
    /**
     * Cancels an invite that was sent to a new member.
     * @summary Cancel Invite
     * @param {string} orgId Either the unique id of the organization, or the URL-friendly key of the organization (i.e: the \&quot;slug\&quot;).
     * @param {string} inviteId Id of the invite to cancel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async cancelInvite(orgId, inviteId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.cancelInvite(
        orgId,
        inviteId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios17, BASE_PATH, configuration);
    },
    /**
     * Creates a new organization that will be owned by the authenticated actor (i.e: human team member or api key).
     * @summary Create Organization
     * @param {OrganizationCreate} organizationCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createOrganization(organizationCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createOrganization(
        organizationCreate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios17, BASE_PATH, configuration);
    },
    /**
     * Deletes an organization (Permit.io account) and all its related data.
     * @summary Delete Organization
     * @param {string} orgId Either the unique id of the organization, or the URL-friendly key of the organization (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteOrganization(orgId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrganization(orgId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios17, BASE_PATH, configuration);
    },
    /**
     * Gets a single organization (Permit.io account) matching the given org_id, if such org exists and can be accessed by the authenticated actor.
     * @summary Get Active Organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getActiveOrganization(options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getActiveOrganization(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios17, BASE_PATH, configuration);
    },
    /**
     * Gets a single organization (Permit.io account) matching the given org_id, if such org exists and can be accessed by the authenticated actor.
     * @summary Get Organization
     * @param {string} orgId Either the unique id of the organization, or the URL-friendly key of the organization (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getOrganization(orgId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganization(orgId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios17, BASE_PATH, configuration);
    },
    /**
     * Invite new members into the organization.
     * @summary Invite Members To Organization
     * @param {string} orgId Either the unique id of the organization, or the URL-friendly key of the organization (i.e: the \&quot;slug\&quot;).
     * @param {Array<InviteCreate>} inviteCreate
     * @param {string} [inviterName]
     * @param {string} [inviterEmail]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async inviteMembersToOrganization(orgId, inviteCreate, inviterName, inviterEmail, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.inviteMembersToOrganization(
        orgId,
        inviteCreate,
        inviterName,
        inviterEmail,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios17, BASE_PATH, configuration);
    },
    /**
     * Lists pending organization invites
     * @summary List Organization Invites
     * @param {string} orgId Either the unique id of the organization, or the URL-friendly key of the organization (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listOrganizationInvites(orgId, page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listOrganizationInvites(
        orgId,
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios17, BASE_PATH, configuration);
    },
    /**
     * Lists all the organizations that can be accessed by the authenticated actor (i.e: human team member or api key).
     * @summary List Organizations
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listOrganizations(page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listOrganizations(
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios17, BASE_PATH, configuration);
    },
    /**
     * Updates the organization\'s profile.
     * @summary Update Organization
     * @param {string} orgId Either the unique id of the organization, or the URL-friendly key of the organization (i.e: the \&quot;slug\&quot;).
     * @param {OrganizationUpdate} organizationUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateOrganization(orgId, organizationUpdate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateOrganization(
        orgId,
        organizationUpdate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios17, BASE_PATH, configuration);
    }
  };
};
var OrganizationsApiFactory = function(configuration, basePath, axios) {
  const localVarFp = OrganizationsApiFp(configuration);
  return {
    /**
     * Cancels an invite that was sent to a new member.
     * @summary Cancel Invite
     * @param {string} orgId Either the unique id of the organization, or the URL-friendly key of the organization (i.e: the \&quot;slug\&quot;).
     * @param {string} inviteId Id of the invite to cancel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelInvite(orgId, inviteId, options) {
      return localVarFp.cancelInvite(orgId, inviteId, options).then((request) => request(axios, basePath));
    },
    /**
     * Creates a new organization that will be owned by the authenticated actor (i.e: human team member or api key).
     * @summary Create Organization
     * @param {OrganizationCreate} organizationCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createOrganization(organizationCreate, options) {
      return localVarFp.createOrganization(organizationCreate, options).then((request) => request(axios, basePath));
    },
    /**
     * Deletes an organization (Permit.io account) and all its related data.
     * @summary Delete Organization
     * @param {string} orgId Either the unique id of the organization, or the URL-friendly key of the organization (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteOrganization(orgId, options) {
      return localVarFp.deleteOrganization(orgId, options).then((request) => request(axios, basePath));
    },
    /**
     * Gets a single organization (Permit.io account) matching the given org_id, if such org exists and can be accessed by the authenticated actor.
     * @summary Get Active Organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getActiveOrganization(options) {
      return localVarFp.getActiveOrganization(options).then((request) => request(axios, basePath));
    },
    /**
     * Gets a single organization (Permit.io account) matching the given org_id, if such org exists and can be accessed by the authenticated actor.
     * @summary Get Organization
     * @param {string} orgId Either the unique id of the organization, or the URL-friendly key of the organization (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrganization(orgId, options) {
      return localVarFp.getOrganization(orgId, options).then((request) => request(axios, basePath));
    },
    /**
     * Invite new members into the organization.
     * @summary Invite Members To Organization
     * @param {string} orgId Either the unique id of the organization, or the URL-friendly key of the organization (i.e: the \&quot;slug\&quot;).
     * @param {Array<InviteCreate>} inviteCreate
     * @param {string} [inviterName]
     * @param {string} [inviterEmail]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    inviteMembersToOrganization(orgId, inviteCreate, inviterName, inviterEmail, options) {
      return localVarFp.inviteMembersToOrganization(orgId, inviteCreate, inviterName, inviterEmail, options).then((request) => request(axios, basePath));
    },
    /**
     * Lists pending organization invites
     * @summary List Organization Invites
     * @param {string} orgId Either the unique id of the organization, or the URL-friendly key of the organization (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listOrganizationInvites(orgId, page, perPage, options) {
      return localVarFp.listOrganizationInvites(orgId, page, perPage, options).then((request) => request(axios, basePath));
    },
    /**
     * Lists all the organizations that can be accessed by the authenticated actor (i.e: human team member or api key).
     * @summary List Organizations
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listOrganizations(page, perPage, options) {
      return localVarFp.listOrganizations(page, perPage, options).then((request) => request(axios, basePath));
    },
    /**
     * Updates the organization\'s profile.
     * @summary Update Organization
     * @param {string} orgId Either the unique id of the organization, or the URL-friendly key of the organization (i.e: the \&quot;slug\&quot;).
     * @param {OrganizationUpdate} organizationUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateOrganization(orgId, organizationUpdate, options) {
      return localVarFp.updateOrganization(orgId, organizationUpdate, options).then((request) => request(axios, basePath));
    }
  };
};
var OrganizationsApi = class extends BaseAPI {
  /**
   * Cancels an invite that was sent to a new member.
   * @summary Cancel Invite
   * @param {OrganizationsApiCancelInviteRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OrganizationsApi
   */
  cancelInvite(requestParameters, options) {
    return OrganizationsApiFp(this.configuration).cancelInvite(requestParameters.orgId, requestParameters.inviteId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Creates a new organization that will be owned by the authenticated actor (i.e: human team member or api key).
   * @summary Create Organization
   * @param {OrganizationsApiCreateOrganizationRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OrganizationsApi
   */
  createOrganization(requestParameters, options) {
    return OrganizationsApiFp(this.configuration).createOrganization(requestParameters.organizationCreate, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Deletes an organization (Permit.io account) and all its related data.
   * @summary Delete Organization
   * @param {OrganizationsApiDeleteOrganizationRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OrganizationsApi
   */
  deleteOrganization(requestParameters, options) {
    return OrganizationsApiFp(this.configuration).deleteOrganization(requestParameters.orgId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Gets a single organization (Permit.io account) matching the given org_id, if such org exists and can be accessed by the authenticated actor.
   * @summary Get Active Organization
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OrganizationsApi
   */
  getActiveOrganization(options) {
    return OrganizationsApiFp(this.configuration).getActiveOrganization(options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Gets a single organization (Permit.io account) matching the given org_id, if such org exists and can be accessed by the authenticated actor.
   * @summary Get Organization
   * @param {OrganizationsApiGetOrganizationRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OrganizationsApi
   */
  getOrganization(requestParameters, options) {
    return OrganizationsApiFp(this.configuration).getOrganization(requestParameters.orgId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Invite new members into the organization.
   * @summary Invite Members To Organization
   * @param {OrganizationsApiInviteMembersToOrganizationRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OrganizationsApi
   */
  inviteMembersToOrganization(requestParameters, options) {
    return OrganizationsApiFp(this.configuration).inviteMembersToOrganization(
      requestParameters.orgId,
      requestParameters.inviteCreate,
      requestParameters.inviterName,
      requestParameters.inviterEmail,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Lists pending organization invites
   * @summary List Organization Invites
   * @param {OrganizationsApiListOrganizationInvitesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OrganizationsApi
   */
  listOrganizationInvites(requestParameters, options) {
    return OrganizationsApiFp(this.configuration).listOrganizationInvites(
      requestParameters.orgId,
      requestParameters.page,
      requestParameters.perPage,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Lists all the organizations that can be accessed by the authenticated actor (i.e: human team member or api key).
   * @summary List Organizations
   * @param {OrganizationsApiListOrganizationsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OrganizationsApi
   */
  listOrganizations(requestParameters = {}, options) {
    return OrganizationsApiFp(this.configuration).listOrganizations(requestParameters.page, requestParameters.perPage, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Updates the organization\'s profile.
   * @summary Update Organization
   * @param {OrganizationsApiUpdateOrganizationRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OrganizationsApi
   */
  updateOrganization(requestParameters, options) {
    return OrganizationsApiFp(this.configuration).updateOrganization(requestParameters.orgId, requestParameters.organizationUpdate, options).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/policy-api.ts
import globalAxios18 from "axios";
var PolicyApiAxiosParamCreator = function(configuration) {
  return {
    /**
     *
     * @summary Get Opal Data Sources
     * @param {string} [token]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOpalDataSources: async (token, options = {}) => {
      const localVarPath = `/v2/opal/data/config`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      if (token !== void 0) {
        localVarQueryParameter["token"] = token;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Get Opal Data Sources
     * @param {string} [token]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOpalDataSourcesOpalDataConfigGet: async (token, options = {}) => {
      const localVarPath = `/opal/data/config`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      if (token !== void 0) {
        localVarQueryParameter["token"] = token;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var PolicyApiFp = function(configuration) {
  const localVarAxiosParamCreator = PolicyApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Get Opal Data Sources
     * @param {string} [token]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getOpalDataSources(token, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getOpalDataSources(token, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios18, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get Opal Data Sources
     * @param {string} [token]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getOpalDataSourcesOpalDataConfigGet(token, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getOpalDataSourcesOpalDataConfigGet(
        token,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios18, BASE_PATH, configuration);
    }
  };
};
var PolicyApiFactory = function(configuration, basePath, axios) {
  const localVarFp = PolicyApiFp(configuration);
  return {
    /**
     *
     * @summary Get Opal Data Sources
     * @param {string} [token]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOpalDataSources(token, options) {
      return localVarFp.getOpalDataSources(token, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get Opal Data Sources
     * @param {string} [token]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOpalDataSourcesOpalDataConfigGet(token, options) {
      return localVarFp.getOpalDataSourcesOpalDataConfigGet(token, options).then((request) => request(axios, basePath));
    }
  };
};
var PolicyApi = class extends BaseAPI {
  /**
   *
   * @summary Get Opal Data Sources
   * @param {PolicyApiGetOpalDataSourcesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PolicyApi
   */
  getOpalDataSources(requestParameters = {}, options) {
    return PolicyApiFp(this.configuration).getOpalDataSources(requestParameters.token, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Get Opal Data Sources
   * @param {PolicyApiGetOpalDataSourcesOpalDataConfigGetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PolicyApi
   */
  getOpalDataSourcesOpalDataConfigGet(requestParameters = {}, options) {
    return PolicyApiFp(this.configuration).getOpalDataSourcesOpalDataConfigGet(requestParameters.token, options).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/policy-decision-points-api.ts
import globalAxios19 from "axios";
var PolicyDecisionPointsApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * Gets the configuration values for the currently authenticated PDP container.  The PDP authenticates with an API key scoped to a given Permit.io environment. The system identifies the PDP via its API key and then returns all the configuration values required for the container to run correctly.  The config values returned are considered \"overrides\", meaning they are overriding any default values given to the container by the user.
     * @summary Get connected PDP configuration and push state
     * @param {PDPStateUpdate} pDPStateUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAuthenticatingPdpConfigValues: async (pDPStateUpdate, options = {}) => {
      assertParamExists("getAuthenticatingPdpConfigValues", "pDPStateUpdate", pDPStateUpdate);
      const localVarPath = `/v2/pdps/me/config`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        pDPStateUpdate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Gets the configuration values for the currently authenticated PDP container.  The PDP authenticates with an API key scoped to a given Permit.io environment. The system identifies the PDP via its API key and then returns all the configuration values required for the container to run correctly.  The config values returned are considered \"overrides\", meaning they are overriding any default values given to the container by the user.
     * @summary Get connected PDP configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAuthenticatingPdpConfigValuesLegacy: async (options = {}) => {
      const localVarPath = `/v2/pdps/me/config`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Gets the configuration values for the PDP container with id `pdp_id`.  The config values returned are considered \"overrides\", meaning they are overriding any default values given to the container by the user.
     * @summary Get PDP configuration
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} pdpId The unique id of the pdp
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPdpConfigValues: async (projId, envId, pdpId, options = {}) => {
      assertParamExists("getPdpConfigValues", "projId", projId);
      assertParamExists("getPdpConfigValues", "envId", envId);
      assertParamExists("getPdpConfigValues", "pdpId", pdpId);
      const localVarPath = `/v2/pdps/{proj_id}/{env_id}/configs/{pdp_id}/values`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"pdp_id"}}`, encodeURIComponent(String(pdpId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary List PDP configurations
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPdpConfigs: async (projId, envId, page, perPage, options = {}) => {
      assertParamExists("listPdpConfigs", "projId", projId);
      assertParamExists("listPdpConfigs", "envId", envId);
      const localVarPath = `/v2/pdps/{proj_id}/{env_id}/configs`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Accept a PDP data callback
     * @param {string} xPermitInstanceId
     * @param {DataUpdateReport} dataUpdateReport
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    opalDataCallback: async (xPermitInstanceId, dataUpdateReport, options = {}) => {
      assertParamExists("opalDataCallback", "xPermitInstanceId", xPermitInstanceId);
      assertParamExists("opalDataCallback", "dataUpdateReport", dataUpdateReport);
      const localVarPath = `/v2/pdps/me/opal_data_callback`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (xPermitInstanceId != null) {
        localVarHeaderParameter["x-permit-instance-id"] = String(xPermitInstanceId);
      }
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        dataUpdateReport,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Push a PDP state update.
     * @summary Push PDP state
     * @param {PDPStateUpdate} pDPStateUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pushPdpState: async (pDPStateUpdate, options = {}) => {
      assertParamExists("pushPdpState", "pDPStateUpdate", pDPStateUpdate);
      const localVarPath = `/v2/pdps/me/state`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        pDPStateUpdate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Rotates the API key of the PDP container with id `pdp_id`.  The rotation of the API key revokes the old API key and issues a new API key to the PDP.
     * @summary Rotate PDP API Key
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} pdpId The unique id of the pdp
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rotatePdpApiKey: async (projId, envId, pdpId, options = {}) => {
      assertParamExists("rotatePdpApiKey", "projId", projId);
      assertParamExists("rotatePdpApiKey", "envId", envId);
      assertParamExists("rotatePdpApiKey", "pdpId", pdpId);
      const localVarPath = `/v2/pdps/{proj_id}/{env_id}/configs/{pdp_id}/rotate-api-key`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"pdp_id"}}`, encodeURIComponent(String(pdpId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var PolicyDecisionPointsApiFp = function(configuration) {
  const localVarAxiosParamCreator = PolicyDecisionPointsApiAxiosParamCreator(configuration);
  return {
    /**
     * Gets the configuration values for the currently authenticated PDP container.  The PDP authenticates with an API key scoped to a given Permit.io environment. The system identifies the PDP via its API key and then returns all the configuration values required for the container to run correctly.  The config values returned are considered \"overrides\", meaning they are overriding any default values given to the container by the user.
     * @summary Get connected PDP configuration and push state
     * @param {PDPStateUpdate} pDPStateUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAuthenticatingPdpConfigValues(pDPStateUpdate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAuthenticatingPdpConfigValues(
        pDPStateUpdate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios19, BASE_PATH, configuration);
    },
    /**
     * Gets the configuration values for the currently authenticated PDP container.  The PDP authenticates with an API key scoped to a given Permit.io environment. The system identifies the PDP via its API key and then returns all the configuration values required for the container to run correctly.  The config values returned are considered \"overrides\", meaning they are overriding any default values given to the container by the user.
     * @summary Get connected PDP configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAuthenticatingPdpConfigValuesLegacy(options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAuthenticatingPdpConfigValuesLegacy(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios19, BASE_PATH, configuration);
    },
    /**
     * Gets the configuration values for the PDP container with id `pdp_id`.  The config values returned are considered \"overrides\", meaning they are overriding any default values given to the container by the user.
     * @summary Get PDP configuration
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} pdpId The unique id of the pdp
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPdpConfigValues(projId, envId, pdpId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPdpConfigValues(
        projId,
        envId,
        pdpId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios19, BASE_PATH, configuration);
    },
    /**
     *
     * @summary List PDP configurations
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listPdpConfigs(projId, envId, page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listPdpConfigs(
        projId,
        envId,
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios19, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Accept a PDP data callback
     * @param {string} xPermitInstanceId
     * @param {DataUpdateReport} dataUpdateReport
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async opalDataCallback(xPermitInstanceId, dataUpdateReport, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.opalDataCallback(
        xPermitInstanceId,
        dataUpdateReport,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios19, BASE_PATH, configuration);
    },
    /**
     * Push a PDP state update.
     * @summary Push PDP state
     * @param {PDPStateUpdate} pDPStateUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async pushPdpState(pDPStateUpdate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.pushPdpState(
        pDPStateUpdate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios19, BASE_PATH, configuration);
    },
    /**
     * Rotates the API key of the PDP container with id `pdp_id`.  The rotation of the API key revokes the old API key and issues a new API key to the PDP.
     * @summary Rotate PDP API Key
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} pdpId The unique id of the pdp
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async rotatePdpApiKey(projId, envId, pdpId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.rotatePdpApiKey(
        projId,
        envId,
        pdpId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios19, BASE_PATH, configuration);
    }
  };
};
var PolicyDecisionPointsApiFactory = function(configuration, basePath, axios) {
  const localVarFp = PolicyDecisionPointsApiFp(configuration);
  return {
    /**
     * Gets the configuration values for the currently authenticated PDP container.  The PDP authenticates with an API key scoped to a given Permit.io environment. The system identifies the PDP via its API key and then returns all the configuration values required for the container to run correctly.  The config values returned are considered \"overrides\", meaning they are overriding any default values given to the container by the user.
     * @summary Get connected PDP configuration and push state
     * @param {PDPStateUpdate} pDPStateUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAuthenticatingPdpConfigValues(pDPStateUpdate, options) {
      return localVarFp.getAuthenticatingPdpConfigValues(pDPStateUpdate, options).then((request) => request(axios, basePath));
    },
    /**
     * Gets the configuration values for the currently authenticated PDP container.  The PDP authenticates with an API key scoped to a given Permit.io environment. The system identifies the PDP via its API key and then returns all the configuration values required for the container to run correctly.  The config values returned are considered \"overrides\", meaning they are overriding any default values given to the container by the user.
     * @summary Get connected PDP configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAuthenticatingPdpConfigValuesLegacy(options) {
      return localVarFp.getAuthenticatingPdpConfigValuesLegacy(options).then((request) => request(axios, basePath));
    },
    /**
     * Gets the configuration values for the PDP container with id `pdp_id`.  The config values returned are considered \"overrides\", meaning they are overriding any default values given to the container by the user.
     * @summary Get PDP configuration
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} pdpId The unique id of the pdp
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPdpConfigValues(projId, envId, pdpId, options) {
      return localVarFp.getPdpConfigValues(projId, envId, pdpId, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary List PDP configurations
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPdpConfigs(projId, envId, page, perPage, options) {
      return localVarFp.listPdpConfigs(projId, envId, page, perPage, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Accept a PDP data callback
     * @param {string} xPermitInstanceId
     * @param {DataUpdateReport} dataUpdateReport
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    opalDataCallback(xPermitInstanceId, dataUpdateReport, options) {
      return localVarFp.opalDataCallback(xPermitInstanceId, dataUpdateReport, options).then((request) => request(axios, basePath));
    },
    /**
     * Push a PDP state update.
     * @summary Push PDP state
     * @param {PDPStateUpdate} pDPStateUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pushPdpState(pDPStateUpdate, options) {
      return localVarFp.pushPdpState(pDPStateUpdate, options).then((request) => request(axios, basePath));
    },
    /**
     * Rotates the API key of the PDP container with id `pdp_id`.  The rotation of the API key revokes the old API key and issues a new API key to the PDP.
     * @summary Rotate PDP API Key
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} pdpId The unique id of the pdp
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rotatePdpApiKey(projId, envId, pdpId, options) {
      return localVarFp.rotatePdpApiKey(projId, envId, pdpId, options).then((request) => request(axios, basePath));
    }
  };
};
var PolicyDecisionPointsApi = class extends BaseAPI {
  /**
   * Gets the configuration values for the currently authenticated PDP container.  The PDP authenticates with an API key scoped to a given Permit.io environment. The system identifies the PDP via its API key and then returns all the configuration values required for the container to run correctly.  The config values returned are considered \"overrides\", meaning they are overriding any default values given to the container by the user.
   * @summary Get connected PDP configuration and push state
   * @param {PolicyDecisionPointsApiGetAuthenticatingPdpConfigValuesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PolicyDecisionPointsApi
   */
  getAuthenticatingPdpConfigValues(requestParameters, options) {
    return PolicyDecisionPointsApiFp(this.configuration).getAuthenticatingPdpConfigValues(requestParameters.pDPStateUpdate, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Gets the configuration values for the currently authenticated PDP container.  The PDP authenticates with an API key scoped to a given Permit.io environment. The system identifies the PDP via its API key and then returns all the configuration values required for the container to run correctly.  The config values returned are considered \"overrides\", meaning they are overriding any default values given to the container by the user.
   * @summary Get connected PDP configuration
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PolicyDecisionPointsApi
   */
  getAuthenticatingPdpConfigValuesLegacy(options) {
    return PolicyDecisionPointsApiFp(this.configuration).getAuthenticatingPdpConfigValuesLegacy(options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Gets the configuration values for the PDP container with id `pdp_id`.  The config values returned are considered \"overrides\", meaning they are overriding any default values given to the container by the user.
   * @summary Get PDP configuration
   * @param {PolicyDecisionPointsApiGetPdpConfigValuesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PolicyDecisionPointsApi
   */
  getPdpConfigValues(requestParameters, options) {
    return PolicyDecisionPointsApiFp(this.configuration).getPdpConfigValues(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.pdpId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary List PDP configurations
   * @param {PolicyDecisionPointsApiListPdpConfigsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PolicyDecisionPointsApi
   */
  listPdpConfigs(requestParameters, options) {
    return PolicyDecisionPointsApiFp(this.configuration).listPdpConfigs(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.page,
      requestParameters.perPage,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Accept a PDP data callback
   * @param {PolicyDecisionPointsApiOpalDataCallbackRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PolicyDecisionPointsApi
   */
  opalDataCallback(requestParameters, options) {
    return PolicyDecisionPointsApiFp(this.configuration).opalDataCallback(
      requestParameters.xPermitInstanceId,
      requestParameters.dataUpdateReport,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Push a PDP state update.
   * @summary Push PDP state
   * @param {PolicyDecisionPointsApiPushPdpStateRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PolicyDecisionPointsApi
   */
  pushPdpState(requestParameters, options) {
    return PolicyDecisionPointsApiFp(this.configuration).pushPdpState(requestParameters.pDPStateUpdate, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Rotates the API key of the PDP container with id `pdp_id`.  The rotation of the API key revokes the old API key and issues a new API key to the PDP.
   * @summary Rotate PDP API Key
   * @param {PolicyDecisionPointsApiRotatePdpApiKeyRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PolicyDecisionPointsApi
   */
  rotatePdpApiKey(requestParameters, options) {
    return PolicyDecisionPointsApiFp(this.configuration).rotatePdpApiKey(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.pdpId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/policy-git-repositories-api.ts
import globalAxios20 from "axios";
var PolicyGitRepositoriesApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * Disable the currently active policy repo, this action means to turn off the gitops feature. If there is no active policy repo, this action will do nothing.
     * @summary Activate Policy Repo
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} repoId Either the unique id of the policy repo, or the URL-friendly key of the policy repo (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    activatePolicyRepo: async (projId, repoId, options = {}) => {
      assertParamExists("activatePolicyRepo", "projId", projId);
      assertParamExists("activatePolicyRepo", "repoId", repoId);
      const localVarPath = `/v2/projects/{proj_id}/repos/{repo_id}/activate`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"repo_id"}}`, encodeURIComponent(String(repoId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Creates a new policy repository configuration under a given project. The given repository is created with status \'pending\', it will be changed and used as the \'active\' repository for the policy only after a successful attempt to use it. The repository main branch must be present in the remote.
     * @summary Create Policy Repo
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {PolicyRepoCreate} policyRepoCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPolicyRepo: async (projId, policyRepoCreate, options = {}) => {
      assertParamExists("createPolicyRepo", "projId", projId);
      assertParamExists("createPolicyRepo", "policyRepoCreate", policyRepoCreate);
      const localVarPath = `/v2/projects/{proj_id}/repos`.replace(
        `{${"proj_id"}}`,
        encodeURIComponent(String(projId))
      );
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        policyRepoCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes an environment and all its related data.
     * @summary Delete Policy Repo
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} repoId Either the unique id of the policy repo, or the URL-friendly key of the policy repo (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePolicyRepo: async (projId, repoId, options = {}) => {
      assertParamExists("deletePolicyRepo", "projId", projId);
      assertParamExists("deletePolicyRepo", "repoId", repoId);
      const localVarPath = `/v2/projects/{proj_id}/repos/{repo_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"repo_id"}}`, encodeURIComponent(String(repoId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Disable the currently active policy repo, this action means to turn off the gitops feature. If there is no active policy repo, this action will do nothing.
     * @summary Disable Active Policy Repo
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    disableActivePolicyRepo: async (projId, options = {}) => {
      assertParamExists("disableActivePolicyRepo", "projId", projId);
      const localVarPath = `/v2/projects/{proj_id}/repos/disable`.replace(
        `{${"proj_id"}}`,
        encodeURIComponent(String(projId))
      );
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Gets the currently active repository, if such repository exists.
     * @summary Get Active Policy Repo
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getActivePolicyRepo: async (projId, options = {}) => {
      assertParamExists("getActivePolicyRepo", "projId", projId);
      const localVarPath = `/v2/projects/{proj_id}/repos/active`.replace(
        `{${"proj_id"}}`,
        encodeURIComponent(String(projId))
      );
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Gets a single repository matching the given repo_id, if such repository exists.
     * @summary Get Policy Repo
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} repoId Either the unique id of the policy repo, or the URL-friendly key of the policy repo (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPolicyRepo: async (projId, repoId, options = {}) => {
      assertParamExists("getPolicyRepo", "projId", projId);
      assertParamExists("getPolicyRepo", "repoId", repoId);
      const localVarPath = `/v2/projects/{proj_id}/repos/{repo_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"repo_id"}}`, encodeURIComponent(String(repoId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Lists all the policy repositories under a given project.
     * @summary List Policy Repos
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPolicyRepos: async (projId, page, perPage, options = {}) => {
      assertParamExists("listPolicyRepos", "projId", projId);
      const localVarPath = `/v2/projects/{proj_id}/repos`.replace(
        `{${"proj_id"}}`,
        encodeURIComponent(String(projId))
      );
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var PolicyGitRepositoriesApiFp = function(configuration) {
  const localVarAxiosParamCreator = PolicyGitRepositoriesApiAxiosParamCreator(configuration);
  return {
    /**
     * Disable the currently active policy repo, this action means to turn off the gitops feature. If there is no active policy repo, this action will do nothing.
     * @summary Activate Policy Repo
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} repoId Either the unique id of the policy repo, or the URL-friendly key of the policy repo (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async activatePolicyRepo(projId, repoId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.activatePolicyRepo(
        projId,
        repoId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios20, BASE_PATH, configuration);
    },
    /**
     * Creates a new policy repository configuration under a given project. The given repository is created with status \'pending\', it will be changed and used as the \'active\' repository for the policy only after a successful attempt to use it. The repository main branch must be present in the remote.
     * @summary Create Policy Repo
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {PolicyRepoCreate} policyRepoCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createPolicyRepo(projId, policyRepoCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createPolicyRepo(
        projId,
        policyRepoCreate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios20, BASE_PATH, configuration);
    },
    /**
     * Deletes an environment and all its related data.
     * @summary Delete Policy Repo
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} repoId Either the unique id of the policy repo, or the URL-friendly key of the policy repo (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletePolicyRepo(projId, repoId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deletePolicyRepo(
        projId,
        repoId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios20, BASE_PATH, configuration);
    },
    /**
     * Disable the currently active policy repo, this action means to turn off the gitops feature. If there is no active policy repo, this action will do nothing.
     * @summary Disable Active Policy Repo
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async disableActivePolicyRepo(projId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.disableActivePolicyRepo(
        projId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios20, BASE_PATH, configuration);
    },
    /**
     * Gets the currently active repository, if such repository exists.
     * @summary Get Active Policy Repo
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getActivePolicyRepo(projId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getActivePolicyRepo(
        projId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios20, BASE_PATH, configuration);
    },
    /**
     * Gets a single repository matching the given repo_id, if such repository exists.
     * @summary Get Policy Repo
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} repoId Either the unique id of the policy repo, or the URL-friendly key of the policy repo (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPolicyRepo(projId, repoId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPolicyRepo(
        projId,
        repoId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios20, BASE_PATH, configuration);
    },
    /**
     * Lists all the policy repositories under a given project.
     * @summary List Policy Repos
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listPolicyRepos(projId, page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listPolicyRepos(
        projId,
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios20, BASE_PATH, configuration);
    }
  };
};
var PolicyGitRepositoriesApiFactory = function(configuration, basePath, axios) {
  const localVarFp = PolicyGitRepositoriesApiFp(configuration);
  return {
    /**
     * Disable the currently active policy repo, this action means to turn off the gitops feature. If there is no active policy repo, this action will do nothing.
     * @summary Activate Policy Repo
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} repoId Either the unique id of the policy repo, or the URL-friendly key of the policy repo (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    activatePolicyRepo(projId, repoId, options) {
      return localVarFp.activatePolicyRepo(projId, repoId, options).then((request) => request(axios, basePath));
    },
    /**
     * Creates a new policy repository configuration under a given project. The given repository is created with status \'pending\', it will be changed and used as the \'active\' repository for the policy only after a successful attempt to use it. The repository main branch must be present in the remote.
     * @summary Create Policy Repo
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {PolicyRepoCreate} policyRepoCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPolicyRepo(projId, policyRepoCreate, options) {
      return localVarFp.createPolicyRepo(projId, policyRepoCreate, options).then((request) => request(axios, basePath));
    },
    /**
     * Deletes an environment and all its related data.
     * @summary Delete Policy Repo
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} repoId Either the unique id of the policy repo, or the URL-friendly key of the policy repo (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePolicyRepo(projId, repoId, options) {
      return localVarFp.deletePolicyRepo(projId, repoId, options).then((request) => request(axios, basePath));
    },
    /**
     * Disable the currently active policy repo, this action means to turn off the gitops feature. If there is no active policy repo, this action will do nothing.
     * @summary Disable Active Policy Repo
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    disableActivePolicyRepo(projId, options) {
      return localVarFp.disableActivePolicyRepo(projId, options).then((request) => request(axios, basePath));
    },
    /**
     * Gets the currently active repository, if such repository exists.
     * @summary Get Active Policy Repo
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getActivePolicyRepo(projId, options) {
      return localVarFp.getActivePolicyRepo(projId, options).then((request) => request(axios, basePath));
    },
    /**
     * Gets a single repository matching the given repo_id, if such repository exists.
     * @summary Get Policy Repo
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} repoId Either the unique id of the policy repo, or the URL-friendly key of the policy repo (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPolicyRepo(projId, repoId, options) {
      return localVarFp.getPolicyRepo(projId, repoId, options).then((request) => request(axios, basePath));
    },
    /**
     * Lists all the policy repositories under a given project.
     * @summary List Policy Repos
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPolicyRepos(projId, page, perPage, options) {
      return localVarFp.listPolicyRepos(projId, page, perPage, options).then((request) => request(axios, basePath));
    }
  };
};
var PolicyGitRepositoriesApi = class extends BaseAPI {
  /**
   * Disable the currently active policy repo, this action means to turn off the gitops feature. If there is no active policy repo, this action will do nothing.
   * @summary Activate Policy Repo
   * @param {PolicyGitRepositoriesApiActivatePolicyRepoRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PolicyGitRepositoriesApi
   */
  activatePolicyRepo(requestParameters, options) {
    return PolicyGitRepositoriesApiFp(this.configuration).activatePolicyRepo(requestParameters.projId, requestParameters.repoId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Creates a new policy repository configuration under a given project. The given repository is created with status \'pending\', it will be changed and used as the \'active\' repository for the policy only after a successful attempt to use it. The repository main branch must be present in the remote.
   * @summary Create Policy Repo
   * @param {PolicyGitRepositoriesApiCreatePolicyRepoRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PolicyGitRepositoriesApi
   */
  createPolicyRepo(requestParameters, options) {
    return PolicyGitRepositoriesApiFp(this.configuration).createPolicyRepo(requestParameters.projId, requestParameters.policyRepoCreate, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Deletes an environment and all its related data.
   * @summary Delete Policy Repo
   * @param {PolicyGitRepositoriesApiDeletePolicyRepoRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PolicyGitRepositoriesApi
   */
  deletePolicyRepo(requestParameters, options) {
    return PolicyGitRepositoriesApiFp(this.configuration).deletePolicyRepo(requestParameters.projId, requestParameters.repoId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Disable the currently active policy repo, this action means to turn off the gitops feature. If there is no active policy repo, this action will do nothing.
   * @summary Disable Active Policy Repo
   * @param {PolicyGitRepositoriesApiDisableActivePolicyRepoRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PolicyGitRepositoriesApi
   */
  disableActivePolicyRepo(requestParameters, options) {
    return PolicyGitRepositoriesApiFp(this.configuration).disableActivePolicyRepo(requestParameters.projId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Gets the currently active repository, if such repository exists.
   * @summary Get Active Policy Repo
   * @param {PolicyGitRepositoriesApiGetActivePolicyRepoRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PolicyGitRepositoriesApi
   */
  getActivePolicyRepo(requestParameters, options) {
    return PolicyGitRepositoriesApiFp(this.configuration).getActivePolicyRepo(requestParameters.projId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Gets a single repository matching the given repo_id, if such repository exists.
   * @summary Get Policy Repo
   * @param {PolicyGitRepositoriesApiGetPolicyRepoRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PolicyGitRepositoriesApi
   */
  getPolicyRepo(requestParameters, options) {
    return PolicyGitRepositoriesApiFp(this.configuration).getPolicyRepo(requestParameters.projId, requestParameters.repoId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Lists all the policy repositories under a given project.
   * @summary List Policy Repos
   * @param {PolicyGitRepositoriesApiListPolicyReposRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PolicyGitRepositoriesApi
   */
  listPolicyRepos(requestParameters, options) {
    return PolicyGitRepositoriesApiFp(this.configuration).listPolicyRepos(
      requestParameters.projId,
      requestParameters.page,
      requestParameters.perPage,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/projects-api.ts
import globalAxios21 from "axios";
var ProjectsApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * Creates a new project under the active organization.
     * @summary Create Project
     * @param {ProjectCreate} projectCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createProject: async (projectCreate, options = {}) => {
      assertParamExists("createProject", "projectCreate", projectCreate);
      const localVarPath = `/v2/projects`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        projectCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes the project and all its related data.
     * @summary Delete Project
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteProject: async (projId, options = {}) => {
      assertParamExists("deleteProject", "projId", projId);
      const localVarPath = `/v2/projects/{proj_id}`.replace(
        `{${"proj_id"}}`,
        encodeURIComponent(String(projId))
      );
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Gets a single project matching the given proj_id, if such project exists.
     * @summary Get Project
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProject: async (projId, options = {}) => {
      assertParamExists("getProject", "projId", projId);
      const localVarPath = `/v2/projects/{proj_id}`.replace(
        `{${"proj_id"}}`,
        encodeURIComponent(String(projId))
      );
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Lists all the projects under the active organization.
     * @summary List Projects
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listProjects: async (page, perPage, options = {}) => {
      const localVarPath = `/v2/projects`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Updates the project.
     * @summary Update Project
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {ProjectUpdate} projectUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProject: async (projId, projectUpdate, options = {}) => {
      assertParamExists("updateProject", "projId", projId);
      assertParamExists("updateProject", "projectUpdate", projectUpdate);
      const localVarPath = `/v2/projects/{proj_id}`.replace(
        `{${"proj_id"}}`,
        encodeURIComponent(String(projId))
      );
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        projectUpdate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var ProjectsApiFp = function(configuration) {
  const localVarAxiosParamCreator = ProjectsApiAxiosParamCreator(configuration);
  return {
    /**
     * Creates a new project under the active organization.
     * @summary Create Project
     * @param {ProjectCreate} projectCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createProject(projectCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createProject(
        projectCreate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios21, BASE_PATH, configuration);
    },
    /**
     * Deletes the project and all its related data.
     * @summary Delete Project
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteProject(projId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProject(projId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios21, BASE_PATH, configuration);
    },
    /**
     * Gets a single project matching the given proj_id, if such project exists.
     * @summary Get Project
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getProject(projId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getProject(projId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios21, BASE_PATH, configuration);
    },
    /**
     * Lists all the projects under the active organization.
     * @summary List Projects
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listProjects(page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listProjects(
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios21, BASE_PATH, configuration);
    },
    /**
     * Updates the project.
     * @summary Update Project
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {ProjectUpdate} projectUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateProject(projId, projectUpdate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateProject(
        projId,
        projectUpdate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios21, BASE_PATH, configuration);
    }
  };
};
var ProjectsApiFactory = function(configuration, basePath, axios) {
  const localVarFp = ProjectsApiFp(configuration);
  return {
    /**
     * Creates a new project under the active organization.
     * @summary Create Project
     * @param {ProjectCreate} projectCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createProject(projectCreate, options) {
      return localVarFp.createProject(projectCreate, options).then((request) => request(axios, basePath));
    },
    /**
     * Deletes the project and all its related data.
     * @summary Delete Project
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteProject(projId, options) {
      return localVarFp.deleteProject(projId, options).then((request) => request(axios, basePath));
    },
    /**
     * Gets a single project matching the given proj_id, if such project exists.
     * @summary Get Project
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProject(projId, options) {
      return localVarFp.getProject(projId, options).then((request) => request(axios, basePath));
    },
    /**
     * Lists all the projects under the active organization.
     * @summary List Projects
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listProjects(page, perPage, options) {
      return localVarFp.listProjects(page, perPage, options).then((request) => request(axios, basePath));
    },
    /**
     * Updates the project.
     * @summary Update Project
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {ProjectUpdate} projectUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProject(projId, projectUpdate, options) {
      return localVarFp.updateProject(projId, projectUpdate, options).then((request) => request(axios, basePath));
    }
  };
};
var ProjectsApi = class extends BaseAPI {
  /**
   * Creates a new project under the active organization.
   * @summary Create Project
   * @param {ProjectsApiCreateProjectRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectsApi
   */
  createProject(requestParameters, options) {
    return ProjectsApiFp(this.configuration).createProject(requestParameters.projectCreate, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Deletes the project and all its related data.
   * @summary Delete Project
   * @param {ProjectsApiDeleteProjectRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectsApi
   */
  deleteProject(requestParameters, options) {
    return ProjectsApiFp(this.configuration).deleteProject(requestParameters.projId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Gets a single project matching the given proj_id, if such project exists.
   * @summary Get Project
   * @param {ProjectsApiGetProjectRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectsApi
   */
  getProject(requestParameters, options) {
    return ProjectsApiFp(this.configuration).getProject(requestParameters.projId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Lists all the projects under the active organization.
   * @summary List Projects
   * @param {ProjectsApiListProjectsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectsApi
   */
  listProjects(requestParameters = {}, options) {
    return ProjectsApiFp(this.configuration).listProjects(requestParameters.page, requestParameters.perPage, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Updates the project.
   * @summary Update Project
   * @param {ProjectsApiUpdateProjectRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectsApi
   */
  updateProject(requestParameters, options) {
    return ProjectsApiFp(this.configuration).updateProject(requestParameters.projId, requestParameters.projectUpdate, options).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/proxy-config-api.ts
import globalAxios22 from "axios";
var ProxyConfigApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * Creates a new proxy config inside the Permit.io system.  If the proxy config is already created: will return 200 instead of 201, and will return the existing proxy config object in the response body.
     * @summary Create Proxy Config
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ProxyConfigCreate} proxyConfigCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createProxyConfig: async (projId, envId, proxyConfigCreate, options = {}) => {
      assertParamExists("createProxyConfig", "projId", projId);
      assertParamExists("createProxyConfig", "envId", envId);
      assertParamExists("createProxyConfig", "proxyConfigCreate", proxyConfigCreate);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/proxy_configs`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        proxyConfigCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes the proxy config and all its related data.
     * @summary Delete Proxy Config
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} proxyConfigId Either the unique id of the proxy config, or the URL-friendly key of the proxy config (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteProxyConfig: async (projId, envId, proxyConfigId, options = {}) => {
      assertParamExists("deleteProxyConfig", "projId", projId);
      assertParamExists("deleteProxyConfig", "envId", envId);
      assertParamExists("deleteProxyConfig", "proxyConfigId", proxyConfigId);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/proxy_configs/{proxy_config_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"proxy_config_id"}}`, encodeURIComponent(String(proxyConfigId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Gets a proxy config, if such proxy config exists. Otherwise returns 404.
     * @summary Get Proxy Config
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} proxyConfigId Either the unique id of the proxy config, or the URL-friendly key of the proxy config (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProxyConfig: async (projId, envId, proxyConfigId, options = {}) => {
      assertParamExists("getProxyConfig", "projId", projId);
      assertParamExists("getProxyConfig", "envId", envId);
      assertParamExists("getProxyConfig", "proxyConfigId", proxyConfigId);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/proxy_configs/{proxy_config_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"proxy_config_id"}}`, encodeURIComponent(String(proxyConfigId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Lists all the proxy configs defined within an environment.
     * @summary List Proxy Configs
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listProxyConfigs: async (projId, envId, page, perPage, options = {}) => {
      assertParamExists("listProxyConfigs", "projId", projId);
      assertParamExists("listProxyConfigs", "envId", envId);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/proxy_configs`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Partially updates the proxy config definition. Fields that will be provided will be completely overwritten.
     * @summary Update Proxy Config
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} proxyConfigId Either the unique id of the proxy config, or the URL-friendly key of the proxy config (i.e: the \&quot;slug\&quot;).
     * @param {ProxyConfigUpdate} proxyConfigUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProxyConfig: async (projId, envId, proxyConfigId, proxyConfigUpdate, options = {}) => {
      assertParamExists("updateProxyConfig", "projId", projId);
      assertParamExists("updateProxyConfig", "envId", envId);
      assertParamExists("updateProxyConfig", "proxyConfigId", proxyConfigId);
      assertParamExists("updateProxyConfig", "proxyConfigUpdate", proxyConfigUpdate);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/proxy_configs/{proxy_config_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"proxy_config_id"}}`, encodeURIComponent(String(proxyConfigId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        proxyConfigUpdate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var ProxyConfigApiFp = function(configuration) {
  const localVarAxiosParamCreator = ProxyConfigApiAxiosParamCreator(configuration);
  return {
    /**
     * Creates a new proxy config inside the Permit.io system.  If the proxy config is already created: will return 200 instead of 201, and will return the existing proxy config object in the response body.
     * @summary Create Proxy Config
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ProxyConfigCreate} proxyConfigCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createProxyConfig(projId, envId, proxyConfigCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createProxyConfig(
        projId,
        envId,
        proxyConfigCreate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios22, BASE_PATH, configuration);
    },
    /**
     * Deletes the proxy config and all its related data.
     * @summary Delete Proxy Config
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} proxyConfigId Either the unique id of the proxy config, or the URL-friendly key of the proxy config (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteProxyConfig(projId, envId, proxyConfigId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProxyConfig(
        projId,
        envId,
        proxyConfigId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios22, BASE_PATH, configuration);
    },
    /**
     * Gets a proxy config, if such proxy config exists. Otherwise returns 404.
     * @summary Get Proxy Config
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} proxyConfigId Either the unique id of the proxy config, or the URL-friendly key of the proxy config (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getProxyConfig(projId, envId, proxyConfigId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getProxyConfig(
        projId,
        envId,
        proxyConfigId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios22, BASE_PATH, configuration);
    },
    /**
     * Lists all the proxy configs defined within an environment.
     * @summary List Proxy Configs
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listProxyConfigs(projId, envId, page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listProxyConfigs(
        projId,
        envId,
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios22, BASE_PATH, configuration);
    },
    /**
     * Partially updates the proxy config definition. Fields that will be provided will be completely overwritten.
     * @summary Update Proxy Config
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} proxyConfigId Either the unique id of the proxy config, or the URL-friendly key of the proxy config (i.e: the \&quot;slug\&quot;).
     * @param {ProxyConfigUpdate} proxyConfigUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateProxyConfig(projId, envId, proxyConfigId, proxyConfigUpdate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateProxyConfig(
        projId,
        envId,
        proxyConfigId,
        proxyConfigUpdate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios22, BASE_PATH, configuration);
    }
  };
};
var ProxyConfigApiFactory = function(configuration, basePath, axios) {
  const localVarFp = ProxyConfigApiFp(configuration);
  return {
    /**
     * Creates a new proxy config inside the Permit.io system.  If the proxy config is already created: will return 200 instead of 201, and will return the existing proxy config object in the response body.
     * @summary Create Proxy Config
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ProxyConfigCreate} proxyConfigCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createProxyConfig(projId, envId, proxyConfigCreate, options) {
      return localVarFp.createProxyConfig(projId, envId, proxyConfigCreate, options).then((request) => request(axios, basePath));
    },
    /**
     * Deletes the proxy config and all its related data.
     * @summary Delete Proxy Config
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} proxyConfigId Either the unique id of the proxy config, or the URL-friendly key of the proxy config (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteProxyConfig(projId, envId, proxyConfigId, options) {
      return localVarFp.deleteProxyConfig(projId, envId, proxyConfigId, options).then((request) => request(axios, basePath));
    },
    /**
     * Gets a proxy config, if such proxy config exists. Otherwise returns 404.
     * @summary Get Proxy Config
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} proxyConfigId Either the unique id of the proxy config, or the URL-friendly key of the proxy config (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProxyConfig(projId, envId, proxyConfigId, options) {
      return localVarFp.getProxyConfig(projId, envId, proxyConfigId, options).then((request) => request(axios, basePath));
    },
    /**
     * Lists all the proxy configs defined within an environment.
     * @summary List Proxy Configs
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listProxyConfigs(projId, envId, page, perPage, options) {
      return localVarFp.listProxyConfigs(projId, envId, page, perPage, options).then((request) => request(axios, basePath));
    },
    /**
     * Partially updates the proxy config definition. Fields that will be provided will be completely overwritten.
     * @summary Update Proxy Config
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} proxyConfigId Either the unique id of the proxy config, or the URL-friendly key of the proxy config (i.e: the \&quot;slug\&quot;).
     * @param {ProxyConfigUpdate} proxyConfigUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProxyConfig(projId, envId, proxyConfigId, proxyConfigUpdate, options) {
      return localVarFp.updateProxyConfig(projId, envId, proxyConfigId, proxyConfigUpdate, options).then((request) => request(axios, basePath));
    }
  };
};
var ProxyConfigApi = class extends BaseAPI {
  /**
   * Creates a new proxy config inside the Permit.io system.  If the proxy config is already created: will return 200 instead of 201, and will return the existing proxy config object in the response body.
   * @summary Create Proxy Config
   * @param {ProxyConfigApiCreateProxyConfigRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProxyConfigApi
   */
  createProxyConfig(requestParameters, options) {
    return ProxyConfigApiFp(this.configuration).createProxyConfig(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.proxyConfigCreate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Deletes the proxy config and all its related data.
   * @summary Delete Proxy Config
   * @param {ProxyConfigApiDeleteProxyConfigRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProxyConfigApi
   */
  deleteProxyConfig(requestParameters, options) {
    return ProxyConfigApiFp(this.configuration).deleteProxyConfig(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.proxyConfigId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Gets a proxy config, if such proxy config exists. Otherwise returns 404.
   * @summary Get Proxy Config
   * @param {ProxyConfigApiGetProxyConfigRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProxyConfigApi
   */
  getProxyConfig(requestParameters, options) {
    return ProxyConfigApiFp(this.configuration).getProxyConfig(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.proxyConfigId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Lists all the proxy configs defined within an environment.
   * @summary List Proxy Configs
   * @param {ProxyConfigApiListProxyConfigsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProxyConfigApi
   */
  listProxyConfigs(requestParameters, options) {
    return ProxyConfigApiFp(this.configuration).listProxyConfigs(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.page,
      requestParameters.perPage,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Partially updates the proxy config definition. Fields that will be provided will be completely overwritten.
   * @summary Update Proxy Config
   * @param {ProxyConfigApiUpdateProxyConfigRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProxyConfigApi
   */
  updateProxyConfig(requestParameters, options) {
    return ProxyConfigApiFp(this.configuration).updateProxyConfig(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.proxyConfigId,
      requestParameters.proxyConfigUpdate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/relationship-tuples-api.ts
import globalAxios23 from "axios";
var RelationshipTuplesApiAxiosParamCreator = function(configuration) {
  return {
    /**
     *
     * @summary Bulk create relationship tuples(EAP)
     * @param {any} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {any} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {RelationshipTupleCreateBulkOperation} relationshipTupleCreateBulkOperation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkCreateRelationshipTuples: async (projId, envId, relationshipTupleCreateBulkOperation, options = {}) => {
      assertParamExists("bulkCreateRelationshipTuples", "projId", projId);
      assertParamExists("bulkCreateRelationshipTuples", "envId", envId);
      assertParamExists(
        "bulkCreateRelationshipTuples",
        "relationshipTupleCreateBulkOperation",
        relationshipTupleCreateBulkOperation
      );
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/relationship_tuples/bulk`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        relationshipTupleCreateBulkOperation,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Bulk Delete Relationship Tuples
     * @param {any} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {any} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {RelationshipTupleDeleteBulkOperation} relationshipTupleDeleteBulkOperation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkDeleteRelationshipTuples: async (projId, envId, relationshipTupleDeleteBulkOperation, options = {}) => {
      assertParamExists("bulkDeleteRelationshipTuples", "projId", projId);
      assertParamExists("bulkDeleteRelationshipTuples", "envId", envId);
      assertParamExists(
        "bulkDeleteRelationshipTuples",
        "relationshipTupleDeleteBulkOperation",
        relationshipTupleDeleteBulkOperation
      );
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/relationship_tuples/bulk`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        relationshipTupleDeleteBulkOperation,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Create a relationship between two resource instances using a relation.
     * @summary Create Relationship Tuple
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {RelationshipTupleCreate} relationshipTupleCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRelationshipTuple: async (projId, envId, relationshipTupleCreate, options = {}) => {
      assertParamExists("createRelationshipTuple", "projId", projId);
      assertParamExists("createRelationshipTuple", "envId", envId);
      assertParamExists(
        "createRelationshipTuple",
        "relationshipTupleCreate",
        relationshipTupleCreate
      );
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/relationship_tuples`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        relationshipTupleCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Delete a relationship between two resource instances.
     * @summary Delete Relationship Tuple
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {RelationshipTupleDelete} relationshipTupleDelete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRelationshipTuple: async (projId, envId, relationshipTupleDelete, options = {}) => {
      assertParamExists("deleteRelationshipTuple", "projId", projId);
      assertParamExists("deleteRelationshipTuple", "envId", envId);
      assertParamExists(
        "deleteRelationshipTuple",
        "relationshipTupleDelete",
        relationshipTupleDelete
      );
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/relationship_tuples`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        relationshipTupleDelete,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Lists the relationship tuples defined within an environment.
     * @summary List Relationship Tuples
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {string} [tenant] The tenant key or id to filter by
     * @param {string} [subject] The subject to filter by, accepts either the resource instance id or resource_type:resource_instance
     * @param {string} [relation] The relation id or key to filter by
     * @param {string} [object] The object to filter by, accepts either the resource instance id or resource_type:resource_instance
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listRelationshipTuples: async (projId, envId, detailed, page, perPage, tenant, subject, relation, object, objectType, subjectType, options = {}) => {
      assertParamExists("listRelationshipTuples", "projId", projId);
      assertParamExists("listRelationshipTuples", "envId", envId);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/relationship_tuples`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (detailed !== void 0) {
        localVarQueryParameter["detailed"] = detailed;
      }
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      if (tenant !== void 0) {
        localVarQueryParameter["tenant"] = tenant;
      }
      if (subject !== void 0) {
        localVarQueryParameter["subject"] = subject;
      }
      if (relation !== void 0) {
        localVarQueryParameter["relation"] = relation;
      }
      if (object !== void 0) {
        localVarQueryParameter["object"] = object;
      }
      if (objectType !== void 0) {
        localVarQueryParameter["object_type"] = objectType;
      }
      if (subjectType !== void 0) {
        localVarQueryParameter["subject_type"] = subjectType;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var RelationshipTuplesApiFp = function(configuration) {
  const localVarAxiosParamCreator = RelationshipTuplesApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Bulk create relationship tuples(EAP)
     * @param {any} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {any} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {RelationshipTupleCreateBulkOperation} relationshipTupleCreateBulkOperation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bulkCreateRelationshipTuples(projId, envId, relationshipTupleCreateBulkOperation, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.bulkCreateRelationshipTuples(
        projId,
        envId,
        relationshipTupleCreateBulkOperation,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios23, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Bulk Delete Relationship Tuples
     * @param {any} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {any} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {RelationshipTupleDeleteBulkOperation} relationshipTupleDeleteBulkOperation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bulkDeleteRelationshipTuples(projId, envId, relationshipTupleDeleteBulkOperation, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.bulkDeleteRelationshipTuples(
        projId,
        envId,
        relationshipTupleDeleteBulkOperation,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios23, BASE_PATH, configuration);
    },
    /**
     * Create a relationship between two resource instances using a relation.
     * @summary Create Relationship Tuple
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {RelationshipTupleCreate} relationshipTupleCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createRelationshipTuple(projId, envId, relationshipTupleCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createRelationshipTuple(
        projId,
        envId,
        relationshipTupleCreate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios23, BASE_PATH, configuration);
    },
    /**
     * Delete a relationship between two resource instances.
     * @summary Delete Relationship Tuple
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {RelationshipTupleDelete} relationshipTupleDelete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteRelationshipTuple(projId, envId, relationshipTupleDelete, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRelationshipTuple(
        projId,
        envId,
        relationshipTupleDelete,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios23, BASE_PATH, configuration);
    },
    /**
     * Lists the relationship tuples defined within an environment.
     * @summary List Relationship Tuples
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {string} [tenant] The tenant key or id to filter by
     * @param {string} [subject] The subject to filter by, accepts either the resource instance id or resource_type:resource_instance
     * @param {string} [relation] The relation id or key to filter by
     * @param {string} [object] The object to filter by, accepts either the resource instance id or resource_type:resource_instance
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listRelationshipTuples(projId, envId, detailed, page, perPage, tenant, subject, relation, object, objectType, subjectType, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listRelationshipTuples(
        projId,
        envId,
        detailed,
        page,
        perPage,
        tenant,
        subject,
        relation,
        object,
        objectType,
        subjectType,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios23, BASE_PATH, configuration);
    }
  };
};
var RelationshipTuplesApiFactory = function(configuration, basePath, axios) {
  const localVarFp = RelationshipTuplesApiFp(configuration);
  return {
    /**
     *
     * @summary Bulk create relationship tuples(EAP)
     * @param {any} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {any} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {RelationshipTupleCreateBulkOperation} relationshipTupleCreateBulkOperation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkCreateRelationshipTuples(projId, envId, relationshipTupleCreateBulkOperation, options) {
      return localVarFp.bulkCreateRelationshipTuples(projId, envId, relationshipTupleCreateBulkOperation, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Bulk Delete Relationship Tuples
     * @param {any} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {any} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {RelationshipTupleDeleteBulkOperation} relationshipTupleDeleteBulkOperation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkDeleteRelationshipTuples(projId, envId, relationshipTupleDeleteBulkOperation, options) {
      return localVarFp.bulkDeleteRelationshipTuples(projId, envId, relationshipTupleDeleteBulkOperation, options).then((request) => request(axios, basePath));
    },
    /**
     * Create a relationship between two resource instances using a relation.
     * @summary Create Relationship Tuple
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {RelationshipTupleCreate} relationshipTupleCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRelationshipTuple(projId, envId, relationshipTupleCreate, options) {
      return localVarFp.createRelationshipTuple(projId, envId, relationshipTupleCreate, options).then((request) => request(axios, basePath));
    },
    /**
     * Delete a relationship between two resource instances.
     * @summary Delete Relationship Tuple
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {RelationshipTupleDelete} relationshipTupleDelete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRelationshipTuple(projId, envId, relationshipTupleDelete, options) {
      return localVarFp.deleteRelationshipTuple(projId, envId, relationshipTupleDelete, options).then((request) => request(axios, basePath));
    },
    /**
     * Lists the relationship tuples defined within an environment.
     * @summary List Relationship Tuples
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} [detailed] If true, will return the full subject and object resource instances.
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {string} [tenant] The tenant key or id to filter by
     * @param {string} [subject] The subject to filter by, accepts either the resource instance id or resource_type:resource_instance
     * @param {string} [relation] The relation id or key to filter by
     * @param {string} [object] The object to filter by, accepts either the resource instance id or resource_type:resource_instance
     * @param {string} [objectType] The object type to filter by, accepts resource type id or key
     * @param {string} [subjectType] The subject type to filter by, accepts resource type id or key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listRelationshipTuples(projId, envId, detailed, page, perPage, tenant, subject, relation, object, objectType, subjectType, options) {
      return localVarFp.listRelationshipTuples(
        projId,
        envId,
        detailed,
        page,
        perPage,
        tenant,
        subject,
        relation,
        object,
        objectType,
        subjectType,
        options
      ).then((request) => request(axios, basePath));
    }
  };
};
var RelationshipTuplesApi = class extends BaseAPI {
  /**
   *
   * @summary Bulk create relationship tuples(EAP)
   * @param {RelationshipTuplesApiBulkCreateRelationshipTuplesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RelationshipTuplesApi
   */
  async bulkCreateRelationshipTuples(requestParameters, options) {
    let request = await RelationshipTuplesApiFp(this.configuration).bulkCreateRelationshipTuples(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.relationshipTupleCreateBulkOperation,
      options
    );
    return request(this.axios, this.basePath);
  }
  /**
   *
   * @summary Bulk Delete Relationship Tuples
   * @param {RelationshipTuplesApiBulkDeleteRelationshipTuplesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RelationshipTuplesApi
   */
  async bulkDeleteRelationshipTuples(requestParameters, options) {
    let request = await RelationshipTuplesApiFp(this.configuration).bulkDeleteRelationshipTuples(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.relationshipTupleDeleteBulkOperation,
      options
    );
    return request(this.axios, this.basePath);
  }
  /**
   * Create a relationship between two resource instances using a relation.
   * @summary Create Relationship Tuple
   * @param {RelationshipTuplesApiCreateRelationshipTupleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RelationshipTuplesApi
   */
  createRelationshipTuple(requestParameters, options) {
    return RelationshipTuplesApiFp(this.configuration).createRelationshipTuple(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.relationshipTupleCreate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Delete a relationship between two resource instances.
   * @summary Delete Relationship Tuple
   * @param {RelationshipTuplesApiDeleteRelationshipTupleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RelationshipTuplesApi
   */
  deleteRelationshipTuple(requestParameters, options) {
    return RelationshipTuplesApiFp(this.configuration).deleteRelationshipTuple(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.relationshipTupleDelete,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Lists the relationship tuples defined within an environment.
   * @summary List Relationship Tuples
   * @param {RelationshipTuplesApiListRelationshipTuplesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RelationshipTuplesApi
   */
  listRelationshipTuples(requestParameters, options) {
    return RelationshipTuplesApiFp(this.configuration).listRelationshipTuples(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.detailed,
      requestParameters.page,
      requestParameters.perPage,
      requestParameters.tenant,
      requestParameters.subject,
      requestParameters.relation,
      requestParameters.object,
      requestParameters.objectType,
      requestParameters.subjectType,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/resource-action-groups-api.ts
import globalAxios24 from "axios";
var ResourceActionGroupsApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * Creates a new action group that can affect the resource.
     * @summary Create Resource Action Group
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {ResourceActionGroupCreate} resourceActionGroupCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createResourceActionGroup: async (projId, envId, resourceId, resourceActionGroupCreate, options = {}) => {
      assertParamExists("createResourceActionGroup", "projId", projId);
      assertParamExists("createResourceActionGroup", "envId", envId);
      assertParamExists("createResourceActionGroup", "resourceId", resourceId);
      assertParamExists(
        "createResourceActionGroup",
        "resourceActionGroupCreate",
        resourceActionGroupCreate
      );
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/action_groups`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        resourceActionGroupCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes the action and all its related data. This includes any permissions granted to perform the action.
     * @summary Delete Resource Action Group
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} actionGroupId Either the unique id of the action group, or the URL-friendly key of the action group (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteResourceActionGroup: async (projId, envId, resourceId, actionGroupId, options = {}) => {
      assertParamExists("deleteResourceActionGroup", "projId", projId);
      assertParamExists("deleteResourceActionGroup", "envId", envId);
      assertParamExists("deleteResourceActionGroup", "resourceId", resourceId);
      assertParamExists("deleteResourceActionGroup", "actionGroupId", actionGroupId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/action_groups/{action_group_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId))).replace(`{${"action_group_id"}}`, encodeURIComponent(String(actionGroupId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Gets a single action group defined on the resource, if such action exists.
     * @summary Get Resource Action Group
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} actionGroupId Either the unique id of the action group, or the URL-friendly key of the action group (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getResourceActionGroup: async (projId, envId, resourceId, actionGroupId, options = {}) => {
      assertParamExists("getResourceActionGroup", "projId", projId);
      assertParamExists("getResourceActionGroup", "envId", envId);
      assertParamExists("getResourceActionGroup", "resourceId", resourceId);
      assertParamExists("getResourceActionGroup", "actionGroupId", actionGroupId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/action_groups/{action_group_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId))).replace(`{${"action_group_id"}}`, encodeURIComponent(String(actionGroupId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Lists all the action groups defined on the resource.
     * @summary List Resource Action Groups
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listResourceActionGroups: async (projId, envId, resourceId, page, perPage, options = {}) => {
      assertParamExists("listResourceActionGroups", "projId", projId);
      assertParamExists("listResourceActionGroups", "envId", envId);
      assertParamExists("listResourceActionGroups", "resourceId", resourceId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/action_groups`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Partially updates the action defined on a resource. Fields that will be provided will be completely overwritten.
     * @summary Update Resource Action Group
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} actionGroupId Either the unique id of the action group, or the URL-friendly key of the action group (i.e: the \&quot;slug\&quot;).
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ResourceActionGroupUpdate} resourceActionGroupUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateResourceActionGroup: async (resourceId, actionGroupId, projId, envId, resourceActionGroupUpdate, options = {}) => {
      assertParamExists("updateResourceActionGroup", "resourceId", resourceId);
      assertParamExists("updateResourceActionGroup", "actionGroupId", actionGroupId);
      assertParamExists("updateResourceActionGroup", "projId", projId);
      assertParamExists("updateResourceActionGroup", "envId", envId);
      assertParamExists(
        "updateResourceActionGroup",
        "resourceActionGroupUpdate",
        resourceActionGroupUpdate
      );
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/action_groups/{action_group_id}`.replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId))).replace(`{${"action_group_id"}}`, encodeURIComponent(String(actionGroupId))).replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        resourceActionGroupUpdate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var ResourceActionGroupsApiFp = function(configuration) {
  const localVarAxiosParamCreator = ResourceActionGroupsApiAxiosParamCreator(configuration);
  return {
    /**
     * Creates a new action group that can affect the resource.
     * @summary Create Resource Action Group
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {ResourceActionGroupCreate} resourceActionGroupCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createResourceActionGroup(projId, envId, resourceId, resourceActionGroupCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createResourceActionGroup(
        projId,
        envId,
        resourceId,
        resourceActionGroupCreate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios24, BASE_PATH, configuration);
    },
    /**
     * Deletes the action and all its related data. This includes any permissions granted to perform the action.
     * @summary Delete Resource Action Group
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} actionGroupId Either the unique id of the action group, or the URL-friendly key of the action group (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteResourceActionGroup(projId, envId, resourceId, actionGroupId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteResourceActionGroup(
        projId,
        envId,
        resourceId,
        actionGroupId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios24, BASE_PATH, configuration);
    },
    /**
     * Gets a single action group defined on the resource, if such action exists.
     * @summary Get Resource Action Group
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} actionGroupId Either the unique id of the action group, or the URL-friendly key of the action group (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getResourceActionGroup(projId, envId, resourceId, actionGroupId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getResourceActionGroup(
        projId,
        envId,
        resourceId,
        actionGroupId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios24, BASE_PATH, configuration);
    },
    /**
     * Lists all the action groups defined on the resource.
     * @summary List Resource Action Groups
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listResourceActionGroups(projId, envId, resourceId, page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listResourceActionGroups(
        projId,
        envId,
        resourceId,
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios24, BASE_PATH, configuration);
    },
    /**
     * Partially updates the action defined on a resource. Fields that will be provided will be completely overwritten.
     * @summary Update Resource Action Group
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} actionGroupId Either the unique id of the action group, or the URL-friendly key of the action group (i.e: the \&quot;slug\&quot;).
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ResourceActionGroupUpdate} resourceActionGroupUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateResourceActionGroup(resourceId, actionGroupId, projId, envId, resourceActionGroupUpdate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateResourceActionGroup(
        resourceId,
        actionGroupId,
        projId,
        envId,
        resourceActionGroupUpdate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios24, BASE_PATH, configuration);
    }
  };
};
var ResourceActionGroupsApiFactory = function(configuration, basePath, axios) {
  const localVarFp = ResourceActionGroupsApiFp(configuration);
  return {
    /**
     * Creates a new action group that can affect the resource.
     * @summary Create Resource Action Group
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {ResourceActionGroupCreate} resourceActionGroupCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createResourceActionGroup(projId, envId, resourceId, resourceActionGroupCreate, options) {
      return localVarFp.createResourceActionGroup(projId, envId, resourceId, resourceActionGroupCreate, options).then((request) => request(axios, basePath));
    },
    /**
     * Deletes the action and all its related data. This includes any permissions granted to perform the action.
     * @summary Delete Resource Action Group
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} actionGroupId Either the unique id of the action group, or the URL-friendly key of the action group (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteResourceActionGroup(projId, envId, resourceId, actionGroupId, options) {
      return localVarFp.deleteResourceActionGroup(projId, envId, resourceId, actionGroupId, options).then((request) => request(axios, basePath));
    },
    /**
     * Gets a single action group defined on the resource, if such action exists.
     * @summary Get Resource Action Group
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} actionGroupId Either the unique id of the action group, or the URL-friendly key of the action group (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getResourceActionGroup(projId, envId, resourceId, actionGroupId, options) {
      return localVarFp.getResourceActionGroup(projId, envId, resourceId, actionGroupId, options).then((request) => request(axios, basePath));
    },
    /**
     * Lists all the action groups defined on the resource.
     * @summary List Resource Action Groups
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listResourceActionGroups(projId, envId, resourceId, page, perPage, options) {
      return localVarFp.listResourceActionGroups(projId, envId, resourceId, page, perPage, options).then((request) => request(axios, basePath));
    },
    /**
     * Partially updates the action defined on a resource. Fields that will be provided will be completely overwritten.
     * @summary Update Resource Action Group
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} actionGroupId Either the unique id of the action group, or the URL-friendly key of the action group (i.e: the \&quot;slug\&quot;).
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ResourceActionGroupUpdate} resourceActionGroupUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateResourceActionGroup(resourceId, actionGroupId, projId, envId, resourceActionGroupUpdate, options) {
      return localVarFp.updateResourceActionGroup(
        resourceId,
        actionGroupId,
        projId,
        envId,
        resourceActionGroupUpdate,
        options
      ).then((request) => request(axios, basePath));
    }
  };
};
var ResourceActionGroupsApi = class extends BaseAPI {
  /**
   * Creates a new action group that can affect the resource.
   * @summary Create Resource Action Group
   * @param {ResourceActionGroupsApiCreateResourceActionGroupRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceActionGroupsApi
   */
  createResourceActionGroup(requestParameters, options) {
    return ResourceActionGroupsApiFp(this.configuration).createResourceActionGroup(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.resourceActionGroupCreate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Deletes the action and all its related data. This includes any permissions granted to perform the action.
   * @summary Delete Resource Action Group
   * @param {ResourceActionGroupsApiDeleteResourceActionGroupRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceActionGroupsApi
   */
  deleteResourceActionGroup(requestParameters, options) {
    return ResourceActionGroupsApiFp(this.configuration).deleteResourceActionGroup(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.actionGroupId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Gets a single action group defined on the resource, if such action exists.
   * @summary Get Resource Action Group
   * @param {ResourceActionGroupsApiGetResourceActionGroupRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceActionGroupsApi
   */
  getResourceActionGroup(requestParameters, options) {
    return ResourceActionGroupsApiFp(this.configuration).getResourceActionGroup(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.actionGroupId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Lists all the action groups defined on the resource.
   * @summary List Resource Action Groups
   * @param {ResourceActionGroupsApiListResourceActionGroupsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceActionGroupsApi
   */
  listResourceActionGroups(requestParameters, options) {
    return ResourceActionGroupsApiFp(this.configuration).listResourceActionGroups(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.page,
      requestParameters.perPage,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Partially updates the action defined on a resource. Fields that will be provided will be completely overwritten.
   * @summary Update Resource Action Group
   * @param {ResourceActionGroupsApiUpdateResourceActionGroupRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceActionGroupsApi
   */
  updateResourceActionGroup(requestParameters, options) {
    return ResourceActionGroupsApiFp(this.configuration).updateResourceActionGroup(
      requestParameters.resourceId,
      requestParameters.actionGroupId,
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceActionGroupUpdate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/resource-actions-api.ts
import globalAxios25 from "axios";
var ResourceActionsApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * Creates a new action that can affect the resource.
     * @summary Create Resource Action
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {ResourceActionCreate} resourceActionCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createResourceAction: async (projId, envId, resourceId, resourceActionCreate, options = {}) => {
      assertParamExists("createResourceAction", "projId", projId);
      assertParamExists("createResourceAction", "envId", envId);
      assertParamExists("createResourceAction", "resourceId", resourceId);
      assertParamExists("createResourceAction", "resourceActionCreate", resourceActionCreate);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/actions`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        resourceActionCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes the action and all its related data. This includes any permissions granted to perform the action.
     * @summary Delete Resource Action
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} actionId Either the unique id of the action, or the URL-friendly key of the action (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteResourceAction: async (projId, envId, resourceId, actionId, options = {}) => {
      assertParamExists("deleteResourceAction", "projId", projId);
      assertParamExists("deleteResourceAction", "envId", envId);
      assertParamExists("deleteResourceAction", "resourceId", resourceId);
      assertParamExists("deleteResourceAction", "actionId", actionId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/actions/{action_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId))).replace(`{${"action_id"}}`, encodeURIComponent(String(actionId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Gets a single action defined on the resource, if such action exists.
     * @summary Get Resource Action
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} actionId Either the unique id of the action, or the URL-friendly key of the action (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getResourceAction: async (projId, envId, resourceId, actionId, options = {}) => {
      assertParamExists("getResourceAction", "projId", projId);
      assertParamExists("getResourceAction", "envId", envId);
      assertParamExists("getResourceAction", "resourceId", resourceId);
      assertParamExists("getResourceAction", "actionId", actionId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/actions/{action_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId))).replace(`{${"action_id"}}`, encodeURIComponent(String(actionId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Lists all the actions defined on the resource.
     * @summary List Resource Actions
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listResourceActions: async (projId, envId, resourceId, page, perPage, options = {}) => {
      assertParamExists("listResourceActions", "projId", projId);
      assertParamExists("listResourceActions", "envId", envId);
      assertParamExists("listResourceActions", "resourceId", resourceId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/actions`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Partially updates the action defined on a resource. Fields that will be provided will be completely overwritten.
     * @summary Update Resource Action
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} actionId Either the unique id of the action, or the URL-friendly key of the action (i.e: the \&quot;slug\&quot;).
     * @param {ResourceActionUpdate} resourceActionUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateResourceAction: async (projId, envId, resourceId, actionId, resourceActionUpdate, options = {}) => {
      assertParamExists("updateResourceAction", "projId", projId);
      assertParamExists("updateResourceAction", "envId", envId);
      assertParamExists("updateResourceAction", "resourceId", resourceId);
      assertParamExists("updateResourceAction", "actionId", actionId);
      assertParamExists("updateResourceAction", "resourceActionUpdate", resourceActionUpdate);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/actions/{action_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId))).replace(`{${"action_id"}}`, encodeURIComponent(String(actionId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        resourceActionUpdate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var ResourceActionsApiFp = function(configuration) {
  const localVarAxiosParamCreator = ResourceActionsApiAxiosParamCreator(configuration);
  return {
    /**
     * Creates a new action that can affect the resource.
     * @summary Create Resource Action
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {ResourceActionCreate} resourceActionCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createResourceAction(projId, envId, resourceId, resourceActionCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createResourceAction(
        projId,
        envId,
        resourceId,
        resourceActionCreate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios25, BASE_PATH, configuration);
    },
    /**
     * Deletes the action and all its related data. This includes any permissions granted to perform the action.
     * @summary Delete Resource Action
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} actionId Either the unique id of the action, or the URL-friendly key of the action (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteResourceAction(projId, envId, resourceId, actionId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteResourceAction(
        projId,
        envId,
        resourceId,
        actionId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios25, BASE_PATH, configuration);
    },
    /**
     * Gets a single action defined on the resource, if such action exists.
     * @summary Get Resource Action
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} actionId Either the unique id of the action, or the URL-friendly key of the action (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getResourceAction(projId, envId, resourceId, actionId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getResourceAction(
        projId,
        envId,
        resourceId,
        actionId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios25, BASE_PATH, configuration);
    },
    /**
     * Lists all the actions defined on the resource.
     * @summary List Resource Actions
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listResourceActions(projId, envId, resourceId, page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listResourceActions(
        projId,
        envId,
        resourceId,
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios25, BASE_PATH, configuration);
    },
    /**
     * Partially updates the action defined on a resource. Fields that will be provided will be completely overwritten.
     * @summary Update Resource Action
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} actionId Either the unique id of the action, or the URL-friendly key of the action (i.e: the \&quot;slug\&quot;).
     * @param {ResourceActionUpdate} resourceActionUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateResourceAction(projId, envId, resourceId, actionId, resourceActionUpdate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateResourceAction(
        projId,
        envId,
        resourceId,
        actionId,
        resourceActionUpdate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios25, BASE_PATH, configuration);
    }
  };
};
var ResourceActionsApiFactory = function(configuration, basePath, axios) {
  const localVarFp = ResourceActionsApiFp(configuration);
  return {
    /**
     * Creates a new action that can affect the resource.
     * @summary Create Resource Action
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {ResourceActionCreate} resourceActionCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createResourceAction(projId, envId, resourceId, resourceActionCreate, options) {
      return localVarFp.createResourceAction(projId, envId, resourceId, resourceActionCreate, options).then((request) => request(axios, basePath));
    },
    /**
     * Deletes the action and all its related data. This includes any permissions granted to perform the action.
     * @summary Delete Resource Action
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} actionId Either the unique id of the action, or the URL-friendly key of the action (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteResourceAction(projId, envId, resourceId, actionId, options) {
      return localVarFp.deleteResourceAction(projId, envId, resourceId, actionId, options).then((request) => request(axios, basePath));
    },
    /**
     * Gets a single action defined on the resource, if such action exists.
     * @summary Get Resource Action
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} actionId Either the unique id of the action, or the URL-friendly key of the action (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getResourceAction(projId, envId, resourceId, actionId, options) {
      return localVarFp.getResourceAction(projId, envId, resourceId, actionId, options).then((request) => request(axios, basePath));
    },
    /**
     * Lists all the actions defined on the resource.
     * @summary List Resource Actions
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listResourceActions(projId, envId, resourceId, page, perPage, options) {
      return localVarFp.listResourceActions(projId, envId, resourceId, page, perPage, options).then((request) => request(axios, basePath));
    },
    /**
     * Partially updates the action defined on a resource. Fields that will be provided will be completely overwritten.
     * @summary Update Resource Action
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} actionId Either the unique id of the action, or the URL-friendly key of the action (i.e: the \&quot;slug\&quot;).
     * @param {ResourceActionUpdate} resourceActionUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateResourceAction(projId, envId, resourceId, actionId, resourceActionUpdate, options) {
      return localVarFp.updateResourceAction(projId, envId, resourceId, actionId, resourceActionUpdate, options).then((request) => request(axios, basePath));
    }
  };
};
var ResourceActionsApi = class extends BaseAPI {
  /**
   * Creates a new action that can affect the resource.
   * @summary Create Resource Action
   * @param {ResourceActionsApiCreateResourceActionRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceActionsApi
   */
  createResourceAction(requestParameters, options) {
    return ResourceActionsApiFp(this.configuration).createResourceAction(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.resourceActionCreate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Deletes the action and all its related data. This includes any permissions granted to perform the action.
   * @summary Delete Resource Action
   * @param {ResourceActionsApiDeleteResourceActionRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceActionsApi
   */
  deleteResourceAction(requestParameters, options) {
    return ResourceActionsApiFp(this.configuration).deleteResourceAction(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.actionId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Gets a single action defined on the resource, if such action exists.
   * @summary Get Resource Action
   * @param {ResourceActionsApiGetResourceActionRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceActionsApi
   */
  getResourceAction(requestParameters, options) {
    return ResourceActionsApiFp(this.configuration).getResourceAction(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.actionId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Lists all the actions defined on the resource.
   * @summary List Resource Actions
   * @param {ResourceActionsApiListResourceActionsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceActionsApi
   */
  listResourceActions(requestParameters, options) {
    return ResourceActionsApiFp(this.configuration).listResourceActions(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.page,
      requestParameters.perPage,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Partially updates the action defined on a resource. Fields that will be provided will be completely overwritten.
   * @summary Update Resource Action
   * @param {ResourceActionsApiUpdateResourceActionRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceActionsApi
   */
  updateResourceAction(requestParameters, options) {
    return ResourceActionsApiFp(this.configuration).updateResourceAction(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.actionId,
      requestParameters.resourceActionUpdate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/resource-attributes-api.ts
import globalAxios26 from "axios";
var ResourceAttributesApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * Creates a new attribute as part of the resource definition.
     * @summary Create Resource Attribute
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {ResourceAttributeCreate} resourceAttributeCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createResourceAttribute: async (projId, envId, resourceId, resourceAttributeCreate, options = {}) => {
      assertParamExists("createResourceAttribute", "projId", projId);
      assertParamExists("createResourceAttribute", "envId", envId);
      assertParamExists("createResourceAttribute", "resourceId", resourceId);
      assertParamExists(
        "createResourceAttribute",
        "resourceAttributeCreate",
        resourceAttributeCreate
      );
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/attributes`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        resourceAttributeCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes the attribute and all its related data.  Note: If the attribute is used by policies, removing it will cause the attribute to evaluate as `undefined`.
     * @summary Delete Resource Attribute
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} attributeId Either the unique id of the attribute, or the URL-friendly key of the attribute (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteResourceAttribute: async (projId, envId, resourceId, attributeId, page, perPage, options = {}) => {
      assertParamExists("deleteResourceAttribute", "projId", projId);
      assertParamExists("deleteResourceAttribute", "envId", envId);
      assertParamExists("deleteResourceAttribute", "resourceId", resourceId);
      assertParamExists("deleteResourceAttribute", "attributeId", attributeId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/attributes/{attribute_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId))).replace(`{${"attribute_id"}}`, encodeURIComponent(String(attributeId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Gets a single attribute defined on the resource, if such attribute exists.
     * @summary Get Resource Attribute
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} attributeId Either the unique id of the attribute, or the URL-friendly key of the attribute (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getResourceAttribute: async (projId, envId, resourceId, attributeId, options = {}) => {
      assertParamExists("getResourceAttribute", "projId", projId);
      assertParamExists("getResourceAttribute", "envId", envId);
      assertParamExists("getResourceAttribute", "resourceId", resourceId);
      assertParamExists("getResourceAttribute", "attributeId", attributeId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/attributes/{attribute_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId))).replace(`{${"attribute_id"}}`, encodeURIComponent(String(attributeId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Lists all the attributes defined on the resource.
     * @summary List Resource Attributes
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listResourceAttributes: async (projId, envId, resourceId, page, perPage, options = {}) => {
      assertParamExists("listResourceAttributes", "projId", projId);
      assertParamExists("listResourceAttributes", "envId", envId);
      assertParamExists("listResourceAttributes", "resourceId", resourceId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/attributes`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Partially updates the attribute defined on a resource. Fields that will be provided will be completely overwritten.
     * @summary Update Resource Attribute
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} attributeId Either the unique id of the attribute, or the URL-friendly key of the attribute (i.e: the \&quot;slug\&quot;).
     * @param {ResourceAttributeUpdate} resourceAttributeUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateResourceAttribute: async (projId, envId, resourceId, attributeId, resourceAttributeUpdate, options = {}) => {
      assertParamExists("updateResourceAttribute", "projId", projId);
      assertParamExists("updateResourceAttribute", "envId", envId);
      assertParamExists("updateResourceAttribute", "resourceId", resourceId);
      assertParamExists("updateResourceAttribute", "attributeId", attributeId);
      assertParamExists(
        "updateResourceAttribute",
        "resourceAttributeUpdate",
        resourceAttributeUpdate
      );
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/attributes/{attribute_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId))).replace(`{${"attribute_id"}}`, encodeURIComponent(String(attributeId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        resourceAttributeUpdate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var ResourceAttributesApiFp = function(configuration) {
  const localVarAxiosParamCreator = ResourceAttributesApiAxiosParamCreator(configuration);
  return {
    /**
     * Creates a new attribute as part of the resource definition.
     * @summary Create Resource Attribute
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {ResourceAttributeCreate} resourceAttributeCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createResourceAttribute(projId, envId, resourceId, resourceAttributeCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createResourceAttribute(
        projId,
        envId,
        resourceId,
        resourceAttributeCreate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios26, BASE_PATH, configuration);
    },
    /**
     * Deletes the attribute and all its related data.  Note: If the attribute is used by policies, removing it will cause the attribute to evaluate as `undefined`.
     * @summary Delete Resource Attribute
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} attributeId Either the unique id of the attribute, or the URL-friendly key of the attribute (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteResourceAttribute(projId, envId, resourceId, attributeId, page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteResourceAttribute(
        projId,
        envId,
        resourceId,
        attributeId,
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios26, BASE_PATH, configuration);
    },
    /**
     * Gets a single attribute defined on the resource, if such attribute exists.
     * @summary Get Resource Attribute
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} attributeId Either the unique id of the attribute, or the URL-friendly key of the attribute (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getResourceAttribute(projId, envId, resourceId, attributeId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getResourceAttribute(
        projId,
        envId,
        resourceId,
        attributeId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios26, BASE_PATH, configuration);
    },
    /**
     * Lists all the attributes defined on the resource.
     * @summary List Resource Attributes
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listResourceAttributes(projId, envId, resourceId, page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listResourceAttributes(
        projId,
        envId,
        resourceId,
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios26, BASE_PATH, configuration);
    },
    /**
     * Partially updates the attribute defined on a resource. Fields that will be provided will be completely overwritten.
     * @summary Update Resource Attribute
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} attributeId Either the unique id of the attribute, or the URL-friendly key of the attribute (i.e: the \&quot;slug\&quot;).
     * @param {ResourceAttributeUpdate} resourceAttributeUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateResourceAttribute(projId, envId, resourceId, attributeId, resourceAttributeUpdate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateResourceAttribute(
        projId,
        envId,
        resourceId,
        attributeId,
        resourceAttributeUpdate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios26, BASE_PATH, configuration);
    }
  };
};
var ResourceAttributesApiFactory = function(configuration, basePath, axios) {
  const localVarFp = ResourceAttributesApiFp(configuration);
  return {
    /**
     * Creates a new attribute as part of the resource definition.
     * @summary Create Resource Attribute
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {ResourceAttributeCreate} resourceAttributeCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createResourceAttribute(projId, envId, resourceId, resourceAttributeCreate, options) {
      return localVarFp.createResourceAttribute(projId, envId, resourceId, resourceAttributeCreate, options).then((request) => request(axios, basePath));
    },
    /**
     * Deletes the attribute and all its related data.  Note: If the attribute is used by policies, removing it will cause the attribute to evaluate as `undefined`.
     * @summary Delete Resource Attribute
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} attributeId Either the unique id of the attribute, or the URL-friendly key of the attribute (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteResourceAttribute(projId, envId, resourceId, attributeId, page, perPage, options) {
      return localVarFp.deleteResourceAttribute(projId, envId, resourceId, attributeId, page, perPage, options).then((request) => request(axios, basePath));
    },
    /**
     * Gets a single attribute defined on the resource, if such attribute exists.
     * @summary Get Resource Attribute
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} attributeId Either the unique id of the attribute, or the URL-friendly key of the attribute (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getResourceAttribute(projId, envId, resourceId, attributeId, options) {
      return localVarFp.getResourceAttribute(projId, envId, resourceId, attributeId, options).then((request) => request(axios, basePath));
    },
    /**
     * Lists all the attributes defined on the resource.
     * @summary List Resource Attributes
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listResourceAttributes(projId, envId, resourceId, page, perPage, options) {
      return localVarFp.listResourceAttributes(projId, envId, resourceId, page, perPage, options).then((request) => request(axios, basePath));
    },
    /**
     * Partially updates the attribute defined on a resource. Fields that will be provided will be completely overwritten.
     * @summary Update Resource Attribute
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} attributeId Either the unique id of the attribute, or the URL-friendly key of the attribute (i.e: the \&quot;slug\&quot;).
     * @param {ResourceAttributeUpdate} resourceAttributeUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateResourceAttribute(projId, envId, resourceId, attributeId, resourceAttributeUpdate, options) {
      return localVarFp.updateResourceAttribute(
        projId,
        envId,
        resourceId,
        attributeId,
        resourceAttributeUpdate,
        options
      ).then((request) => request(axios, basePath));
    }
  };
};
var ResourceAttributesApi = class extends BaseAPI {
  /**
   * Creates a new attribute as part of the resource definition.
   * @summary Create Resource Attribute
   * @param {ResourceAttributesApiCreateResourceAttributeRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceAttributesApi
   */
  createResourceAttribute(requestParameters, options) {
    return ResourceAttributesApiFp(this.configuration).createResourceAttribute(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.resourceAttributeCreate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Deletes the attribute and all its related data.  Note: If the attribute is used by policies, removing it will cause the attribute to evaluate as `undefined`.
   * @summary Delete Resource Attribute
   * @param {ResourceAttributesApiDeleteResourceAttributeRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceAttributesApi
   */
  deleteResourceAttribute(requestParameters, options) {
    return ResourceAttributesApiFp(this.configuration).deleteResourceAttribute(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.attributeId,
      requestParameters.page,
      requestParameters.perPage,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Gets a single attribute defined on the resource, if such attribute exists.
   * @summary Get Resource Attribute
   * @param {ResourceAttributesApiGetResourceAttributeRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceAttributesApi
   */
  getResourceAttribute(requestParameters, options) {
    return ResourceAttributesApiFp(this.configuration).getResourceAttribute(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.attributeId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Lists all the attributes defined on the resource.
   * @summary List Resource Attributes
   * @param {ResourceAttributesApiListResourceAttributesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceAttributesApi
   */
  listResourceAttributes(requestParameters, options) {
    return ResourceAttributesApiFp(this.configuration).listResourceAttributes(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.page,
      requestParameters.perPage,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Partially updates the attribute defined on a resource. Fields that will be provided will be completely overwritten.
   * @summary Update Resource Attribute
   * @param {ResourceAttributesApiUpdateResourceAttributeRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceAttributesApi
   */
  updateResourceAttribute(requestParameters, options) {
    return ResourceAttributesApiFp(this.configuration).updateResourceAttribute(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.attributeId,
      requestParameters.resourceAttributeUpdate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/resource-instances-api.ts
import globalAxios27 from "axios";
var ResourceInstancesApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * Creates a new instance inside the Permit.io system.  If the instance is already created: will return 200 instead of 201, and will return the existing instance object in the response body.
     * @summary Create Resource Instance
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ResourceInstanceCreate} resourceInstanceCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createResourceInstance: async (projId, envId, resourceInstanceCreate, options = {}) => {
      assertParamExists("createResourceInstance", "projId", projId);
      assertParamExists("createResourceInstance", "envId", envId);
      assertParamExists("createResourceInstance", "resourceInstanceCreate", resourceInstanceCreate);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/resource_instances`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        resourceInstanceCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes the instance and all its related data.
     * @summary Delete Resource Instance
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} instanceId Either the unique id of the resource instance, or the URL-friendly key of the resource instance (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteResourceInstance: async (projId, envId, instanceId, options = {}) => {
      assertParamExists("deleteResourceInstance", "projId", projId);
      assertParamExists("deleteResourceInstance", "envId", envId);
      assertParamExists("deleteResourceInstance", "instanceId", instanceId);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/resource_instances/{instance_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"instance_id"}}`, encodeURIComponent(String(instanceId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Gets a instance, if such instance exists. Otherwise returns 404.
     * @summary Get Resource Instance
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} instanceId Either the unique id of the resource instance, or the URL-friendly key of the resource instance (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getResourceInstance: async (projId, envId, instanceId, options = {}) => {
      assertParamExists("getResourceInstance", "projId", projId);
      assertParamExists("getResourceInstance", "envId", envId);
      assertParamExists("getResourceInstance", "instanceId", instanceId);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/resource_instances/{instance_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"instance_id"}}`, encodeURIComponent(String(instanceId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Lists all the resource instances defined within an environment.
     * @summary List Resource Instances
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} [tenant] The tenant key or id to filter by
     * @param {string} [resource] The resource key or id to filter by
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listResourceInstances: async (projId, envId, tenant, resource, page, perPage, options = {}) => {
      assertParamExists("listResourceInstances", "projId", projId);
      assertParamExists("listResourceInstances", "envId", envId);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/resource_instances`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (tenant !== void 0) {
        localVarQueryParameter["tenant"] = tenant;
      }
      if (resource !== void 0) {
        localVarQueryParameter["resource"] = resource;
      }
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Partially updates the instance definition. Fields that will be provided will be completely overwritten.
     * @summary Update Resource Instance
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} instanceId Either the unique id of the resource instance, or the URL-friendly key of the resource instance (i.e: the \&quot;slug\&quot;).
     * @param {ResourceInstanceUpdate} resourceInstanceUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateResourceInstance: async (projId, envId, instanceId, resourceInstanceUpdate, options = {}) => {
      assertParamExists("updateResourceInstance", "projId", projId);
      assertParamExists("updateResourceInstance", "envId", envId);
      assertParamExists("updateResourceInstance", "instanceId", instanceId);
      assertParamExists("updateResourceInstance", "resourceInstanceUpdate", resourceInstanceUpdate);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/resource_instances/{instance_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"instance_id"}}`, encodeURIComponent(String(instanceId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        resourceInstanceUpdate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var ResourceInstancesApiFp = function(configuration) {
  const localVarAxiosParamCreator = ResourceInstancesApiAxiosParamCreator(configuration);
  return {
    /**
     * Creates a new instance inside the Permit.io system.  If the instance is already created: will return 200 instead of 201, and will return the existing instance object in the response body.
     * @summary Create Resource Instance
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ResourceInstanceCreate} resourceInstanceCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createResourceInstance(projId, envId, resourceInstanceCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createResourceInstance(
        projId,
        envId,
        resourceInstanceCreate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios27, BASE_PATH, configuration);
    },
    /**
     * Deletes the instance and all its related data.
     * @summary Delete Resource Instance
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} instanceId Either the unique id of the resource instance, or the URL-friendly key of the resource instance (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteResourceInstance(projId, envId, instanceId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteResourceInstance(
        projId,
        envId,
        instanceId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios27, BASE_PATH, configuration);
    },
    /**
     * Gets a instance, if such instance exists. Otherwise returns 404.
     * @summary Get Resource Instance
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} instanceId Either the unique id of the resource instance, or the URL-friendly key of the resource instance (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getResourceInstance(projId, envId, instanceId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getResourceInstance(
        projId,
        envId,
        instanceId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios27, BASE_PATH, configuration);
    },
    /**
     * Lists all the resource instances defined within an environment.
     * @summary List Resource Instances
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} [tenant] The tenant key or id to filter by
     * @param {string} [resource] The resource key or id to filter by
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listResourceInstances(projId, envId, tenant, resource, page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listResourceInstances(
        projId,
        envId,
        tenant,
        resource,
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios27, BASE_PATH, configuration);
    },
    /**
     * Partially updates the instance definition. Fields that will be provided will be completely overwritten.
     * @summary Update Resource Instance
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} instanceId Either the unique id of the resource instance, or the URL-friendly key of the resource instance (i.e: the \&quot;slug\&quot;).
     * @param {ResourceInstanceUpdate} resourceInstanceUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateResourceInstance(projId, envId, instanceId, resourceInstanceUpdate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateResourceInstance(
        projId,
        envId,
        instanceId,
        resourceInstanceUpdate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios27, BASE_PATH, configuration);
    }
  };
};
var ResourceInstancesApiFactory = function(configuration, basePath, axios) {
  const localVarFp = ResourceInstancesApiFp(configuration);
  return {
    /**
     * Creates a new instance inside the Permit.io system.  If the instance is already created: will return 200 instead of 201, and will return the existing instance object in the response body.
     * @summary Create Resource Instance
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ResourceInstanceCreate} resourceInstanceCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createResourceInstance(projId, envId, resourceInstanceCreate, options) {
      return localVarFp.createResourceInstance(projId, envId, resourceInstanceCreate, options).then((request) => request(axios, basePath));
    },
    /**
     * Deletes the instance and all its related data.
     * @summary Delete Resource Instance
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} instanceId Either the unique id of the resource instance, or the URL-friendly key of the resource instance (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteResourceInstance(projId, envId, instanceId, options) {
      return localVarFp.deleteResourceInstance(projId, envId, instanceId, options).then((request) => request(axios, basePath));
    },
    /**
     * Gets a instance, if such instance exists. Otherwise returns 404.
     * @summary Get Resource Instance
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} instanceId Either the unique id of the resource instance, or the URL-friendly key of the resource instance (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getResourceInstance(projId, envId, instanceId, options) {
      return localVarFp.getResourceInstance(projId, envId, instanceId, options).then((request) => request(axios, basePath));
    },
    /**
     * Lists all the resource instances defined within an environment.
     * @summary List Resource Instances
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} [tenant] The tenant key or id to filter by
     * @param {string} [resource] The resource key or id to filter by
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listResourceInstances(projId, envId, tenant, resource, page, perPage, options) {
      return localVarFp.listResourceInstances(projId, envId, tenant, resource, page, perPage, options).then((request) => request(axios, basePath));
    },
    /**
     * Partially updates the instance definition. Fields that will be provided will be completely overwritten.
     * @summary Update Resource Instance
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} instanceId Either the unique id of the resource instance, or the URL-friendly key of the resource instance (i.e: the \&quot;slug\&quot;).
     * @param {ResourceInstanceUpdate} resourceInstanceUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateResourceInstance(projId, envId, instanceId, resourceInstanceUpdate, options) {
      return localVarFp.updateResourceInstance(projId, envId, instanceId, resourceInstanceUpdate, options).then((request) => request(axios, basePath));
    }
  };
};
var ResourceInstancesApi = class extends BaseAPI {
  /**
   * Creates a new instance inside the Permit.io system.  If the instance is already created: will return 200 instead of 201, and will return the existing instance object in the response body.
   * @summary Create Resource Instance
   * @param {ResourceInstancesApiCreateResourceInstanceRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceInstancesApi
   */
  createResourceInstance(requestParameters, options) {
    return ResourceInstancesApiFp(this.configuration).createResourceInstance(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceInstanceCreate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Deletes the instance and all its related data.
   * @summary Delete Resource Instance
   * @param {ResourceInstancesApiDeleteResourceInstanceRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceInstancesApi
   */
  deleteResourceInstance(requestParameters, options) {
    return ResourceInstancesApiFp(this.configuration).deleteResourceInstance(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.instanceId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Gets a instance, if such instance exists. Otherwise returns 404.
   * @summary Get Resource Instance
   * @param {ResourceInstancesApiGetResourceInstanceRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceInstancesApi
   */
  getResourceInstance(requestParameters, options) {
    return ResourceInstancesApiFp(this.configuration).getResourceInstance(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.instanceId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Lists all the resource instances defined within an environment.
   * @summary List Resource Instances
   * @param {ResourceInstancesApiListResourceInstancesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceInstancesApi
   */
  listResourceInstances(requestParameters, options) {
    return ResourceInstancesApiFp(this.configuration).listResourceInstances(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.tenant,
      requestParameters.resource,
      requestParameters.page,
      requestParameters.perPage,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Partially updates the instance definition. Fields that will be provided will be completely overwritten.
   * @summary Update Resource Instance
   * @param {ResourceInstancesApiUpdateResourceInstanceRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceInstancesApi
   */
  updateResourceInstance(requestParameters, options) {
    return ResourceInstancesApiFp(this.configuration).updateResourceInstance(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.instanceId,
      requestParameters.resourceInstanceUpdate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/resource-relations-api.ts
import globalAxios28 from "axios";
var ResourceRelationsApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * Creates a resource relation to another resource
     * @summary Create Resource Relation
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {RelationCreate} relationCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createResourceRelation: async (projId, envId, resourceId, relationCreate, options = {}) => {
      assertParamExists("createResourceRelation", "projId", projId);
      assertParamExists("createResourceRelation", "envId", envId);
      assertParamExists("createResourceRelation", "resourceId", resourceId);
      assertParamExists("createResourceRelation", "relationCreate", relationCreate);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/relations`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        relationCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes a resource relation
     * @summary Delete Resource Relation
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} relationId Either the unique id of the relation, or the URL-friendly key of the relation (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteResourceRelation: async (projId, envId, resourceId, relationId, options = {}) => {
      assertParamExists("deleteResourceRelation", "projId", projId);
      assertParamExists("deleteResourceRelation", "envId", envId);
      assertParamExists("deleteResourceRelation", "resourceId", resourceId);
      assertParamExists("deleteResourceRelation", "relationId", relationId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/relations/{relation_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId))).replace(`{${"relation_id"}}`, encodeURIComponent(String(relationId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Get a resource relation
     * @summary Get Resource Relation
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} relationId Either the unique id of the relation, or the URL-friendly key of the relation (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getResourceRelation: async (projId, envId, resourceId, relationId, options = {}) => {
      assertParamExists("getResourceRelation", "projId", projId);
      assertParamExists("getResourceRelation", "envId", envId);
      assertParamExists("getResourceRelation", "resourceId", resourceId);
      assertParamExists("getResourceRelation", "relationId", relationId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/relations/{relation_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId))).replace(`{${"relation_id"}}`, encodeURIComponent(String(relationId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Creates a resource relation to another resource
     * @summary List Resource Relations
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listResourceRelations: async (projId, envId, resourceId, page, perPage, options = {}) => {
      assertParamExists("listResourceRelations", "projId", projId);
      assertParamExists("listResourceRelations", "envId", envId);
      assertParamExists("listResourceRelations", "resourceId", resourceId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/relations`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var ResourceRelationsApiFp = function(configuration) {
  const localVarAxiosParamCreator = ResourceRelationsApiAxiosParamCreator(configuration);
  return {
    /**
     * Creates a resource relation to another resource
     * @summary Create Resource Relation
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {RelationCreate} relationCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createResourceRelation(projId, envId, resourceId, relationCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createResourceRelation(
        projId,
        envId,
        resourceId,
        relationCreate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios28, BASE_PATH, configuration);
    },
    /**
     * Deletes a resource relation
     * @summary Delete Resource Relation
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} relationId Either the unique id of the relation, or the URL-friendly key of the relation (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteResourceRelation(projId, envId, resourceId, relationId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteResourceRelation(
        projId,
        envId,
        resourceId,
        relationId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios28, BASE_PATH, configuration);
    },
    /**
     * Get a resource relation
     * @summary Get Resource Relation
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} relationId Either the unique id of the relation, or the URL-friendly key of the relation (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getResourceRelation(projId, envId, resourceId, relationId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getResourceRelation(
        projId,
        envId,
        resourceId,
        relationId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios28, BASE_PATH, configuration);
    },
    /**
     * Creates a resource relation to another resource
     * @summary List Resource Relations
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listResourceRelations(projId, envId, resourceId, page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listResourceRelations(
        projId,
        envId,
        resourceId,
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios28, BASE_PATH, configuration);
    }
  };
};
var ResourceRelationsApiFactory = function(configuration, basePath, axios) {
  const localVarFp = ResourceRelationsApiFp(configuration);
  return {
    /**
     * Creates a resource relation to another resource
     * @summary Create Resource Relation
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {RelationCreate} relationCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createResourceRelation(projId, envId, resourceId, relationCreate, options) {
      return localVarFp.createResourceRelation(projId, envId, resourceId, relationCreate, options).then((request) => request(axios, basePath));
    },
    /**
     * Deletes a resource relation
     * @summary Delete Resource Relation
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} relationId Either the unique id of the relation, or the URL-friendly key of the relation (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteResourceRelation(projId, envId, resourceId, relationId, options) {
      return localVarFp.deleteResourceRelation(projId, envId, resourceId, relationId, options).then((request) => request(axios, basePath));
    },
    /**
     * Get a resource relation
     * @summary Get Resource Relation
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} relationId Either the unique id of the relation, or the URL-friendly key of the relation (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getResourceRelation(projId, envId, resourceId, relationId, options) {
      return localVarFp.getResourceRelation(projId, envId, resourceId, relationId, options).then((request) => request(axios, basePath));
    },
    /**
     * Creates a resource relation to another resource
     * @summary List Resource Relations
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listResourceRelations(projId, envId, resourceId, page, perPage, options) {
      return localVarFp.listResourceRelations(projId, envId, resourceId, page, perPage, options).then((request) => request(axios, basePath));
    }
  };
};
var ResourceRelationsApi = class extends BaseAPI {
  /**
   * Creates a resource relation to another resource
   * @summary Create Resource Relation
   * @param {ResourceRelationsApiCreateResourceRelationRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceRelationsApi
   */
  createResourceRelation(requestParameters, options) {
    return ResourceRelationsApiFp(this.configuration).createResourceRelation(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.relationCreate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Deletes a resource relation
   * @summary Delete Resource Relation
   * @param {ResourceRelationsApiDeleteResourceRelationRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceRelationsApi
   */
  deleteResourceRelation(requestParameters, options) {
    return ResourceRelationsApiFp(this.configuration).deleteResourceRelation(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.relationId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Get a resource relation
   * @summary Get Resource Relation
   * @param {ResourceRelationsApiGetResourceRelationRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceRelationsApi
   */
  getResourceRelation(requestParameters, options) {
    return ResourceRelationsApiFp(this.configuration).getResourceRelation(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.relationId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Creates a resource relation to another resource
   * @summary List Resource Relations
   * @param {ResourceRelationsApiListResourceRelationsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceRelationsApi
   */
  listResourceRelations(requestParameters, options) {
    return ResourceRelationsApiFp(this.configuration).listResourceRelations(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.page,
      requestParameters.perPage,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/resource-roles-api.ts
import globalAxios29 from "axios";
var ResourceRolesApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * Assign permissions to role.  If some of the permissions specified are already assigned, will skip them.
     * @summary Assign Permissions to Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {AddRolePermissions} addRolePermissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    assignPermissionsToResourceRole: async (projId, envId, resourceId, roleId, addRolePermissions, options = {}) => {
      assertParamExists("assignPermissionsToResourceRole", "projId", projId);
      assertParamExists("assignPermissionsToResourceRole", "envId", envId);
      assertParamExists("assignPermissionsToResourceRole", "resourceId", resourceId);
      assertParamExists("assignPermissionsToResourceRole", "roleId", roleId);
      assertParamExists(
        "assignPermissionsToResourceRole",
        "addRolePermissions",
        addRolePermissions
      );
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/roles/{role_id}/permissions`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId))).replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        addRolePermissions,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Creates a new role associated with the resource.
     * @summary Create Resource Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {ResourceRoleCreate} resourceRoleCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createResourceRole: async (projId, envId, resourceId, resourceRoleCreate, options = {}) => {
      assertParamExists("createResourceRole", "projId", projId);
      assertParamExists("createResourceRole", "envId", envId);
      assertParamExists("createResourceRole", "resourceId", resourceId);
      assertParamExists("createResourceRole", "resourceRoleCreate", resourceRoleCreate);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/roles`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        resourceRoleCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes the role and all its related data. This includes any permissions granted to said role.
     * @summary Delete Resource Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteResourceRole: async (projId, envId, resourceId, roleId, options = {}) => {
      assertParamExists("deleteResourceRole", "projId", projId);
      assertParamExists("deleteResourceRole", "envId", envId);
      assertParamExists("deleteResourceRole", "resourceId", resourceId);
      assertParamExists("deleteResourceRole", "roleId", roleId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/roles/{role_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId))).replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Gets a single role defined on the resource, if such role exists.
     * @summary Get Resource Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getResourceRole: async (projId, envId, resourceId, roleId, options = {}) => {
      assertParamExists("getResourceRole", "projId", projId);
      assertParamExists("getResourceRole", "envId", envId);
      assertParamExists("getResourceRole", "resourceId", resourceId);
      assertParamExists("getResourceRole", "roleId", roleId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/roles/{role_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId))).replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Lists all the roles defined on the resource.
     * @summary List Resource Roles
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listResourceRoles: async (projId, envId, resourceId, page, perPage, options = {}) => {
      assertParamExists("listResourceRoles", "projId", projId);
      assertParamExists("listResourceRoles", "envId", envId);
      assertParamExists("listResourceRoles", "resourceId", resourceId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/roles`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Remove permissions from role.  If some of the permissions specified are already unassigned, will skip them.
     * @summary Remove Permissions from Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {RemoveRolePermissions} removeRolePermissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removePermissionsFromResourceRole: async (projId, envId, resourceId, roleId, removeRolePermissions, options = {}) => {
      assertParamExists("removePermissionsFromResourceRole", "projId", projId);
      assertParamExists("removePermissionsFromResourceRole", "envId", envId);
      assertParamExists("removePermissionsFromResourceRole", "resourceId", resourceId);
      assertParamExists("removePermissionsFromResourceRole", "roleId", roleId);
      assertParamExists(
        "removePermissionsFromResourceRole",
        "removeRolePermissions",
        removeRolePermissions
      );
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/roles/{role_id}/permissions`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId))).replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        removeRolePermissions,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Partially updates the role defined on a resource. Fields that will be provided will be completely overwritten.
     * @summary Update Resource Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {ResourceRoleUpdate} resourceRoleUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateResourceRole: async (projId, envId, resourceId, roleId, resourceRoleUpdate, options = {}) => {
      assertParamExists("updateResourceRole", "projId", projId);
      assertParamExists("updateResourceRole", "envId", envId);
      assertParamExists("updateResourceRole", "resourceId", resourceId);
      assertParamExists("updateResourceRole", "roleId", roleId);
      assertParamExists("updateResourceRole", "resourceRoleUpdate", resourceRoleUpdate);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/roles/{role_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId))).replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        resourceRoleUpdate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var ResourceRolesApiFp = function(configuration) {
  const localVarAxiosParamCreator = ResourceRolesApiAxiosParamCreator(configuration);
  return {
    /**
     * Assign permissions to role.  If some of the permissions specified are already assigned, will skip them.
     * @summary Assign Permissions to Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {AddRolePermissions} addRolePermissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async assignPermissionsToResourceRole(projId, envId, resourceId, roleId, addRolePermissions, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.assignPermissionsToResourceRole(
        projId,
        envId,
        resourceId,
        roleId,
        addRolePermissions,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios29, BASE_PATH, configuration);
    },
    /**
     * Creates a new role associated with the resource.
     * @summary Create Resource Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {ResourceRoleCreate} resourceRoleCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createResourceRole(projId, envId, resourceId, resourceRoleCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createResourceRole(
        projId,
        envId,
        resourceId,
        resourceRoleCreate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios29, BASE_PATH, configuration);
    },
    /**
     * Deletes the role and all its related data. This includes any permissions granted to said role.
     * @summary Delete Resource Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteResourceRole(projId, envId, resourceId, roleId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteResourceRole(
        projId,
        envId,
        resourceId,
        roleId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios29, BASE_PATH, configuration);
    },
    /**
     * Gets a single role defined on the resource, if such role exists.
     * @summary Get Resource Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getResourceRole(projId, envId, resourceId, roleId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getResourceRole(
        projId,
        envId,
        resourceId,
        roleId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios29, BASE_PATH, configuration);
    },
    /**
     * Lists all the roles defined on the resource.
     * @summary List Resource Roles
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listResourceRoles(projId, envId, resourceId, page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listResourceRoles(
        projId,
        envId,
        resourceId,
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios29, BASE_PATH, configuration);
    },
    /**
     * Remove permissions from role.  If some of the permissions specified are already unassigned, will skip them.
     * @summary Remove Permissions from Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {RemoveRolePermissions} removeRolePermissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removePermissionsFromResourceRole(projId, envId, resourceId, roleId, removeRolePermissions, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.removePermissionsFromResourceRole(
        projId,
        envId,
        resourceId,
        roleId,
        removeRolePermissions,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios29, BASE_PATH, configuration);
    },
    /**
     * Partially updates the role defined on a resource. Fields that will be provided will be completely overwritten.
     * @summary Update Resource Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {ResourceRoleUpdate} resourceRoleUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateResourceRole(projId, envId, resourceId, roleId, resourceRoleUpdate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateResourceRole(
        projId,
        envId,
        resourceId,
        roleId,
        resourceRoleUpdate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios29, BASE_PATH, configuration);
    }
  };
};
var ResourceRolesApiFactory = function(configuration, basePath, axios) {
  const localVarFp = ResourceRolesApiFp(configuration);
  return {
    /**
     * Assign permissions to role.  If some of the permissions specified are already assigned, will skip them.
     * @summary Assign Permissions to Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {AddRolePermissions} addRolePermissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    assignPermissionsToResourceRole(projId, envId, resourceId, roleId, addRolePermissions, options) {
      return localVarFp.assignPermissionsToResourceRole(
        projId,
        envId,
        resourceId,
        roleId,
        addRolePermissions,
        options
      ).then((request) => request(axios, basePath));
    },
    /**
     * Creates a new role associated with the resource.
     * @summary Create Resource Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {ResourceRoleCreate} resourceRoleCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createResourceRole(projId, envId, resourceId, resourceRoleCreate, options) {
      return localVarFp.createResourceRole(projId, envId, resourceId, resourceRoleCreate, options).then((request) => request(axios, basePath));
    },
    /**
     * Deletes the role and all its related data. This includes any permissions granted to said role.
     * @summary Delete Resource Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteResourceRole(projId, envId, resourceId, roleId, options) {
      return localVarFp.deleteResourceRole(projId, envId, resourceId, roleId, options).then((request) => request(axios, basePath));
    },
    /**
     * Gets a single role defined on the resource, if such role exists.
     * @summary Get Resource Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getResourceRole(projId, envId, resourceId, roleId, options) {
      return localVarFp.getResourceRole(projId, envId, resourceId, roleId, options).then((request) => request(axios, basePath));
    },
    /**
     * Lists all the roles defined on the resource.
     * @summary List Resource Roles
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listResourceRoles(projId, envId, resourceId, page, perPage, options) {
      return localVarFp.listResourceRoles(projId, envId, resourceId, page, perPage, options).then((request) => request(axios, basePath));
    },
    /**
     * Remove permissions from role.  If some of the permissions specified are already unassigned, will skip them.
     * @summary Remove Permissions from Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {RemoveRolePermissions} removeRolePermissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removePermissionsFromResourceRole(projId, envId, resourceId, roleId, removeRolePermissions, options) {
      return localVarFp.removePermissionsFromResourceRole(
        projId,
        envId,
        resourceId,
        roleId,
        removeRolePermissions,
        options
      ).then((request) => request(axios, basePath));
    },
    /**
     * Partially updates the role defined on a resource. Fields that will be provided will be completely overwritten.
     * @summary Update Resource Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {ResourceRoleUpdate} resourceRoleUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateResourceRole(projId, envId, resourceId, roleId, resourceRoleUpdate, options) {
      return localVarFp.updateResourceRole(projId, envId, resourceId, roleId, resourceRoleUpdate, options).then((request) => request(axios, basePath));
    }
  };
};
var ResourceRolesApi = class extends BaseAPI {
  /**
   * Assign permissions to role.  If some of the permissions specified are already assigned, will skip them.
   * @summary Assign Permissions to Role
   * @param {ResourceRolesApiAssignPermissionsToResourceRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceRolesApi
   */
  assignPermissionsToResourceRole(requestParameters, options) {
    return ResourceRolesApiFp(this.configuration).assignPermissionsToResourceRole(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.roleId,
      requestParameters.addRolePermissions,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Creates a new role associated with the resource.
   * @summary Create Resource Role
   * @param {ResourceRolesApiCreateResourceRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceRolesApi
   */
  createResourceRole(requestParameters, options) {
    return ResourceRolesApiFp(this.configuration).createResourceRole(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.resourceRoleCreate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Deletes the role and all its related data. This includes any permissions granted to said role.
   * @summary Delete Resource Role
   * @param {ResourceRolesApiDeleteResourceRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceRolesApi
   */
  deleteResourceRole(requestParameters, options) {
    return ResourceRolesApiFp(this.configuration).deleteResourceRole(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.roleId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Gets a single role defined on the resource, if such role exists.
   * @summary Get Resource Role
   * @param {ResourceRolesApiGetResourceRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceRolesApi
   */
  getResourceRole(requestParameters, options) {
    return ResourceRolesApiFp(this.configuration).getResourceRole(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.roleId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Lists all the roles defined on the resource.
   * @summary List Resource Roles
   * @param {ResourceRolesApiListResourceRolesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceRolesApi
   */
  listResourceRoles(requestParameters, options) {
    return ResourceRolesApiFp(this.configuration).listResourceRoles(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.page,
      requestParameters.perPage,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Remove permissions from role.  If some of the permissions specified are already unassigned, will skip them.
   * @summary Remove Permissions from Role
   * @param {ResourceRolesApiRemovePermissionsFromResourceRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceRolesApi
   */
  removePermissionsFromResourceRole(requestParameters, options) {
    return ResourceRolesApiFp(this.configuration).removePermissionsFromResourceRole(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.roleId,
      requestParameters.removeRolePermissions,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Partially updates the role defined on a resource. Fields that will be provided will be completely overwritten.
   * @summary Update Resource Role
   * @param {ResourceRolesApiUpdateResourceRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceRolesApi
   */
  updateResourceRole(requestParameters, options) {
    return ResourceRolesApiFp(this.configuration).updateResourceRole(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.roleId,
      requestParameters.resourceRoleUpdate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/resources-api.ts
import globalAxios30 from "axios";
var ResourcesApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * Creates a new resource (a type of object you may protect with permissions).
     * @summary Create Resource
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ResourceCreate} resourceCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createResource: async (projId, envId, resourceCreate, options = {}) => {
      assertParamExists("createResource", "projId", projId);
      assertParamExists("createResource", "envId", envId);
      assertParamExists("createResource", "resourceCreate", resourceCreate);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        resourceCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes the resource and all its related data.
     * @summary Delete Resource
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteResource: async (projId, envId, resourceId, options = {}) => {
      assertParamExists("deleteResource", "projId", projId);
      assertParamExists("deleteResource", "envId", envId);
      assertParamExists("deleteResource", "resourceId", resourceId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Gets a single resource, if such resource exists.
     * @summary Get Resource
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getResource: async (projId, envId, resourceId, options = {}) => {
      assertParamExists("getResource", "projId", projId);
      assertParamExists("getResource", "envId", envId);
      assertParamExists("getResource", "resourceId", resourceId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Lists all the resources defined in your schema.
     * @summary List Resources
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {boolean} [includeBuiltIn] Whether to include or exclude built-in resources, default is False
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {includeTotalCount} [includeTotalCount] Include the total count of resources in the response, default is False
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listResources: async (projId, envId, includeBuiltIn, page, perPage, includeTotalCount, options = {}) => {
      assertParamExists("listResources", "projId", projId);
      assertParamExists("listResources", "envId", envId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (includeBuiltIn !== void 0) {
        localVarQueryParameter["include_built_in"] = includeBuiltIn;
      }
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      if (includeTotalCount !== void 0) {
        localVarQueryParameter["include_total_count"] = includeTotalCount;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Completely replaces the resource definition.  - If the resource key is changed, all role and permissions assignments for the the resource will be revoked. - If the resource key is unchanged, but some actions are removed or renamed from the resource definition, role and permissions assignments for these actions will be revoked.  TODO: we need to decide if we are auto-revoking, or if we are rejecting the PUT completely while there are permissions that can be affected.
     * @summary Replace Resource
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {ResourceReplace} resourceReplace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    replaceResource: async (projId, envId, resourceId, resourceReplace, options = {}) => {
      assertParamExists("replaceResource", "projId", projId);
      assertParamExists("replaceResource", "envId", envId);
      assertParamExists("replaceResource", "resourceId", resourceId);
      assertParamExists("replaceResource", "resourceReplace", resourceReplace);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        resourceReplace,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Partially updates the resource definition. Fields that will be provided will be completely overwritten.
     * @summary Update Resource
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {ResourceUpdate} resourceUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateResource: async (projId, envId, resourceId, resourceUpdate, options = {}) => {
      assertParamExists("updateResource", "projId", projId);
      assertParamExists("updateResource", "envId", envId);
      assertParamExists("updateResource", "resourceId", resourceId);
      assertParamExists("updateResource", "resourceUpdate", resourceUpdate);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        resourceUpdate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var ResourcesApiFp = function(configuration) {
  const localVarAxiosParamCreator = ResourcesApiAxiosParamCreator(configuration);
  return {
    /**
     * Creates a new resource (a type of object you may protect with permissions).
     * @summary Create Resource
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ResourceCreate} resourceCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createResource(projId, envId, resourceCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createResource(
        projId,
        envId,
        resourceCreate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios30, BASE_PATH, configuration);
    },
    /**
     * Deletes the resource and all its related data.
     * @summary Delete Resource
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteResource(projId, envId, resourceId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteResource(
        projId,
        envId,
        resourceId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios30, BASE_PATH, configuration);
    },
    /**
     * Gets a single resource, if such resource exists.
     * @summary Get Resource
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getResource(projId, envId, resourceId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getResource(
        projId,
        envId,
        resourceId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios30, BASE_PATH, configuration);
    },
    /**
     * Lists all the resources defined in your schema.
     * @summary List Resources
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {boolean} [includeBuiltIn] Whether to include or exclude built-in resources, default is False
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {includeTotalCount} [includeTotalCount] Include the total count of resources in the response, default is False
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listResources(projId, envId, includeBuiltIn, page, perPage, includeTotalCount, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listResources(
        projId,
        envId,
        includeBuiltIn,
        page,
        perPage,
        includeTotalCount,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios30, BASE_PATH, configuration);
    },
    /**
     * Completely replaces the resource definition.  - If the resource key is changed, all role and permissions assignments for the the resource will be revoked. - If the resource key is unchanged, but some actions are removed or renamed from the resource definition, role and permissions assignments for these actions will be revoked.  TODO: we need to decide if we are auto-revoking, or if we are rejecting the PUT completely while there are permissions that can be affected.
     * @summary Replace Resource
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {ResourceReplace} resourceReplace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async replaceResource(projId, envId, resourceId, resourceReplace, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.replaceResource(
        projId,
        envId,
        resourceId,
        resourceReplace,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios30, BASE_PATH, configuration);
    },
    /**
     * Partially updates the resource definition. Fields that will be provided will be completely overwritten.
     * @summary Update Resource
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {ResourceUpdate} resourceUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateResource(projId, envId, resourceId, resourceUpdate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateResource(
        projId,
        envId,
        resourceId,
        resourceUpdate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios30, BASE_PATH, configuration);
    }
  };
};
var ResourcesApiFactory = function(configuration, basePath, axios) {
  const localVarFp = ResourcesApiFp(configuration);
  return {
    /**
     * Creates a new resource (a type of object you may protect with permissions).
     * @summary Create Resource
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ResourceCreate} resourceCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createResource(projId, envId, resourceCreate, options) {
      return localVarFp.createResource(projId, envId, resourceCreate, options).then((request) => request(axios, basePath));
    },
    /**
     * Deletes the resource and all its related data.
     * @summary Delete Resource
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteResource(projId, envId, resourceId, options) {
      return localVarFp.deleteResource(projId, envId, resourceId, options).then((request) => request(axios, basePath));
    },
    /**
     * Gets a single resource, if such resource exists.
     * @summary Get Resource
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getResource(projId, envId, resourceId, options) {
      return localVarFp.getResource(projId, envId, resourceId, options).then((request) => request(axios, basePath));
    },
    /**
     * Lists all the resources defined in your schema.
     * @summary List Resources
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {boolean} [includeBuiltIn] Whether to include or exclude built-in resources, default is False
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {includeTotalCount} [includeTotalCount] Include the total count of resources in the response, default is False
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listResources(projId, envId, includeBuiltIn, page, perPage, includeTotalCount, options) {
      return localVarFp.listResources(projId, envId, includeBuiltIn, page, perPage, includeTotalCount, options).then((request) => request(axios, basePath));
    },
    /**
     * Completely replaces the resource definition.  - If the resource key is changed, all role and permissions assignments for the the resource will be revoked. - If the resource key is unchanged, but some actions are removed or renamed from the resource definition, role and permissions assignments for these actions will be revoked.  TODO: we need to decide if we are auto-revoking, or if we are rejecting the PUT completely while there are permissions that can be affected.
     * @summary Replace Resource
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {ResourceReplace} resourceReplace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    replaceResource(projId, envId, resourceId, resourceReplace, options) {
      return localVarFp.replaceResource(projId, envId, resourceId, resourceReplace, options).then((request) => request(axios, basePath));
    },
    /**
     * Partially updates the resource definition. Fields that will be provided will be completely overwritten.
     * @summary Update Resource
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {ResourceUpdate} resourceUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateResource(projId, envId, resourceId, resourceUpdate, options) {
      return localVarFp.updateResource(projId, envId, resourceId, resourceUpdate, options).then((request) => request(axios, basePath));
    }
  };
};
var ResourcesApi = class extends BaseAPI {
  /**
   * Creates a new resource (a type of object you may protect with permissions).
   * @summary Create Resource
   * @param {ResourcesApiCreateResourceRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  createResource(requestParameters, options) {
    return ResourcesApiFp(this.configuration).createResource(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceCreate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Deletes the resource and all its related data.
   * @summary Delete Resource
   * @param {ResourcesApiDeleteResourceRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  deleteResource(requestParameters, options) {
    return ResourcesApiFp(this.configuration).deleteResource(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Gets a single resource, if such resource exists.
   * @summary Get Resource
   * @param {ResourcesApiGetResourceRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  getResource(requestParameters, options) {
    return ResourcesApiFp(this.configuration).getResource(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Lists all the resources defined in your schema.
   * @summary List Resources
   * @param {ResourcesApiListResourcesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  listResources(requestParameters, options) {
    return ResourcesApiFp(this.configuration).listResources(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.includeBuiltIn,
      requestParameters.page,
      requestParameters.perPage,
      requestParameters.includeTotalCount,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Completely replaces the resource definition.  - If the resource key is changed, all role and permissions assignments for the the resource will be revoked. - If the resource key is unchanged, but some actions are removed or renamed from the resource definition, role and permissions assignments for these actions will be revoked.  TODO: we need to decide if we are auto-revoking, or if we are rejecting the PUT completely while there are permissions that can be affected.
   * @summary Replace Resource
   * @param {ResourcesApiReplaceResourceRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  replaceResource(requestParameters, options) {
    return ResourcesApiFp(this.configuration).replaceResource(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.resourceReplace,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Partially updates the resource definition. Fields that will be provided will be completely overwritten.
   * @summary Update Resource
   * @param {ResourcesApiUpdateResourceRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  updateResource(requestParameters, options) {
    return ResourcesApiFp(this.configuration).updateResource(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.resourceUpdate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/role-assignments-api.ts
import globalAxios31 from "axios";
var RoleAssignmentsApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * Assigns a role to a user within a tenant.  The tenant defines the scope of the assignment. In other words, the role is effective only within the tenant.
     * @summary Assign Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {RoleAssignmentCreate} roleAssignmentCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    assignRole: async (projId, envId, roleAssignmentCreate, options = {}) => {
      assertParamExists("assignRole", "projId", projId);
      assertParamExists("assignRole", "envId", envId);
      assertParamExists("assignRole", "roleAssignmentCreate", roleAssignmentCreate);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/role_assignments`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        roleAssignmentCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Bulk Assign Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {Array<RoleAssignmentCreate>} roleAssignmentCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkAssignRole: async (projId, envId, roleAssignmentCreate, options = {}) => {
      assertParamExists("bulkAssignRole", "projId", projId);
      assertParamExists("bulkAssignRole", "envId", envId);
      assertParamExists("bulkAssignRole", "roleAssignmentCreate", roleAssignmentCreate);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/role_assignments/bulk`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        roleAssignmentCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Bulk Unassign Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {Array<RoleAssignmentRemove>} roleAssignmentRemove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkUnassignRole: async (projId, envId, roleAssignmentRemove, options = {}) => {
      assertParamExists("bulkUnassignRole", "projId", projId);
      assertParamExists("bulkUnassignRole", "envId", envId);
      assertParamExists("bulkUnassignRole", "roleAssignmentRemove", roleAssignmentRemove);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/role_assignments/bulk`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        roleAssignmentRemove,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Lists the role assignments defined within an environment.  - If the `user` filter is present, will only return the role assignments of that user (supports multiple). - If the `tenant` filter is present, will only return the role assignments in that tenant (supports multiple). - If the `role` filter is present, will only return role assignments that are granting that role (supports multiple). - If the `resource` filter is present, will only return role assignments for resource instances of that resource type. - If the `resource_instance` filter is present, will only return role assignments for that resource instance.  Providing both `tenant` and `resource_instance` filters will only return role assignments if the resource instance is in that tenant. If multiple tenants are received, the last tenant will be compared with the resource instance.
     * @summary List Role Assignments
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} [user] optional user(s) filter, will only return role assignments granted to this user(s).
     * @param {string} [role] optional role(s) filter, will only return role assignments granting this role(s).
     * @param {string} [tenant] optional tenant(s) filter, will only return role assignments granted in that tenant(s).
     * @param {string} [resource] optional resource **type** filter, will only return role assignments granted on that resource type.
     * @param {string} [resourceInstance] optional resource instance filter, will only return role assignments granted on that resource instance.
     * @param {boolean} [detailed] Whether to return full details about the user, tenant and role
     * @param {boolean} [includeTotalCount] If true, returns the list of role assignments and the total count.
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listRoleAssignments: async (projId, envId, user, role, tenant, resource, resourceInstance, detailed, includeTotalCount, page, perPage, options = {}) => {
      assertParamExists("listRoleAssignments", "projId", projId);
      assertParamExists("listRoleAssignments", "envId", envId);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/role_assignments`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (user !== void 0) {
        localVarQueryParameter["user"] = user;
      }
      if (role !== void 0) {
        localVarQueryParameter["role"] = role;
      }
      if (tenant !== void 0) {
        localVarQueryParameter["tenant"] = tenant;
      }
      if (resource !== void 0) {
        localVarQueryParameter["resource"] = resource;
      }
      if (resourceInstance !== void 0) {
        localVarQueryParameter["resource_instance"] = resourceInstance;
      }
      if (detailed !== void 0) {
        localVarQueryParameter["detailed"] = detailed;
      }
      if (includeTotalCount !== void 0) {
        localVarQueryParameter["include_total_count"] = includeTotalCount;
      }
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Unassigns a user role within a tenant.  The tenant defines the scope of the assignment. In other words, the role is effective only within the tenant.  If the role is not actually assigned, will return 404.
     * @summary Unassign Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {RoleAssignmentRemove} roleAssignmentRemove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unassignRole: async (projId, envId, roleAssignmentRemove, options = {}) => {
      assertParamExists("unassignRole", "projId", projId);
      assertParamExists("unassignRole", "envId", envId);
      assertParamExists("unassignRole", "roleAssignmentRemove", roleAssignmentRemove);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/role_assignments`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        roleAssignmentRemove,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var RoleAssignmentsApiFp = function(configuration) {
  const localVarAxiosParamCreator = RoleAssignmentsApiAxiosParamCreator(configuration);
  return {
    /**
     * Assigns a role to a user within a tenant.  The tenant defines the scope of the assignment. In other words, the role is effective only within the tenant.
     * @summary Assign Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {RoleAssignmentCreate} roleAssignmentCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async assignRole(projId, envId, roleAssignmentCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.assignRole(
        projId,
        envId,
        roleAssignmentCreate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios31, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Bulk Assign Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {Array<RoleAssignmentCreate>} roleAssignmentCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bulkAssignRole(projId, envId, roleAssignmentCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.bulkAssignRole(
        projId,
        envId,
        roleAssignmentCreate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios31, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Bulk Unassign Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {Array<RoleAssignmentRemove>} roleAssignmentRemove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bulkUnassignRole(projId, envId, roleAssignmentRemove, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.bulkUnassignRole(
        projId,
        envId,
        roleAssignmentRemove,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios31, BASE_PATH, configuration);
    },
    /**
     * Lists the role assignments defined within an environment.  - If the `user` filter is present, will only return the role assignments of that user (supports multiple). - If the `tenant` filter is present, will only return the role assignments in that tenant (supports multiple). - If the `role` filter is present, will only return role assignments that are granting that role (supports multiple). - If the `resource` filter is present, will only return role assignments for resource instances of that resource type. - If the `resource_instance` filter is present, will only return role assignments for that resource instance.  Providing both `tenant` and `resource_instance` filters will only return role assignments if the resource instance is in that tenant. If multiple tenants are received, the last tenant will be compared with the resource instance.
     * @summary List Role Assignments
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} [user] optional user(s) filter, will only return role assignments granted to this user(s).
     * @param {string} [role] optional role(s) filter, will only return role assignments granting this role(s).
     * @param {string} [tenant] optional tenant(s) filter, will only return role assignments granted in that tenant(s).
     * @param {string} [resource] optional resource **type** filter, will only return role assignments granted on that resource type.
     * @param {string} [resourceInstance] optional resource instance filter, will only return role assignments granted on that resource instance.
     * @param {boolean} [detailed] Whether to return full details about the user, tenant and role
     * @param {boolean} [includeTotalCount] If true, returns the list of role assignments and the total count.
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listRoleAssignments(projId, envId, user, role, tenant, resource, resourceInstance, detailed, includeTotalCount, page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listRoleAssignments(
        projId,
        envId,
        user,
        role,
        tenant,
        resource,
        resourceInstance,
        detailed,
        includeTotalCount,
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios31, BASE_PATH, configuration);
    },
    /**
     * Unassigns a user role within a tenant.  The tenant defines the scope of the assignment. In other words, the role is effective only within the tenant.  If the role is not actually assigned, will return 404.
     * @summary Unassign Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {RoleAssignmentRemove} roleAssignmentRemove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async unassignRole(projId, envId, roleAssignmentRemove, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.unassignRole(
        projId,
        envId,
        roleAssignmentRemove,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios31, BASE_PATH, configuration);
    }
  };
};
var RoleAssignmentsApiFactory = function(configuration, basePath, axios) {
  const localVarFp = RoleAssignmentsApiFp(configuration);
  return {
    /**
     * Assigns a role to a user within a tenant.  The tenant defines the scope of the assignment. In other words, the role is effective only within the tenant.
     * @summary Assign Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {RoleAssignmentCreate} roleAssignmentCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    assignRole(projId, envId, roleAssignmentCreate, options) {
      return localVarFp.assignRole(projId, envId, roleAssignmentCreate, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Bulk Assign Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {Array<RoleAssignmentCreate>} roleAssignmentCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkAssignRole(projId, envId, roleAssignmentCreate, options) {
      return localVarFp.bulkAssignRole(projId, envId, roleAssignmentCreate, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Bulk Unassign Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {Array<RoleAssignmentRemove>} roleAssignmentRemove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkUnassignRole(projId, envId, roleAssignmentRemove, options) {
      return localVarFp.bulkUnassignRole(projId, envId, roleAssignmentRemove, options).then((request) => request(axios, basePath));
    },
    /**
     * Lists the role assignments defined within an environment.  - If the `user` filter is present, will only return the role assignments of that user (supports multiple). - If the `tenant` filter is present, will only return the role assignments in that tenant (supports multiple). - If the `role` filter is present, will only return role assignments that are granting that role (supports multiple). - If the `resource` filter is present, will only return role assignments for resource instances of that resource type. - If the `resource_instance` filter is present, will only return role assignments for that resource instance.  Providing both `tenant` and `resource_instance` filters will only return role assignments if the resource instance is in that tenant. If multiple tenants are received, the last tenant will be compared with the resource instance.
     * @summary List Role Assignments
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} [user] optional user(s) filter, will only return role assignments granted to this user(s).
     * @param {string} [role] optional role(s) filter, will only return role assignments granting this role(s).
     * @param {string} [tenant] optional tenant(s) filter, will only return role assignments granted in that tenant(s).
     * @param {string} [resource] optional resource **type** filter, will only return role assignments granted on that resource type.
     * @param {string} [resourceInstance] optional resource instance filter, will only return role assignments granted on that resource instance.
     * @param {boolean} [detailed] Whether to return full details about the user, tenant and role
     * @param {boolean} [includeTotalCount] If true, returns the list of role assignments and the total count.
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listRoleAssignments(projId, envId, user, role, tenant, resource, resourceInstance, detailed, includeTotalCount, page, perPage, options) {
      return localVarFp.listRoleAssignments(
        projId,
        envId,
        user,
        role,
        tenant,
        resource,
        resourceInstance,
        detailed,
        includeTotalCount,
        page,
        perPage,
        options
      ).then((request) => request(axios, basePath));
    },
    /**
     * Unassigns a user role within a tenant.  The tenant defines the scope of the assignment. In other words, the role is effective only within the tenant.  If the role is not actually assigned, will return 404.
     * @summary Unassign Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {RoleAssignmentRemove} roleAssignmentRemove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unassignRole(projId, envId, roleAssignmentRemove, options) {
      return localVarFp.unassignRole(projId, envId, roleAssignmentRemove, options).then((request) => request(axios, basePath));
    }
  };
};
var RoleAssignmentsApi = class extends BaseAPI {
  /**
   * Assigns a role to a user within a tenant.  The tenant defines the scope of the assignment. In other words, the role is effective only within the tenant.
   * @summary Assign Role
   * @param {RoleAssignmentsApiAssignRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RoleAssignmentsApi
   */
  assignRole(requestParameters, options) {
    return RoleAssignmentsApiFp(this.configuration).assignRole(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.roleAssignmentCreate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Bulk Assign Role
   * @param {RoleAssignmentsApiBulkAssignRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RoleAssignmentsApi
   */
  bulkAssignRole(requestParameters, options) {
    return RoleAssignmentsApiFp(this.configuration).bulkAssignRole(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.roleAssignmentCreate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Bulk Unassign Role
   * @param {RoleAssignmentsApiBulkUnassignRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RoleAssignmentsApi
   */
  bulkUnassignRole(requestParameters, options) {
    return RoleAssignmentsApiFp(this.configuration).bulkUnassignRole(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.roleAssignmentRemove,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Lists the role assignments defined within an environment.  - If the `user` filter is present, will only return the role assignments of that user (supports multiple). - If the `tenant` filter is present, will only return the role assignments in that tenant (supports multiple). - If the `role` filter is present, will only return role assignments that are granting that role (supports multiple). - If the `resource` filter is present, will only return role assignments for resource instances of that resource type. - If the `resource_instance` filter is present, will only return role assignments for that resource instance.  Providing both `tenant` and `resource_instance` filters will only return role assignments if the resource instance is in that tenant. If multiple tenants are received, the last tenant will be compared with the resource instance.
   * @summary List Role Assignments
   * @param {RoleAssignmentsApiListRoleAssignmentsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RoleAssignmentsApi
   */
  listRoleAssignments(requestParameters, options) {
    return RoleAssignmentsApiFp(this.configuration).listRoleAssignments(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.user,
      requestParameters.role,
      requestParameters.tenant,
      requestParameters.resource,
      requestParameters.resourceInstance,
      requestParameters.detailed,
      requestParameters.includeTotalCount,
      requestParameters.page,
      requestParameters.perPage,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Unassigns a user role within a tenant.  The tenant defines the scope of the assignment. In other words, the role is effective only within the tenant.  If the role is not actually assigned, will return 404.
   * @summary Unassign Role
   * @param {RoleAssignmentsApiUnassignRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RoleAssignmentsApi
   */
  unassignRole(requestParameters, options) {
    return RoleAssignmentsApiFp(this.configuration).unassignRole(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.roleAssignmentRemove,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/roles-api.ts
import globalAxios32 from "axios";
var RolesApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * This endpoint is part of the role hierarchy feature.  Makes role with id `role_id` extend the role with id `parent_role_id`. In other words, `role_id` will automatically be assigned any permissions that are granted to `parent_role_id`.  We can say the `role_id` **extends** `parent_role_id` or **inherits** from `parent_role_id`.  If `role_id` is already an ancestor of `parent_role_id`, the request will fail with HTTP 400 to prevent a cycle in the role hierarchy.
     * @summary Add Parent Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {string} parentRoleId Either the unique id of the parent role, or the URL-friendly key of the parent role (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addParentRole: async (projId, envId, roleId, parentRoleId, options = {}) => {
      assertParamExists("addParentRole", "projId", projId);
      assertParamExists("addParentRole", "envId", envId);
      assertParamExists("addParentRole", "roleId", roleId);
      assertParamExists("addParentRole", "parentRoleId", parentRoleId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/roles/{role_id}/parents/{parent_role_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"role_id"}}`, encodeURIComponent(String(roleId))).replace(`{${"parent_role_id"}}`, encodeURIComponent(String(parentRoleId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Assign permissions to role.  If some of the permissions specified are already assigned, will skip them.
     * @summary Assign Permissions To Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {AddRolePermissions} addRolePermissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    assignPermissionsToRole: async (projId, envId, roleId, addRolePermissions, options = {}) => {
      assertParamExists("assignPermissionsToRole", "projId", projId);
      assertParamExists("assignPermissionsToRole", "envId", envId);
      assertParamExists("assignPermissionsToRole", "roleId", roleId);
      assertParamExists("assignPermissionsToRole", "addRolePermissions", addRolePermissions);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/roles/{role_id}/permissions`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        addRolePermissions,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Creates a new tenant role.
     * @summary Create Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {RoleCreate} roleCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRole: async (projId, envId, roleCreate, options = {}) => {
      assertParamExists("createRole", "projId", projId);
      assertParamExists("createRole", "envId", envId);
      assertParamExists("createRole", "roleCreate", roleCreate);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/roles`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        roleCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes a tenant role and all its related data. This includes any permissions granted to said role.
     * @summary Delete Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRole: async (projId, envId, roleId, options = {}) => {
      assertParamExists("deleteRole", "projId", projId);
      assertParamExists("deleteRole", "envId", envId);
      assertParamExists("deleteRole", "roleId", roleId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/roles/{role_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Gets a single tenant role, if such role exists.
     * @summary Get Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRole: async (projId, envId, roleId, options = {}) => {
      assertParamExists("getRole", "projId", projId);
      assertParamExists("getRole", "envId", envId);
      assertParamExists("getRole", "roleId", roleId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/roles/{role_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Lists all tenant roles.
     * @summary List Roles
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {boolean} [includeTotalCount] Include total count in response (default to false)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listRoles: async (projId, envId, page, perPage, includeTotalCount, options = {}) => {
      assertParamExists("listRoles", "projId", projId);
      assertParamExists("listRoles", "envId", envId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/roles`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      if (includeTotalCount !== void 0) {
        localVarQueryParameter["include_total_count"] = includeTotalCount;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * This endpoint is part of the role hierarchy feature.  Removes `parent_role_id` from the list of parent roles of role with id `role_id`. In other words, `role_id` will no longer be automatically assigned permissions that are granted to `parent_role_id`.  We can say the `role_id` **not longer extends** `parent_role_id` or **no longer inherits** from `parent_role_id`.
     * @summary Remove Parent Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {string} parentRoleId Either the unique id of the parent role, or the URL-friendly key of the parent role (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeParentRole: async (projId, envId, roleId, parentRoleId, options = {}) => {
      assertParamExists("removeParentRole", "projId", projId);
      assertParamExists("removeParentRole", "envId", envId);
      assertParamExists("removeParentRole", "roleId", roleId);
      assertParamExists("removeParentRole", "parentRoleId", parentRoleId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/roles/{role_id}/parents/{parent_role_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"role_id"}}`, encodeURIComponent(String(roleId))).replace(`{${"parent_role_id"}}`, encodeURIComponent(String(parentRoleId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Remove permissions from role.  If some of the permissions specified are already unassigned, will skip them.
     * @summary Remove Permissions From Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {RemoveRolePermissions} removeRolePermissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removePermissionsFromRole: async (projId, envId, roleId, removeRolePermissions, options = {}) => {
      assertParamExists("removePermissionsFromRole", "projId", projId);
      assertParamExists("removePermissionsFromRole", "envId", envId);
      assertParamExists("removePermissionsFromRole", "roleId", roleId);
      assertParamExists(
        "removePermissionsFromRole",
        "removeRolePermissions",
        removeRolePermissions
      );
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/roles/{role_id}/permissions`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        removeRolePermissions,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Partially updates a tenant role. Fields that will be provided will be completely overwritten.
     * @summary Update Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {RoleUpdate} roleUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRole: async (projId, envId, roleId, roleUpdate, options = {}) => {
      assertParamExists("updateRole", "projId", projId);
      assertParamExists("updateRole", "envId", envId);
      assertParamExists("updateRole", "roleId", roleId);
      assertParamExists("updateRole", "roleUpdate", roleUpdate);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/roles/{role_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        roleUpdate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var RolesApiFp = function(configuration) {
  const localVarAxiosParamCreator = RolesApiAxiosParamCreator(configuration);
  return {
    /**
     * This endpoint is part of the role hierarchy feature.  Makes role with id `role_id` extend the role with id `parent_role_id`. In other words, `role_id` will automatically be assigned any permissions that are granted to `parent_role_id`.  We can say the `role_id` **extends** `parent_role_id` or **inherits** from `parent_role_id`.  If `role_id` is already an ancestor of `parent_role_id`, the request will fail with HTTP 400 to prevent a cycle in the role hierarchy.
     * @summary Add Parent Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {string} parentRoleId Either the unique id of the parent role, or the URL-friendly key of the parent role (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addParentRole(projId, envId, roleId, parentRoleId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addParentRole(
        projId,
        envId,
        roleId,
        parentRoleId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios32, BASE_PATH, configuration);
    },
    /**
     * Assign permissions to role.  If some of the permissions specified are already assigned, will skip them.
     * @summary Assign Permissions To Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {AddRolePermissions} addRolePermissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async assignPermissionsToRole(projId, envId, roleId, addRolePermissions, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.assignPermissionsToRole(
        projId,
        envId,
        roleId,
        addRolePermissions,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios32, BASE_PATH, configuration);
    },
    /**
     * Creates a new tenant role.
     * @summary Create Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {RoleCreate} roleCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createRole(projId, envId, roleCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createRole(
        projId,
        envId,
        roleCreate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios32, BASE_PATH, configuration);
    },
    /**
     * Deletes a tenant role and all its related data. This includes any permissions granted to said role.
     * @summary Delete Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteRole(projId, envId, roleId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRole(
        projId,
        envId,
        roleId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios32, BASE_PATH, configuration);
    },
    /**
     * Gets a single tenant role, if such role exists.
     * @summary Get Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRole(projId, envId, roleId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getRole(
        projId,
        envId,
        roleId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios32, BASE_PATH, configuration);
    },
    /**
     * Lists all tenant roles.
     * @summary List Roles
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {boolean} [includeTotalCount] Include total count in response (default to false)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listRoles(projId, envId, page, perPage, includeTotalCount, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listRoles(
        projId,
        envId,
        page,
        perPage,
        includeTotalCount,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios32, BASE_PATH, configuration);
    },
    /**
     * This endpoint is part of the role hierarchy feature.  Removes `parent_role_id` from the list of parent roles of role with id `role_id`. In other words, `role_id` will no longer be automatically assigned permissions that are granted to `parent_role_id`.  We can say the `role_id` **not longer extends** `parent_role_id` or **no longer inherits** from `parent_role_id`.
     * @summary Remove Parent Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {string} parentRoleId Either the unique id of the parent role, or the URL-friendly key of the parent role (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removeParentRole(projId, envId, roleId, parentRoleId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.removeParentRole(
        projId,
        envId,
        roleId,
        parentRoleId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios32, BASE_PATH, configuration);
    },
    /**
     * Remove permissions from role.  If some of the permissions specified are already unassigned, will skip them.
     * @summary Remove Permissions From Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {RemoveRolePermissions} removeRolePermissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removePermissionsFromRole(projId, envId, roleId, removeRolePermissions, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.removePermissionsFromRole(
        projId,
        envId,
        roleId,
        removeRolePermissions,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios32, BASE_PATH, configuration);
    },
    /**
     * Partially updates a tenant role. Fields that will be provided will be completely overwritten.
     * @summary Update Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {RoleUpdate} roleUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateRole(projId, envId, roleId, roleUpdate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateRole(
        projId,
        envId,
        roleId,
        roleUpdate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios32, BASE_PATH, configuration);
    }
  };
};
var RolesApiFactory = function(configuration, basePath, axios) {
  const localVarFp = RolesApiFp(configuration);
  return {
    /**
     * This endpoint is part of the role hierarchy feature.  Makes role with id `role_id` extend the role with id `parent_role_id`. In other words, `role_id` will automatically be assigned any permissions that are granted to `parent_role_id`.  We can say the `role_id` **extends** `parent_role_id` or **inherits** from `parent_role_id`.  If `role_id` is already an ancestor of `parent_role_id`, the request will fail with HTTP 400 to prevent a cycle in the role hierarchy.
     * @summary Add Parent Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {string} parentRoleId Either the unique id of the parent role, or the URL-friendly key of the parent role (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addParentRole(projId, envId, roleId, parentRoleId, options) {
      return localVarFp.addParentRole(projId, envId, roleId, parentRoleId, options).then((request) => request(axios, basePath));
    },
    /**
     * Assign permissions to role.  If some of the permissions specified are already assigned, will skip them.
     * @summary Assign Permissions To Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {AddRolePermissions} addRolePermissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    assignPermissionsToRole(projId, envId, roleId, addRolePermissions, options) {
      return localVarFp.assignPermissionsToRole(projId, envId, roleId, addRolePermissions, options).then((request) => request(axios, basePath));
    },
    /**
     * Creates a new tenant role.
     * @summary Create Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {RoleCreate} roleCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRole(projId, envId, roleCreate, options) {
      return localVarFp.createRole(projId, envId, roleCreate, options).then((request) => request(axios, basePath));
    },
    /**
     * Deletes a tenant role and all its related data. This includes any permissions granted to said role.
     * @summary Delete Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRole(projId, envId, roleId, options) {
      return localVarFp.deleteRole(projId, envId, roleId, options).then((request) => request(axios, basePath));
    },
    /**
     * Gets a single tenant role, if such role exists.
     * @summary Get Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRole(projId, envId, roleId, options) {
      return localVarFp.getRole(projId, envId, roleId, options).then((request) => request(axios, basePath));
    },
    /**
     * Lists all tenant roles.
     * @summary List Roles
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listRoles(projId, envId, page, perPage, options) {
      return localVarFp.listRoles(projId, envId, page, perPage, options).then((request) => request(axios, basePath));
    },
    /**
     * This endpoint is part of the role hierarchy feature.  Removes `parent_role_id` from the list of parent roles of role with id `role_id`. In other words, `role_id` will no longer be automatically assigned permissions that are granted to `parent_role_id`.  We can say the `role_id` **not longer extends** `parent_role_id` or **no longer inherits** from `parent_role_id`.
     * @summary Remove Parent Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {string} parentRoleId Either the unique id of the parent role, or the URL-friendly key of the parent role (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeParentRole(projId, envId, roleId, parentRoleId, options) {
      return localVarFp.removeParentRole(projId, envId, roleId, parentRoleId, options).then((request) => request(axios, basePath));
    },
    /**
     * Remove permissions from role.  If some of the permissions specified are already unassigned, will skip them.
     * @summary Remove Permissions From Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {RemoveRolePermissions} removeRolePermissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removePermissionsFromRole(projId, envId, roleId, removeRolePermissions, options) {
      return localVarFp.removePermissionsFromRole(projId, envId, roleId, removeRolePermissions, options).then((request) => request(axios, basePath));
    },
    /**
     * Partially updates a tenant role. Fields that will be provided will be completely overwritten.
     * @summary Update Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {RoleUpdate} roleUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRole(projId, envId, roleId, roleUpdate, options) {
      return localVarFp.updateRole(projId, envId, roleId, roleUpdate, options).then((request) => request(axios, basePath));
    }
  };
};
var RolesApi = class extends BaseAPI {
  /**
   * This endpoint is part of the role hierarchy feature.  Makes role with id `role_id` extend the role with id `parent_role_id`. In other words, `role_id` will automatically be assigned any permissions that are granted to `parent_role_id`.  We can say the `role_id` **extends** `parent_role_id` or **inherits** from `parent_role_id`.  If `role_id` is already an ancestor of `parent_role_id`, the request will fail with HTTP 400 to prevent a cycle in the role hierarchy.
   * @summary Add Parent Role
   * @param {RolesApiAddParentRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RolesApi
   */
  addParentRole(requestParameters, options) {
    return RolesApiFp(this.configuration).addParentRole(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.roleId,
      requestParameters.parentRoleId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Assign permissions to role.  If some of the permissions specified are already assigned, will skip them.
   * @summary Assign Permissions To Role
   * @param {RolesApiAssignPermissionsToRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RolesApi
   */
  assignPermissionsToRole(requestParameters, options) {
    return RolesApiFp(this.configuration).assignPermissionsToRole(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.roleId,
      requestParameters.addRolePermissions,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Creates a new tenant role.
   * @summary Create Role
   * @param {RolesApiCreateRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RolesApi
   */
  createRole(requestParameters, options) {
    return RolesApiFp(this.configuration).createRole(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.roleCreate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Deletes a tenant role and all its related data. This includes any permissions granted to said role.
   * @summary Delete Role
   * @param {RolesApiDeleteRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RolesApi
   */
  deleteRole(requestParameters, options) {
    return RolesApiFp(this.configuration).deleteRole(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.roleId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Gets a single tenant role, if such role exists.
   * @summary Get Role
   * @param {RolesApiGetRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RolesApi
   */
  getRole(requestParameters, options) {
    return RolesApiFp(this.configuration).getRole(requestParameters.projId, requestParameters.envId, requestParameters.roleId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Lists all tenant roles.
   * @summary List Roles
   * @param {RolesApiListRolesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RolesApi
   */
  listRoles(requestParameters, options) {
    return RolesApiFp(this.configuration).listRoles(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.page,
      requestParameters.perPage,
      requestParameters.includeTotalCount,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * This endpoint is part of the role hierarchy feature.  Removes `parent_role_id` from the list of parent roles of role with id `role_id`. In other words, `role_id` will no longer be automatically assigned permissions that are granted to `parent_role_id`.  We can say the `role_id` **not longer extends** `parent_role_id` or **no longer inherits** from `parent_role_id`.
   * @summary Remove Parent Role
   * @param {RolesApiRemoveParentRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RolesApi
   */
  removeParentRole(requestParameters, options) {
    return RolesApiFp(this.configuration).removeParentRole(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.roleId,
      requestParameters.parentRoleId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Remove permissions from role.  If some of the permissions specified are already unassigned, will skip them.
   * @summary Remove Permissions From Role
   * @param {RolesApiRemovePermissionsFromRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RolesApi
   */
  removePermissionsFromRole(requestParameters, options) {
    return RolesApiFp(this.configuration).removePermissionsFromRole(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.roleId,
      requestParameters.removeRolePermissions,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Partially updates a tenant role. Fields that will be provided will be completely overwritten.
   * @summary Update Role
   * @param {RolesApiUpdateRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RolesApi
   */
  updateRole(requestParameters, options) {
    return RolesApiFp(this.configuration).updateRole(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.roleId,
      requestParameters.roleUpdate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/tenants-api.ts
import globalAxios33 from "axios";
var TenantsApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * Creates a new tenant inside the Permit.io system.  If the tenant is already created: will return 200 instead of 201, and will return the existing tenant object in the response body.
     * @summary Create Tenant
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {TenantCreate} tenantCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTenant: async (projId, envId, tenantCreate, options = {}) => {
      assertParamExists("createTenant", "projId", projId);
      assertParamExists("createTenant", "envId", envId);
      assertParamExists("createTenant", "tenantCreate", tenantCreate);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/tenants`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        tenantCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes the tenant and all its related data.
     * @summary Delete Tenant
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} tenantId Either the unique id of the tenant, or the URL-friendly key of the tenant (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTenant: async (projId, envId, tenantId, options = {}) => {
      assertParamExists("deleteTenant", "projId", projId);
      assertParamExists("deleteTenant", "envId", envId);
      assertParamExists("deleteTenant", "tenantId", tenantId);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/tenants/{tenant_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"tenant_id"}}`, encodeURIComponent(String(tenantId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes a user under a tenant.
     * @summary Delete Tenant User
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} tenantId Either the unique id of the tenant, or the URL-friendly key of the tenant (i.e: the \&quot;slug\&quot;).
     * @param {string} userId Either the unique id of the user, or the URL-friendly key of the user (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTenantUser: async (projId, envId, tenantId, userId, options = {}) => {
      assertParamExists("deleteTenantUser", "projId", projId);
      assertParamExists("deleteTenantUser", "envId", envId);
      assertParamExists("deleteTenantUser", "tenantId", tenantId);
      assertParamExists("deleteTenantUser", "userId", userId);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/tenants/{tenant_id}/users/{user_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"tenant_id"}}`, encodeURIComponent(String(tenantId))).replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Gets a tenant, if such tenant exists. Otherwise returns 404.
     * @summary Get Tenant
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} tenantId Either the unique id of the tenant, or the URL-friendly key of the tenant (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTenant: async (projId, envId, tenantId, options = {}) => {
      assertParamExists("getTenant", "projId", projId);
      assertParamExists("getTenant", "envId", envId);
      assertParamExists("getTenant", "tenantId", tenantId);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/tenants/{tenant_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"tenant_id"}}`, encodeURIComponent(String(tenantId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary List Tenant Users
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} tenantId Either the unique id of the tenant, or the URL-friendly key of the tenant (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} [search] Text search for the email field
     * @param {string} [role] Match users with a specific role
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTenantUsers: async (projId, tenantId, envId, search, role, page, perPage, options = {}) => {
      assertParamExists("listTenantUsers", "projId", projId);
      assertParamExists("listTenantUsers", "tenantId", tenantId);
      assertParamExists("listTenantUsers", "envId", envId);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/tenants/{tenant_id}/users`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"tenant_id"}}`, encodeURIComponent(String(tenantId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (search !== void 0) {
        localVarQueryParameter["search"] = search;
      }
      if (role !== void 0) {
        localVarQueryParameter["role"] = role;
      }
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Lists all the tenants defined within an environment.
     * @summary List Tenants
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} [search] Text search for the tenant name or key
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTenants: async (projId, envId, search, page, perPage, options = {}) => {
      assertParamExists("listTenants", "projId", projId);
      assertParamExists("listTenants", "envId", envId);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/tenants`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (search !== void 0) {
        localVarQueryParameter["search"] = search;
      }
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Partially updates the tenant definition. Fields that will be provided will be completely overwritten.
     * @summary Update Tenant
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} tenantId Either the unique id of the tenant, or the URL-friendly key of the tenant (i.e: the \&quot;slug\&quot;).
     * @param {TenantUpdate} tenantUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateTenant: async (projId, envId, tenantId, tenantUpdate, options = {}) => {
      assertParamExists("updateTenant", "projId", projId);
      assertParamExists("updateTenant", "envId", envId);
      assertParamExists("updateTenant", "tenantId", tenantId);
      assertParamExists("updateTenant", "tenantUpdate", tenantUpdate);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/tenants/{tenant_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"tenant_id"}}`, encodeURIComponent(String(tenantId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        tenantUpdate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var TenantsApiFp = function(configuration) {
  const localVarAxiosParamCreator = TenantsApiAxiosParamCreator(configuration);
  return {
    /**
     * Creates a new tenant inside the Permit.io system.  If the tenant is already created: will return 200 instead of 201, and will return the existing tenant object in the response body.
     * @summary Create Tenant
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {TenantCreate} tenantCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createTenant(projId, envId, tenantCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createTenant(
        projId,
        envId,
        tenantCreate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios33, BASE_PATH, configuration);
    },
    /**
     * Deletes the tenant and all its related data.
     * @summary Delete Tenant
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} tenantId Either the unique id of the tenant, or the URL-friendly key of the tenant (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteTenant(projId, envId, tenantId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTenant(
        projId,
        envId,
        tenantId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios33, BASE_PATH, configuration);
    },
    /**
     * Deletes a user under a tenant.
     * @summary Delete Tenant User
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} tenantId Either the unique id of the tenant, or the URL-friendly key of the tenant (i.e: the \&quot;slug\&quot;).
     * @param {string} userId Either the unique id of the user, or the URL-friendly key of the user (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteTenantUser(projId, envId, tenantId, userId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTenantUser(
        projId,
        envId,
        tenantId,
        userId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios33, BASE_PATH, configuration);
    },
    /**
     * Gets a tenant, if such tenant exists. Otherwise returns 404.
     * @summary Get Tenant
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} tenantId Either the unique id of the tenant, or the URL-friendly key of the tenant (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTenant(projId, envId, tenantId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getTenant(
        projId,
        envId,
        tenantId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios33, BASE_PATH, configuration);
    },
    /**
     *
     * @summary List Tenant Users
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} tenantId Either the unique id of the tenant, or the URL-friendly key of the tenant (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} [search] Text search for the email field
     * @param {string} [role] Match users with a specific role
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listTenantUsers(projId, tenantId, envId, search, role, page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listTenantUsers(
        projId,
        tenantId,
        envId,
        search,
        role,
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios33, BASE_PATH, configuration);
    },
    /**
     * Lists all the tenants defined within an environment.
     * @summary List Tenants
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} [search] Text search for the tenant name or key
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listTenants(projId, envId, search, page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listTenants(
        projId,
        envId,
        search,
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios33, BASE_PATH, configuration);
    },
    /**
     * Partially updates the tenant definition. Fields that will be provided will be completely overwritten.
     * @summary Update Tenant
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} tenantId Either the unique id of the tenant, or the URL-friendly key of the tenant (i.e: the \&quot;slug\&quot;).
     * @param {TenantUpdate} tenantUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateTenant(projId, envId, tenantId, tenantUpdate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateTenant(
        projId,
        envId,
        tenantId,
        tenantUpdate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios33, BASE_PATH, configuration);
    }
  };
};
var TenantsApiFactory = function(configuration, basePath, axios) {
  const localVarFp = TenantsApiFp(configuration);
  return {
    /**
     * Creates a new tenant inside the Permit.io system.  If the tenant is already created: will return 200 instead of 201, and will return the existing tenant object in the response body.
     * @summary Create Tenant
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {TenantCreate} tenantCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTenant(projId, envId, tenantCreate, options) {
      return localVarFp.createTenant(projId, envId, tenantCreate, options).then((request) => request(axios, basePath));
    },
    /**
     * Deletes the tenant and all its related data.
     * @summary Delete Tenant
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} tenantId Either the unique id of the tenant, or the URL-friendly key of the tenant (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTenant(projId, envId, tenantId, options) {
      return localVarFp.deleteTenant(projId, envId, tenantId, options).then((request) => request(axios, basePath));
    },
    /**
     * Deletes a user under a tenant.
     * @summary Delete Tenant User
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} tenantId Either the unique id of the tenant, or the URL-friendly key of the tenant (i.e: the \&quot;slug\&quot;).
     * @param {string} userId Either the unique id of the user, or the URL-friendly key of the user (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTenantUser(projId, envId, tenantId, userId, options) {
      return localVarFp.deleteTenantUser(projId, envId, tenantId, userId, options).then((request) => request(axios, basePath));
    },
    /**
     * Gets a tenant, if such tenant exists. Otherwise returns 404.
     * @summary Get Tenant
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} tenantId Either the unique id of the tenant, or the URL-friendly key of the tenant (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTenant(projId, envId, tenantId, options) {
      return localVarFp.getTenant(projId, envId, tenantId, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary List Tenant Users
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} tenantId Either the unique id of the tenant, or the URL-friendly key of the tenant (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} [search] Text search for the email field
     * @param {string} [role] Match users with a specific role
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTenantUsers(projId, tenantId, envId, search, role, page, perPage, options) {
      return localVarFp.listTenantUsers(projId, tenantId, envId, search, role, page, perPage, options).then((request) => request(axios, basePath));
    },
    /**
     * Lists all the tenants defined within an environment.
     * @summary List Tenants
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} [search] Text search for the tenant name or key
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTenants(projId, envId, search, page, perPage, options) {
      return localVarFp.listTenants(projId, envId, search, page, perPage, options).then((request) => request(axios, basePath));
    },
    /**
     * Partially updates the tenant definition. Fields that will be provided will be completely overwritten.
     * @summary Update Tenant
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} tenantId Either the unique id of the tenant, or the URL-friendly key of the tenant (i.e: the \&quot;slug\&quot;).
     * @param {TenantUpdate} tenantUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateTenant(projId, envId, tenantId, tenantUpdate, options) {
      return localVarFp.updateTenant(projId, envId, tenantId, tenantUpdate, options).then((request) => request(axios, basePath));
    }
  };
};
var TenantsApi = class extends BaseAPI {
  /**
   * Creates a new tenant inside the Permit.io system.  If the tenant is already created: will return 200 instead of 201, and will return the existing tenant object in the response body.
   * @summary Create Tenant
   * @param {TenantsApiCreateTenantRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TenantsApi
   */
  createTenant(requestParameters, options) {
    return TenantsApiFp(this.configuration).createTenant(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.tenantCreate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Deletes the tenant and all its related data.
   * @summary Delete Tenant
   * @param {TenantsApiDeleteTenantRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TenantsApi
   */
  deleteTenant(requestParameters, options) {
    return TenantsApiFp(this.configuration).deleteTenant(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.tenantId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Deletes a user under a tenant.
   * @summary Delete Tenant User
   * @param {TenantsApiDeleteTenantUserRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TenantsApi
   */
  deleteTenantUser(requestParameters, options) {
    return TenantsApiFp(this.configuration).deleteTenantUser(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.tenantId,
      requestParameters.userId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Gets a tenant, if such tenant exists. Otherwise returns 404.
   * @summary Get Tenant
   * @param {TenantsApiGetTenantRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TenantsApi
   */
  getTenant(requestParameters, options) {
    return TenantsApiFp(this.configuration).getTenant(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.tenantId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary List Tenant Users
   * @param {TenantsApiListTenantUsersRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TenantsApi
   */
  listTenantUsers(requestParameters, options) {
    return TenantsApiFp(this.configuration).listTenantUsers(
      requestParameters.projId,
      requestParameters.tenantId,
      requestParameters.envId,
      requestParameters.search,
      requestParameters.role,
      requestParameters.page,
      requestParameters.perPage,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Lists all the tenants defined within an environment.
   * @summary List Tenants
   * @param {TenantsApiListTenantsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TenantsApi
   */
  listTenants(requestParameters, options) {
    return TenantsApiFp(this.configuration).listTenants(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.search,
      requestParameters.page,
      requestParameters.perPage,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Partially updates the tenant definition. Fields that will be provided will be completely overwritten.
   * @summary Update Tenant
   * @param {TenantsApiUpdateTenantRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TenantsApi
   */
  updateTenant(requestParameters, options) {
    return TenantsApiFp(this.configuration).updateTenant(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.tenantId,
      requestParameters.tenantUpdate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/user-attributes-api.ts
import globalAxios34 from "axios";
var UserAttributesApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * Creates a new attribute for the User resource.
     * @summary Create User Attribute
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ResourceAttributeCreate} resourceAttributeCreate
     * @param {string} [resourceId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUserAttribute: async (projId, envId, resourceAttributeCreate, resourceId, options = {}) => {
      assertParamExists("createUserAttribute", "projId", projId);
      assertParamExists("createUserAttribute", "envId", envId);
      assertParamExists("createUserAttribute", "resourceAttributeCreate", resourceAttributeCreate);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/users/attributes`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (resourceId !== void 0) {
        localVarQueryParameter["resource_id"] = resourceId;
      }
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        resourceAttributeCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes the attribute and all its related data.  Note: If the attribute is used by policies, removing it will cause the attribute to evaluate as `undefined`.
     * @summary Delete User Attribute
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} attributeId Either the unique id of the attribute, or the URL-friendly key of the attribute (i.e: the \&quot;slug\&quot;).
     * @param {string} [resourceId]
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserAttribute: async (projId, envId, attributeId, resourceId, page, perPage, options = {}) => {
      assertParamExists("deleteUserAttribute", "projId", projId);
      assertParamExists("deleteUserAttribute", "envId", envId);
      assertParamExists("deleteUserAttribute", "attributeId", attributeId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/users/attributes/{attribute_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"attribute_id"}}`, encodeURIComponent(String(attributeId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (resourceId !== void 0) {
        localVarQueryParameter["resource_id"] = resourceId;
      }
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Gets a single attribute defined on the User resource, if such attribute exists.
     * @summary Get User Attribute
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} attributeId Either the unique id of the attribute, or the URL-friendly key of the attribute (i.e: the \&quot;slug\&quot;).
     * @param {string} [resourceId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserAttribute: async (projId, envId, attributeId, resourceId, options = {}) => {
      assertParamExists("getUserAttribute", "projId", projId);
      assertParamExists("getUserAttribute", "envId", envId);
      assertParamExists("getUserAttribute", "attributeId", attributeId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/users/attributes/{attribute_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"attribute_id"}}`, encodeURIComponent(String(attributeId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (resourceId !== void 0) {
        localVarQueryParameter["resource_id"] = resourceId;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Lists all the attributes defined on the User resource.
     * @summary List User Attributes
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} [resourceId]
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listUserAttributes: async (projId, envId, resourceId, page, perPage, options = {}) => {
      assertParamExists("listUserAttributes", "projId", projId);
      assertParamExists("listUserAttributes", "envId", envId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/users/attributes`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (resourceId !== void 0) {
        localVarQueryParameter["resource_id"] = resourceId;
      }
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Partially updates the attribute defined on the User resource. Fields that will be provided will be completely overwritten.
     * @summary Update User Attribute
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} attributeId Either the unique id of the attribute, or the URL-friendly key of the attribute (i.e: the \&quot;slug\&quot;).
     * @param {ResourceAttributeUpdate} resourceAttributeUpdate
     * @param {string} [resourceId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserAttribute: async (projId, envId, attributeId, resourceAttributeUpdate, resourceId, options = {}) => {
      assertParamExists("updateUserAttribute", "projId", projId);
      assertParamExists("updateUserAttribute", "envId", envId);
      assertParamExists("updateUserAttribute", "attributeId", attributeId);
      assertParamExists("updateUserAttribute", "resourceAttributeUpdate", resourceAttributeUpdate);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/users/attributes/{attribute_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"attribute_id"}}`, encodeURIComponent(String(attributeId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (resourceId !== void 0) {
        localVarQueryParameter["resource_id"] = resourceId;
      }
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        resourceAttributeUpdate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var UserAttributesApiFp = function(configuration) {
  const localVarAxiosParamCreator = UserAttributesApiAxiosParamCreator(configuration);
  return {
    /**
     * Creates a new attribute for the User resource.
     * @summary Create User Attribute
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ResourceAttributeCreate} resourceAttributeCreate
     * @param {string} [resourceId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createUserAttribute(projId, envId, resourceAttributeCreate, resourceId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createUserAttribute(
        projId,
        envId,
        resourceAttributeCreate,
        resourceId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios34, BASE_PATH, configuration);
    },
    /**
     * Deletes the attribute and all its related data.  Note: If the attribute is used by policies, removing it will cause the attribute to evaluate as `undefined`.
     * @summary Delete User Attribute
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} attributeId Either the unique id of the attribute, or the URL-friendly key of the attribute (i.e: the \&quot;slug\&quot;).
     * @param {string} [resourceId]
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteUserAttribute(projId, envId, attributeId, resourceId, page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserAttribute(
        projId,
        envId,
        attributeId,
        resourceId,
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios34, BASE_PATH, configuration);
    },
    /**
     * Gets a single attribute defined on the User resource, if such attribute exists.
     * @summary Get User Attribute
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} attributeId Either the unique id of the attribute, or the URL-friendly key of the attribute (i.e: the \&quot;slug\&quot;).
     * @param {string} [resourceId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUserAttribute(projId, envId, attributeId, resourceId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUserAttribute(
        projId,
        envId,
        attributeId,
        resourceId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios34, BASE_PATH, configuration);
    },
    /**
     * Lists all the attributes defined on the User resource.
     * @summary List User Attributes
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} [resourceId]
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listUserAttributes(projId, envId, resourceId, page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listUserAttributes(
        projId,
        envId,
        resourceId,
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios34, BASE_PATH, configuration);
    },
    /**
     * Partially updates the attribute defined on the User resource. Fields that will be provided will be completely overwritten.
     * @summary Update User Attribute
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} attributeId Either the unique id of the attribute, or the URL-friendly key of the attribute (i.e: the \&quot;slug\&quot;).
     * @param {ResourceAttributeUpdate} resourceAttributeUpdate
     * @param {string} [resourceId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateUserAttribute(projId, envId, attributeId, resourceAttributeUpdate, resourceId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserAttribute(
        projId,
        envId,
        attributeId,
        resourceAttributeUpdate,
        resourceId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios34, BASE_PATH, configuration);
    }
  };
};
var UserAttributesApiFactory = function(configuration, basePath, axios) {
  const localVarFp = UserAttributesApiFp(configuration);
  return {
    /**
     * Creates a new attribute for the User resource.
     * @summary Create User Attribute
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ResourceAttributeCreate} resourceAttributeCreate
     * @param {string} [resourceId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUserAttribute(projId, envId, resourceAttributeCreate, resourceId, options) {
      return localVarFp.createUserAttribute(projId, envId, resourceAttributeCreate, resourceId, options).then((request) => request(axios, basePath));
    },
    /**
     * Deletes the attribute and all its related data.  Note: If the attribute is used by policies, removing it will cause the attribute to evaluate as `undefined`.
     * @summary Delete User Attribute
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} attributeId Either the unique id of the attribute, or the URL-friendly key of the attribute (i.e: the \&quot;slug\&quot;).
     * @param {string} [resourceId]
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserAttribute(projId, envId, attributeId, resourceId, page, perPage, options) {
      return localVarFp.deleteUserAttribute(projId, envId, attributeId, resourceId, page, perPage, options).then((request) => request(axios, basePath));
    },
    /**
     * Gets a single attribute defined on the User resource, if such attribute exists.
     * @summary Get User Attribute
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} attributeId Either the unique id of the attribute, or the URL-friendly key of the attribute (i.e: the \&quot;slug\&quot;).
     * @param {string} [resourceId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserAttribute(projId, envId, attributeId, resourceId, options) {
      return localVarFp.getUserAttribute(projId, envId, attributeId, resourceId, options).then((request) => request(axios, basePath));
    },
    /**
     * Lists all the attributes defined on the User resource.
     * @summary List User Attributes
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} [resourceId]
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listUserAttributes(projId, envId, resourceId, page, perPage, options) {
      return localVarFp.listUserAttributes(projId, envId, resourceId, page, perPage, options).then((request) => request(axios, basePath));
    },
    /**
     * Partially updates the attribute defined on the User resource. Fields that will be provided will be completely overwritten.
     * @summary Update User Attribute
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} attributeId Either the unique id of the attribute, or the URL-friendly key of the attribute (i.e: the \&quot;slug\&quot;).
     * @param {ResourceAttributeUpdate} resourceAttributeUpdate
     * @param {string} [resourceId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserAttribute(projId, envId, attributeId, resourceAttributeUpdate, resourceId, options) {
      return localVarFp.updateUserAttribute(
        projId,
        envId,
        attributeId,
        resourceAttributeUpdate,
        resourceId,
        options
      ).then((request) => request(axios, basePath));
    }
  };
};
var UserAttributesApi = class extends BaseAPI {
  /**
   * Creates a new attribute for the User resource.
   * @summary Create User Attribute
   * @param {UserAttributesApiCreateUserAttributeRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserAttributesApi
   */
  createUserAttribute(requestParameters, options) {
    return UserAttributesApiFp(this.configuration).createUserAttribute(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceAttributeCreate,
      requestParameters.resourceId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Deletes the attribute and all its related data.  Note: If the attribute is used by policies, removing it will cause the attribute to evaluate as `undefined`.
   * @summary Delete User Attribute
   * @param {UserAttributesApiDeleteUserAttributeRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserAttributesApi
   */
  deleteUserAttribute(requestParameters, options) {
    return UserAttributesApiFp(this.configuration).deleteUserAttribute(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.attributeId,
      requestParameters.resourceId,
      requestParameters.page,
      requestParameters.perPage,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Gets a single attribute defined on the User resource, if such attribute exists.
   * @summary Get User Attribute
   * @param {UserAttributesApiGetUserAttributeRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserAttributesApi
   */
  getUserAttribute(requestParameters, options) {
    return UserAttributesApiFp(this.configuration).getUserAttribute(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.attributeId,
      requestParameters.resourceId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Lists all the attributes defined on the User resource.
   * @summary List User Attributes
   * @param {UserAttributesApiListUserAttributesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserAttributesApi
   */
  listUserAttributes(requestParameters, options) {
    return UserAttributesApiFp(this.configuration).listUserAttributes(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.page,
      requestParameters.perPage,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Partially updates the attribute defined on the User resource. Fields that will be provided will be completely overwritten.
   * @summary Update User Attribute
   * @param {UserAttributesApiUpdateUserAttributeRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserAttributesApi
   */
  updateUserAttribute(requestParameters, options) {
    return UserAttributesApiFp(this.configuration).updateUserAttribute(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.attributeId,
      requestParameters.resourceAttributeUpdate,
      requestParameters.resourceId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/users-api.ts
import globalAxios35 from "axios";
var UsersApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * Assigns a role to the user within the tenant.  The tenant defines the scope of the assignment. In other words, the role is effective only within the tenant.
     * @summary Assign Role To User
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} userId Either the unique id of the user, or the URL-friendly key of the user (i.e: the \&quot;slug\&quot;).
     * @param {UserRoleCreate} userRoleCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    assignRoleToUser: async (projId, envId, userId, userRoleCreate, options = {}) => {
      assertParamExists("assignRoleToUser", "projId", projId);
      assertParamExists("assignRoleToUser", "envId", envId);
      assertParamExists("assignRoleToUser", "userId", userId);
      assertParamExists("assignRoleToUser", "userRoleCreate", userRoleCreate);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/users/{user_id}/roles`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userRoleCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Creates a new user inside the Permit.io system, from that point forward you may run permission checks on that user.  If the user is already created: will return 200 instead of 201, and will return the existing user object in the response body.
     * @summary Create User
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {UserCreate} userCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUser: async (projId, envId, userCreate, options = {}) => {
      assertParamExists("createUser", "projId", projId);
      assertParamExists("createUser", "envId", envId);
      assertParamExists("createUser", "userCreate", userCreate);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/users`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes the user and all its related data.
     * @summary Delete User
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} userId Either the unique id of the user, or the URL-friendly key of the user (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser: async (projId, envId, userId, options = {}) => {
      assertParamExists("deleteUser", "projId", projId);
      assertParamExists("deleteUser", "envId", envId);
      assertParamExists("deleteUser", "userId", userId);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/users/{user_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Gets a user, if such user exists. Otherwise returns 404.
     * @summary Get User
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} userId Either the unique id of the user, or the URL-friendly key of the user (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUser: async (projId, envId, userId, options = {}) => {
      assertParamExists("getUser", "projId", projId);
      assertParamExists("getUser", "envId", envId);
      assertParamExists("getUser", "userId", userId);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/users/{user_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Lists all the users defined within an environment.
     * @summary List Users
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} [search] Text search for the email field
     * @param {string} [role] Match users with a specific role
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listUsers: async (projId, envId, search, role, page, perPage, options = {}) => {
      assertParamExists("listUsers", "projId", projId);
      assertParamExists("listUsers", "envId", envId);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/users`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (search !== void 0) {
        localVarQueryParameter["search"] = search;
      }
      if (role !== void 0) {
        localVarQueryParameter["role"] = role;
      }
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Replace User
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} userId Either the unique id of the user, or the URL-friendly key of the user (i.e: the \&quot;slug\&quot;).
     * @param {UserCreate} userCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    replaceUser: async (projId, envId, userId, userCreate, options = {}) => {
      assertParamExists("replaceUser", "projId", projId);
      assertParamExists("replaceUser", "envId", envId);
      assertParamExists("replaceUser", "userId", userId);
      assertParamExists("replaceUser", "userCreate", userCreate);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/users/{user_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Unassigns the role from the user within the tenant.  The tenant defines the scope of the assignment. In other words, the role is effective only within the tenant.  If the role is not actually assigned, will return 404.
     * @summary Unassign Role From User
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} userId Either the unique id of the user, or the URL-friendly key of the user (i.e: the \&quot;slug\&quot;).
     * @param {UserRoleRemove} userRoleRemove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unassignRoleFromUser: async (projId, envId, userId, userRoleRemove, options = {}) => {
      assertParamExists("unassignRoleFromUser", "projId", projId);
      assertParamExists("unassignRoleFromUser", "envId", envId);
      assertParamExists("unassignRoleFromUser", "userId", userId);
      assertParamExists("unassignRoleFromUser", "userRoleRemove", userRoleRemove);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/users/{user_id}/roles`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userRoleRemove,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Partially updates the user definition. Fields that will be provided will be completely overwritten.
     * @summary Update User
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} userId Either the unique id of the user, or the URL-friendly key of the user (i.e: the \&quot;slug\&quot;).
     * @param {UserUpdate} userUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUser: async (projId, envId, userId, userUpdate, options = {}) => {
      assertParamExists("updateUser", "projId", projId);
      assertParamExists("updateUser", "envId", envId);
      assertParamExists("updateUser", "userId", userId);
      assertParamExists("updateUser", "userUpdate", userUpdate);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/users/{user_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userUpdate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var UsersApiFp = function(configuration) {
  const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration);
  return {
    /**
     * Assigns a role to the user within the tenant.  The tenant defines the scope of the assignment. In other words, the role is effective only within the tenant.
     * @summary Assign Role To User
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} userId Either the unique id of the user, or the URL-friendly key of the user (i.e: the \&quot;slug\&quot;).
     * @param {UserRoleCreate} userRoleCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async assignRoleToUser(projId, envId, userId, userRoleCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.assignRoleToUser(
        projId,
        envId,
        userId,
        userRoleCreate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios35, BASE_PATH, configuration);
    },
    /**
     * Creates a new user inside the Permit.io system, from that point forward you may run permission checks on that user.  If the user is already created: will return 200 instead of 201, and will return the existing user object in the response body.
     * @summary Create User
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {UserCreate} userCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createUser(projId, envId, userCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(
        projId,
        envId,
        userCreate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios35, BASE_PATH, configuration);
    },
    /**
     * Deletes the user and all its related data.
     * @summary Delete User
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} userId Either the unique id of the user, or the URL-friendly key of the user (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteUser(projId, envId, userId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(
        projId,
        envId,
        userId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios35, BASE_PATH, configuration);
    },
    /**
     * Gets a user, if such user exists. Otherwise returns 404.
     * @summary Get User
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} userId Either the unique id of the user, or the URL-friendly key of the user (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUser(projId, envId, userId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(
        projId,
        envId,
        userId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios35, BASE_PATH, configuration);
    },
    /**
     * Lists all the users defined within an environment.
     * @summary List Users
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} [search] Text search for the email field
     * @param {string} [role] Match users with a specific role
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listUsers(projId, envId, search, role, page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listUsers(
        projId,
        envId,
        search,
        role,
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios35, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Replace User
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} userId Either the unique id of the user, or the URL-friendly key of the user (i.e: the \&quot;slug\&quot;).
     * @param {UserCreate} userCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async replaceUser(projId, envId, userId, userCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.replaceUser(
        projId,
        envId,
        userId,
        userCreate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios35, BASE_PATH, configuration);
    },
    /**
     * Unassigns the role from the user within the tenant.  The tenant defines the scope of the assignment. In other words, the role is effective only within the tenant.  If the role is not actually assigned, will return 404.
     * @summary Unassign Role From User
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} userId Either the unique id of the user, or the URL-friendly key of the user (i.e: the \&quot;slug\&quot;).
     * @param {UserRoleRemove} userRoleRemove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async unassignRoleFromUser(projId, envId, userId, userRoleRemove, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.unassignRoleFromUser(
        projId,
        envId,
        userId,
        userRoleRemove,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios35, BASE_PATH, configuration);
    },
    /**
     * Partially updates the user definition. Fields that will be provided will be completely overwritten.
     * @summary Update User
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} userId Either the unique id of the user, or the URL-friendly key of the user (i.e: the \&quot;slug\&quot;).
     * @param {UserUpdate} userUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateUser(projId, envId, userId, userUpdate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(
        projId,
        envId,
        userId,
        userUpdate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios35, BASE_PATH, configuration);
    }
  };
};
var UsersApiFactory = function(configuration, basePath, axios) {
  const localVarFp = UsersApiFp(configuration);
  return {
    /**
     * Assigns a role to the user within the tenant.  The tenant defines the scope of the assignment. In other words, the role is effective only within the tenant.
     * @summary Assign Role To User
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} userId Either the unique id of the user, or the URL-friendly key of the user (i.e: the \&quot;slug\&quot;).
     * @param {UserRoleCreate} userRoleCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    assignRoleToUser(projId, envId, userId, userRoleCreate, options) {
      return localVarFp.assignRoleToUser(projId, envId, userId, userRoleCreate, options).then((request) => request(axios, basePath));
    },
    /**
     * Creates a new user inside the Permit.io system, from that point forward you may run permission checks on that user.  If the user is already created: will return 200 instead of 201, and will return the existing user object in the response body.
     * @summary Create User
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {UserCreate} userCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUser(projId, envId, userCreate, options) {
      return localVarFp.createUser(projId, envId, userCreate, options).then((request) => request(axios, basePath));
    },
    /**
     * Deletes the user and all its related data.
     * @summary Delete User
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} userId Either the unique id of the user, or the URL-friendly key of the user (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser(projId, envId, userId, options) {
      return localVarFp.deleteUser(projId, envId, userId, options).then((request) => request(axios, basePath));
    },
    /**
     * Gets a user, if such user exists. Otherwise returns 404.
     * @summary Get User
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} userId Either the unique id of the user, or the URL-friendly key of the user (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUser(projId, envId, userId, options) {
      return localVarFp.getUser(projId, envId, userId, options).then((request) => request(axios, basePath));
    },
    /**
     * Lists all the users defined within an environment.
     * @summary List Users
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} [search] Text search for the email field
     * @param {string} [role] Match users with a specific role
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listUsers(projId, envId, search, role, page, perPage, options) {
      return localVarFp.listUsers(projId, envId, search, role, page, perPage, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Replace User
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} userId Either the unique id of the user, or the URL-friendly key of the user (i.e: the \&quot;slug\&quot;).
     * @param {UserCreate} userCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    replaceUser(projId, envId, userId, userCreate, options) {
      return localVarFp.replaceUser(projId, envId, userId, userCreate, options).then((request) => request(axios, basePath));
    },
    /**
     * Unassigns the role from the user within the tenant.  The tenant defines the scope of the assignment. In other words, the role is effective only within the tenant.  If the role is not actually assigned, will return 404.
     * @summary Unassign Role From User
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} userId Either the unique id of the user, or the URL-friendly key of the user (i.e: the \&quot;slug\&quot;).
     * @param {UserRoleRemove} userRoleRemove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unassignRoleFromUser(projId, envId, userId, userRoleRemove, options) {
      return localVarFp.unassignRoleFromUser(projId, envId, userId, userRoleRemove, options).then((request) => request(axios, basePath));
    },
    /**
     * Partially updates the user definition. Fields that will be provided will be completely overwritten.
     * @summary Update User
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} userId Either the unique id of the user, or the URL-friendly key of the user (i.e: the \&quot;slug\&quot;).
     * @param {UserUpdate} userUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUser(projId, envId, userId, userUpdate, options) {
      return localVarFp.updateUser(projId, envId, userId, userUpdate, options).then((request) => request(axios, basePath));
    }
  };
};
var UsersApi = class extends BaseAPI {
  /**
   * Assigns a role to the user within the tenant.  The tenant defines the scope of the assignment. In other words, the role is effective only within the tenant.
   * @summary Assign Role To User
   * @param {UsersApiAssignRoleToUserRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  assignRoleToUser(requestParameters, options) {
    return UsersApiFp(this.configuration).assignRoleToUser(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.userId,
      requestParameters.userRoleCreate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Creates a new user inside the Permit.io system, from that point forward you may run permission checks on that user.  If the user is already created: will return 200 instead of 201, and will return the existing user object in the response body.
   * @summary Create User
   * @param {UsersApiCreateUserRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  createUser(requestParameters, options) {
    return UsersApiFp(this.configuration).createUser(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.userCreate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Deletes the user and all its related data.
   * @summary Delete User
   * @param {UsersApiDeleteUserRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  deleteUser(requestParameters, options) {
    return UsersApiFp(this.configuration).deleteUser(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.userId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Gets a user, if such user exists. Otherwise returns 404.
   * @summary Get User
   * @param {UsersApiGetUserRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  getUser(requestParameters, options) {
    return UsersApiFp(this.configuration).getUser(requestParameters.projId, requestParameters.envId, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Lists all the users defined within an environment.
   * @summary List Users
   * @param {UsersApiListUsersRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  listUsers(requestParameters, options) {
    return UsersApiFp(this.configuration).listUsers(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.search,
      requestParameters.role,
      requestParameters.page,
      requestParameters.perPage,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Replace User
   * @param {UsersApiReplaceUserRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  replaceUser(requestParameters, options) {
    return UsersApiFp(this.configuration).replaceUser(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.userId,
      requestParameters.userCreate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Unassigns the role from the user within the tenant.  The tenant defines the scope of the assignment. In other words, the role is effective only within the tenant.  If the role is not actually assigned, will return 404.
   * @summary Unassign Role From User
   * @param {UsersApiUnassignRoleFromUserRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  unassignRoleFromUser(requestParameters, options) {
    return UsersApiFp(this.configuration).unassignRoleFromUser(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.userId,
      requestParameters.userRoleRemove,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Partially updates the user definition. Fields that will be provided will be completely overwritten.
   * @summary Update User
   * @param {UsersApiUpdateUserRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  updateUser(requestParameters, options) {
    return UsersApiFp(this.configuration).updateUser(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.userId,
      requestParameters.userUpdate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/users-elements-data-api.ts
import globalAxios36 from "axios";
var UsersElementsDataApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * Assigns a role to the user within the tenant.  The tenant defines the scope of the assignment. In other words, the role is effective only within the tenant.
     * @summary Assign role to user
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} elementsConfigId Either the unique id of the elements_config, or the URL-friendly key of the elements_config (i.e: the \&quot;slug\&quot;).
     * @param {string} userId Either the unique id of the user, or the URL-friendly key of the user (i.e: the \&quot;slug\&quot;).
     * @param {ElementsUserRoleCreate} elementsUserRoleCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    elementsAssignRoleToUser: async (projId, envId, elementsConfigId, userId, elementsUserRoleCreate, options = {}) => {
      assertParamExists("elementsAssignRoleToUser", "projId", projId);
      assertParamExists("elementsAssignRoleToUser", "envId", envId);
      assertParamExists("elementsAssignRoleToUser", "elementsConfigId", elementsConfigId);
      assertParamExists("elementsAssignRoleToUser", "userId", userId);
      assertParamExists(
        "elementsAssignRoleToUser",
        "elementsUserRoleCreate",
        elementsUserRoleCreate
      );
      const localVarPath = `/v2/elements/{proj_id}/{env_id}/config/{elements_config_id}/data/users/{user_id}/roles`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"elements_config_id"}}`, encodeURIComponent(String(elementsConfigId))).replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        elementsUserRoleCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Creates a new user inside the Permit.io system, from that point forward you may run permission checks on that user.  If the user is already created: will return 200 instead of 201, and will return the existing user object in the response body.
     * @summary Create user
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} elementsConfigId Either the unique id of the elements_config, or the URL-friendly key of the elements_config (i.e: the \&quot;slug\&quot;).
     * @param {ElementsUserCreate} elementsUserCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    elementsCreateUser: async (projId, envId, elementsConfigId, elementsUserCreate, options = {}) => {
      assertParamExists("elementsCreateUser", "projId", projId);
      assertParamExists("elementsCreateUser", "envId", envId);
      assertParamExists("elementsCreateUser", "elementsConfigId", elementsConfigId);
      assertParamExists("elementsCreateUser", "elementsUserCreate", elementsUserCreate);
      const localVarPath = `/v2/elements/{proj_id}/{env_id}/config/{elements_config_id}/data/users`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"elements_config_id"}}`, encodeURIComponent(String(elementsConfigId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        elementsUserCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Delete user
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} elementsConfigId Either the unique id of the elements_config, or the URL-friendly key of the elements_config (i.e: the \&quot;slug\&quot;).
     * @param {string} userId Either the unique id of the user, or the URL-friendly key of the user (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    elementsDeleteUser: async (projId, envId, elementsConfigId, userId, options = {}) => {
      assertParamExists("elementsDeleteUser", "projId", projId);
      assertParamExists("elementsDeleteUser", "envId", envId);
      assertParamExists("elementsDeleteUser", "elementsConfigId", elementsConfigId);
      assertParamExists("elementsDeleteUser", "userId", userId);
      const localVarPath = `/v2/elements/{proj_id}/{env_id}/config/{elements_config_id}/data/users/{user_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"elements_config_id"}}`, encodeURIComponent(String(elementsConfigId))).replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Lists all the users defined within an environment.
     * @summary List roles
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} elementsConfigId Either the unique id of the elements_config, or the URL-friendly key of the elements_config (i.e: the \&quot;slug\&quot;).
     * @param {string} [search] Text search for the email field
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    elementsListRoles: async (projId, envId, elementsConfigId, search, page, perPage, options = {}) => {
      assertParamExists("elementsListRoles", "projId", projId);
      assertParamExists("elementsListRoles", "envId", envId);
      assertParamExists("elementsListRoles", "elementsConfigId", elementsConfigId);
      const localVarPath = `/v2/elements/{proj_id}/{env_id}/config/{elements_config_id}/data/roles`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"elements_config_id"}}`, encodeURIComponent(String(elementsConfigId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (search !== void 0) {
        localVarQueryParameter["search"] = search;
      }
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Lists all the users defined within an environment.
     * @summary List users
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} elementsConfigId Either the unique id of the elements_config, or the URL-friendly key of the elements_config (i.e: the \&quot;slug\&quot;).
     * @param {string} [search] Text search for the email field
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    elementsListUsers: async (projId, envId, elementsConfigId, search, page, perPage, options = {}) => {
      assertParamExists("elementsListUsers", "projId", projId);
      assertParamExists("elementsListUsers", "envId", envId);
      assertParamExists("elementsListUsers", "elementsConfigId", elementsConfigId);
      const localVarPath = `/v2/elements/{proj_id}/{env_id}/config/{elements_config_id}/data/users`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"elements_config_id"}}`, encodeURIComponent(String(elementsConfigId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (search !== void 0) {
        localVarQueryParameter["search"] = search;
      }
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Unassigns the role from the user within the tenant.  The tenant defines the scope of the assignment. In other words, the role is effective only within the tenant.  If the role is not actually assigned, will return 404.
     * @summary Unassign role from user
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} elementsConfigId Either the unique id of the elements_config, or the URL-friendly key of the elements_config (i.e: the \&quot;slug\&quot;).
     * @param {string} userId Either the unique id of the user, or the URL-friendly key of the user (i.e: the \&quot;slug\&quot;).
     * @param {ElementsUserRoleRemove} elementsUserRoleRemove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    elementsUnassignRoleFromUser: async (projId, envId, elementsConfigId, userId, elementsUserRoleRemove, options = {}) => {
      assertParamExists("elementsUnassignRoleFromUser", "projId", projId);
      assertParamExists("elementsUnassignRoleFromUser", "envId", envId);
      assertParamExists("elementsUnassignRoleFromUser", "elementsConfigId", elementsConfigId);
      assertParamExists("elementsUnassignRoleFromUser", "userId", userId);
      assertParamExists(
        "elementsUnassignRoleFromUser",
        "elementsUserRoleRemove",
        elementsUserRoleRemove
      );
      const localVarPath = `/v2/elements/{proj_id}/{env_id}/config/{elements_config_id}/data/users/{user_id}/roles`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"elements_config_id"}}`, encodeURIComponent(String(elementsConfigId))).replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        elementsUserRoleRemove,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Updates the embed_config.
     * @summary Set Config Active
     * @param {string} elementsConfigId Either the unique id of the elements_config, or the URL-friendly key of the elements_config (i.e: the \&quot;slug\&quot;).
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setConfigActive: async (elementsConfigId, projId, envId, options = {}) => {
      assertParamExists("setConfigActive", "elementsConfigId", elementsConfigId);
      assertParamExists("setConfigActive", "projId", projId);
      assertParamExists("setConfigActive", "envId", envId);
      const localVarPath = `/v2/elements/{proj_id}/{env_id}/config/{elements_config_id}/data/active`.replace(`{${"elements_config_id"}}`, encodeURIComponent(String(elementsConfigId))).replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var UsersElementsDataApiFp = function(configuration) {
  const localVarAxiosParamCreator = UsersElementsDataApiAxiosParamCreator(configuration);
  return {
    /**
     * Assigns a role to the user within the tenant.  The tenant defines the scope of the assignment. In other words, the role is effective only within the tenant.
     * @summary Assign role to user
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} elementsConfigId Either the unique id of the elements_config, or the URL-friendly key of the elements_config (i.e: the \&quot;slug\&quot;).
     * @param {string} userId Either the unique id of the user, or the URL-friendly key of the user (i.e: the \&quot;slug\&quot;).
     * @param {ElementsUserRoleCreate} elementsUserRoleCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async elementsAssignRoleToUser(projId, envId, elementsConfigId, userId, elementsUserRoleCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.elementsAssignRoleToUser(
        projId,
        envId,
        elementsConfigId,
        userId,
        elementsUserRoleCreate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios36, BASE_PATH, configuration);
    },
    /**
     * Creates a new user inside the Permit.io system, from that point forward you may run permission checks on that user.  If the user is already created: will return 200 instead of 201, and will return the existing user object in the response body.
     * @summary Create user
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} elementsConfigId Either the unique id of the elements_config, or the URL-friendly key of the elements_config (i.e: the \&quot;slug\&quot;).
     * @param {ElementsUserCreate} elementsUserCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async elementsCreateUser(projId, envId, elementsConfigId, elementsUserCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.elementsCreateUser(
        projId,
        envId,
        elementsConfigId,
        elementsUserCreate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios36, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Delete user
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} elementsConfigId Either the unique id of the elements_config, or the URL-friendly key of the elements_config (i.e: the \&quot;slug\&quot;).
     * @param {string} userId Either the unique id of the user, or the URL-friendly key of the user (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async elementsDeleteUser(projId, envId, elementsConfigId, userId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.elementsDeleteUser(
        projId,
        envId,
        elementsConfigId,
        userId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios36, BASE_PATH, configuration);
    },
    /**
     * Lists all the users defined within an environment.
     * @summary List roles
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} elementsConfigId Either the unique id of the elements_config, or the URL-friendly key of the elements_config (i.e: the \&quot;slug\&quot;).
     * @param {string} [search] Text search for the email field
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async elementsListRoles(projId, envId, elementsConfigId, search, page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.elementsListRoles(
        projId,
        envId,
        elementsConfigId,
        search,
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios36, BASE_PATH, configuration);
    },
    /**
     * Lists all the users defined within an environment.
     * @summary List users
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} elementsConfigId Either the unique id of the elements_config, or the URL-friendly key of the elements_config (i.e: the \&quot;slug\&quot;).
     * @param {string} [search] Text search for the email field
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async elementsListUsers(projId, envId, elementsConfigId, search, page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.elementsListUsers(
        projId,
        envId,
        elementsConfigId,
        search,
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios36, BASE_PATH, configuration);
    },
    /**
     * Unassigns the role from the user within the tenant.  The tenant defines the scope of the assignment. In other words, the role is effective only within the tenant.  If the role is not actually assigned, will return 404.
     * @summary Unassign role from user
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} elementsConfigId Either the unique id of the elements_config, or the URL-friendly key of the elements_config (i.e: the \&quot;slug\&quot;).
     * @param {string} userId Either the unique id of the user, or the URL-friendly key of the user (i.e: the \&quot;slug\&quot;).
     * @param {ElementsUserRoleRemove} elementsUserRoleRemove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async elementsUnassignRoleFromUser(projId, envId, elementsConfigId, userId, elementsUserRoleRemove, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.elementsUnassignRoleFromUser(
        projId,
        envId,
        elementsConfigId,
        userId,
        elementsUserRoleRemove,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios36, BASE_PATH, configuration);
    },
    /**
     * Updates the embed_config.
     * @summary Set Config Active
     * @param {string} elementsConfigId Either the unique id of the elements_config, or the URL-friendly key of the elements_config (i.e: the \&quot;slug\&quot;).
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setConfigActive(elementsConfigId, projId, envId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setConfigActive(
        elementsConfigId,
        projId,
        envId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios36, BASE_PATH, configuration);
    }
  };
};
var UsersElementsDataApiFactory = function(configuration, basePath, axios) {
  const localVarFp = UsersElementsDataApiFp(configuration);
  return {
    /**
     * Assigns a role to the user within the tenant.  The tenant defines the scope of the assignment. In other words, the role is effective only within the tenant.
     * @summary Assign role to user
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} elementsConfigId Either the unique id of the elements_config, or the URL-friendly key of the elements_config (i.e: the \&quot;slug\&quot;).
     * @param {string} userId Either the unique id of the user, or the URL-friendly key of the user (i.e: the \&quot;slug\&quot;).
     * @param {ElementsUserRoleCreate} elementsUserRoleCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    elementsAssignRoleToUser(projId, envId, elementsConfigId, userId, elementsUserRoleCreate, options) {
      return localVarFp.elementsAssignRoleToUser(
        projId,
        envId,
        elementsConfigId,
        userId,
        elementsUserRoleCreate,
        options
      ).then((request) => request(axios, basePath));
    },
    /**
     * Creates a new user inside the Permit.io system, from that point forward you may run permission checks on that user.  If the user is already created: will return 200 instead of 201, and will return the existing user object in the response body.
     * @summary Create user
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} elementsConfigId Either the unique id of the elements_config, or the URL-friendly key of the elements_config (i.e: the \&quot;slug\&quot;).
     * @param {ElementsUserCreate} elementsUserCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    elementsCreateUser(projId, envId, elementsConfigId, elementsUserCreate, options) {
      return localVarFp.elementsCreateUser(projId, envId, elementsConfigId, elementsUserCreate, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Delete user
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} elementsConfigId Either the unique id of the elements_config, or the URL-friendly key of the elements_config (i.e: the \&quot;slug\&quot;).
     * @param {string} userId Either the unique id of the user, or the URL-friendly key of the user (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    elementsDeleteUser(projId, envId, elementsConfigId, userId, options) {
      return localVarFp.elementsDeleteUser(projId, envId, elementsConfigId, userId, options).then((request) => request(axios, basePath));
    },
    /**
     * Lists all the users defined within an environment.
     * @summary List roles
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} elementsConfigId Either the unique id of the elements_config, or the URL-friendly key of the elements_config (i.e: the \&quot;slug\&quot;).
     * @param {string} [search] Text search for the email field
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    elementsListRoles(projId, envId, elementsConfigId, search, page, perPage, options) {
      return localVarFp.elementsListRoles(projId, envId, elementsConfigId, search, page, perPage, options).then((request) => request(axios, basePath));
    },
    /**
     * Lists all the users defined within an environment.
     * @summary List users
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} elementsConfigId Either the unique id of the elements_config, or the URL-friendly key of the elements_config (i.e: the \&quot;slug\&quot;).
     * @param {string} [search] Text search for the email field
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    elementsListUsers(projId, envId, elementsConfigId, search, page, perPage, options) {
      return localVarFp.elementsListUsers(projId, envId, elementsConfigId, search, page, perPage, options).then((request) => request(axios, basePath));
    },
    /**
     * Unassigns the role from the user within the tenant.  The tenant defines the scope of the assignment. In other words, the role is effective only within the tenant.  If the role is not actually assigned, will return 404.
     * @summary Unassign role from user
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} elementsConfigId Either the unique id of the elements_config, or the URL-friendly key of the elements_config (i.e: the \&quot;slug\&quot;).
     * @param {string} userId Either the unique id of the user, or the URL-friendly key of the user (i.e: the \&quot;slug\&quot;).
     * @param {ElementsUserRoleRemove} elementsUserRoleRemove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    elementsUnassignRoleFromUser(projId, envId, elementsConfigId, userId, elementsUserRoleRemove, options) {
      return localVarFp.elementsUnassignRoleFromUser(
        projId,
        envId,
        elementsConfigId,
        userId,
        elementsUserRoleRemove,
        options
      ).then((request) => request(axios, basePath));
    },
    /**
     * Updates the embed_config.
     * @summary Set Config Active
     * @param {string} elementsConfigId Either the unique id of the elements_config, or the URL-friendly key of the elements_config (i.e: the \&quot;slug\&quot;).
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setConfigActive(elementsConfigId, projId, envId, options) {
      return localVarFp.setConfigActive(elementsConfigId, projId, envId, options).then((request) => request(axios, basePath));
    }
  };
};
var UsersElementsDataApi = class extends BaseAPI {
  /**
   * Assigns a role to the user within the tenant.  The tenant defines the scope of the assignment. In other words, the role is effective only within the tenant.
   * @summary Assign role to user
   * @param {UsersElementsDataApiElementsAssignRoleToUserRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersElementsDataApi
   */
  elementsAssignRoleToUser(requestParameters, options) {
    return UsersElementsDataApiFp(this.configuration).elementsAssignRoleToUser(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.elementsConfigId,
      requestParameters.userId,
      requestParameters.elementsUserRoleCreate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Creates a new user inside the Permit.io system, from that point forward you may run permission checks on that user.  If the user is already created: will return 200 instead of 201, and will return the existing user object in the response body.
   * @summary Create user
   * @param {UsersElementsDataApiElementsCreateUserRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersElementsDataApi
   */
  elementsCreateUser(requestParameters, options) {
    return UsersElementsDataApiFp(this.configuration).elementsCreateUser(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.elementsConfigId,
      requestParameters.elementsUserCreate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Delete user
   * @param {UsersElementsDataApiElementsDeleteUserRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersElementsDataApi
   */
  elementsDeleteUser(requestParameters, options) {
    return UsersElementsDataApiFp(this.configuration).elementsDeleteUser(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.elementsConfigId,
      requestParameters.userId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Lists all the users defined within an environment.
   * @summary List roles
   * @param {UsersElementsDataApiElementsListRolesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersElementsDataApi
   */
  elementsListRoles(requestParameters, options) {
    return UsersElementsDataApiFp(this.configuration).elementsListRoles(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.elementsConfigId,
      requestParameters.search,
      requestParameters.page,
      requestParameters.perPage,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Lists all the users defined within an environment.
   * @summary List users
   * @param {UsersElementsDataApiElementsListUsersRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersElementsDataApi
   */
  elementsListUsers(requestParameters, options) {
    return UsersElementsDataApiFp(this.configuration).elementsListUsers(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.elementsConfigId,
      requestParameters.search,
      requestParameters.page,
      requestParameters.perPage,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Unassigns the role from the user within the tenant.  The tenant defines the scope of the assignment. In other words, the role is effective only within the tenant.  If the role is not actually assigned, will return 404.
   * @summary Unassign role from user
   * @param {UsersElementsDataApiElementsUnassignRoleFromUserRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersElementsDataApi
   */
  elementsUnassignRoleFromUser(requestParameters, options) {
    return UsersElementsDataApiFp(this.configuration).elementsUnassignRoleFromUser(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.elementsConfigId,
      requestParameters.userId,
      requestParameters.elementsUserRoleRemove,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Updates the embed_config.
   * @summary Set Config Active
   * @param {UsersElementsDataApiSetConfigActiveRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersElementsDataApi
   */
  setConfigActive(requestParameters, options) {
    return UsersElementsDataApiFp(this.configuration).setConfigActive(
      requestParameters.elementsConfigId,
      requestParameters.projId,
      requestParameters.envId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
};
export {
  APIKeysApi,
  APIKeysApiAxiosParamCreator,
  APIKeysApiFactory,
  APIKeysApiFp,
  AuditElementsDataApi,
  AuditElementsDataApiAxiosParamCreator,
  AuditElementsDataApiFactory,
  AuditElementsDataApiFp,
  AuditLogsApi,
  AuditLogsApiAxiosParamCreator,
  AuditLogsApiFactory,
  AuditLogsApiFp,
  AuthenticationApi,
  AuthenticationApiAxiosParamCreator,
  AuthenticationApiFactory,
  AuthenticationApiFp,
  ConditionSetRulesApi,
  ConditionSetRulesApiAxiosParamCreator,
  ConditionSetRulesApiFactory,
  ConditionSetRulesApiFp,
  ConditionSetsApi,
  ConditionSetsApiAxiosParamCreator,
  ConditionSetsApiFactory,
  ConditionSetsApiFp,
  DecisionLogsApi,
  DecisionLogsApiAxiosParamCreator,
  DecisionLogsApiFactory,
  DecisionLogsApiFp,
  DecisionLogsIngressApi,
  DecisionLogsIngressApiAxiosParamCreator,
  DecisionLogsIngressApiFactory,
  DecisionLogsIngressApiFp,
  DefaultApi,
  DefaultApiAxiosParamCreator,
  DefaultApiFactory,
  DefaultApiFp,
  ElementsConfigsApi,
  ElementsConfigsApiAxiosParamCreator,
  ElementsConfigsApiFactory,
  ElementsConfigsApiFp,
  EnvironmentsApi,
  EnvironmentsApiAxiosParamCreator,
  EnvironmentsApiFactory,
  EnvironmentsApiFp,
  ImplicitGrantsApi,
  ImplicitGrantsApiAxiosParamCreator,
  ImplicitGrantsApiFactory,
  ImplicitGrantsApiFp,
  InstructionsApi,
  InstructionsApiAxiosParamCreator,
  InstructionsApiFactory,
  InstructionsApiFp,
  MembersApi,
  MembersApiAxiosParamCreator,
  MembersApiFactory,
  MembersApiFp,
  OPALDataApi,
  OPALDataApiAxiosParamCreator,
  OPALDataApiFactory,
  OPALDataApiFp,
  OrganizationsApi,
  OrganizationsApiAxiosParamCreator,
  OrganizationsApiFactory,
  OrganizationsApiFp,
  PolicyApi,
  PolicyApiAxiosParamCreator,
  PolicyApiFactory,
  PolicyApiFp,
  PolicyDecisionPointsApi,
  PolicyDecisionPointsApiAxiosParamCreator,
  PolicyDecisionPointsApiFactory,
  PolicyDecisionPointsApiFp,
  PolicyGitRepositoriesApi,
  PolicyGitRepositoriesApiAxiosParamCreator,
  PolicyGitRepositoriesApiFactory,
  PolicyGitRepositoriesApiFp,
  ProjectsApi,
  ProjectsApiAxiosParamCreator,
  ProjectsApiFactory,
  ProjectsApiFp,
  ProxyConfigApi,
  ProxyConfigApiAxiosParamCreator,
  ProxyConfigApiFactory,
  ProxyConfigApiFp,
  RelationshipTuplesApi,
  RelationshipTuplesApiAxiosParamCreator,
  RelationshipTuplesApiFactory,
  RelationshipTuplesApiFp,
  ResourceActionGroupsApi,
  ResourceActionGroupsApiAxiosParamCreator,
  ResourceActionGroupsApiFactory,
  ResourceActionGroupsApiFp,
  ResourceActionsApi,
  ResourceActionsApiAxiosParamCreator,
  ResourceActionsApiFactory,
  ResourceActionsApiFp,
  ResourceAttributesApi,
  ResourceAttributesApiAxiosParamCreator,
  ResourceAttributesApiFactory,
  ResourceAttributesApiFp,
  ResourceInstancesApi,
  ResourceInstancesApiAxiosParamCreator,
  ResourceInstancesApiFactory,
  ResourceInstancesApiFp,
  ResourceRelationsApi,
  ResourceRelationsApiAxiosParamCreator,
  ResourceRelationsApiFactory,
  ResourceRelationsApiFp,
  ResourceRolesApi,
  ResourceRolesApiAxiosParamCreator,
  ResourceRolesApiFactory,
  ResourceRolesApiFp,
  ResourcesApi,
  ResourcesApiAxiosParamCreator,
  ResourcesApiFactory,
  ResourcesApiFp,
  RoleAssignmentsApi,
  RoleAssignmentsApiAxiosParamCreator,
  RoleAssignmentsApiFactory,
  RoleAssignmentsApiFp,
  RolesApi,
  RolesApiAxiosParamCreator,
  RolesApiFactory,
  RolesApiFp,
  TenantsApi,
  TenantsApiAxiosParamCreator,
  TenantsApiFactory,
  TenantsApiFp,
  UserAttributesApi,
  UserAttributesApiAxiosParamCreator,
  UserAttributesApiFactory,
  UserAttributesApiFp,
  UsersApi,
  UsersApiAxiosParamCreator,
  UsersApiFactory,
  UsersApiFp,
  UsersElementsDataApi,
  UsersElementsDataApiAxiosParamCreator,
  UsersElementsDataApiFactory,
  UsersElementsDataApiFp
};
//# sourceMappingURL=api.mjs.map