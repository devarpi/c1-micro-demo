"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  APIKeyOwnerType: () => APIKeyOwnerType,
  ApiClient: () => ApiClient,
  ApiContext: () => ApiContext,
  ApiKeyLevel: () => ApiKeyLevel,
  AttributeType: () => AttributeType,
  ConditionSetRulesApi: () => ConditionSetRulesApi2,
  ConditionSetType: () => ConditionSetType,
  ConditionSetsApi: () => ConditionSetsApi2,
  DeprecatedApiClient: () => DeprecatedApiClient,
  ElementsApiErrors: () => ElementsApiErrors,
  ElementsClient: () => ElementsClient,
  EnvironmentCopyConflictStrategyEnum: () => EnvironmentCopyConflictStrategyEnum,
  EnvironmentsApi: () => EnvironmentsApi2,
  MemberAccessLevel: () => MemberAccessLevel,
  MemberAccessObj: () => MemberAccessObj,
  Permit: () => Permit,
  PermitApiError: () => PermitApiError,
  PermitConnectionError: () => PermitConnectionError,
  PermitContextError: () => PermitContextError,
  PermitError: () => PermitError,
  PermitPDPStatusError: () => PermitPDPStatusError,
  ProjectsApi: () => ProjectsApi2,
  ResourceActionGroupsApi: () => ResourceActionGroupsApi2,
  ResourceActionsApi: () => ResourceActionsApi2,
  ResourceAttributesApi: () => ResourceAttributesApi2,
  ResourcesApi: () => ResourcesApi2,
  RoleAssignmentsApi: () => RoleAssignmentsApi2,
  RolesApi: () => RolesApi2,
  TenantsApi: () => TenantsApi2,
  UsersApi: () => UsersApi2
});
module.exports = __toCommonJS(index_exports);

// src/openapi/api/apikeys-api.ts
var import_axios2 = __toESM(require("axios"));

// src/openapi/base.ts
var import_axios = __toESM(require("axios"));
var BASE_PATH = "http://localhost".replace(/\/+$/, "");
var BaseAPI = class {
  constructor(configuration, basePath = BASE_PATH, axios4 = import_axios.default) {
    this.basePath = basePath;
    this.axios = axios4;
    if (configuration) {
      this.configuration = configuration;
      this.basePath = configuration.basePath || this.basePath;
    }
  }
};
var RequiredError = class extends Error {
  constructor(field, msg) {
    super(msg);
    this.field = field;
    this.name = "RequiredError";
  }
};

// src/openapi/common.ts
var DUMMY_BASE_URL = "https://example.com";
var assertParamExists = function(functionName, paramName, paramValue) {
  if (paramValue === null || paramValue === void 0) {
    throw new RequiredError(
      paramName,
      `Required parameter ${paramName} was null or undefined when calling ${functionName}.`
    );
  }
};
var setBearerAuthToObject = async function(object, configuration) {
  if (configuration && configuration.accessToken) {
    const accessToken = typeof configuration.accessToken === "function" ? await configuration.accessToken() : await configuration.accessToken;
    object["Authorization"] = "Bearer " + accessToken;
  }
};
function setFlattenedQueryParams(urlSearchParams, parameter, key = "") {
  if (typeof parameter === "object") {
    if (Array.isArray(parameter)) {
      parameter.forEach((item) => setFlattenedQueryParams(urlSearchParams, item, key));
    } else {
      Object.keys(parameter).forEach(
        (currentKey) => setFlattenedQueryParams(
          urlSearchParams,
          parameter[currentKey],
          `${key}${key !== "" ? "." : ""}${currentKey}`
        )
      );
    }
  } else {
    if (urlSearchParams.has(key)) {
      urlSearchParams.append(key, parameter);
    } else {
      urlSearchParams.set(key, parameter);
    }
  }
}
var setSearchParams = function(url, ...objects) {
  const searchParams = new URLSearchParams(url.search);
  setFlattenedQueryParams(searchParams, objects);
  url.search = searchParams.toString();
};
var serializeDataIfNeeded = function(value, requestOptions, configuration) {
  const nonString = typeof value !== "string";
  const needsSerialization = nonString && configuration && configuration.isJsonMime ? configuration.isJsonMime(requestOptions.headers["Content-Type"]) : nonString;
  return needsSerialization ? JSON.stringify(value !== void 0 ? value : {}) : value || "";
};
var toPathString = function(url) {
  return url.pathname + url.search + url.hash;
};
var createRequestFunction = function(axiosArgs, globalAxios39, BASE_PATH2, configuration) {
  return (axios4 = globalAxios39, basePath = BASE_PATH2) => {
    const axiosRequestArgs = {
      ...axiosArgs.options,
      url: ((configuration == null ? void 0 : configuration.basePath) || basePath) + axiosArgs.url
    };
    return axios4.request(axiosRequestArgs);
  };
};

// src/openapi/api/apikeys-api.ts
var APIKeysApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * Creates a new api_key under the active organization.
     * @summary Create Api Key
     * @param {APIKeyCreate} aPIKeyCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createApiKey: async (aPIKeyCreate, options = {}) => {
      assertParamExists("createApiKey", "aPIKeyCreate", aPIKeyCreate);
      const localVarPath = `/v2/api-key`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        aPIKeyCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes the api_key and all its related data.
     * @summary Delete Api Key
     * @param {string} apiKeyId The unique id of the API key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteApiKey: async (apiKeyId, options = {}) => {
      assertParamExists("deleteApiKey", "apiKeyId", apiKeyId);
      const localVarPath = `/v2/api-key/{api_key_id}`.replace(
        `{${"api_key_id"}}`,
        encodeURIComponent(String(apiKeyId))
      );
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Gets a single api_key matching the given api_key_id, if such api_key exists.
     * @summary Get Api Key
     * @param {string} apiKeyId The unique id of the API key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getApiKey: async (apiKeyId, options = {}) => {
      assertParamExists("getApiKey", "apiKeyId", apiKeyId);
      const localVarPath = `/v2/api-key/{api_key_id}`.replace(
        `{${"api_key_id"}}`,
        encodeURIComponent(String(apiKeyId))
      );
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Get Api Key Scope
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getApiKeyScope: async (options = {}) => {
      const localVarPath = `/v2/api-key/scope`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Get Environment Api Key
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEnvironmentApiKey: async (projId, envId, options = {}) => {
      assertParamExists("getEnvironmentApiKey", "projId", projId);
      assertParamExists("getEnvironmentApiKey", "envId", envId);
      const localVarPath = `/v2/api-key/{proj_id}/{env_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Lists all the api_keys under the active organization.
     * @summary List Api Keys
     * @param {MemberAccessObj} [objectType]
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listApiKeys: async (objectType, page, perPage, options = {}) => {
      const localVarPath = `/v2/api-key`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (objectType !== void 0) {
        localVarQueryParameter["object_type"] = objectType;
      }
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Rotates the API key of the PDP container with id `pdp_id`.  The rotation of the API key revokes the old API key and issues a new API key to the PDP.
     * @summary Rotate API Key
     * @param {string} apiKeyId The unique id of the API key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rotateApiKey: async (apiKeyId, options = {}) => {
      assertParamExists("rotateApiKey", "apiKeyId", apiKeyId);
      const localVarPath = `/v2/api-key/{api_key_id}/rotate-secret`.replace(
        `{${"api_key_id"}}`,
        encodeURIComponent(String(apiKeyId))
      );
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var APIKeysApiFp = function(configuration) {
  const localVarAxiosParamCreator = APIKeysApiAxiosParamCreator(configuration);
  return {
    /**
     * Creates a new api_key under the active organization.
     * @summary Create Api Key
     * @param {APIKeyCreate} aPIKeyCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createApiKey(aPIKeyCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createApiKey(aPIKeyCreate, options);
      return createRequestFunction(localVarAxiosArgs, import_axios2.default, BASE_PATH, configuration);
    },
    /**
     * Deletes the api_key and all its related data.
     * @summary Delete Api Key
     * @param {string} apiKeyId The unique id of the API key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteApiKey(apiKeyId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApiKey(apiKeyId, options);
      return createRequestFunction(localVarAxiosArgs, import_axios2.default, BASE_PATH, configuration);
    },
    /**
     * Gets a single api_key matching the given api_key_id, if such api_key exists.
     * @summary Get Api Key
     * @param {string} apiKeyId The unique id of the API key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getApiKey(apiKeyId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getApiKey(apiKeyId, options);
      return createRequestFunction(localVarAxiosArgs, import_axios2.default, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get Api Key Scope
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getApiKeyScope(options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getApiKeyScope(options);
      return createRequestFunction(localVarAxiosArgs, import_axios2.default, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get Environment Api Key
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEnvironmentApiKey(projId, envId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getEnvironmentApiKey(
        projId,
        envId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios2.default, BASE_PATH, configuration);
    },
    /**
     * Lists all the api_keys under the active organization.
     * @summary List Api Keys
     * @param {MemberAccessObj} [objectType]
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listApiKeys(objectType, page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listApiKeys(
        objectType,
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios2.default, BASE_PATH, configuration);
    },
    /**
     * Rotates the API key of the PDP container with id `pdp_id`.  The rotation of the API key revokes the old API key and issues a new API key to the PDP.
     * @summary Rotate API Key
     * @param {string} apiKeyId The unique id of the API key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async rotateApiKey(apiKeyId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.rotateApiKey(apiKeyId, options);
      return createRequestFunction(localVarAxiosArgs, import_axios2.default, BASE_PATH, configuration);
    }
  };
};
var APIKeysApi = class extends BaseAPI {
  /**
   * Creates a new api_key under the active organization.
   * @summary Create Api Key
   * @param {APIKeysApiCreateApiKeyRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIKeysApi
   */
  createApiKey(requestParameters, options) {
    return APIKeysApiFp(this.configuration).createApiKey(requestParameters.aPIKeyCreate, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Deletes the api_key and all its related data.
   * @summary Delete Api Key
   * @param {APIKeysApiDeleteApiKeyRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIKeysApi
   */
  deleteApiKey(requestParameters, options) {
    return APIKeysApiFp(this.configuration).deleteApiKey(requestParameters.apiKeyId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Gets a single api_key matching the given api_key_id, if such api_key exists.
   * @summary Get Api Key
   * @param {APIKeysApiGetApiKeyRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIKeysApi
   */
  getApiKey(requestParameters, options) {
    return APIKeysApiFp(this.configuration).getApiKey(requestParameters.apiKeyId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Get Api Key Scope
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIKeysApi
   */
  getApiKeyScope(options) {
    return APIKeysApiFp(this.configuration).getApiKeyScope(options).then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Get Environment Api Key
   * @param {APIKeysApiGetEnvironmentApiKeyRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIKeysApi
   */
  getEnvironmentApiKey(requestParameters, options) {
    return APIKeysApiFp(this.configuration).getEnvironmentApiKey(requestParameters.projId, requestParameters.envId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Lists all the api_keys under the active organization.
   * @summary List Api Keys
   * @param {APIKeysApiListApiKeysRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIKeysApi
   */
  listApiKeys(requestParameters = {}, options) {
    return APIKeysApiFp(this.configuration).listApiKeys(
      requestParameters.objectType,
      requestParameters.page,
      requestParameters.perPage,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Rotates the API key of the PDP container with id `pdp_id`.  The rotation of the API key revokes the old API key and issues a new API key to the PDP.
   * @summary Rotate API Key
   * @param {APIKeysApiRotateApiKeyRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIKeysApi
   */
  rotateApiKey(requestParameters, options) {
    return APIKeysApiFp(this.configuration).rotateApiKey(requestParameters.apiKeyId, options).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/audit-elements-data-api.ts
var import_axios3 = __toESM(require("axios"));

// src/openapi/api/audit-logs-api.ts
var import_axios4 = __toESM(require("axios"));

// src/openapi/api/authentication-api.ts
var import_axios5 = __toESM(require("axios"));
var AuthenticationApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * The dev-login endpoints allows a developer inside permit.io to log in with an email address.  THIS IS ONLY AVAILABLE IN DEV MODE.
     * @summary (DEV MODE) Login
     * @param {DevLogin} devLogin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    devLogin: async (devLogin, options = {}) => {
      assertParamExists("devLogin", "devLogin", devLogin);
      const localVarPath = `/v2/auth/devlogin`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        devLogin,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Elements Fe Login As
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {UserFELoginRequestInput} userFELoginRequestInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    elementsFeLoginAs: async (envId, userFELoginRequestInput, options = {}) => {
      assertParamExists("elementsFeLoginAs", "envId", envId);
      assertParamExists("elementsFeLoginAs", "userFELoginRequestInput", userFELoginRequestInput);
      const localVarPath = `/v2/auth/{env_id}/elements_fe_login_as`.replace(
        `{${"env_id"}}`,
        encodeURIComponent(String(envId))
      );
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userFELoginRequestInput,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Elements Login As
     * @param {UserLoginRequestInput} userLoginRequestInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    elementsLoginAs: async (userLoginRequestInput, options = {}) => {
      assertParamExists("elementsLoginAs", "userLoginRequestInput", userLoginRequestInput);
      const localVarPath = `/v2/auth/elements_login_as`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userLoginRequestInput,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * The login endpoint allows the frontend app to exchange a user JWT with a user session. The user session is stored on an httpOnly + secure cookie.
     * @summary Login
     * @param {string} [inviteCode] An optional invite code to an existing organization. If the invite code is provided and is valid, the member will gain access to that organization.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    login: async (inviteCode, options = {}) => {
      const localVarPath = `/v2/auth/login`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (inviteCode !== void 0) {
        localVarQueryParameter["invite_code"] = inviteCode;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * The login endpoint allows the frontend app to exchange a user JWT with a user session. The user session is stored on an httpOnly + secure cookie.
     * @summary Login Elements
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    loginElements: async (token, options = {}) => {
      assertParamExists("loginElements", "token", token);
      const localVarPath = `/v2/auth/login_elements`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      if (token !== void 0) {
        localVarQueryParameter["token"] = token;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * The logout endpoint deletes the session cookie of a logged in user and invalidates cached VCs.
     * @summary Logout Get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logoutGet: async (options = {}) => {
      const localVarPath = `/v2/auth/logout`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * The logout endpoint deletes the session cookie of a logged in user and invalidates cached VCs.
     * @summary Logout Post
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logoutPost: async (options = {}) => {
      const localVarPath = `/v2/auth/logout`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Me
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    me: async (options = {}) => {
      const localVarPath = `/v2/auth/me`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Allows the user to switch his active organization (manipulates the user\'s login session).  This route will return a new login cookie to the user.
     * @summary Switch Organization
     * @param {string} orgId the organization id the user wishes to switch to as the active org on the session
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    switchOrganization: async (orgId, options = {}) => {
      assertParamExists("switchOrganization", "orgId", orgId);
      const localVarPath = `/v2/auth/switch_org/{org_id}`.replace(
        `{${"org_id"}}`,
        encodeURIComponent(String(orgId))
      );
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var AuthenticationApiFp = function(configuration) {
  const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration);
  return {
    /**
     * The dev-login endpoints allows a developer inside permit.io to log in with an email address.  THIS IS ONLY AVAILABLE IN DEV MODE.
     * @summary (DEV MODE) Login
     * @param {DevLogin} devLogin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async devLogin(devLogin, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.devLogin(devLogin, options);
      return createRequestFunction(localVarAxiosArgs, import_axios5.default, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Elements Fe Login As
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {UserFELoginRequestInput} userFELoginRequestInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async elementsFeLoginAs(envId, userFELoginRequestInput, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.elementsFeLoginAs(
        envId,
        userFELoginRequestInput,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios5.default, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Elements Login As
     * @param {UserLoginRequestInput} userLoginRequestInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async elementsLoginAs(userLoginRequestInput, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.elementsLoginAs(
        userLoginRequestInput,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios5.default, BASE_PATH, configuration);
    },
    /**
     * The login endpoint allows the frontend app to exchange a user JWT with a user session. The user session is stored on an httpOnly + secure cookie.
     * @summary Login
     * @param {string} [inviteCode] An optional invite code to an existing organization. If the invite code is provided and is valid, the member will gain access to that organization.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async login(inviteCode, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.login(inviteCode, options);
      return createRequestFunction(localVarAxiosArgs, import_axios5.default, BASE_PATH, configuration);
    },
    /**
     * The login endpoint allows the frontend app to exchange a user JWT with a user session. The user session is stored on an httpOnly + secure cookie.
     * @summary Login Elements
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async loginElements(token, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.loginElements(token, options);
      return createRequestFunction(localVarAxiosArgs, import_axios5.default, BASE_PATH, configuration);
    },
    /**
     * The logout endpoint deletes the session cookie of a logged in user and invalidates cached VCs.
     * @summary Logout Get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async logoutGet(options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.logoutGet(options);
      return createRequestFunction(localVarAxiosArgs, import_axios5.default, BASE_PATH, configuration);
    },
    /**
     * The logout endpoint deletes the session cookie of a logged in user and invalidates cached VCs.
     * @summary Logout Post
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async logoutPost(options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.logoutPost(options);
      return createRequestFunction(localVarAxiosArgs, import_axios5.default, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Me
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async me(options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.me(options);
      return createRequestFunction(localVarAxiosArgs, import_axios5.default, BASE_PATH, configuration);
    },
    /**
     * Allows the user to switch his active organization (manipulates the user\'s login session).  This route will return a new login cookie to the user.
     * @summary Switch Organization
     * @param {string} orgId the organization id the user wishes to switch to as the active org on the session
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async switchOrganization(orgId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.switchOrganization(orgId, options);
      return createRequestFunction(localVarAxiosArgs, import_axios5.default, BASE_PATH, configuration);
    }
  };
};
var AuthenticationApi = class extends BaseAPI {
  /**
   * The dev-login endpoints allows a developer inside permit.io to log in with an email address.  THIS IS ONLY AVAILABLE IN DEV MODE.
   * @summary (DEV MODE) Login
   * @param {AuthenticationApiDevLoginRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationApi
   */
  devLogin(requestParameters, options) {
    return AuthenticationApiFp(this.configuration).devLogin(requestParameters.devLogin, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Elements Fe Login As
   * @param {AuthenticationApiElementsFeLoginAsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationApi
   */
  elementsFeLoginAs(requestParameters, options) {
    return AuthenticationApiFp(this.configuration).elementsFeLoginAs(
      requestParameters.envId,
      requestParameters.userFELoginRequestInput,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Elements Login As
   * @param {AuthenticationApiElementsLoginAsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationApi
   */
  elementsLoginAs(requestParameters, options) {
    return AuthenticationApiFp(this.configuration).elementsLoginAs(requestParameters.userLoginRequestInput, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * The login endpoint allows the frontend app to exchange a user JWT with a user session. The user session is stored on an httpOnly + secure cookie.
   * @summary Login
   * @param {AuthenticationApiLoginRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationApi
   */
  login(requestParameters = {}, options) {
    return AuthenticationApiFp(this.configuration).login(requestParameters.inviteCode, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * The login endpoint allows the frontend app to exchange a user JWT with a user session. The user session is stored on an httpOnly + secure cookie.
   * @summary Login Elements
   * @param {AuthenticationApiLoginElementsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationApi
   */
  loginElements(requestParameters, options) {
    return AuthenticationApiFp(this.configuration).loginElements(requestParameters.token, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * The logout endpoint deletes the session cookie of a logged in user and invalidates cached VCs.
   * @summary Logout Get
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationApi
   */
  logoutGet(options) {
    return AuthenticationApiFp(this.configuration).logoutGet(options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * The logout endpoint deletes the session cookie of a logged in user and invalidates cached VCs.
   * @summary Logout Post
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationApi
   */
  logoutPost(options) {
    return AuthenticationApiFp(this.configuration).logoutPost(options).then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Me
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationApi
   */
  me(options) {
    return AuthenticationApiFp(this.configuration).me(options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Allows the user to switch his active organization (manipulates the user\'s login session).  This route will return a new login cookie to the user.
   * @summary Switch Organization
   * @param {AuthenticationApiSwitchOrganizationRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationApi
   */
  switchOrganization(requestParameters, options) {
    return AuthenticationApiFp(this.configuration).switchOrganization(requestParameters.orgId, options).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/condition-set-rules-api.ts
var import_axios6 = __toESM(require("axios"));
var ConditionSetRulesApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * Grant permissions to a user set *on* a resource set.  If the permission is already granted, it is skipped.
     * @summary Assign Set Permissions
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ConditionSetRuleCreate} conditionSetRuleCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    assignSetPermissions: async (projId, envId, conditionSetRuleCreate, options = {}) => {
      assertParamExists("assignSetPermissions", "projId", projId);
      assertParamExists("assignSetPermissions", "envId", envId);
      assertParamExists("assignSetPermissions", "conditionSetRuleCreate", conditionSetRuleCreate);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/set_rules`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        conditionSetRuleCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Lists the condition set rules matching the filter. - If the `user_set` filter is present, will only return the permissions set of that user set. - If the `permission` filter is present, will only return the permissions sets that equals to the queried permission. - If the `resource_set` filter is present, will only return the permissions set of that resource set.
     * @summary List Set Permissions
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} [userSet] optional user set filter, will only return rules where the permission is granted to this user set
     * @param {string} [permission] optional permission filter, will only return condition set rules granting this permission
     * @param {string} [resourceSet] optional resource set filter, will only return rules where the permission is granted on this resource set
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listSetPermissions: async (projId, envId, userSet, permission, resourceSet, page, perPage, options = {}) => {
      assertParamExists("listSetPermissions", "projId", projId);
      assertParamExists("listSetPermissions", "envId", envId);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/set_rules`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (userSet !== void 0) {
        localVarQueryParameter["user_set"] = userSet;
      }
      if (permission !== void 0) {
        localVarQueryParameter["permission"] = permission;
      }
      if (resourceSet !== void 0) {
        localVarQueryParameter["resource_set"] = resourceSet;
      }
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Revokes permissions to a user set *on* a resource set.  If the permission is not granted, it is skipped.
     * @summary Unassign Set Permissions
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ConditionSetRuleRemove} conditionSetRuleRemove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unassignSetPermissions: async (projId, envId, conditionSetRuleRemove, options = {}) => {
      assertParamExists("unassignSetPermissions", "projId", projId);
      assertParamExists("unassignSetPermissions", "envId", envId);
      assertParamExists("unassignSetPermissions", "conditionSetRuleRemove", conditionSetRuleRemove);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/set_rules`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        conditionSetRuleRemove,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var ConditionSetRulesApiFp = function(configuration) {
  const localVarAxiosParamCreator = ConditionSetRulesApiAxiosParamCreator(configuration);
  return {
    /**
     * Grant permissions to a user set *on* a resource set.  If the permission is already granted, it is skipped.
     * @summary Assign Set Permissions
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ConditionSetRuleCreate} conditionSetRuleCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async assignSetPermissions(projId, envId, conditionSetRuleCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.assignSetPermissions(
        projId,
        envId,
        conditionSetRuleCreate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios6.default, BASE_PATH, configuration);
    },
    /**
     * Lists the condition set rules matching the filter. - If the `user_set` filter is present, will only return the permissions set of that user set. - If the `permission` filter is present, will only return the permissions sets that equals to the queried permission. - If the `resource_set` filter is present, will only return the permissions set of that resource set.
     * @summary List Set Permissions
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} [userSet] optional user set filter, will only return rules where the permission is granted to this user set
     * @param {string} [permission] optional permission filter, will only return condition set rules granting this permission
     * @param {string} [resourceSet] optional resource set filter, will only return rules where the permission is granted on this resource set
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listSetPermissions(projId, envId, userSet, permission, resourceSet, page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listSetPermissions(
        projId,
        envId,
        userSet,
        permission,
        resourceSet,
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios6.default, BASE_PATH, configuration);
    },
    /**
     * Revokes permissions to a user set *on* a resource set.  If the permission is not granted, it is skipped.
     * @summary Unassign Set Permissions
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ConditionSetRuleRemove} conditionSetRuleRemove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async unassignSetPermissions(projId, envId, conditionSetRuleRemove, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.unassignSetPermissions(
        projId,
        envId,
        conditionSetRuleRemove,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios6.default, BASE_PATH, configuration);
    }
  };
};
var ConditionSetRulesApi = class extends BaseAPI {
  /**
   * Grant permissions to a user set *on* a resource set.  If the permission is already granted, it is skipped.
   * @summary Assign Set Permissions
   * @param {ConditionSetRulesApiAssignSetPermissionsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConditionSetRulesApi
   */
  assignSetPermissions(requestParameters, options) {
    return ConditionSetRulesApiFp(this.configuration).assignSetPermissions(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.conditionSetRuleCreate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Lists the condition set rules matching the filter. - If the `user_set` filter is present, will only return the permissions set of that user set. - If the `permission` filter is present, will only return the permissions sets that equals to the queried permission. - If the `resource_set` filter is present, will only return the permissions set of that resource set.
   * @summary List Set Permissions
   * @param {ConditionSetRulesApiListSetPermissionsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConditionSetRulesApi
   */
  listSetPermissions(requestParameters, options) {
    return ConditionSetRulesApiFp(this.configuration).listSetPermissions(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.userSet,
      requestParameters.permission,
      requestParameters.resourceSet,
      requestParameters.page,
      requestParameters.perPage,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Revokes permissions to a user set *on* a resource set.  If the permission is not granted, it is skipped.
   * @summary Unassign Set Permissions
   * @param {ConditionSetRulesApiUnassignSetPermissionsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConditionSetRulesApi
   */
  unassignSetPermissions(requestParameters, options) {
    return ConditionSetRulesApiFp(this.configuration).unassignSetPermissions(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.conditionSetRuleRemove,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/condition-sets-api.ts
var import_axios7 = __toESM(require("axios"));
var ConditionSetsApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * Creates a new condition set (can be either a user set or a resource set).
     * @summary Create Condition Set
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ConditionSetCreate} conditionSetCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createConditionSet: async (projId, envId, conditionSetCreate, options = {}) => {
      assertParamExists("createConditionSet", "projId", projId);
      assertParamExists("createConditionSet", "envId", envId);
      assertParamExists("createConditionSet", "conditionSetCreate", conditionSetCreate);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/condition_sets`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        conditionSetCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes a condition set and all its related data. This includes any permissions granted to said condition set (i.e: any matching condition set rules).
     * @summary Delete Condition Set
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} conditionSetId Either the unique id of the condition set, or the URL-friendly key of the condition set (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteConditionSet: async (projId, envId, conditionSetId, options = {}) => {
      assertParamExists("deleteConditionSet", "projId", projId);
      assertParamExists("deleteConditionSet", "envId", envId);
      assertParamExists("deleteConditionSet", "conditionSetId", conditionSetId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/condition_sets/{condition_set_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"condition_set_id"}}`, encodeURIComponent(String(conditionSetId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Gets a single condition set, if such condition set exists.
     * @summary Get Condition Set
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} conditionSetId Either the unique id of the condition set, or the URL-friendly key of the condition set (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConditionSet: async (projId, envId, conditionSetId, options = {}) => {
      assertParamExists("getConditionSet", "projId", projId);
      assertParamExists("getConditionSet", "envId", envId);
      assertParamExists("getConditionSet", "conditionSetId", conditionSetId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/condition_sets/{condition_set_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"condition_set_id"}}`, encodeURIComponent(String(conditionSetId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Gets all ancestors (parent, parent of parent, and so on)
     * @summary Get Condition Set Ancestors
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} conditionSetId Either the unique id of the condition set, or the URL-friendly key of the condition set (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConditionSetAncestors: async (projId, envId, conditionSetId, page, perPage, options = {}) => {
      assertParamExists("getConditionSetAncestors", "projId", projId);
      assertParamExists("getConditionSetAncestors", "envId", envId);
      assertParamExists("getConditionSetAncestors", "conditionSetId", conditionSetId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/condition_sets/{condition_set_id}/ancestors`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"condition_set_id"}}`, encodeURIComponent(String(conditionSetId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Gets all descendants (children, children of children, and so on)
     * @summary Get Condition Set Descendants
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} conditionSetId Either the unique id of the condition set, or the URL-friendly key of the condition set (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConditionSetDescendants: async (projId, envId, conditionSetId, page, perPage, options = {}) => {
      assertParamExists("getConditionSetDescendants", "projId", projId);
      assertParamExists("getConditionSetDescendants", "envId", envId);
      assertParamExists("getConditionSetDescendants", "conditionSetId", conditionSetId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/condition_sets/{condition_set_id}/descendants`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"condition_set_id"}}`, encodeURIComponent(String(conditionSetId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Get Condition Set Possible Parents
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} conditionSetId Either the unique id of the condition set, or the URL-friendly key of the condition set (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConditionSetPossibleParents: async (projId, envId, conditionSetId, page, perPage, options = {}) => {
      assertParamExists("getConditionSetPossibleParents", "projId", projId);
      assertParamExists("getConditionSetPossibleParents", "envId", envId);
      assertParamExists("getConditionSetPossibleParents", "conditionSetId", conditionSetId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/condition_sets/{condition_set_id}/possible_parents`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"condition_set_id"}}`, encodeURIComponent(String(conditionSetId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Lists all condition sets matching a filter.
     * @summary List Condition Sets
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ConditionSetType} [type] if provided, will return only the condition sets of the specified type. e.g: only user sets.
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listConditionSets: async (projId, envId, type, page, perPage, options = {}) => {
      assertParamExists("listConditionSets", "projId", projId);
      assertParamExists("listConditionSets", "envId", envId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/condition_sets`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (type !== void 0) {
        localVarQueryParameter["type"] = type;
      }
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Partially updates a condition set. Fields that will be provided will be completely overwritten.
     * @summary Update Condition Set
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} conditionSetId Either the unique id of the condition set, or the URL-friendly key of the condition set (i.e: the \&quot;slug\&quot;).
     * @param {ConditionSetUpdate} conditionSetUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateConditionSet: async (projId, envId, conditionSetId, conditionSetUpdate, options = {}) => {
      assertParamExists("updateConditionSet", "projId", projId);
      assertParamExists("updateConditionSet", "envId", envId);
      assertParamExists("updateConditionSet", "conditionSetId", conditionSetId);
      assertParamExists("updateConditionSet", "conditionSetUpdate", conditionSetUpdate);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/condition_sets/{condition_set_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"condition_set_id"}}`, encodeURIComponent(String(conditionSetId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        conditionSetUpdate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var ConditionSetsApiFp = function(configuration) {
  const localVarAxiosParamCreator = ConditionSetsApiAxiosParamCreator(configuration);
  return {
    /**
     * Creates a new condition set (can be either a user set or a resource set).
     * @summary Create Condition Set
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ConditionSetCreate} conditionSetCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createConditionSet(projId, envId, conditionSetCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createConditionSet(
        projId,
        envId,
        conditionSetCreate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios7.default, BASE_PATH, configuration);
    },
    /**
     * Deletes a condition set and all its related data. This includes any permissions granted to said condition set (i.e: any matching condition set rules).
     * @summary Delete Condition Set
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} conditionSetId Either the unique id of the condition set, or the URL-friendly key of the condition set (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteConditionSet(projId, envId, conditionSetId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteConditionSet(
        projId,
        envId,
        conditionSetId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios7.default, BASE_PATH, configuration);
    },
    /**
     * Gets a single condition set, if such condition set exists.
     * @summary Get Condition Set
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} conditionSetId Either the unique id of the condition set, or the URL-friendly key of the condition set (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getConditionSet(projId, envId, conditionSetId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getConditionSet(
        projId,
        envId,
        conditionSetId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios7.default, BASE_PATH, configuration);
    },
    /**
     * Gets all ancestors (parent, parent of parent, and so on)
     * @summary Get Condition Set Ancestors
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} conditionSetId Either the unique id of the condition set, or the URL-friendly key of the condition set (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getConditionSetAncestors(projId, envId, conditionSetId, page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getConditionSetAncestors(
        projId,
        envId,
        conditionSetId,
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios7.default, BASE_PATH, configuration);
    },
    /**
     * Gets all descendants (children, children of children, and so on)
     * @summary Get Condition Set Descendants
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} conditionSetId Either the unique id of the condition set, or the URL-friendly key of the condition set (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getConditionSetDescendants(projId, envId, conditionSetId, page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getConditionSetDescendants(
        projId,
        envId,
        conditionSetId,
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios7.default, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get Condition Set Possible Parents
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} conditionSetId Either the unique id of the condition set, or the URL-friendly key of the condition set (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getConditionSetPossibleParents(projId, envId, conditionSetId, page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getConditionSetPossibleParents(
        projId,
        envId,
        conditionSetId,
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios7.default, BASE_PATH, configuration);
    },
    /**
     * Lists all condition sets matching a filter.
     * @summary List Condition Sets
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ConditionSetType} [type] if provided, will return only the condition sets of the specified type. e.g: only user sets.
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listConditionSets(projId, envId, type, page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listConditionSets(
        projId,
        envId,
        type,
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios7.default, BASE_PATH, configuration);
    },
    /**
     * Partially updates a condition set. Fields that will be provided will be completely overwritten.
     * @summary Update Condition Set
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} conditionSetId Either the unique id of the condition set, or the URL-friendly key of the condition set (i.e: the \&quot;slug\&quot;).
     * @param {ConditionSetUpdate} conditionSetUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateConditionSet(projId, envId, conditionSetId, conditionSetUpdate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateConditionSet(
        projId,
        envId,
        conditionSetId,
        conditionSetUpdate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios7.default, BASE_PATH, configuration);
    }
  };
};
var ConditionSetsApi = class extends BaseAPI {
  /**
   * Creates a new condition set (can be either a user set or a resource set).
   * @summary Create Condition Set
   * @param {ConditionSetsApiCreateConditionSetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConditionSetsApi
   */
  createConditionSet(requestParameters, options) {
    return ConditionSetsApiFp(this.configuration).createConditionSet(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.conditionSetCreate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Deletes a condition set and all its related data. This includes any permissions granted to said condition set (i.e: any matching condition set rules).
   * @summary Delete Condition Set
   * @param {ConditionSetsApiDeleteConditionSetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConditionSetsApi
   */
  deleteConditionSet(requestParameters, options) {
    return ConditionSetsApiFp(this.configuration).deleteConditionSet(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.conditionSetId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Gets a single condition set, if such condition set exists.
   * @summary Get Condition Set
   * @param {ConditionSetsApiGetConditionSetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConditionSetsApi
   */
  getConditionSet(requestParameters, options) {
    return ConditionSetsApiFp(this.configuration).getConditionSet(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.conditionSetId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Gets all ancestors (parent, parent of parent, and so on)
   * @summary Get Condition Set Ancestors
   * @param {ConditionSetsApiGetConditionSetAncestorsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConditionSetsApi
   */
  getConditionSetAncestors(requestParameters, options) {
    return ConditionSetsApiFp(this.configuration).getConditionSetAncestors(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.conditionSetId,
      requestParameters.page,
      requestParameters.perPage,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Gets all descendants (children, children of children, and so on)
   * @summary Get Condition Set Descendants
   * @param {ConditionSetsApiGetConditionSetDescendantsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConditionSetsApi
   */
  getConditionSetDescendants(requestParameters, options) {
    return ConditionSetsApiFp(this.configuration).getConditionSetDescendants(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.conditionSetId,
      requestParameters.page,
      requestParameters.perPage,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Get Condition Set Possible Parents
   * @param {ConditionSetsApiGetConditionSetPossibleParentsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConditionSetsApi
   */
  getConditionSetPossibleParents(requestParameters, options) {
    return ConditionSetsApiFp(this.configuration).getConditionSetPossibleParents(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.conditionSetId,
      requestParameters.page,
      requestParameters.perPage,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Lists all condition sets matching a filter.
   * @summary List Condition Sets
   * @param {ConditionSetsApiListConditionSetsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConditionSetsApi
   */
  listConditionSets(requestParameters, options) {
    return ConditionSetsApiFp(this.configuration).listConditionSets(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.type,
      requestParameters.page,
      requestParameters.perPage,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Partially updates a condition set. Fields that will be provided will be completely overwritten.
   * @summary Update Condition Set
   * @param {ConditionSetsApiUpdateConditionSetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConditionSetsApi
   */
  updateConditionSet(requestParameters, options) {
    return ConditionSetsApiFp(this.configuration).updateConditionSet(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.conditionSetId,
      requestParameters.conditionSetUpdate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/decision-logs-api.ts
var import_axios8 = __toESM(require("axios"));

// src/openapi/api/decision-logs-ingress-api.ts
var import_axios9 = __toESM(require("axios"));

// src/openapi/api/default-api.ts
var import_axios10 = __toESM(require("axios"));

// src/openapi/api/elements-configs-api.ts
var import_axios11 = __toESM(require("axios"));

// src/openapi/api/environments-api.ts
var import_axios12 = __toESM(require("axios"));
var EnvironmentsApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * Copy environment  This endpoint either duplicates an existing environment to a new environment in the same project, or copies from an existing environment to another existing environment.  The `scope` object controls which objects will be copied to the target environment.  To clone to a new environment, the user must have write permissions to the containing project. To clone into an existing environment, the user must have write permissions to the target environment.  Copying environments across projects or organizations is not allowed.
     * @summary Copy Environment
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {EnvironmentCopy} environmentCopy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    copyEnvironment: async (projId, envId, environmentCopy, options = {}) => {
      assertParamExists("copyEnvironment", "projId", projId);
      assertParamExists("copyEnvironment", "envId", envId);
      assertParamExists("copyEnvironment", "environmentCopy", environmentCopy);
      const localVarPath = `/v2/projects/{proj_id}/envs/{env_id}/copy`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        environmentCopy,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Creates a new environment under a given project.
     * @summary Create Environment
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {EnvironmentCreate} environmentCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createEnvironment: async (projId, environmentCreate, options = {}) => {
      assertParamExists("createEnvironment", "projId", projId);
      assertParamExists("createEnvironment", "environmentCreate", environmentCreate);
      const localVarPath = `/v2/projects/{proj_id}/envs`.replace(
        `{${"proj_id"}}`,
        encodeURIComponent(String(projId))
      );
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        environmentCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes an environment and all its related data.
     * @summary Delete Environment
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteEnvironment: async (projId, envId, options = {}) => {
      assertParamExists("deleteEnvironment", "projId", projId);
      assertParamExists("deleteEnvironment", "envId", envId);
      const localVarPath = `/v2/projects/{proj_id}/envs/{env_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Gets a single environment matching the given env_id, if such environment exists.
     * @summary Get Environment
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEnvironment: async (projId, envId, options = {}) => {
      assertParamExists("getEnvironment", "projId", projId);
      assertParamExists("getEnvironment", "envId", envId);
      const localVarPath = `/v2/projects/{proj_id}/envs/{env_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Lists all the environments under a given project.
     * @summary List Environments
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listEnvironments: async (projId, page, perPage, options = {}) => {
      assertParamExists("listEnvironments", "projId", projId);
      const localVarPath = `/v2/projects/{proj_id}/envs`.replace(
        `{${"proj_id"}}`,
        encodeURIComponent(String(projId))
      );
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Stats Environments
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    statsEnvironments: async (projId, envId, options = {}) => {
      assertParamExists("statsEnvironments", "projId", projId);
      assertParamExists("statsEnvironments", "envId", envId);
      const localVarPath = `/v2/projects/{proj_id}/envs/{env_id}/stats`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Updates the environment.
     * @summary Update Environment
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {EnvironmentUpdate} environmentUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateEnvironment: async (projId, envId, environmentUpdate, options = {}) => {
      assertParamExists("updateEnvironment", "projId", projId);
      assertParamExists("updateEnvironment", "envId", envId);
      assertParamExists("updateEnvironment", "environmentUpdate", environmentUpdate);
      const localVarPath = `/v2/projects/{proj_id}/envs/{env_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        environmentUpdate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var EnvironmentsApiFp = function(configuration) {
  const localVarAxiosParamCreator = EnvironmentsApiAxiosParamCreator(configuration);
  return {
    /**
     * Copy environment  This endpoint either duplicates an existing environment to a new environment in the same project, or copies from an existing environment to another existing environment.  The `scope` object controls which objects will be copied to the target environment.  To clone to a new environment, the user must have write permissions to the containing project. To clone into an existing environment, the user must have write permissions to the target environment.  Copying environments across projects or organizations is not allowed.
     * @summary Copy Environment
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {EnvironmentCopy} environmentCopy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async copyEnvironment(projId, envId, environmentCopy, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.copyEnvironment(
        projId,
        envId,
        environmentCopy,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios12.default, BASE_PATH, configuration);
    },
    /**
     * Creates a new environment under a given project.
     * @summary Create Environment
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {EnvironmentCreate} environmentCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createEnvironment(projId, environmentCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createEnvironment(
        projId,
        environmentCreate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios12.default, BASE_PATH, configuration);
    },
    /**
     * Deletes an environment and all its related data.
     * @summary Delete Environment
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteEnvironment(projId, envId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEnvironment(
        projId,
        envId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios12.default, BASE_PATH, configuration);
    },
    /**
     * Gets a single environment matching the given env_id, if such environment exists.
     * @summary Get Environment
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEnvironment(projId, envId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getEnvironment(
        projId,
        envId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios12.default, BASE_PATH, configuration);
    },
    /**
     * Lists all the environments under a given project.
     * @summary List Environments
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listEnvironments(projId, page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listEnvironments(
        projId,
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios12.default, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Stats Environments
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async statsEnvironments(projId, envId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.statsEnvironments(
        projId,
        envId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios12.default, BASE_PATH, configuration);
    },
    /**
     * Updates the environment.
     * @summary Update Environment
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {EnvironmentUpdate} environmentUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateEnvironment(projId, envId, environmentUpdate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateEnvironment(
        projId,
        envId,
        environmentUpdate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios12.default, BASE_PATH, configuration);
    }
  };
};
var EnvironmentsApi = class extends BaseAPI {
  /**
   * Copy environment  This endpoint either duplicates an existing environment to a new environment in the same project, or copies from an existing environment to another existing environment.  The `scope` object controls which objects will be copied to the target environment.  To clone to a new environment, the user must have write permissions to the containing project. To clone into an existing environment, the user must have write permissions to the target environment.  Copying environments across projects or organizations is not allowed.
   * @summary Copy Environment
   * @param {EnvironmentsApiCopyEnvironmentRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EnvironmentsApi
   */
  copyEnvironment(requestParameters, options) {
    return EnvironmentsApiFp(this.configuration).copyEnvironment(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.environmentCopy,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Creates a new environment under a given project.
   * @summary Create Environment
   * @param {EnvironmentsApiCreateEnvironmentRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EnvironmentsApi
   */
  createEnvironment(requestParameters, options) {
    return EnvironmentsApiFp(this.configuration).createEnvironment(requestParameters.projId, requestParameters.environmentCreate, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Deletes an environment and all its related data.
   * @summary Delete Environment
   * @param {EnvironmentsApiDeleteEnvironmentRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EnvironmentsApi
   */
  deleteEnvironment(requestParameters, options) {
    return EnvironmentsApiFp(this.configuration).deleteEnvironment(requestParameters.projId, requestParameters.envId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Gets a single environment matching the given env_id, if such environment exists.
   * @summary Get Environment
   * @param {EnvironmentsApiGetEnvironmentRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EnvironmentsApi
   */
  getEnvironment(requestParameters, options) {
    return EnvironmentsApiFp(this.configuration).getEnvironment(requestParameters.projId, requestParameters.envId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Lists all the environments under a given project.
   * @summary List Environments
   * @param {EnvironmentsApiListEnvironmentsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EnvironmentsApi
   */
  listEnvironments(requestParameters, options) {
    return EnvironmentsApiFp(this.configuration).listEnvironments(
      requestParameters.projId,
      requestParameters.page,
      requestParameters.perPage,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Stats Environments
   * @param {EnvironmentsApiStatsEnvironmentsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EnvironmentsApi
   */
  statsEnvironments(requestParameters, options) {
    return EnvironmentsApiFp(this.configuration).statsEnvironments(requestParameters.projId, requestParameters.envId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Updates the environment.
   * @summary Update Environment
   * @param {EnvironmentsApiUpdateEnvironmentRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EnvironmentsApi
   */
  updateEnvironment(requestParameters, options) {
    return EnvironmentsApiFp(this.configuration).updateEnvironment(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.environmentUpdate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/implicit-grants-api.ts
var import_axios13 = __toESM(require("axios"));
var ImplicitGrantsApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * Creates an implicit grant on a given role
     * @summary Create Implicit Grant
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {DerivedRoleRuleCreate} derivedRoleRuleCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createImplicitGrant: async (projId, envId, resourceId, roleId, derivedRoleRuleCreate, options = {}) => {
      assertParamExists("createImplicitGrant", "projId", projId);
      assertParamExists("createImplicitGrant", "envId", envId);
      assertParamExists("createImplicitGrant", "resourceId", resourceId);
      assertParamExists("createImplicitGrant", "roleId", roleId);
      assertParamExists("createImplicitGrant", "derivedRoleRuleCreate", derivedRoleRuleCreate);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/roles/{role_id}/implicit_grants`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId))).replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        derivedRoleRuleCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes an implicit grant on a given role
     * @summary Delete Implicit Grant
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {DerivedRoleRuleDelete} derivedRoleRuleDelete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteImplicitGrant: async (projId, envId, roleId, resourceId, derivedRoleRuleDelete, options = {}) => {
      assertParamExists("deleteImplicitGrant", "projId", projId);
      assertParamExists("deleteImplicitGrant", "envId", envId);
      assertParamExists("deleteImplicitGrant", "roleId", roleId);
      assertParamExists("deleteImplicitGrant", "resourceId", resourceId);
      assertParamExists("deleteImplicitGrant", "derivedRoleRuleDelete", derivedRoleRuleDelete);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/roles/{role_id}/implicit_grants`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"role_id"}}`, encodeURIComponent(String(roleId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        derivedRoleRuleDelete,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Update the `when` for implicit grants on a given role
     * @summary Update Implicit Grants Conditions
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {PermitBackendSchemasSchemaDerivedRoleDerivedRoleSettings} permitBackendSchemasSchemaDerivedRoleDerivedRoleSettings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateImplicitGrantsConditions: async (projId, envId, resourceId, roleId, permitBackendSchemasSchemaDerivedRoleDerivedRoleSettings, options = {}) => {
      assertParamExists("updateImplicitGrantsConditions", "projId", projId);
      assertParamExists("updateImplicitGrantsConditions", "envId", envId);
      assertParamExists("updateImplicitGrantsConditions", "resourceId", resourceId);
      assertParamExists("updateImplicitGrantsConditions", "roleId", roleId);
      assertParamExists(
        "updateImplicitGrantsConditions",
        "permitBackendSchemasSchemaDerivedRoleDerivedRoleSettings",
        permitBackendSchemasSchemaDerivedRoleDerivedRoleSettings
      );
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/roles/{role_id}/implicit_grants/conditions`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId))).replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        permitBackendSchemasSchemaDerivedRoleDerivedRoleSettings,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var ImplicitGrantsApiFp = function(configuration) {
  const localVarAxiosParamCreator = ImplicitGrantsApiAxiosParamCreator(configuration);
  return {
    /**
     * Creates an implicit grant on a given role
     * @summary Create Implicit Grant
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {DerivedRoleRuleCreate} derivedRoleRuleCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createImplicitGrant(projId, envId, resourceId, roleId, derivedRoleRuleCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createImplicitGrant(
        projId,
        envId,
        resourceId,
        roleId,
        derivedRoleRuleCreate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios13.default, BASE_PATH, configuration);
    },
    /**
     * Deletes an implicit grant on a given role
     * @summary Delete Implicit Grant
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {DerivedRoleRuleDelete} derivedRoleRuleDelete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteImplicitGrant(projId, envId, roleId, resourceId, derivedRoleRuleDelete, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteImplicitGrant(
        projId,
        envId,
        roleId,
        resourceId,
        derivedRoleRuleDelete,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios13.default, BASE_PATH, configuration);
    },
    /**
     * Update the `when` for implicit grants on a given role
     * @summary Update Implicit Grants Conditions
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {PermitBackendSchemasSchemaDerivedRoleDerivedRoleSettings} permitBackendSchemasSchemaDerivedRoleDerivedRoleSettings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateImplicitGrantsConditions(projId, envId, resourceId, roleId, permitBackendSchemasSchemaDerivedRoleDerivedRoleSettings, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateImplicitGrantsConditions(
        projId,
        envId,
        resourceId,
        roleId,
        permitBackendSchemasSchemaDerivedRoleDerivedRoleSettings,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios13.default, BASE_PATH, configuration);
    }
  };
};
var ImplicitGrantsApi = class extends BaseAPI {
  /**
   * Creates an implicit grant on a given role
   * @summary Create Implicit Grant
   * @param {ImplicitGrantsApiCreateImplicitGrantRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ImplicitGrantsApi
   */
  createImplicitGrant(requestParameters, options) {
    return ImplicitGrantsApiFp(this.configuration).createImplicitGrant(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.roleId,
      requestParameters.derivedRoleRuleCreate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Deletes an implicit grant on a given role
   * @summary Delete Implicit Grant
   * @param {ImplicitGrantsApiDeleteImplicitGrantRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ImplicitGrantsApi
   */
  deleteImplicitGrant(requestParameters, options) {
    return ImplicitGrantsApiFp(this.configuration).deleteImplicitGrant(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.roleId,
      requestParameters.resourceId,
      requestParameters.derivedRoleRuleDelete,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Update the `when` for implicit grants on a given role
   * @summary Update Implicit Grants Conditions
   * @param {ImplicitGrantsApiUpdateImplicitGrantsConditionsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ImplicitGrantsApi
   */
  updateImplicitGrantsConditions(requestParameters, options) {
    return ImplicitGrantsApiFp(this.configuration).updateImplicitGrantsConditions(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.roleId,
      requestParameters.permitBackendSchemasSchemaDerivedRoleDerivedRoleSettings,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/instructions-api.ts
var import_axios14 = __toESM(require("axios"));

// src/openapi/api/members-api.ts
var import_axios15 = __toESM(require("axios"));

// src/openapi/api/opaldata-api.ts
var import_axios16 = __toESM(require("axios"));

// src/openapi/api/organizations-api.ts
var import_axios17 = __toESM(require("axios"));

// src/openapi/api/policy-api.ts
var import_axios18 = __toESM(require("axios"));

// src/openapi/api/policy-decision-points-api.ts
var import_axios19 = __toESM(require("axios"));

// src/openapi/api/policy-git-repositories-api.ts
var import_axios20 = __toESM(require("axios"));

// src/openapi/api/projects-api.ts
var import_axios21 = __toESM(require("axios"));
var ProjectsApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * Creates a new project under the active organization.
     * @summary Create Project
     * @param {ProjectCreate} projectCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createProject: async (projectCreate, options = {}) => {
      assertParamExists("createProject", "projectCreate", projectCreate);
      const localVarPath = `/v2/projects`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        projectCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes the project and all its related data.
     * @summary Delete Project
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteProject: async (projId, options = {}) => {
      assertParamExists("deleteProject", "projId", projId);
      const localVarPath = `/v2/projects/{proj_id}`.replace(
        `{${"proj_id"}}`,
        encodeURIComponent(String(projId))
      );
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Gets a single project matching the given proj_id, if such project exists.
     * @summary Get Project
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProject: async (projId, options = {}) => {
      assertParamExists("getProject", "projId", projId);
      const localVarPath = `/v2/projects/{proj_id}`.replace(
        `{${"proj_id"}}`,
        encodeURIComponent(String(projId))
      );
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Lists all the projects under the active organization.
     * @summary List Projects
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listProjects: async (page, perPage, options = {}) => {
      const localVarPath = `/v2/projects`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Updates the project.
     * @summary Update Project
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {ProjectUpdate} projectUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProject: async (projId, projectUpdate, options = {}) => {
      assertParamExists("updateProject", "projId", projId);
      assertParamExists("updateProject", "projectUpdate", projectUpdate);
      const localVarPath = `/v2/projects/{proj_id}`.replace(
        `{${"proj_id"}}`,
        encodeURIComponent(String(projId))
      );
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        projectUpdate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var ProjectsApiFp = function(configuration) {
  const localVarAxiosParamCreator = ProjectsApiAxiosParamCreator(configuration);
  return {
    /**
     * Creates a new project under the active organization.
     * @summary Create Project
     * @param {ProjectCreate} projectCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createProject(projectCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createProject(
        projectCreate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios21.default, BASE_PATH, configuration);
    },
    /**
     * Deletes the project and all its related data.
     * @summary Delete Project
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteProject(projId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProject(projId, options);
      return createRequestFunction(localVarAxiosArgs, import_axios21.default, BASE_PATH, configuration);
    },
    /**
     * Gets a single project matching the given proj_id, if such project exists.
     * @summary Get Project
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getProject(projId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getProject(projId, options);
      return createRequestFunction(localVarAxiosArgs, import_axios21.default, BASE_PATH, configuration);
    },
    /**
     * Lists all the projects under the active organization.
     * @summary List Projects
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listProjects(page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listProjects(
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios21.default, BASE_PATH, configuration);
    },
    /**
     * Updates the project.
     * @summary Update Project
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {ProjectUpdate} projectUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateProject(projId, projectUpdate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateProject(
        projId,
        projectUpdate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios21.default, BASE_PATH, configuration);
    }
  };
};
var ProjectsApi = class extends BaseAPI {
  /**
   * Creates a new project under the active organization.
   * @summary Create Project
   * @param {ProjectsApiCreateProjectRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectsApi
   */
  createProject(requestParameters, options) {
    return ProjectsApiFp(this.configuration).createProject(requestParameters.projectCreate, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Deletes the project and all its related data.
   * @summary Delete Project
   * @param {ProjectsApiDeleteProjectRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectsApi
   */
  deleteProject(requestParameters, options) {
    return ProjectsApiFp(this.configuration).deleteProject(requestParameters.projId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Gets a single project matching the given proj_id, if such project exists.
   * @summary Get Project
   * @param {ProjectsApiGetProjectRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectsApi
   */
  getProject(requestParameters, options) {
    return ProjectsApiFp(this.configuration).getProject(requestParameters.projId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Lists all the projects under the active organization.
   * @summary List Projects
   * @param {ProjectsApiListProjectsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectsApi
   */
  listProjects(requestParameters = {}, options) {
    return ProjectsApiFp(this.configuration).listProjects(requestParameters.page, requestParameters.perPage, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Updates the project.
   * @summary Update Project
   * @param {ProjectsApiUpdateProjectRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectsApi
   */
  updateProject(requestParameters, options) {
    return ProjectsApiFp(this.configuration).updateProject(requestParameters.projId, requestParameters.projectUpdate, options).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/proxy-config-api.ts
var import_axios22 = __toESM(require("axios"));

// src/openapi/api/relationship-tuples-api.ts
var import_axios23 = __toESM(require("axios"));
var RelationshipTuplesApiAxiosParamCreator = function(configuration) {
  return {
    /**
     *
     * @summary Bulk create relationship tuples(EAP)
     * @param {any} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {any} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {RelationshipTupleCreateBulkOperation} relationshipTupleCreateBulkOperation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkCreateRelationshipTuples: async (projId, envId, relationshipTupleCreateBulkOperation, options = {}) => {
      assertParamExists("bulkCreateRelationshipTuples", "projId", projId);
      assertParamExists("bulkCreateRelationshipTuples", "envId", envId);
      assertParamExists(
        "bulkCreateRelationshipTuples",
        "relationshipTupleCreateBulkOperation",
        relationshipTupleCreateBulkOperation
      );
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/relationship_tuples/bulk`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        relationshipTupleCreateBulkOperation,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Bulk Delete Relationship Tuples
     * @param {any} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {any} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {RelationshipTupleDeleteBulkOperation} relationshipTupleDeleteBulkOperation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkDeleteRelationshipTuples: async (projId, envId, relationshipTupleDeleteBulkOperation, options = {}) => {
      assertParamExists("bulkDeleteRelationshipTuples", "projId", projId);
      assertParamExists("bulkDeleteRelationshipTuples", "envId", envId);
      assertParamExists(
        "bulkDeleteRelationshipTuples",
        "relationshipTupleDeleteBulkOperation",
        relationshipTupleDeleteBulkOperation
      );
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/relationship_tuples/bulk`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        relationshipTupleDeleteBulkOperation,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Create a relationship between two resource instances using a relation.
     * @summary Create Relationship Tuple
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {RelationshipTupleCreate} relationshipTupleCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRelationshipTuple: async (projId, envId, relationshipTupleCreate, options = {}) => {
      assertParamExists("createRelationshipTuple", "projId", projId);
      assertParamExists("createRelationshipTuple", "envId", envId);
      assertParamExists(
        "createRelationshipTuple",
        "relationshipTupleCreate",
        relationshipTupleCreate
      );
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/relationship_tuples`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        relationshipTupleCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Delete a relationship between two resource instances.
     * @summary Delete Relationship Tuple
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {RelationshipTupleDelete} relationshipTupleDelete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRelationshipTuple: async (projId, envId, relationshipTupleDelete, options = {}) => {
      assertParamExists("deleteRelationshipTuple", "projId", projId);
      assertParamExists("deleteRelationshipTuple", "envId", envId);
      assertParamExists(
        "deleteRelationshipTuple",
        "relationshipTupleDelete",
        relationshipTupleDelete
      );
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/relationship_tuples`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        relationshipTupleDelete,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Lists the relationship tuples defined within an environment.
     * @summary List Relationship Tuples
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {string} [tenant] The tenant key or id to filter by
     * @param {string} [subject] The subject to filter by, accepts either the resource instance id or resource_type:resource_instance
     * @param {string} [relation] The relation id or key to filter by
     * @param {string} [object] The object to filter by, accepts either the resource instance id or resource_type:resource_instance
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listRelationshipTuples: async (projId, envId, detailed, page, perPage, tenant, subject, relation, object, objectType, subjectType, options = {}) => {
      assertParamExists("listRelationshipTuples", "projId", projId);
      assertParamExists("listRelationshipTuples", "envId", envId);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/relationship_tuples`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (detailed !== void 0) {
        localVarQueryParameter["detailed"] = detailed;
      }
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      if (tenant !== void 0) {
        localVarQueryParameter["tenant"] = tenant;
      }
      if (subject !== void 0) {
        localVarQueryParameter["subject"] = subject;
      }
      if (relation !== void 0) {
        localVarQueryParameter["relation"] = relation;
      }
      if (object !== void 0) {
        localVarQueryParameter["object"] = object;
      }
      if (objectType !== void 0) {
        localVarQueryParameter["object_type"] = objectType;
      }
      if (subjectType !== void 0) {
        localVarQueryParameter["subject_type"] = subjectType;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var RelationshipTuplesApiFp = function(configuration) {
  const localVarAxiosParamCreator = RelationshipTuplesApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Bulk create relationship tuples(EAP)
     * @param {any} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {any} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {RelationshipTupleCreateBulkOperation} relationshipTupleCreateBulkOperation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bulkCreateRelationshipTuples(projId, envId, relationshipTupleCreateBulkOperation, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.bulkCreateRelationshipTuples(
        projId,
        envId,
        relationshipTupleCreateBulkOperation,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios23.default, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Bulk Delete Relationship Tuples
     * @param {any} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {any} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {RelationshipTupleDeleteBulkOperation} relationshipTupleDeleteBulkOperation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bulkDeleteRelationshipTuples(projId, envId, relationshipTupleDeleteBulkOperation, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.bulkDeleteRelationshipTuples(
        projId,
        envId,
        relationshipTupleDeleteBulkOperation,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios23.default, BASE_PATH, configuration);
    },
    /**
     * Create a relationship between two resource instances using a relation.
     * @summary Create Relationship Tuple
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {RelationshipTupleCreate} relationshipTupleCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createRelationshipTuple(projId, envId, relationshipTupleCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createRelationshipTuple(
        projId,
        envId,
        relationshipTupleCreate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios23.default, BASE_PATH, configuration);
    },
    /**
     * Delete a relationship between two resource instances.
     * @summary Delete Relationship Tuple
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {RelationshipTupleDelete} relationshipTupleDelete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteRelationshipTuple(projId, envId, relationshipTupleDelete, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRelationshipTuple(
        projId,
        envId,
        relationshipTupleDelete,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios23.default, BASE_PATH, configuration);
    },
    /**
     * Lists the relationship tuples defined within an environment.
     * @summary List Relationship Tuples
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {string} [tenant] The tenant key or id to filter by
     * @param {string} [subject] The subject to filter by, accepts either the resource instance id or resource_type:resource_instance
     * @param {string} [relation] The relation id or key to filter by
     * @param {string} [object] The object to filter by, accepts either the resource instance id or resource_type:resource_instance
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listRelationshipTuples(projId, envId, detailed, page, perPage, tenant, subject, relation, object, objectType, subjectType, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listRelationshipTuples(
        projId,
        envId,
        detailed,
        page,
        perPage,
        tenant,
        subject,
        relation,
        object,
        objectType,
        subjectType,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios23.default, BASE_PATH, configuration);
    }
  };
};
var RelationshipTuplesApi = class extends BaseAPI {
  /**
   *
   * @summary Bulk create relationship tuples(EAP)
   * @param {RelationshipTuplesApiBulkCreateRelationshipTuplesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RelationshipTuplesApi
   */
  async bulkCreateRelationshipTuples(requestParameters, options) {
    let request = await RelationshipTuplesApiFp(this.configuration).bulkCreateRelationshipTuples(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.relationshipTupleCreateBulkOperation,
      options
    );
    return request(this.axios, this.basePath);
  }
  /**
   *
   * @summary Bulk Delete Relationship Tuples
   * @param {RelationshipTuplesApiBulkDeleteRelationshipTuplesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RelationshipTuplesApi
   */
  async bulkDeleteRelationshipTuples(requestParameters, options) {
    let request = await RelationshipTuplesApiFp(this.configuration).bulkDeleteRelationshipTuples(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.relationshipTupleDeleteBulkOperation,
      options
    );
    return request(this.axios, this.basePath);
  }
  /**
   * Create a relationship between two resource instances using a relation.
   * @summary Create Relationship Tuple
   * @param {RelationshipTuplesApiCreateRelationshipTupleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RelationshipTuplesApi
   */
  createRelationshipTuple(requestParameters, options) {
    return RelationshipTuplesApiFp(this.configuration).createRelationshipTuple(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.relationshipTupleCreate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Delete a relationship between two resource instances.
   * @summary Delete Relationship Tuple
   * @param {RelationshipTuplesApiDeleteRelationshipTupleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RelationshipTuplesApi
   */
  deleteRelationshipTuple(requestParameters, options) {
    return RelationshipTuplesApiFp(this.configuration).deleteRelationshipTuple(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.relationshipTupleDelete,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Lists the relationship tuples defined within an environment.
   * @summary List Relationship Tuples
   * @param {RelationshipTuplesApiListRelationshipTuplesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RelationshipTuplesApi
   */
  listRelationshipTuples(requestParameters, options) {
    return RelationshipTuplesApiFp(this.configuration).listRelationshipTuples(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.detailed,
      requestParameters.page,
      requestParameters.perPage,
      requestParameters.tenant,
      requestParameters.subject,
      requestParameters.relation,
      requestParameters.object,
      requestParameters.objectType,
      requestParameters.subjectType,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/resource-action-groups-api.ts
var import_axios24 = __toESM(require("axios"));
var ResourceActionGroupsApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * Creates a new action group that can affect the resource.
     * @summary Create Resource Action Group
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {ResourceActionGroupCreate} resourceActionGroupCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createResourceActionGroup: async (projId, envId, resourceId, resourceActionGroupCreate, options = {}) => {
      assertParamExists("createResourceActionGroup", "projId", projId);
      assertParamExists("createResourceActionGroup", "envId", envId);
      assertParamExists("createResourceActionGroup", "resourceId", resourceId);
      assertParamExists(
        "createResourceActionGroup",
        "resourceActionGroupCreate",
        resourceActionGroupCreate
      );
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/action_groups`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        resourceActionGroupCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes the action and all its related data. This includes any permissions granted to perform the action.
     * @summary Delete Resource Action Group
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} actionGroupId Either the unique id of the action group, or the URL-friendly key of the action group (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteResourceActionGroup: async (projId, envId, resourceId, actionGroupId, options = {}) => {
      assertParamExists("deleteResourceActionGroup", "projId", projId);
      assertParamExists("deleteResourceActionGroup", "envId", envId);
      assertParamExists("deleteResourceActionGroup", "resourceId", resourceId);
      assertParamExists("deleteResourceActionGroup", "actionGroupId", actionGroupId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/action_groups/{action_group_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId))).replace(`{${"action_group_id"}}`, encodeURIComponent(String(actionGroupId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Gets a single action group defined on the resource, if such action exists.
     * @summary Get Resource Action Group
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} actionGroupId Either the unique id of the action group, or the URL-friendly key of the action group (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getResourceActionGroup: async (projId, envId, resourceId, actionGroupId, options = {}) => {
      assertParamExists("getResourceActionGroup", "projId", projId);
      assertParamExists("getResourceActionGroup", "envId", envId);
      assertParamExists("getResourceActionGroup", "resourceId", resourceId);
      assertParamExists("getResourceActionGroup", "actionGroupId", actionGroupId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/action_groups/{action_group_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId))).replace(`{${"action_group_id"}}`, encodeURIComponent(String(actionGroupId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Lists all the action groups defined on the resource.
     * @summary List Resource Action Groups
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listResourceActionGroups: async (projId, envId, resourceId, page, perPage, options = {}) => {
      assertParamExists("listResourceActionGroups", "projId", projId);
      assertParamExists("listResourceActionGroups", "envId", envId);
      assertParamExists("listResourceActionGroups", "resourceId", resourceId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/action_groups`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Partially updates the action defined on a resource. Fields that will be provided will be completely overwritten.
     * @summary Update Resource Action Group
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} actionGroupId Either the unique id of the action group, or the URL-friendly key of the action group (i.e: the \&quot;slug\&quot;).
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ResourceActionGroupUpdate} resourceActionGroupUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateResourceActionGroup: async (resourceId, actionGroupId, projId, envId, resourceActionGroupUpdate, options = {}) => {
      assertParamExists("updateResourceActionGroup", "resourceId", resourceId);
      assertParamExists("updateResourceActionGroup", "actionGroupId", actionGroupId);
      assertParamExists("updateResourceActionGroup", "projId", projId);
      assertParamExists("updateResourceActionGroup", "envId", envId);
      assertParamExists(
        "updateResourceActionGroup",
        "resourceActionGroupUpdate",
        resourceActionGroupUpdate
      );
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/action_groups/{action_group_id}`.replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId))).replace(`{${"action_group_id"}}`, encodeURIComponent(String(actionGroupId))).replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        resourceActionGroupUpdate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var ResourceActionGroupsApiFp = function(configuration) {
  const localVarAxiosParamCreator = ResourceActionGroupsApiAxiosParamCreator(configuration);
  return {
    /**
     * Creates a new action group that can affect the resource.
     * @summary Create Resource Action Group
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {ResourceActionGroupCreate} resourceActionGroupCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createResourceActionGroup(projId, envId, resourceId, resourceActionGroupCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createResourceActionGroup(
        projId,
        envId,
        resourceId,
        resourceActionGroupCreate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios24.default, BASE_PATH, configuration);
    },
    /**
     * Deletes the action and all its related data. This includes any permissions granted to perform the action.
     * @summary Delete Resource Action Group
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} actionGroupId Either the unique id of the action group, or the URL-friendly key of the action group (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteResourceActionGroup(projId, envId, resourceId, actionGroupId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteResourceActionGroup(
        projId,
        envId,
        resourceId,
        actionGroupId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios24.default, BASE_PATH, configuration);
    },
    /**
     * Gets a single action group defined on the resource, if such action exists.
     * @summary Get Resource Action Group
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} actionGroupId Either the unique id of the action group, or the URL-friendly key of the action group (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getResourceActionGroup(projId, envId, resourceId, actionGroupId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getResourceActionGroup(
        projId,
        envId,
        resourceId,
        actionGroupId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios24.default, BASE_PATH, configuration);
    },
    /**
     * Lists all the action groups defined on the resource.
     * @summary List Resource Action Groups
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listResourceActionGroups(projId, envId, resourceId, page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listResourceActionGroups(
        projId,
        envId,
        resourceId,
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios24.default, BASE_PATH, configuration);
    },
    /**
     * Partially updates the action defined on a resource. Fields that will be provided will be completely overwritten.
     * @summary Update Resource Action Group
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} actionGroupId Either the unique id of the action group, or the URL-friendly key of the action group (i.e: the \&quot;slug\&quot;).
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ResourceActionGroupUpdate} resourceActionGroupUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateResourceActionGroup(resourceId, actionGroupId, projId, envId, resourceActionGroupUpdate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateResourceActionGroup(
        resourceId,
        actionGroupId,
        projId,
        envId,
        resourceActionGroupUpdate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios24.default, BASE_PATH, configuration);
    }
  };
};
var ResourceActionGroupsApi = class extends BaseAPI {
  /**
   * Creates a new action group that can affect the resource.
   * @summary Create Resource Action Group
   * @param {ResourceActionGroupsApiCreateResourceActionGroupRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceActionGroupsApi
   */
  createResourceActionGroup(requestParameters, options) {
    return ResourceActionGroupsApiFp(this.configuration).createResourceActionGroup(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.resourceActionGroupCreate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Deletes the action and all its related data. This includes any permissions granted to perform the action.
   * @summary Delete Resource Action Group
   * @param {ResourceActionGroupsApiDeleteResourceActionGroupRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceActionGroupsApi
   */
  deleteResourceActionGroup(requestParameters, options) {
    return ResourceActionGroupsApiFp(this.configuration).deleteResourceActionGroup(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.actionGroupId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Gets a single action group defined on the resource, if such action exists.
   * @summary Get Resource Action Group
   * @param {ResourceActionGroupsApiGetResourceActionGroupRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceActionGroupsApi
   */
  getResourceActionGroup(requestParameters, options) {
    return ResourceActionGroupsApiFp(this.configuration).getResourceActionGroup(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.actionGroupId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Lists all the action groups defined on the resource.
   * @summary List Resource Action Groups
   * @param {ResourceActionGroupsApiListResourceActionGroupsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceActionGroupsApi
   */
  listResourceActionGroups(requestParameters, options) {
    return ResourceActionGroupsApiFp(this.configuration).listResourceActionGroups(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.page,
      requestParameters.perPage,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Partially updates the action defined on a resource. Fields that will be provided will be completely overwritten.
   * @summary Update Resource Action Group
   * @param {ResourceActionGroupsApiUpdateResourceActionGroupRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceActionGroupsApi
   */
  updateResourceActionGroup(requestParameters, options) {
    return ResourceActionGroupsApiFp(this.configuration).updateResourceActionGroup(
      requestParameters.resourceId,
      requestParameters.actionGroupId,
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceActionGroupUpdate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/resource-actions-api.ts
var import_axios25 = __toESM(require("axios"));
var ResourceActionsApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * Creates a new action that can affect the resource.
     * @summary Create Resource Action
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {ResourceActionCreate} resourceActionCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createResourceAction: async (projId, envId, resourceId, resourceActionCreate, options = {}) => {
      assertParamExists("createResourceAction", "projId", projId);
      assertParamExists("createResourceAction", "envId", envId);
      assertParamExists("createResourceAction", "resourceId", resourceId);
      assertParamExists("createResourceAction", "resourceActionCreate", resourceActionCreate);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/actions`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        resourceActionCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes the action and all its related data. This includes any permissions granted to perform the action.
     * @summary Delete Resource Action
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} actionId Either the unique id of the action, or the URL-friendly key of the action (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteResourceAction: async (projId, envId, resourceId, actionId, options = {}) => {
      assertParamExists("deleteResourceAction", "projId", projId);
      assertParamExists("deleteResourceAction", "envId", envId);
      assertParamExists("deleteResourceAction", "resourceId", resourceId);
      assertParamExists("deleteResourceAction", "actionId", actionId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/actions/{action_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId))).replace(`{${"action_id"}}`, encodeURIComponent(String(actionId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Gets a single action defined on the resource, if such action exists.
     * @summary Get Resource Action
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} actionId Either the unique id of the action, or the URL-friendly key of the action (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getResourceAction: async (projId, envId, resourceId, actionId, options = {}) => {
      assertParamExists("getResourceAction", "projId", projId);
      assertParamExists("getResourceAction", "envId", envId);
      assertParamExists("getResourceAction", "resourceId", resourceId);
      assertParamExists("getResourceAction", "actionId", actionId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/actions/{action_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId))).replace(`{${"action_id"}}`, encodeURIComponent(String(actionId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Lists all the actions defined on the resource.
     * @summary List Resource Actions
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listResourceActions: async (projId, envId, resourceId, page, perPage, options = {}) => {
      assertParamExists("listResourceActions", "projId", projId);
      assertParamExists("listResourceActions", "envId", envId);
      assertParamExists("listResourceActions", "resourceId", resourceId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/actions`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Partially updates the action defined on a resource. Fields that will be provided will be completely overwritten.
     * @summary Update Resource Action
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} actionId Either the unique id of the action, or the URL-friendly key of the action (i.e: the \&quot;slug\&quot;).
     * @param {ResourceActionUpdate} resourceActionUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateResourceAction: async (projId, envId, resourceId, actionId, resourceActionUpdate, options = {}) => {
      assertParamExists("updateResourceAction", "projId", projId);
      assertParamExists("updateResourceAction", "envId", envId);
      assertParamExists("updateResourceAction", "resourceId", resourceId);
      assertParamExists("updateResourceAction", "actionId", actionId);
      assertParamExists("updateResourceAction", "resourceActionUpdate", resourceActionUpdate);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/actions/{action_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId))).replace(`{${"action_id"}}`, encodeURIComponent(String(actionId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        resourceActionUpdate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var ResourceActionsApiFp = function(configuration) {
  const localVarAxiosParamCreator = ResourceActionsApiAxiosParamCreator(configuration);
  return {
    /**
     * Creates a new action that can affect the resource.
     * @summary Create Resource Action
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {ResourceActionCreate} resourceActionCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createResourceAction(projId, envId, resourceId, resourceActionCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createResourceAction(
        projId,
        envId,
        resourceId,
        resourceActionCreate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios25.default, BASE_PATH, configuration);
    },
    /**
     * Deletes the action and all its related data. This includes any permissions granted to perform the action.
     * @summary Delete Resource Action
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} actionId Either the unique id of the action, or the URL-friendly key of the action (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteResourceAction(projId, envId, resourceId, actionId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteResourceAction(
        projId,
        envId,
        resourceId,
        actionId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios25.default, BASE_PATH, configuration);
    },
    /**
     * Gets a single action defined on the resource, if such action exists.
     * @summary Get Resource Action
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} actionId Either the unique id of the action, or the URL-friendly key of the action (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getResourceAction(projId, envId, resourceId, actionId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getResourceAction(
        projId,
        envId,
        resourceId,
        actionId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios25.default, BASE_PATH, configuration);
    },
    /**
     * Lists all the actions defined on the resource.
     * @summary List Resource Actions
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listResourceActions(projId, envId, resourceId, page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listResourceActions(
        projId,
        envId,
        resourceId,
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios25.default, BASE_PATH, configuration);
    },
    /**
     * Partially updates the action defined on a resource. Fields that will be provided will be completely overwritten.
     * @summary Update Resource Action
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} actionId Either the unique id of the action, or the URL-friendly key of the action (i.e: the \&quot;slug\&quot;).
     * @param {ResourceActionUpdate} resourceActionUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateResourceAction(projId, envId, resourceId, actionId, resourceActionUpdate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateResourceAction(
        projId,
        envId,
        resourceId,
        actionId,
        resourceActionUpdate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios25.default, BASE_PATH, configuration);
    }
  };
};
var ResourceActionsApi = class extends BaseAPI {
  /**
   * Creates a new action that can affect the resource.
   * @summary Create Resource Action
   * @param {ResourceActionsApiCreateResourceActionRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceActionsApi
   */
  createResourceAction(requestParameters, options) {
    return ResourceActionsApiFp(this.configuration).createResourceAction(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.resourceActionCreate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Deletes the action and all its related data. This includes any permissions granted to perform the action.
   * @summary Delete Resource Action
   * @param {ResourceActionsApiDeleteResourceActionRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceActionsApi
   */
  deleteResourceAction(requestParameters, options) {
    return ResourceActionsApiFp(this.configuration).deleteResourceAction(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.actionId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Gets a single action defined on the resource, if such action exists.
   * @summary Get Resource Action
   * @param {ResourceActionsApiGetResourceActionRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceActionsApi
   */
  getResourceAction(requestParameters, options) {
    return ResourceActionsApiFp(this.configuration).getResourceAction(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.actionId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Lists all the actions defined on the resource.
   * @summary List Resource Actions
   * @param {ResourceActionsApiListResourceActionsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceActionsApi
   */
  listResourceActions(requestParameters, options) {
    return ResourceActionsApiFp(this.configuration).listResourceActions(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.page,
      requestParameters.perPage,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Partially updates the action defined on a resource. Fields that will be provided will be completely overwritten.
   * @summary Update Resource Action
   * @param {ResourceActionsApiUpdateResourceActionRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceActionsApi
   */
  updateResourceAction(requestParameters, options) {
    return ResourceActionsApiFp(this.configuration).updateResourceAction(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.actionId,
      requestParameters.resourceActionUpdate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/resource-attributes-api.ts
var import_axios26 = __toESM(require("axios"));
var ResourceAttributesApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * Creates a new attribute as part of the resource definition.
     * @summary Create Resource Attribute
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {ResourceAttributeCreate} resourceAttributeCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createResourceAttribute: async (projId, envId, resourceId, resourceAttributeCreate, options = {}) => {
      assertParamExists("createResourceAttribute", "projId", projId);
      assertParamExists("createResourceAttribute", "envId", envId);
      assertParamExists("createResourceAttribute", "resourceId", resourceId);
      assertParamExists(
        "createResourceAttribute",
        "resourceAttributeCreate",
        resourceAttributeCreate
      );
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/attributes`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        resourceAttributeCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes the attribute and all its related data.  Note: If the attribute is used by policies, removing it will cause the attribute to evaluate as `undefined`.
     * @summary Delete Resource Attribute
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} attributeId Either the unique id of the attribute, or the URL-friendly key of the attribute (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteResourceAttribute: async (projId, envId, resourceId, attributeId, page, perPage, options = {}) => {
      assertParamExists("deleteResourceAttribute", "projId", projId);
      assertParamExists("deleteResourceAttribute", "envId", envId);
      assertParamExists("deleteResourceAttribute", "resourceId", resourceId);
      assertParamExists("deleteResourceAttribute", "attributeId", attributeId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/attributes/{attribute_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId))).replace(`{${"attribute_id"}}`, encodeURIComponent(String(attributeId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Gets a single attribute defined on the resource, if such attribute exists.
     * @summary Get Resource Attribute
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} attributeId Either the unique id of the attribute, or the URL-friendly key of the attribute (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getResourceAttribute: async (projId, envId, resourceId, attributeId, options = {}) => {
      assertParamExists("getResourceAttribute", "projId", projId);
      assertParamExists("getResourceAttribute", "envId", envId);
      assertParamExists("getResourceAttribute", "resourceId", resourceId);
      assertParamExists("getResourceAttribute", "attributeId", attributeId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/attributes/{attribute_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId))).replace(`{${"attribute_id"}}`, encodeURIComponent(String(attributeId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Lists all the attributes defined on the resource.
     * @summary List Resource Attributes
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listResourceAttributes: async (projId, envId, resourceId, page, perPage, options = {}) => {
      assertParamExists("listResourceAttributes", "projId", projId);
      assertParamExists("listResourceAttributes", "envId", envId);
      assertParamExists("listResourceAttributes", "resourceId", resourceId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/attributes`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Partially updates the attribute defined on a resource. Fields that will be provided will be completely overwritten.
     * @summary Update Resource Attribute
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} attributeId Either the unique id of the attribute, or the URL-friendly key of the attribute (i.e: the \&quot;slug\&quot;).
     * @param {ResourceAttributeUpdate} resourceAttributeUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateResourceAttribute: async (projId, envId, resourceId, attributeId, resourceAttributeUpdate, options = {}) => {
      assertParamExists("updateResourceAttribute", "projId", projId);
      assertParamExists("updateResourceAttribute", "envId", envId);
      assertParamExists("updateResourceAttribute", "resourceId", resourceId);
      assertParamExists("updateResourceAttribute", "attributeId", attributeId);
      assertParamExists(
        "updateResourceAttribute",
        "resourceAttributeUpdate",
        resourceAttributeUpdate
      );
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/attributes/{attribute_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId))).replace(`{${"attribute_id"}}`, encodeURIComponent(String(attributeId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        resourceAttributeUpdate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var ResourceAttributesApiFp = function(configuration) {
  const localVarAxiosParamCreator = ResourceAttributesApiAxiosParamCreator(configuration);
  return {
    /**
     * Creates a new attribute as part of the resource definition.
     * @summary Create Resource Attribute
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {ResourceAttributeCreate} resourceAttributeCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createResourceAttribute(projId, envId, resourceId, resourceAttributeCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createResourceAttribute(
        projId,
        envId,
        resourceId,
        resourceAttributeCreate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios26.default, BASE_PATH, configuration);
    },
    /**
     * Deletes the attribute and all its related data.  Note: If the attribute is used by policies, removing it will cause the attribute to evaluate as `undefined`.
     * @summary Delete Resource Attribute
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} attributeId Either the unique id of the attribute, or the URL-friendly key of the attribute (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteResourceAttribute(projId, envId, resourceId, attributeId, page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteResourceAttribute(
        projId,
        envId,
        resourceId,
        attributeId,
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios26.default, BASE_PATH, configuration);
    },
    /**
     * Gets a single attribute defined on the resource, if such attribute exists.
     * @summary Get Resource Attribute
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} attributeId Either the unique id of the attribute, or the URL-friendly key of the attribute (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getResourceAttribute(projId, envId, resourceId, attributeId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getResourceAttribute(
        projId,
        envId,
        resourceId,
        attributeId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios26.default, BASE_PATH, configuration);
    },
    /**
     * Lists all the attributes defined on the resource.
     * @summary List Resource Attributes
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listResourceAttributes(projId, envId, resourceId, page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listResourceAttributes(
        projId,
        envId,
        resourceId,
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios26.default, BASE_PATH, configuration);
    },
    /**
     * Partially updates the attribute defined on a resource. Fields that will be provided will be completely overwritten.
     * @summary Update Resource Attribute
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} attributeId Either the unique id of the attribute, or the URL-friendly key of the attribute (i.e: the \&quot;slug\&quot;).
     * @param {ResourceAttributeUpdate} resourceAttributeUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateResourceAttribute(projId, envId, resourceId, attributeId, resourceAttributeUpdate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateResourceAttribute(
        projId,
        envId,
        resourceId,
        attributeId,
        resourceAttributeUpdate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios26.default, BASE_PATH, configuration);
    }
  };
};
var ResourceAttributesApi = class extends BaseAPI {
  /**
   * Creates a new attribute as part of the resource definition.
   * @summary Create Resource Attribute
   * @param {ResourceAttributesApiCreateResourceAttributeRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceAttributesApi
   */
  createResourceAttribute(requestParameters, options) {
    return ResourceAttributesApiFp(this.configuration).createResourceAttribute(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.resourceAttributeCreate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Deletes the attribute and all its related data.  Note: If the attribute is used by policies, removing it will cause the attribute to evaluate as `undefined`.
   * @summary Delete Resource Attribute
   * @param {ResourceAttributesApiDeleteResourceAttributeRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceAttributesApi
   */
  deleteResourceAttribute(requestParameters, options) {
    return ResourceAttributesApiFp(this.configuration).deleteResourceAttribute(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.attributeId,
      requestParameters.page,
      requestParameters.perPage,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Gets a single attribute defined on the resource, if such attribute exists.
   * @summary Get Resource Attribute
   * @param {ResourceAttributesApiGetResourceAttributeRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceAttributesApi
   */
  getResourceAttribute(requestParameters, options) {
    return ResourceAttributesApiFp(this.configuration).getResourceAttribute(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.attributeId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Lists all the attributes defined on the resource.
   * @summary List Resource Attributes
   * @param {ResourceAttributesApiListResourceAttributesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceAttributesApi
   */
  listResourceAttributes(requestParameters, options) {
    return ResourceAttributesApiFp(this.configuration).listResourceAttributes(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.page,
      requestParameters.perPage,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Partially updates the attribute defined on a resource. Fields that will be provided will be completely overwritten.
   * @summary Update Resource Attribute
   * @param {ResourceAttributesApiUpdateResourceAttributeRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceAttributesApi
   */
  updateResourceAttribute(requestParameters, options) {
    return ResourceAttributesApiFp(this.configuration).updateResourceAttribute(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.attributeId,
      requestParameters.resourceAttributeUpdate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/resource-instances-api.ts
var import_axios27 = __toESM(require("axios"));
var ResourceInstancesApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * Creates a new instance inside the Permit.io system.  If the instance is already created: will return 200 instead of 201, and will return the existing instance object in the response body.
     * @summary Create Resource Instance
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ResourceInstanceCreate} resourceInstanceCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createResourceInstance: async (projId, envId, resourceInstanceCreate, options = {}) => {
      assertParamExists("createResourceInstance", "projId", projId);
      assertParamExists("createResourceInstance", "envId", envId);
      assertParamExists("createResourceInstance", "resourceInstanceCreate", resourceInstanceCreate);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/resource_instances`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        resourceInstanceCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes the instance and all its related data.
     * @summary Delete Resource Instance
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} instanceId Either the unique id of the resource instance, or the URL-friendly key of the resource instance (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteResourceInstance: async (projId, envId, instanceId, options = {}) => {
      assertParamExists("deleteResourceInstance", "projId", projId);
      assertParamExists("deleteResourceInstance", "envId", envId);
      assertParamExists("deleteResourceInstance", "instanceId", instanceId);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/resource_instances/{instance_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"instance_id"}}`, encodeURIComponent(String(instanceId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Gets a instance, if such instance exists. Otherwise returns 404.
     * @summary Get Resource Instance
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} instanceId Either the unique id of the resource instance, or the URL-friendly key of the resource instance (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getResourceInstance: async (projId, envId, instanceId, options = {}) => {
      assertParamExists("getResourceInstance", "projId", projId);
      assertParamExists("getResourceInstance", "envId", envId);
      assertParamExists("getResourceInstance", "instanceId", instanceId);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/resource_instances/{instance_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"instance_id"}}`, encodeURIComponent(String(instanceId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Lists all the resource instances defined within an environment.
     * @summary List Resource Instances
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} [tenant] The tenant key or id to filter by
     * @param {string} [resource] The resource key or id to filter by
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listResourceInstances: async (projId, envId, tenant, resource, page, perPage, options = {}) => {
      assertParamExists("listResourceInstances", "projId", projId);
      assertParamExists("listResourceInstances", "envId", envId);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/resource_instances`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (tenant !== void 0) {
        localVarQueryParameter["tenant"] = tenant;
      }
      if (resource !== void 0) {
        localVarQueryParameter["resource"] = resource;
      }
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Partially updates the instance definition. Fields that will be provided will be completely overwritten.
     * @summary Update Resource Instance
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} instanceId Either the unique id of the resource instance, or the URL-friendly key of the resource instance (i.e: the \&quot;slug\&quot;).
     * @param {ResourceInstanceUpdate} resourceInstanceUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateResourceInstance: async (projId, envId, instanceId, resourceInstanceUpdate, options = {}) => {
      assertParamExists("updateResourceInstance", "projId", projId);
      assertParamExists("updateResourceInstance", "envId", envId);
      assertParamExists("updateResourceInstance", "instanceId", instanceId);
      assertParamExists("updateResourceInstance", "resourceInstanceUpdate", resourceInstanceUpdate);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/resource_instances/{instance_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"instance_id"}}`, encodeURIComponent(String(instanceId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        resourceInstanceUpdate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var ResourceInstancesApiFp = function(configuration) {
  const localVarAxiosParamCreator = ResourceInstancesApiAxiosParamCreator(configuration);
  return {
    /**
     * Creates a new instance inside the Permit.io system.  If the instance is already created: will return 200 instead of 201, and will return the existing instance object in the response body.
     * @summary Create Resource Instance
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ResourceInstanceCreate} resourceInstanceCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createResourceInstance(projId, envId, resourceInstanceCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createResourceInstance(
        projId,
        envId,
        resourceInstanceCreate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios27.default, BASE_PATH, configuration);
    },
    /**
     * Deletes the instance and all its related data.
     * @summary Delete Resource Instance
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} instanceId Either the unique id of the resource instance, or the URL-friendly key of the resource instance (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteResourceInstance(projId, envId, instanceId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteResourceInstance(
        projId,
        envId,
        instanceId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios27.default, BASE_PATH, configuration);
    },
    /**
     * Gets a instance, if such instance exists. Otherwise returns 404.
     * @summary Get Resource Instance
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} instanceId Either the unique id of the resource instance, or the URL-friendly key of the resource instance (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getResourceInstance(projId, envId, instanceId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getResourceInstance(
        projId,
        envId,
        instanceId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios27.default, BASE_PATH, configuration);
    },
    /**
     * Lists all the resource instances defined within an environment.
     * @summary List Resource Instances
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} [tenant] The tenant key or id to filter by
     * @param {string} [resource] The resource key or id to filter by
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listResourceInstances(projId, envId, tenant, resource, page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listResourceInstances(
        projId,
        envId,
        tenant,
        resource,
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios27.default, BASE_PATH, configuration);
    },
    /**
     * Partially updates the instance definition. Fields that will be provided will be completely overwritten.
     * @summary Update Resource Instance
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} instanceId Either the unique id of the resource instance, or the URL-friendly key of the resource instance (i.e: the \&quot;slug\&quot;).
     * @param {ResourceInstanceUpdate} resourceInstanceUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateResourceInstance(projId, envId, instanceId, resourceInstanceUpdate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateResourceInstance(
        projId,
        envId,
        instanceId,
        resourceInstanceUpdate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios27.default, BASE_PATH, configuration);
    }
  };
};
var ResourceInstancesApi = class extends BaseAPI {
  /**
   * Creates a new instance inside the Permit.io system.  If the instance is already created: will return 200 instead of 201, and will return the existing instance object in the response body.
   * @summary Create Resource Instance
   * @param {ResourceInstancesApiCreateResourceInstanceRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceInstancesApi
   */
  createResourceInstance(requestParameters, options) {
    return ResourceInstancesApiFp(this.configuration).createResourceInstance(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceInstanceCreate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Deletes the instance and all its related data.
   * @summary Delete Resource Instance
   * @param {ResourceInstancesApiDeleteResourceInstanceRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceInstancesApi
   */
  deleteResourceInstance(requestParameters, options) {
    return ResourceInstancesApiFp(this.configuration).deleteResourceInstance(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.instanceId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Gets a instance, if such instance exists. Otherwise returns 404.
   * @summary Get Resource Instance
   * @param {ResourceInstancesApiGetResourceInstanceRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceInstancesApi
   */
  getResourceInstance(requestParameters, options) {
    return ResourceInstancesApiFp(this.configuration).getResourceInstance(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.instanceId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Lists all the resource instances defined within an environment.
   * @summary List Resource Instances
   * @param {ResourceInstancesApiListResourceInstancesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceInstancesApi
   */
  listResourceInstances(requestParameters, options) {
    return ResourceInstancesApiFp(this.configuration).listResourceInstances(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.tenant,
      requestParameters.resource,
      requestParameters.page,
      requestParameters.perPage,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Partially updates the instance definition. Fields that will be provided will be completely overwritten.
   * @summary Update Resource Instance
   * @param {ResourceInstancesApiUpdateResourceInstanceRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceInstancesApi
   */
  updateResourceInstance(requestParameters, options) {
    return ResourceInstancesApiFp(this.configuration).updateResourceInstance(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.instanceId,
      requestParameters.resourceInstanceUpdate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/resource-relations-api.ts
var import_axios28 = __toESM(require("axios"));
var ResourceRelationsApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * Creates a resource relation to another resource
     * @summary Create Resource Relation
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {RelationCreate} relationCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createResourceRelation: async (projId, envId, resourceId, relationCreate, options = {}) => {
      assertParamExists("createResourceRelation", "projId", projId);
      assertParamExists("createResourceRelation", "envId", envId);
      assertParamExists("createResourceRelation", "resourceId", resourceId);
      assertParamExists("createResourceRelation", "relationCreate", relationCreate);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/relations`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        relationCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes a resource relation
     * @summary Delete Resource Relation
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} relationId Either the unique id of the relation, or the URL-friendly key of the relation (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteResourceRelation: async (projId, envId, resourceId, relationId, options = {}) => {
      assertParamExists("deleteResourceRelation", "projId", projId);
      assertParamExists("deleteResourceRelation", "envId", envId);
      assertParamExists("deleteResourceRelation", "resourceId", resourceId);
      assertParamExists("deleteResourceRelation", "relationId", relationId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/relations/{relation_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId))).replace(`{${"relation_id"}}`, encodeURIComponent(String(relationId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Get a resource relation
     * @summary Get Resource Relation
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} relationId Either the unique id of the relation, or the URL-friendly key of the relation (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getResourceRelation: async (projId, envId, resourceId, relationId, options = {}) => {
      assertParamExists("getResourceRelation", "projId", projId);
      assertParamExists("getResourceRelation", "envId", envId);
      assertParamExists("getResourceRelation", "resourceId", resourceId);
      assertParamExists("getResourceRelation", "relationId", relationId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/relations/{relation_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId))).replace(`{${"relation_id"}}`, encodeURIComponent(String(relationId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Creates a resource relation to another resource
     * @summary List Resource Relations
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listResourceRelations: async (projId, envId, resourceId, page, perPage, options = {}) => {
      assertParamExists("listResourceRelations", "projId", projId);
      assertParamExists("listResourceRelations", "envId", envId);
      assertParamExists("listResourceRelations", "resourceId", resourceId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/relations`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var ResourceRelationsApiFp = function(configuration) {
  const localVarAxiosParamCreator = ResourceRelationsApiAxiosParamCreator(configuration);
  return {
    /**
     * Creates a resource relation to another resource
     * @summary Create Resource Relation
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {RelationCreate} relationCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createResourceRelation(projId, envId, resourceId, relationCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createResourceRelation(
        projId,
        envId,
        resourceId,
        relationCreate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios28.default, BASE_PATH, configuration);
    },
    /**
     * Deletes a resource relation
     * @summary Delete Resource Relation
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} relationId Either the unique id of the relation, or the URL-friendly key of the relation (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteResourceRelation(projId, envId, resourceId, relationId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteResourceRelation(
        projId,
        envId,
        resourceId,
        relationId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios28.default, BASE_PATH, configuration);
    },
    /**
     * Get a resource relation
     * @summary Get Resource Relation
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} relationId Either the unique id of the relation, or the URL-friendly key of the relation (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getResourceRelation(projId, envId, resourceId, relationId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getResourceRelation(
        projId,
        envId,
        resourceId,
        relationId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios28.default, BASE_PATH, configuration);
    },
    /**
     * Creates a resource relation to another resource
     * @summary List Resource Relations
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listResourceRelations(projId, envId, resourceId, page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listResourceRelations(
        projId,
        envId,
        resourceId,
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios28.default, BASE_PATH, configuration);
    }
  };
};
var ResourceRelationsApi = class extends BaseAPI {
  /**
   * Creates a resource relation to another resource
   * @summary Create Resource Relation
   * @param {ResourceRelationsApiCreateResourceRelationRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceRelationsApi
   */
  createResourceRelation(requestParameters, options) {
    return ResourceRelationsApiFp(this.configuration).createResourceRelation(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.relationCreate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Deletes a resource relation
   * @summary Delete Resource Relation
   * @param {ResourceRelationsApiDeleteResourceRelationRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceRelationsApi
   */
  deleteResourceRelation(requestParameters, options) {
    return ResourceRelationsApiFp(this.configuration).deleteResourceRelation(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.relationId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Get a resource relation
   * @summary Get Resource Relation
   * @param {ResourceRelationsApiGetResourceRelationRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceRelationsApi
   */
  getResourceRelation(requestParameters, options) {
    return ResourceRelationsApiFp(this.configuration).getResourceRelation(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.relationId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Creates a resource relation to another resource
   * @summary List Resource Relations
   * @param {ResourceRelationsApiListResourceRelationsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceRelationsApi
   */
  listResourceRelations(requestParameters, options) {
    return ResourceRelationsApiFp(this.configuration).listResourceRelations(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.page,
      requestParameters.perPage,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/resource-roles-api.ts
var import_axios29 = __toESM(require("axios"));
var ResourceRolesApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * Assign permissions to role.  If some of the permissions specified are already assigned, will skip them.
     * @summary Assign Permissions to Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {AddRolePermissions} addRolePermissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    assignPermissionsToResourceRole: async (projId, envId, resourceId, roleId, addRolePermissions, options = {}) => {
      assertParamExists("assignPermissionsToResourceRole", "projId", projId);
      assertParamExists("assignPermissionsToResourceRole", "envId", envId);
      assertParamExists("assignPermissionsToResourceRole", "resourceId", resourceId);
      assertParamExists("assignPermissionsToResourceRole", "roleId", roleId);
      assertParamExists(
        "assignPermissionsToResourceRole",
        "addRolePermissions",
        addRolePermissions
      );
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/roles/{role_id}/permissions`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId))).replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        addRolePermissions,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Creates a new role associated with the resource.
     * @summary Create Resource Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {ResourceRoleCreate} resourceRoleCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createResourceRole: async (projId, envId, resourceId, resourceRoleCreate, options = {}) => {
      assertParamExists("createResourceRole", "projId", projId);
      assertParamExists("createResourceRole", "envId", envId);
      assertParamExists("createResourceRole", "resourceId", resourceId);
      assertParamExists("createResourceRole", "resourceRoleCreate", resourceRoleCreate);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/roles`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        resourceRoleCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes the role and all its related data. This includes any permissions granted to said role.
     * @summary Delete Resource Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteResourceRole: async (projId, envId, resourceId, roleId, options = {}) => {
      assertParamExists("deleteResourceRole", "projId", projId);
      assertParamExists("deleteResourceRole", "envId", envId);
      assertParamExists("deleteResourceRole", "resourceId", resourceId);
      assertParamExists("deleteResourceRole", "roleId", roleId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/roles/{role_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId))).replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Gets a single role defined on the resource, if such role exists.
     * @summary Get Resource Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getResourceRole: async (projId, envId, resourceId, roleId, options = {}) => {
      assertParamExists("getResourceRole", "projId", projId);
      assertParamExists("getResourceRole", "envId", envId);
      assertParamExists("getResourceRole", "resourceId", resourceId);
      assertParamExists("getResourceRole", "roleId", roleId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/roles/{role_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId))).replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Lists all the roles defined on the resource.
     * @summary List Resource Roles
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listResourceRoles: async (projId, envId, resourceId, page, perPage, options = {}) => {
      assertParamExists("listResourceRoles", "projId", projId);
      assertParamExists("listResourceRoles", "envId", envId);
      assertParamExists("listResourceRoles", "resourceId", resourceId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/roles`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Remove permissions from role.  If some of the permissions specified are already unassigned, will skip them.
     * @summary Remove Permissions from Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {RemoveRolePermissions} removeRolePermissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removePermissionsFromResourceRole: async (projId, envId, resourceId, roleId, removeRolePermissions, options = {}) => {
      assertParamExists("removePermissionsFromResourceRole", "projId", projId);
      assertParamExists("removePermissionsFromResourceRole", "envId", envId);
      assertParamExists("removePermissionsFromResourceRole", "resourceId", resourceId);
      assertParamExists("removePermissionsFromResourceRole", "roleId", roleId);
      assertParamExists(
        "removePermissionsFromResourceRole",
        "removeRolePermissions",
        removeRolePermissions
      );
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/roles/{role_id}/permissions`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId))).replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        removeRolePermissions,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Partially updates the role defined on a resource. Fields that will be provided will be completely overwritten.
     * @summary Update Resource Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {ResourceRoleUpdate} resourceRoleUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateResourceRole: async (projId, envId, resourceId, roleId, resourceRoleUpdate, options = {}) => {
      assertParamExists("updateResourceRole", "projId", projId);
      assertParamExists("updateResourceRole", "envId", envId);
      assertParamExists("updateResourceRole", "resourceId", resourceId);
      assertParamExists("updateResourceRole", "roleId", roleId);
      assertParamExists("updateResourceRole", "resourceRoleUpdate", resourceRoleUpdate);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/roles/{role_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId))).replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        resourceRoleUpdate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var ResourceRolesApiFp = function(configuration) {
  const localVarAxiosParamCreator = ResourceRolesApiAxiosParamCreator(configuration);
  return {
    /**
     * Assign permissions to role.  If some of the permissions specified are already assigned, will skip them.
     * @summary Assign Permissions to Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {AddRolePermissions} addRolePermissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async assignPermissionsToResourceRole(projId, envId, resourceId, roleId, addRolePermissions, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.assignPermissionsToResourceRole(
        projId,
        envId,
        resourceId,
        roleId,
        addRolePermissions,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios29.default, BASE_PATH, configuration);
    },
    /**
     * Creates a new role associated with the resource.
     * @summary Create Resource Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {ResourceRoleCreate} resourceRoleCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createResourceRole(projId, envId, resourceId, resourceRoleCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createResourceRole(
        projId,
        envId,
        resourceId,
        resourceRoleCreate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios29.default, BASE_PATH, configuration);
    },
    /**
     * Deletes the role and all its related data. This includes any permissions granted to said role.
     * @summary Delete Resource Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteResourceRole(projId, envId, resourceId, roleId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteResourceRole(
        projId,
        envId,
        resourceId,
        roleId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios29.default, BASE_PATH, configuration);
    },
    /**
     * Gets a single role defined on the resource, if such role exists.
     * @summary Get Resource Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getResourceRole(projId, envId, resourceId, roleId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getResourceRole(
        projId,
        envId,
        resourceId,
        roleId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios29.default, BASE_PATH, configuration);
    },
    /**
     * Lists all the roles defined on the resource.
     * @summary List Resource Roles
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listResourceRoles(projId, envId, resourceId, page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listResourceRoles(
        projId,
        envId,
        resourceId,
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios29.default, BASE_PATH, configuration);
    },
    /**
     * Remove permissions from role.  If some of the permissions specified are already unassigned, will skip them.
     * @summary Remove Permissions from Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {RemoveRolePermissions} removeRolePermissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removePermissionsFromResourceRole(projId, envId, resourceId, roleId, removeRolePermissions, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.removePermissionsFromResourceRole(
        projId,
        envId,
        resourceId,
        roleId,
        removeRolePermissions,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios29.default, BASE_PATH, configuration);
    },
    /**
     * Partially updates the role defined on a resource. Fields that will be provided will be completely overwritten.
     * @summary Update Resource Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {ResourceRoleUpdate} resourceRoleUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateResourceRole(projId, envId, resourceId, roleId, resourceRoleUpdate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateResourceRole(
        projId,
        envId,
        resourceId,
        roleId,
        resourceRoleUpdate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios29.default, BASE_PATH, configuration);
    }
  };
};
var ResourceRolesApi = class extends BaseAPI {
  /**
   * Assign permissions to role.  If some of the permissions specified are already assigned, will skip them.
   * @summary Assign Permissions to Role
   * @param {ResourceRolesApiAssignPermissionsToResourceRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceRolesApi
   */
  assignPermissionsToResourceRole(requestParameters, options) {
    return ResourceRolesApiFp(this.configuration).assignPermissionsToResourceRole(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.roleId,
      requestParameters.addRolePermissions,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Creates a new role associated with the resource.
   * @summary Create Resource Role
   * @param {ResourceRolesApiCreateResourceRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceRolesApi
   */
  createResourceRole(requestParameters, options) {
    return ResourceRolesApiFp(this.configuration).createResourceRole(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.resourceRoleCreate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Deletes the role and all its related data. This includes any permissions granted to said role.
   * @summary Delete Resource Role
   * @param {ResourceRolesApiDeleteResourceRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceRolesApi
   */
  deleteResourceRole(requestParameters, options) {
    return ResourceRolesApiFp(this.configuration).deleteResourceRole(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.roleId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Gets a single role defined on the resource, if such role exists.
   * @summary Get Resource Role
   * @param {ResourceRolesApiGetResourceRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceRolesApi
   */
  getResourceRole(requestParameters, options) {
    return ResourceRolesApiFp(this.configuration).getResourceRole(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.roleId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Lists all the roles defined on the resource.
   * @summary List Resource Roles
   * @param {ResourceRolesApiListResourceRolesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceRolesApi
   */
  listResourceRoles(requestParameters, options) {
    return ResourceRolesApiFp(this.configuration).listResourceRoles(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.page,
      requestParameters.perPage,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Remove permissions from role.  If some of the permissions specified are already unassigned, will skip them.
   * @summary Remove Permissions from Role
   * @param {ResourceRolesApiRemovePermissionsFromResourceRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceRolesApi
   */
  removePermissionsFromResourceRole(requestParameters, options) {
    return ResourceRolesApiFp(this.configuration).removePermissionsFromResourceRole(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.roleId,
      requestParameters.removeRolePermissions,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Partially updates the role defined on a resource. Fields that will be provided will be completely overwritten.
   * @summary Update Resource Role
   * @param {ResourceRolesApiUpdateResourceRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceRolesApi
   */
  updateResourceRole(requestParameters, options) {
    return ResourceRolesApiFp(this.configuration).updateResourceRole(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.roleId,
      requestParameters.resourceRoleUpdate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/resources-api.ts
var import_axios30 = __toESM(require("axios"));
var ResourcesApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * Creates a new resource (a type of object you may protect with permissions).
     * @summary Create Resource
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ResourceCreate} resourceCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createResource: async (projId, envId, resourceCreate, options = {}) => {
      assertParamExists("createResource", "projId", projId);
      assertParamExists("createResource", "envId", envId);
      assertParamExists("createResource", "resourceCreate", resourceCreate);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        resourceCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes the resource and all its related data.
     * @summary Delete Resource
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteResource: async (projId, envId, resourceId, options = {}) => {
      assertParamExists("deleteResource", "projId", projId);
      assertParamExists("deleteResource", "envId", envId);
      assertParamExists("deleteResource", "resourceId", resourceId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Gets a single resource, if such resource exists.
     * @summary Get Resource
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getResource: async (projId, envId, resourceId, options = {}) => {
      assertParamExists("getResource", "projId", projId);
      assertParamExists("getResource", "envId", envId);
      assertParamExists("getResource", "resourceId", resourceId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Lists all the resources defined in your schema.
     * @summary List Resources
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {boolean} [includeBuiltIn] Whether to include or exclude built-in resources, default is False
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {includeTotalCount} [includeTotalCount] Include the total count of resources in the response, default is False
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listResources: async (projId, envId, includeBuiltIn, page, perPage, includeTotalCount, options = {}) => {
      assertParamExists("listResources", "projId", projId);
      assertParamExists("listResources", "envId", envId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (includeBuiltIn !== void 0) {
        localVarQueryParameter["include_built_in"] = includeBuiltIn;
      }
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      if (includeTotalCount !== void 0) {
        localVarQueryParameter["include_total_count"] = includeTotalCount;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Completely replaces the resource definition.  - If the resource key is changed, all role and permissions assignments for the the resource will be revoked. - If the resource key is unchanged, but some actions are removed or renamed from the resource definition, role and permissions assignments for these actions will be revoked.  TODO: we need to decide if we are auto-revoking, or if we are rejecting the PUT completely while there are permissions that can be affected.
     * @summary Replace Resource
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {ResourceReplace} resourceReplace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    replaceResource: async (projId, envId, resourceId, resourceReplace, options = {}) => {
      assertParamExists("replaceResource", "projId", projId);
      assertParamExists("replaceResource", "envId", envId);
      assertParamExists("replaceResource", "resourceId", resourceId);
      assertParamExists("replaceResource", "resourceReplace", resourceReplace);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        resourceReplace,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Partially updates the resource definition. Fields that will be provided will be completely overwritten.
     * @summary Update Resource
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {ResourceUpdate} resourceUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateResource: async (projId, envId, resourceId, resourceUpdate, options = {}) => {
      assertParamExists("updateResource", "projId", projId);
      assertParamExists("updateResource", "envId", envId);
      assertParamExists("updateResource", "resourceId", resourceId);
      assertParamExists("updateResource", "resourceUpdate", resourceUpdate);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        resourceUpdate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var ResourcesApiFp = function(configuration) {
  const localVarAxiosParamCreator = ResourcesApiAxiosParamCreator(configuration);
  return {
    /**
     * Creates a new resource (a type of object you may protect with permissions).
     * @summary Create Resource
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ResourceCreate} resourceCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createResource(projId, envId, resourceCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createResource(
        projId,
        envId,
        resourceCreate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios30.default, BASE_PATH, configuration);
    },
    /**
     * Deletes the resource and all its related data.
     * @summary Delete Resource
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteResource(projId, envId, resourceId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteResource(
        projId,
        envId,
        resourceId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios30.default, BASE_PATH, configuration);
    },
    /**
     * Gets a single resource, if such resource exists.
     * @summary Get Resource
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getResource(projId, envId, resourceId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getResource(
        projId,
        envId,
        resourceId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios30.default, BASE_PATH, configuration);
    },
    /**
     * Lists all the resources defined in your schema.
     * @summary List Resources
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {boolean} [includeBuiltIn] Whether to include or exclude built-in resources, default is False
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {includeTotalCount} [includeTotalCount] Include the total count of resources in the response, default is False
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listResources(projId, envId, includeBuiltIn, page, perPage, includeTotalCount, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listResources(
        projId,
        envId,
        includeBuiltIn,
        page,
        perPage,
        includeTotalCount,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios30.default, BASE_PATH, configuration);
    },
    /**
     * Completely replaces the resource definition.  - If the resource key is changed, all role and permissions assignments for the the resource will be revoked. - If the resource key is unchanged, but some actions are removed or renamed from the resource definition, role and permissions assignments for these actions will be revoked.  TODO: we need to decide if we are auto-revoking, or if we are rejecting the PUT completely while there are permissions that can be affected.
     * @summary Replace Resource
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {ResourceReplace} resourceReplace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async replaceResource(projId, envId, resourceId, resourceReplace, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.replaceResource(
        projId,
        envId,
        resourceId,
        resourceReplace,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios30.default, BASE_PATH, configuration);
    },
    /**
     * Partially updates the resource definition. Fields that will be provided will be completely overwritten.
     * @summary Update Resource
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {ResourceUpdate} resourceUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateResource(projId, envId, resourceId, resourceUpdate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateResource(
        projId,
        envId,
        resourceId,
        resourceUpdate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios30.default, BASE_PATH, configuration);
    }
  };
};
var ResourcesApi = class extends BaseAPI {
  /**
   * Creates a new resource (a type of object you may protect with permissions).
   * @summary Create Resource
   * @param {ResourcesApiCreateResourceRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  createResource(requestParameters, options) {
    return ResourcesApiFp(this.configuration).createResource(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceCreate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Deletes the resource and all its related data.
   * @summary Delete Resource
   * @param {ResourcesApiDeleteResourceRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  deleteResource(requestParameters, options) {
    return ResourcesApiFp(this.configuration).deleteResource(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Gets a single resource, if such resource exists.
   * @summary Get Resource
   * @param {ResourcesApiGetResourceRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  getResource(requestParameters, options) {
    return ResourcesApiFp(this.configuration).getResource(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Lists all the resources defined in your schema.
   * @summary List Resources
   * @param {ResourcesApiListResourcesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  listResources(requestParameters, options) {
    return ResourcesApiFp(this.configuration).listResources(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.includeBuiltIn,
      requestParameters.page,
      requestParameters.perPage,
      requestParameters.includeTotalCount,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Completely replaces the resource definition.  - If the resource key is changed, all role and permissions assignments for the the resource will be revoked. - If the resource key is unchanged, but some actions are removed or renamed from the resource definition, role and permissions assignments for these actions will be revoked.  TODO: we need to decide if we are auto-revoking, or if we are rejecting the PUT completely while there are permissions that can be affected.
   * @summary Replace Resource
   * @param {ResourcesApiReplaceResourceRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  replaceResource(requestParameters, options) {
    return ResourcesApiFp(this.configuration).replaceResource(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.resourceReplace,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Partially updates the resource definition. Fields that will be provided will be completely overwritten.
   * @summary Update Resource
   * @param {ResourcesApiUpdateResourceRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  updateResource(requestParameters, options) {
    return ResourcesApiFp(this.configuration).updateResource(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.resourceUpdate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/role-assignments-api.ts
var import_axios31 = __toESM(require("axios"));
var RoleAssignmentsApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * Assigns a role to a user within a tenant.  The tenant defines the scope of the assignment. In other words, the role is effective only within the tenant.
     * @summary Assign Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {RoleAssignmentCreate} roleAssignmentCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    assignRole: async (projId, envId, roleAssignmentCreate, options = {}) => {
      assertParamExists("assignRole", "projId", projId);
      assertParamExists("assignRole", "envId", envId);
      assertParamExists("assignRole", "roleAssignmentCreate", roleAssignmentCreate);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/role_assignments`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        roleAssignmentCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Bulk Assign Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {Array<RoleAssignmentCreate>} roleAssignmentCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkAssignRole: async (projId, envId, roleAssignmentCreate, options = {}) => {
      assertParamExists("bulkAssignRole", "projId", projId);
      assertParamExists("bulkAssignRole", "envId", envId);
      assertParamExists("bulkAssignRole", "roleAssignmentCreate", roleAssignmentCreate);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/role_assignments/bulk`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        roleAssignmentCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Bulk Unassign Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {Array<RoleAssignmentRemove>} roleAssignmentRemove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkUnassignRole: async (projId, envId, roleAssignmentRemove, options = {}) => {
      assertParamExists("bulkUnassignRole", "projId", projId);
      assertParamExists("bulkUnassignRole", "envId", envId);
      assertParamExists("bulkUnassignRole", "roleAssignmentRemove", roleAssignmentRemove);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/role_assignments/bulk`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        roleAssignmentRemove,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Lists the role assignments defined within an environment.  - If the `user` filter is present, will only return the role assignments of that user (supports multiple). - If the `tenant` filter is present, will only return the role assignments in that tenant (supports multiple). - If the `role` filter is present, will only return role assignments that are granting that role (supports multiple). - If the `resource` filter is present, will only return role assignments for resource instances of that resource type. - If the `resource_instance` filter is present, will only return role assignments for that resource instance.  Providing both `tenant` and `resource_instance` filters will only return role assignments if the resource instance is in that tenant. If multiple tenants are received, the last tenant will be compared with the resource instance.
     * @summary List Role Assignments
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} [user] optional user(s) filter, will only return role assignments granted to this user(s).
     * @param {string} [role] optional role(s) filter, will only return role assignments granting this role(s).
     * @param {string} [tenant] optional tenant(s) filter, will only return role assignments granted in that tenant(s).
     * @param {string} [resource] optional resource **type** filter, will only return role assignments granted on that resource type.
     * @param {string} [resourceInstance] optional resource instance filter, will only return role assignments granted on that resource instance.
     * @param {boolean} [detailed] Whether to return full details about the user, tenant and role
     * @param {boolean} [includeTotalCount] If true, returns the list of role assignments and the total count.
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listRoleAssignments: async (projId, envId, user, role, tenant, resource, resourceInstance, detailed, includeTotalCount, page, perPage, options = {}) => {
      assertParamExists("listRoleAssignments", "projId", projId);
      assertParamExists("listRoleAssignments", "envId", envId);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/role_assignments`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (user !== void 0) {
        localVarQueryParameter["user"] = user;
      }
      if (role !== void 0) {
        localVarQueryParameter["role"] = role;
      }
      if (tenant !== void 0) {
        localVarQueryParameter["tenant"] = tenant;
      }
      if (resource !== void 0) {
        localVarQueryParameter["resource"] = resource;
      }
      if (resourceInstance !== void 0) {
        localVarQueryParameter["resource_instance"] = resourceInstance;
      }
      if (detailed !== void 0) {
        localVarQueryParameter["detailed"] = detailed;
      }
      if (includeTotalCount !== void 0) {
        localVarQueryParameter["include_total_count"] = includeTotalCount;
      }
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Unassigns a user role within a tenant.  The tenant defines the scope of the assignment. In other words, the role is effective only within the tenant.  If the role is not actually assigned, will return 404.
     * @summary Unassign Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {RoleAssignmentRemove} roleAssignmentRemove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unassignRole: async (projId, envId, roleAssignmentRemove, options = {}) => {
      assertParamExists("unassignRole", "projId", projId);
      assertParamExists("unassignRole", "envId", envId);
      assertParamExists("unassignRole", "roleAssignmentRemove", roleAssignmentRemove);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/role_assignments`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        roleAssignmentRemove,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var RoleAssignmentsApiFp = function(configuration) {
  const localVarAxiosParamCreator = RoleAssignmentsApiAxiosParamCreator(configuration);
  return {
    /**
     * Assigns a role to a user within a tenant.  The tenant defines the scope of the assignment. In other words, the role is effective only within the tenant.
     * @summary Assign Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {RoleAssignmentCreate} roleAssignmentCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async assignRole(projId, envId, roleAssignmentCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.assignRole(
        projId,
        envId,
        roleAssignmentCreate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios31.default, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Bulk Assign Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {Array<RoleAssignmentCreate>} roleAssignmentCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bulkAssignRole(projId, envId, roleAssignmentCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.bulkAssignRole(
        projId,
        envId,
        roleAssignmentCreate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios31.default, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Bulk Unassign Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {Array<RoleAssignmentRemove>} roleAssignmentRemove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bulkUnassignRole(projId, envId, roleAssignmentRemove, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.bulkUnassignRole(
        projId,
        envId,
        roleAssignmentRemove,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios31.default, BASE_PATH, configuration);
    },
    /**
     * Lists the role assignments defined within an environment.  - If the `user` filter is present, will only return the role assignments of that user (supports multiple). - If the `tenant` filter is present, will only return the role assignments in that tenant (supports multiple). - If the `role` filter is present, will only return role assignments that are granting that role (supports multiple). - If the `resource` filter is present, will only return role assignments for resource instances of that resource type. - If the `resource_instance` filter is present, will only return role assignments for that resource instance.  Providing both `tenant` and `resource_instance` filters will only return role assignments if the resource instance is in that tenant. If multiple tenants are received, the last tenant will be compared with the resource instance.
     * @summary List Role Assignments
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} [user] optional user(s) filter, will only return role assignments granted to this user(s).
     * @param {string} [role] optional role(s) filter, will only return role assignments granting this role(s).
     * @param {string} [tenant] optional tenant(s) filter, will only return role assignments granted in that tenant(s).
     * @param {string} [resource] optional resource **type** filter, will only return role assignments granted on that resource type.
     * @param {string} [resourceInstance] optional resource instance filter, will only return role assignments granted on that resource instance.
     * @param {boolean} [detailed] Whether to return full details about the user, tenant and role
     * @param {boolean} [includeTotalCount] If true, returns the list of role assignments and the total count.
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listRoleAssignments(projId, envId, user, role, tenant, resource, resourceInstance, detailed, includeTotalCount, page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listRoleAssignments(
        projId,
        envId,
        user,
        role,
        tenant,
        resource,
        resourceInstance,
        detailed,
        includeTotalCount,
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios31.default, BASE_PATH, configuration);
    },
    /**
     * Unassigns a user role within a tenant.  The tenant defines the scope of the assignment. In other words, the role is effective only within the tenant.  If the role is not actually assigned, will return 404.
     * @summary Unassign Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {RoleAssignmentRemove} roleAssignmentRemove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async unassignRole(projId, envId, roleAssignmentRemove, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.unassignRole(
        projId,
        envId,
        roleAssignmentRemove,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios31.default, BASE_PATH, configuration);
    }
  };
};
var RoleAssignmentsApi = class extends BaseAPI {
  /**
   * Assigns a role to a user within a tenant.  The tenant defines the scope of the assignment. In other words, the role is effective only within the tenant.
   * @summary Assign Role
   * @param {RoleAssignmentsApiAssignRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RoleAssignmentsApi
   */
  assignRole(requestParameters, options) {
    return RoleAssignmentsApiFp(this.configuration).assignRole(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.roleAssignmentCreate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Bulk Assign Role
   * @param {RoleAssignmentsApiBulkAssignRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RoleAssignmentsApi
   */
  bulkAssignRole(requestParameters, options) {
    return RoleAssignmentsApiFp(this.configuration).bulkAssignRole(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.roleAssignmentCreate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Bulk Unassign Role
   * @param {RoleAssignmentsApiBulkUnassignRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RoleAssignmentsApi
   */
  bulkUnassignRole(requestParameters, options) {
    return RoleAssignmentsApiFp(this.configuration).bulkUnassignRole(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.roleAssignmentRemove,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Lists the role assignments defined within an environment.  - If the `user` filter is present, will only return the role assignments of that user (supports multiple). - If the `tenant` filter is present, will only return the role assignments in that tenant (supports multiple). - If the `role` filter is present, will only return role assignments that are granting that role (supports multiple). - If the `resource` filter is present, will only return role assignments for resource instances of that resource type. - If the `resource_instance` filter is present, will only return role assignments for that resource instance.  Providing both `tenant` and `resource_instance` filters will only return role assignments if the resource instance is in that tenant. If multiple tenants are received, the last tenant will be compared with the resource instance.
   * @summary List Role Assignments
   * @param {RoleAssignmentsApiListRoleAssignmentsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RoleAssignmentsApi
   */
  listRoleAssignments(requestParameters, options) {
    return RoleAssignmentsApiFp(this.configuration).listRoleAssignments(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.user,
      requestParameters.role,
      requestParameters.tenant,
      requestParameters.resource,
      requestParameters.resourceInstance,
      requestParameters.detailed,
      requestParameters.includeTotalCount,
      requestParameters.page,
      requestParameters.perPage,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Unassigns a user role within a tenant.  The tenant defines the scope of the assignment. In other words, the role is effective only within the tenant.  If the role is not actually assigned, will return 404.
   * @summary Unassign Role
   * @param {RoleAssignmentsApiUnassignRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RoleAssignmentsApi
   */
  unassignRole(requestParameters, options) {
    return RoleAssignmentsApiFp(this.configuration).unassignRole(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.roleAssignmentRemove,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/roles-api.ts
var import_axios32 = __toESM(require("axios"));
var RolesApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * This endpoint is part of the role hierarchy feature.  Makes role with id `role_id` extend the role with id `parent_role_id`. In other words, `role_id` will automatically be assigned any permissions that are granted to `parent_role_id`.  We can say the `role_id` **extends** `parent_role_id` or **inherits** from `parent_role_id`.  If `role_id` is already an ancestor of `parent_role_id`, the request will fail with HTTP 400 to prevent a cycle in the role hierarchy.
     * @summary Add Parent Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {string} parentRoleId Either the unique id of the parent role, or the URL-friendly key of the parent role (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addParentRole: async (projId, envId, roleId, parentRoleId, options = {}) => {
      assertParamExists("addParentRole", "projId", projId);
      assertParamExists("addParentRole", "envId", envId);
      assertParamExists("addParentRole", "roleId", roleId);
      assertParamExists("addParentRole", "parentRoleId", parentRoleId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/roles/{role_id}/parents/{parent_role_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"role_id"}}`, encodeURIComponent(String(roleId))).replace(`{${"parent_role_id"}}`, encodeURIComponent(String(parentRoleId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Assign permissions to role.  If some of the permissions specified are already assigned, will skip them.
     * @summary Assign Permissions To Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {AddRolePermissions} addRolePermissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    assignPermissionsToRole: async (projId, envId, roleId, addRolePermissions, options = {}) => {
      assertParamExists("assignPermissionsToRole", "projId", projId);
      assertParamExists("assignPermissionsToRole", "envId", envId);
      assertParamExists("assignPermissionsToRole", "roleId", roleId);
      assertParamExists("assignPermissionsToRole", "addRolePermissions", addRolePermissions);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/roles/{role_id}/permissions`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        addRolePermissions,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Creates a new tenant role.
     * @summary Create Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {RoleCreate} roleCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRole: async (projId, envId, roleCreate, options = {}) => {
      assertParamExists("createRole", "projId", projId);
      assertParamExists("createRole", "envId", envId);
      assertParamExists("createRole", "roleCreate", roleCreate);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/roles`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        roleCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes a tenant role and all its related data. This includes any permissions granted to said role.
     * @summary Delete Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRole: async (projId, envId, roleId, options = {}) => {
      assertParamExists("deleteRole", "projId", projId);
      assertParamExists("deleteRole", "envId", envId);
      assertParamExists("deleteRole", "roleId", roleId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/roles/{role_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Gets a single tenant role, if such role exists.
     * @summary Get Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRole: async (projId, envId, roleId, options = {}) => {
      assertParamExists("getRole", "projId", projId);
      assertParamExists("getRole", "envId", envId);
      assertParamExists("getRole", "roleId", roleId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/roles/{role_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Lists all tenant roles.
     * @summary List Roles
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {boolean} [includeTotalCount] Include total count in response (default to false)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listRoles: async (projId, envId, page, perPage, includeTotalCount, options = {}) => {
      assertParamExists("listRoles", "projId", projId);
      assertParamExists("listRoles", "envId", envId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/roles`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      if (includeTotalCount !== void 0) {
        localVarQueryParameter["include_total_count"] = includeTotalCount;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * This endpoint is part of the role hierarchy feature.  Removes `parent_role_id` from the list of parent roles of role with id `role_id`. In other words, `role_id` will no longer be automatically assigned permissions that are granted to `parent_role_id`.  We can say the `role_id` **not longer extends** `parent_role_id` or **no longer inherits** from `parent_role_id`.
     * @summary Remove Parent Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {string} parentRoleId Either the unique id of the parent role, or the URL-friendly key of the parent role (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeParentRole: async (projId, envId, roleId, parentRoleId, options = {}) => {
      assertParamExists("removeParentRole", "projId", projId);
      assertParamExists("removeParentRole", "envId", envId);
      assertParamExists("removeParentRole", "roleId", roleId);
      assertParamExists("removeParentRole", "parentRoleId", parentRoleId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/roles/{role_id}/parents/{parent_role_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"role_id"}}`, encodeURIComponent(String(roleId))).replace(`{${"parent_role_id"}}`, encodeURIComponent(String(parentRoleId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Remove permissions from role.  If some of the permissions specified are already unassigned, will skip them.
     * @summary Remove Permissions From Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {RemoveRolePermissions} removeRolePermissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removePermissionsFromRole: async (projId, envId, roleId, removeRolePermissions, options = {}) => {
      assertParamExists("removePermissionsFromRole", "projId", projId);
      assertParamExists("removePermissionsFromRole", "envId", envId);
      assertParamExists("removePermissionsFromRole", "roleId", roleId);
      assertParamExists(
        "removePermissionsFromRole",
        "removeRolePermissions",
        removeRolePermissions
      );
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/roles/{role_id}/permissions`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        removeRolePermissions,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Partially updates a tenant role. Fields that will be provided will be completely overwritten.
     * @summary Update Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {RoleUpdate} roleUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRole: async (projId, envId, roleId, roleUpdate, options = {}) => {
      assertParamExists("updateRole", "projId", projId);
      assertParamExists("updateRole", "envId", envId);
      assertParamExists("updateRole", "roleId", roleId);
      assertParamExists("updateRole", "roleUpdate", roleUpdate);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/roles/{role_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        roleUpdate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var RolesApiFp = function(configuration) {
  const localVarAxiosParamCreator = RolesApiAxiosParamCreator(configuration);
  return {
    /**
     * This endpoint is part of the role hierarchy feature.  Makes role with id `role_id` extend the role with id `parent_role_id`. In other words, `role_id` will automatically be assigned any permissions that are granted to `parent_role_id`.  We can say the `role_id` **extends** `parent_role_id` or **inherits** from `parent_role_id`.  If `role_id` is already an ancestor of `parent_role_id`, the request will fail with HTTP 400 to prevent a cycle in the role hierarchy.
     * @summary Add Parent Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {string} parentRoleId Either the unique id of the parent role, or the URL-friendly key of the parent role (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addParentRole(projId, envId, roleId, parentRoleId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addParentRole(
        projId,
        envId,
        roleId,
        parentRoleId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios32.default, BASE_PATH, configuration);
    },
    /**
     * Assign permissions to role.  If some of the permissions specified are already assigned, will skip them.
     * @summary Assign Permissions To Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {AddRolePermissions} addRolePermissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async assignPermissionsToRole(projId, envId, roleId, addRolePermissions, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.assignPermissionsToRole(
        projId,
        envId,
        roleId,
        addRolePermissions,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios32.default, BASE_PATH, configuration);
    },
    /**
     * Creates a new tenant role.
     * @summary Create Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {RoleCreate} roleCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createRole(projId, envId, roleCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createRole(
        projId,
        envId,
        roleCreate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios32.default, BASE_PATH, configuration);
    },
    /**
     * Deletes a tenant role and all its related data. This includes any permissions granted to said role.
     * @summary Delete Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteRole(projId, envId, roleId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRole(
        projId,
        envId,
        roleId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios32.default, BASE_PATH, configuration);
    },
    /**
     * Gets a single tenant role, if such role exists.
     * @summary Get Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRole(projId, envId, roleId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getRole(
        projId,
        envId,
        roleId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios32.default, BASE_PATH, configuration);
    },
    /**
     * Lists all tenant roles.
     * @summary List Roles
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {boolean} [includeTotalCount] Include total count in response (default to false)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listRoles(projId, envId, page, perPage, includeTotalCount, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listRoles(
        projId,
        envId,
        page,
        perPage,
        includeTotalCount,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios32.default, BASE_PATH, configuration);
    },
    /**
     * This endpoint is part of the role hierarchy feature.  Removes `parent_role_id` from the list of parent roles of role with id `role_id`. In other words, `role_id` will no longer be automatically assigned permissions that are granted to `parent_role_id`.  We can say the `role_id` **not longer extends** `parent_role_id` or **no longer inherits** from `parent_role_id`.
     * @summary Remove Parent Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {string} parentRoleId Either the unique id of the parent role, or the URL-friendly key of the parent role (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removeParentRole(projId, envId, roleId, parentRoleId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.removeParentRole(
        projId,
        envId,
        roleId,
        parentRoleId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios32.default, BASE_PATH, configuration);
    },
    /**
     * Remove permissions from role.  If some of the permissions specified are already unassigned, will skip them.
     * @summary Remove Permissions From Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {RemoveRolePermissions} removeRolePermissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removePermissionsFromRole(projId, envId, roleId, removeRolePermissions, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.removePermissionsFromRole(
        projId,
        envId,
        roleId,
        removeRolePermissions,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios32.default, BASE_PATH, configuration);
    },
    /**
     * Partially updates a tenant role. Fields that will be provided will be completely overwritten.
     * @summary Update Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {RoleUpdate} roleUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateRole(projId, envId, roleId, roleUpdate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateRole(
        projId,
        envId,
        roleId,
        roleUpdate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios32.default, BASE_PATH, configuration);
    }
  };
};
var RolesApi = class extends BaseAPI {
  /**
   * This endpoint is part of the role hierarchy feature.  Makes role with id `role_id` extend the role with id `parent_role_id`. In other words, `role_id` will automatically be assigned any permissions that are granted to `parent_role_id`.  We can say the `role_id` **extends** `parent_role_id` or **inherits** from `parent_role_id`.  If `role_id` is already an ancestor of `parent_role_id`, the request will fail with HTTP 400 to prevent a cycle in the role hierarchy.
   * @summary Add Parent Role
   * @param {RolesApiAddParentRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RolesApi
   */
  addParentRole(requestParameters, options) {
    return RolesApiFp(this.configuration).addParentRole(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.roleId,
      requestParameters.parentRoleId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Assign permissions to role.  If some of the permissions specified are already assigned, will skip them.
   * @summary Assign Permissions To Role
   * @param {RolesApiAssignPermissionsToRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RolesApi
   */
  assignPermissionsToRole(requestParameters, options) {
    return RolesApiFp(this.configuration).assignPermissionsToRole(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.roleId,
      requestParameters.addRolePermissions,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Creates a new tenant role.
   * @summary Create Role
   * @param {RolesApiCreateRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RolesApi
   */
  createRole(requestParameters, options) {
    return RolesApiFp(this.configuration).createRole(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.roleCreate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Deletes a tenant role and all its related data. This includes any permissions granted to said role.
   * @summary Delete Role
   * @param {RolesApiDeleteRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RolesApi
   */
  deleteRole(requestParameters, options) {
    return RolesApiFp(this.configuration).deleteRole(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.roleId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Gets a single tenant role, if such role exists.
   * @summary Get Role
   * @param {RolesApiGetRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RolesApi
   */
  getRole(requestParameters, options) {
    return RolesApiFp(this.configuration).getRole(requestParameters.projId, requestParameters.envId, requestParameters.roleId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Lists all tenant roles.
   * @summary List Roles
   * @param {RolesApiListRolesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RolesApi
   */
  listRoles(requestParameters, options) {
    return RolesApiFp(this.configuration).listRoles(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.page,
      requestParameters.perPage,
      requestParameters.includeTotalCount,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * This endpoint is part of the role hierarchy feature.  Removes `parent_role_id` from the list of parent roles of role with id `role_id`. In other words, `role_id` will no longer be automatically assigned permissions that are granted to `parent_role_id`.  We can say the `role_id` **not longer extends** `parent_role_id` or **no longer inherits** from `parent_role_id`.
   * @summary Remove Parent Role
   * @param {RolesApiRemoveParentRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RolesApi
   */
  removeParentRole(requestParameters, options) {
    return RolesApiFp(this.configuration).removeParentRole(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.roleId,
      requestParameters.parentRoleId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Remove permissions from role.  If some of the permissions specified are already unassigned, will skip them.
   * @summary Remove Permissions From Role
   * @param {RolesApiRemovePermissionsFromRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RolesApi
   */
  removePermissionsFromRole(requestParameters, options) {
    return RolesApiFp(this.configuration).removePermissionsFromRole(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.roleId,
      requestParameters.removeRolePermissions,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Partially updates a tenant role. Fields that will be provided will be completely overwritten.
   * @summary Update Role
   * @param {RolesApiUpdateRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RolesApi
   */
  updateRole(requestParameters, options) {
    return RolesApiFp(this.configuration).updateRole(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.roleId,
      requestParameters.roleUpdate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/tenants-api.ts
var import_axios33 = __toESM(require("axios"));
var TenantsApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * Creates a new tenant inside the Permit.io system.  If the tenant is already created: will return 200 instead of 201, and will return the existing tenant object in the response body.
     * @summary Create Tenant
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {TenantCreate} tenantCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTenant: async (projId, envId, tenantCreate, options = {}) => {
      assertParamExists("createTenant", "projId", projId);
      assertParamExists("createTenant", "envId", envId);
      assertParamExists("createTenant", "tenantCreate", tenantCreate);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/tenants`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        tenantCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes the tenant and all its related data.
     * @summary Delete Tenant
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} tenantId Either the unique id of the tenant, or the URL-friendly key of the tenant (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTenant: async (projId, envId, tenantId, options = {}) => {
      assertParamExists("deleteTenant", "projId", projId);
      assertParamExists("deleteTenant", "envId", envId);
      assertParamExists("deleteTenant", "tenantId", tenantId);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/tenants/{tenant_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"tenant_id"}}`, encodeURIComponent(String(tenantId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes a user under a tenant.
     * @summary Delete Tenant User
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} tenantId Either the unique id of the tenant, or the URL-friendly key of the tenant (i.e: the \&quot;slug\&quot;).
     * @param {string} userId Either the unique id of the user, or the URL-friendly key of the user (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTenantUser: async (projId, envId, tenantId, userId, options = {}) => {
      assertParamExists("deleteTenantUser", "projId", projId);
      assertParamExists("deleteTenantUser", "envId", envId);
      assertParamExists("deleteTenantUser", "tenantId", tenantId);
      assertParamExists("deleteTenantUser", "userId", userId);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/tenants/{tenant_id}/users/{user_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"tenant_id"}}`, encodeURIComponent(String(tenantId))).replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Gets a tenant, if such tenant exists. Otherwise returns 404.
     * @summary Get Tenant
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} tenantId Either the unique id of the tenant, or the URL-friendly key of the tenant (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTenant: async (projId, envId, tenantId, options = {}) => {
      assertParamExists("getTenant", "projId", projId);
      assertParamExists("getTenant", "envId", envId);
      assertParamExists("getTenant", "tenantId", tenantId);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/tenants/{tenant_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"tenant_id"}}`, encodeURIComponent(String(tenantId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary List Tenant Users
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} tenantId Either the unique id of the tenant, or the URL-friendly key of the tenant (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} [search] Text search for the email field
     * @param {string} [role] Match users with a specific role
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTenantUsers: async (projId, tenantId, envId, search, role, page, perPage, options = {}) => {
      assertParamExists("listTenantUsers", "projId", projId);
      assertParamExists("listTenantUsers", "tenantId", tenantId);
      assertParamExists("listTenantUsers", "envId", envId);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/tenants/{tenant_id}/users`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"tenant_id"}}`, encodeURIComponent(String(tenantId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (search !== void 0) {
        localVarQueryParameter["search"] = search;
      }
      if (role !== void 0) {
        localVarQueryParameter["role"] = role;
      }
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Lists all the tenants defined within an environment.
     * @summary List Tenants
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} [search] Text search for the tenant name or key
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTenants: async (projId, envId, search, page, perPage, options = {}) => {
      assertParamExists("listTenants", "projId", projId);
      assertParamExists("listTenants", "envId", envId);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/tenants`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (search !== void 0) {
        localVarQueryParameter["search"] = search;
      }
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Partially updates the tenant definition. Fields that will be provided will be completely overwritten.
     * @summary Update Tenant
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} tenantId Either the unique id of the tenant, or the URL-friendly key of the tenant (i.e: the \&quot;slug\&quot;).
     * @param {TenantUpdate} tenantUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateTenant: async (projId, envId, tenantId, tenantUpdate, options = {}) => {
      assertParamExists("updateTenant", "projId", projId);
      assertParamExists("updateTenant", "envId", envId);
      assertParamExists("updateTenant", "tenantId", tenantId);
      assertParamExists("updateTenant", "tenantUpdate", tenantUpdate);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/tenants/{tenant_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"tenant_id"}}`, encodeURIComponent(String(tenantId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        tenantUpdate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var TenantsApiFp = function(configuration) {
  const localVarAxiosParamCreator = TenantsApiAxiosParamCreator(configuration);
  return {
    /**
     * Creates a new tenant inside the Permit.io system.  If the tenant is already created: will return 200 instead of 201, and will return the existing tenant object in the response body.
     * @summary Create Tenant
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {TenantCreate} tenantCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createTenant(projId, envId, tenantCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createTenant(
        projId,
        envId,
        tenantCreate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios33.default, BASE_PATH, configuration);
    },
    /**
     * Deletes the tenant and all its related data.
     * @summary Delete Tenant
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} tenantId Either the unique id of the tenant, or the URL-friendly key of the tenant (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteTenant(projId, envId, tenantId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTenant(
        projId,
        envId,
        tenantId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios33.default, BASE_PATH, configuration);
    },
    /**
     * Deletes a user under a tenant.
     * @summary Delete Tenant User
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} tenantId Either the unique id of the tenant, or the URL-friendly key of the tenant (i.e: the \&quot;slug\&quot;).
     * @param {string} userId Either the unique id of the user, or the URL-friendly key of the user (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteTenantUser(projId, envId, tenantId, userId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTenantUser(
        projId,
        envId,
        tenantId,
        userId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios33.default, BASE_PATH, configuration);
    },
    /**
     * Gets a tenant, if such tenant exists. Otherwise returns 404.
     * @summary Get Tenant
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} tenantId Either the unique id of the tenant, or the URL-friendly key of the tenant (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTenant(projId, envId, tenantId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getTenant(
        projId,
        envId,
        tenantId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios33.default, BASE_PATH, configuration);
    },
    /**
     *
     * @summary List Tenant Users
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} tenantId Either the unique id of the tenant, or the URL-friendly key of the tenant (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} [search] Text search for the email field
     * @param {string} [role] Match users with a specific role
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listTenantUsers(projId, tenantId, envId, search, role, page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listTenantUsers(
        projId,
        tenantId,
        envId,
        search,
        role,
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios33.default, BASE_PATH, configuration);
    },
    /**
     * Lists all the tenants defined within an environment.
     * @summary List Tenants
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} [search] Text search for the tenant name or key
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listTenants(projId, envId, search, page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listTenants(
        projId,
        envId,
        search,
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios33.default, BASE_PATH, configuration);
    },
    /**
     * Partially updates the tenant definition. Fields that will be provided will be completely overwritten.
     * @summary Update Tenant
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} tenantId Either the unique id of the tenant, or the URL-friendly key of the tenant (i.e: the \&quot;slug\&quot;).
     * @param {TenantUpdate} tenantUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateTenant(projId, envId, tenantId, tenantUpdate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateTenant(
        projId,
        envId,
        tenantId,
        tenantUpdate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios33.default, BASE_PATH, configuration);
    }
  };
};
var TenantsApi = class extends BaseAPI {
  /**
   * Creates a new tenant inside the Permit.io system.  If the tenant is already created: will return 200 instead of 201, and will return the existing tenant object in the response body.
   * @summary Create Tenant
   * @param {TenantsApiCreateTenantRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TenantsApi
   */
  createTenant(requestParameters, options) {
    return TenantsApiFp(this.configuration).createTenant(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.tenantCreate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Deletes the tenant and all its related data.
   * @summary Delete Tenant
   * @param {TenantsApiDeleteTenantRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TenantsApi
   */
  deleteTenant(requestParameters, options) {
    return TenantsApiFp(this.configuration).deleteTenant(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.tenantId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Deletes a user under a tenant.
   * @summary Delete Tenant User
   * @param {TenantsApiDeleteTenantUserRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TenantsApi
   */
  deleteTenantUser(requestParameters, options) {
    return TenantsApiFp(this.configuration).deleteTenantUser(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.tenantId,
      requestParameters.userId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Gets a tenant, if such tenant exists. Otherwise returns 404.
   * @summary Get Tenant
   * @param {TenantsApiGetTenantRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TenantsApi
   */
  getTenant(requestParameters, options) {
    return TenantsApiFp(this.configuration).getTenant(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.tenantId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary List Tenant Users
   * @param {TenantsApiListTenantUsersRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TenantsApi
   */
  listTenantUsers(requestParameters, options) {
    return TenantsApiFp(this.configuration).listTenantUsers(
      requestParameters.projId,
      requestParameters.tenantId,
      requestParameters.envId,
      requestParameters.search,
      requestParameters.role,
      requestParameters.page,
      requestParameters.perPage,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Lists all the tenants defined within an environment.
   * @summary List Tenants
   * @param {TenantsApiListTenantsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TenantsApi
   */
  listTenants(requestParameters, options) {
    return TenantsApiFp(this.configuration).listTenants(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.search,
      requestParameters.page,
      requestParameters.perPage,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Partially updates the tenant definition. Fields that will be provided will be completely overwritten.
   * @summary Update Tenant
   * @param {TenantsApiUpdateTenantRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TenantsApi
   */
  updateTenant(requestParameters, options) {
    return TenantsApiFp(this.configuration).updateTenant(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.tenantId,
      requestParameters.tenantUpdate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/user-attributes-api.ts
var import_axios34 = __toESM(require("axios"));

// src/openapi/api/users-api.ts
var import_axios35 = __toESM(require("axios"));
var UsersApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * Assigns a role to the user within the tenant.  The tenant defines the scope of the assignment. In other words, the role is effective only within the tenant.
     * @summary Assign Role To User
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} userId Either the unique id of the user, or the URL-friendly key of the user (i.e: the \&quot;slug\&quot;).
     * @param {UserRoleCreate} userRoleCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    assignRoleToUser: async (projId, envId, userId, userRoleCreate, options = {}) => {
      assertParamExists("assignRoleToUser", "projId", projId);
      assertParamExists("assignRoleToUser", "envId", envId);
      assertParamExists("assignRoleToUser", "userId", userId);
      assertParamExists("assignRoleToUser", "userRoleCreate", userRoleCreate);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/users/{user_id}/roles`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userRoleCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Creates a new user inside the Permit.io system, from that point forward you may run permission checks on that user.  If the user is already created: will return 200 instead of 201, and will return the existing user object in the response body.
     * @summary Create User
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {UserCreate} userCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUser: async (projId, envId, userCreate, options = {}) => {
      assertParamExists("createUser", "projId", projId);
      assertParamExists("createUser", "envId", envId);
      assertParamExists("createUser", "userCreate", userCreate);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/users`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes the user and all its related data.
     * @summary Delete User
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} userId Either the unique id of the user, or the URL-friendly key of the user (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser: async (projId, envId, userId, options = {}) => {
      assertParamExists("deleteUser", "projId", projId);
      assertParamExists("deleteUser", "envId", envId);
      assertParamExists("deleteUser", "userId", userId);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/users/{user_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Gets a user, if such user exists. Otherwise returns 404.
     * @summary Get User
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} userId Either the unique id of the user, or the URL-friendly key of the user (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUser: async (projId, envId, userId, options = {}) => {
      assertParamExists("getUser", "projId", projId);
      assertParamExists("getUser", "envId", envId);
      assertParamExists("getUser", "userId", userId);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/users/{user_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Lists all the users defined within an environment.
     * @summary List Users
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} [search] Text search for the email field
     * @param {string} [role] Match users with a specific role
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listUsers: async (projId, envId, search, role, page, perPage, options = {}) => {
      assertParamExists("listUsers", "projId", projId);
      assertParamExists("listUsers", "envId", envId);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/users`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (search !== void 0) {
        localVarQueryParameter["search"] = search;
      }
      if (role !== void 0) {
        localVarQueryParameter["role"] = role;
      }
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Replace User
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} userId Either the unique id of the user, or the URL-friendly key of the user (i.e: the \&quot;slug\&quot;).
     * @param {UserCreate} userCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    replaceUser: async (projId, envId, userId, userCreate, options = {}) => {
      assertParamExists("replaceUser", "projId", projId);
      assertParamExists("replaceUser", "envId", envId);
      assertParamExists("replaceUser", "userId", userId);
      assertParamExists("replaceUser", "userCreate", userCreate);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/users/{user_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Unassigns the role from the user within the tenant.  The tenant defines the scope of the assignment. In other words, the role is effective only within the tenant.  If the role is not actually assigned, will return 404.
     * @summary Unassign Role From User
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} userId Either the unique id of the user, or the URL-friendly key of the user (i.e: the \&quot;slug\&quot;).
     * @param {UserRoleRemove} userRoleRemove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unassignRoleFromUser: async (projId, envId, userId, userRoleRemove, options = {}) => {
      assertParamExists("unassignRoleFromUser", "projId", projId);
      assertParamExists("unassignRoleFromUser", "envId", envId);
      assertParamExists("unassignRoleFromUser", "userId", userId);
      assertParamExists("unassignRoleFromUser", "userRoleRemove", userRoleRemove);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/users/{user_id}/roles`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userRoleRemove,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Partially updates the user definition. Fields that will be provided will be completely overwritten.
     * @summary Update User
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} userId Either the unique id of the user, or the URL-friendly key of the user (i.e: the \&quot;slug\&quot;).
     * @param {UserUpdate} userUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUser: async (projId, envId, userId, userUpdate, options = {}) => {
      assertParamExists("updateUser", "projId", projId);
      assertParamExists("updateUser", "envId", envId);
      assertParamExists("updateUser", "userId", userId);
      assertParamExists("updateUser", "userUpdate", userUpdate);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/users/{user_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userUpdate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var UsersApiFp = function(configuration) {
  const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration);
  return {
    /**
     * Assigns a role to the user within the tenant.  The tenant defines the scope of the assignment. In other words, the role is effective only within the tenant.
     * @summary Assign Role To User
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} userId Either the unique id of the user, or the URL-friendly key of the user (i.e: the \&quot;slug\&quot;).
     * @param {UserRoleCreate} userRoleCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async assignRoleToUser(projId, envId, userId, userRoleCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.assignRoleToUser(
        projId,
        envId,
        userId,
        userRoleCreate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios35.default, BASE_PATH, configuration);
    },
    /**
     * Creates a new user inside the Permit.io system, from that point forward you may run permission checks on that user.  If the user is already created: will return 200 instead of 201, and will return the existing user object in the response body.
     * @summary Create User
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {UserCreate} userCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createUser(projId, envId, userCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(
        projId,
        envId,
        userCreate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios35.default, BASE_PATH, configuration);
    },
    /**
     * Deletes the user and all its related data.
     * @summary Delete User
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} userId Either the unique id of the user, or the URL-friendly key of the user (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteUser(projId, envId, userId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(
        projId,
        envId,
        userId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios35.default, BASE_PATH, configuration);
    },
    /**
     * Gets a user, if such user exists. Otherwise returns 404.
     * @summary Get User
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} userId Either the unique id of the user, or the URL-friendly key of the user (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUser(projId, envId, userId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(
        projId,
        envId,
        userId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios35.default, BASE_PATH, configuration);
    },
    /**
     * Lists all the users defined within an environment.
     * @summary List Users
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} [search] Text search for the email field
     * @param {string} [role] Match users with a specific role
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listUsers(projId, envId, search, role, page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listUsers(
        projId,
        envId,
        search,
        role,
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios35.default, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Replace User
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} userId Either the unique id of the user, or the URL-friendly key of the user (i.e: the \&quot;slug\&quot;).
     * @param {UserCreate} userCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async replaceUser(projId, envId, userId, userCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.replaceUser(
        projId,
        envId,
        userId,
        userCreate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios35.default, BASE_PATH, configuration);
    },
    /**
     * Unassigns the role from the user within the tenant.  The tenant defines the scope of the assignment. In other words, the role is effective only within the tenant.  If the role is not actually assigned, will return 404.
     * @summary Unassign Role From User
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} userId Either the unique id of the user, or the URL-friendly key of the user (i.e: the \&quot;slug\&quot;).
     * @param {UserRoleRemove} userRoleRemove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async unassignRoleFromUser(projId, envId, userId, userRoleRemove, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.unassignRoleFromUser(
        projId,
        envId,
        userId,
        userRoleRemove,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios35.default, BASE_PATH, configuration);
    },
    /**
     * Partially updates the user definition. Fields that will be provided will be completely overwritten.
     * @summary Update User
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} userId Either the unique id of the user, or the URL-friendly key of the user (i.e: the \&quot;slug\&quot;).
     * @param {UserUpdate} userUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateUser(projId, envId, userId, userUpdate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(
        projId,
        envId,
        userId,
        userUpdate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios35.default, BASE_PATH, configuration);
    }
  };
};
var UsersApi = class extends BaseAPI {
  /**
   * Assigns a role to the user within the tenant.  The tenant defines the scope of the assignment. In other words, the role is effective only within the tenant.
   * @summary Assign Role To User
   * @param {UsersApiAssignRoleToUserRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  assignRoleToUser(requestParameters, options) {
    return UsersApiFp(this.configuration).assignRoleToUser(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.userId,
      requestParameters.userRoleCreate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Creates a new user inside the Permit.io system, from that point forward you may run permission checks on that user.  If the user is already created: will return 200 instead of 201, and will return the existing user object in the response body.
   * @summary Create User
   * @param {UsersApiCreateUserRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  createUser(requestParameters, options) {
    return UsersApiFp(this.configuration).createUser(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.userCreate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Deletes the user and all its related data.
   * @summary Delete User
   * @param {UsersApiDeleteUserRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  deleteUser(requestParameters, options) {
    return UsersApiFp(this.configuration).deleteUser(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.userId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Gets a user, if such user exists. Otherwise returns 404.
   * @summary Get User
   * @param {UsersApiGetUserRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  getUser(requestParameters, options) {
    return UsersApiFp(this.configuration).getUser(requestParameters.projId, requestParameters.envId, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Lists all the users defined within an environment.
   * @summary List Users
   * @param {UsersApiListUsersRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  listUsers(requestParameters, options) {
    return UsersApiFp(this.configuration).listUsers(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.search,
      requestParameters.role,
      requestParameters.page,
      requestParameters.perPage,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Replace User
   * @param {UsersApiReplaceUserRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  replaceUser(requestParameters, options) {
    return UsersApiFp(this.configuration).replaceUser(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.userId,
      requestParameters.userCreate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Unassigns the role from the user within the tenant.  The tenant defines the scope of the assignment. In other words, the role is effective only within the tenant.  If the role is not actually assigned, will return 404.
   * @summary Unassign Role From User
   * @param {UsersApiUnassignRoleFromUserRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  unassignRoleFromUser(requestParameters, options) {
    return UsersApiFp(this.configuration).unassignRoleFromUser(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.userId,
      requestParameters.userRoleRemove,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Partially updates the user definition. Fields that will be provided will be completely overwritten.
   * @summary Update User
   * @param {UsersApiUpdateUserRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  updateUser(requestParameters, options) {
    return UsersApiFp(this.configuration).updateUser(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.userId,
      requestParameters.userUpdate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/users-elements-data-api.ts
var import_axios36 = __toESM(require("axios"));

// src/openapi/configuration.ts
var Configuration = class {
  constructor(param = {}) {
    this.apiKey = param.apiKey;
    this.username = param.username;
    this.password = param.password;
    this.accessToken = param.accessToken;
    this.basePath = param.basePath;
    this.baseOptions = param.baseOptions;
    this.formDataCtor = param.formDataCtor;
  }
  /**
   * Check if the given MIME is a JSON MIME.
   * JSON MIME examples:
   *   application/json
   *   application/json; charset=UTF8
   *   APPLICATION/JSON
   *   application/vnd.company+json
   * @param mime - MIME (Multipurpose Internet Mail Extensions)
   * @return True if the given MIME is JSON, false otherwise.
   */
  isJsonMime(mime) {
    const jsonMime = new RegExp(
      "^(application/json|[^;/ 	]+/[^;/ 	]+[+]json)[ 	]*(;.*)?$",
      "i"
    );
    return mime !== null && (jsonMime.test(mime) || mime.toLowerCase() === "application/json-patch+json");
  }
};

// src/openapi/types/apikey-owner-type.ts
var APIKeyOwnerType = {
  PdpConfig: "pdp_config",
  Member: "member",
  Elements: "elements"
};

// src/openapi/types/attribute-type.ts
var AttributeType = {
  Bool: "bool",
  Number: "number",
  String: "string",
  Time: "time",
  Array: "array",
  Json: "json"
};

// src/openapi/types/condition-set-type.ts
var ConditionSetType = {
  Userset: "userset",
  Resourceset: "resourceset"
};

// src/openapi/types/environment-copy.ts
var EnvironmentCopyConflictStrategyEnum = {
  Fail: "fail",
  Overwrite: "overwrite"
};

// src/openapi/types/member-access-level.ts
var MemberAccessLevel = {
  Admin: "admin",
  Write: "write",
  Read: "read"
};

// src/openapi/types/member-access-obj.ts
var MemberAccessObj = {
  Org: "org",
  Project: "project",
  Env: "env"
};

// src/api/base.ts
var import_axios37 = __toESM(require("axios"));

// src/api/context.ts
var ApiKeyLevel = /* @__PURE__ */ ((ApiKeyLevel2) => {
  ApiKeyLevel2["WAIT_FOR_INIT"] = "WAIT_FOR_INIT";
  ApiKeyLevel2["ORGANIZATION_LEVEL_API_KEY"] = "ORGANIZATION_LEVEL_API_KEY";
  ApiKeyLevel2["PROJECT_LEVEL_API_KEY"] = "PROJECT_LEVEL_API_KEY";
  ApiKeyLevel2["ENVIRONMENT_LEVEL_API_KEY"] = "ENVIRONMENT_LEVEL_API_KEY";
  return ApiKeyLevel2;
})(ApiKeyLevel || {});
var API_ACCESS_LEVELS = [
  "ORGANIZATION_LEVEL_API_KEY" /* ORGANIZATION_LEVEL_API_KEY */,
  "PROJECT_LEVEL_API_KEY" /* PROJECT_LEVEL_API_KEY */,
  "ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */
];
var ApiContextLevel = /* @__PURE__ */ ((ApiContextLevel2) => {
  ApiContextLevel2[ApiContextLevel2["WAIT_FOR_INIT"] = 0] = "WAIT_FOR_INIT";
  ApiContextLevel2[ApiContextLevel2["ORGANIZATION"] = 1] = "ORGANIZATION";
  ApiContextLevel2[ApiContextLevel2["PROJECT"] = 2] = "PROJECT";
  ApiContextLevel2[ApiContextLevel2["ENVIRONMENT"] = 3] = "ENVIRONMENT";
  return ApiContextLevel2;
})(ApiContextLevel || {});
var PermitContextError = class extends Error {
  constructor(message) {
    super(message);
  }
};
var PermitContextChangeError = class extends Error {
  constructor(message) {
    super(message);
  }
};
var ApiContext = class {
  constructor() {
    this._level = "WAIT_FOR_INIT" /* WAIT_FOR_INIT */;
    this._permittedOrganization = null;
    this._permittedProject = null;
    this._permittedEnvironment = null;
    this._contextLevel = 0 /* WAIT_FOR_INIT */;
    this._organization = null;
    this._project = null;
    this._environment = null;
  }
  /**
   * Do not call this method directly!
   */
  _saveApiKeyAccessibleScope(org, project, environment) {
    this._permittedOrganization = org;
    if (project && environment) {
      this._permittedProject = project;
      this._permittedEnvironment = environment;
      this._level = "ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */;
    } else if (project) {
      this._permittedProject = project;
      this._permittedEnvironment = null;
      this._level = "PROJECT_LEVEL_API_KEY" /* PROJECT_LEVEL_API_KEY */;
    } else {
      this._permittedProject = null;
      this._permittedEnvironment = null;
      this._level = "ORGANIZATION_LEVEL_API_KEY" /* ORGANIZATION_LEVEL_API_KEY */;
    }
  }
  /**
   * Get the current API key access level.
   */
  get permittedAccessLevel() {
    return this._level;
  }
  /**
   * Get the current API key level.
   * @deprecated replaced with permit.config.apiContext.permittedAccessLevel
   */
  get level() {
    return this._level;
  }
  /**
   * Get the current SDK context level.
   */
  get contextLevel() {
    return this._contextLevel;
  }
  /**
   * Get the current organization in the context.
   */
  get organization() {
    return this._organization;
  }
  /**
   * Get the current project in the context.
   */
  get project() {
    return this._project;
  }
  /**
   * Get the current environment in the context.
   */
  get environment() {
    return this._environment;
  }
  verifyCanAccessOrg(org) {
    if (org !== this._permittedOrganization) {
      throw new PermitContextChangeError(
        `You cannot set an SDK context with org '${org}' due to insufficient API Key permissions`
      );
    }
  }
  verifyCanAccessProject(org, project) {
    this.verifyCanAccessOrg(org);
    if (this._permittedProject !== null && project !== this._permittedProject) {
      throw new PermitContextChangeError(
        `You cannot set an SDK context with project '${project}' due to insufficient API Key permissions`
      );
    }
  }
  verifyCanAccessEnvironment(org, project, environment) {
    this.verifyCanAccessProject(org, project);
    if (this._permittedEnvironment !== null && environment !== this._permittedEnvironment) {
      throw new PermitContextChangeError(
        `You cannot set an SDK context with environment '${environment}' due to insufficient API Key permissions`
      );
    }
  }
  /**
   * Set the context to organization level.
   * @param org The organization key.
   */
  setOrganizationLevelContext(org) {
    this.verifyCanAccessOrg(org);
    this._contextLevel = 1 /* ORGANIZATION */;
    this._organization = org;
    this._project = null;
    this._environment = null;
  }
  /**
   * Set the context to project level.
   * @param org The organization key.
   * @param project The project key.
   */
  setProjectLevelContext(org, project) {
    this.verifyCanAccessProject(org, project);
    this._contextLevel = 2 /* PROJECT */;
    this._organization = org;
    this._project = project;
    this._environment = null;
  }
  /**
   * Set the context to environment level.
   * @param org The organization key.
   * @param project The project key.
   * @param environment The environment key.
   */
  setEnvironmentLevelContext(org, project, environment) {
    this.verifyCanAccessEnvironment(org, project, environment);
    this._contextLevel = 3 /* ENVIRONMENT */;
    this._organization = org;
    this._project = project;
    this._environment = environment;
  }
  /**
   * Get the API project and environment parameters from an environment-level context.
   * @returns An object containing the project and environment IDs.
   * @throws {@link PermitContextError} If the API context is not set to environment level or the project or environment is null.
   */
  get environmentContext() {
    if (this._contextLevel !== 3 /* ENVIRONMENT */ || this._project === null || this._environment === null) {
      throw new PermitContextError(
        `You cannot get environment context, current api context is: ${ApiContextLevel[this._contextLevel]}`
      );
    }
    return {
      projId: this._project,
      envId: this._environment
    };
  }
};

// src/api/base.ts
var PermitApiError = class extends Error {
  constructor(message, originalError) {
    super(message);
    this.originalError = originalError;
  }
  get formattedAxiosError() {
    var _a;
    return {
      code: this.originalError.code,
      message: this.message,
      error: (_a = this.originalError.response) == null ? void 0 : _a.data,
      status: this.originalError.status
    };
  }
  get request() {
    return this.originalError.request;
  }
  get response() {
    return this.originalError.response;
  }
};
var BasePermitApi = class {
  constructor(config, logger) {
    this.config = config;
    this.logger = logger;
    const version = process.env.npm_package_version ?? "unknown";
    this.openapiClientConfig = new Configuration({
      basePath: `${this.config.apiUrl}`,
      accessToken: this.config.token,
      baseOptions: {
        headers: {
          "X-Permit-SDK-Version": `node:${version}`
        }
      }
    });
    this.scopeApi = new APIKeysApi(this.openapiClientConfig, BASE_PATH, this.config.axiosInstance);
  }
  /**
   * Sets the API context and permitted access level based on the API key scope.
   */
  async setContextFromApiKey() {
    var _a, _b;
    try {
      this.logger.debug("Fetching api key scope");
      const response = await this.scopeApi.getApiKeyScope();
      if (response.data.organization_id !== void 0 && response.data.organization_id !== null) {
        this.config.apiContext._saveApiKeyAccessibleScope(
          response.data.organization_id,
          response.data.project_id,
          response.data.environment_id
        );
        if (response.data.project_id !== void 0 && response.data.project_id !== null) {
          if (response.data.environment_id !== void 0 && response.data.environment_id !== null) {
            this.logger.debug(`setting: environment-level api context`);
            this.config.apiContext.setEnvironmentLevelContext(
              response.data.organization_id,
              response.data.project_id,
              response.data.environment_id
            );
            return;
          }
          this.logger.debug(`setting: project-level api context`);
          this.config.apiContext.setProjectLevelContext(
            response.data.organization_id,
            response.data.project_id
          );
          return;
        }
        this.logger.debug(`setting: organization-level api context`);
        this.config.apiContext.setOrganizationLevelContext(response.data.organization_id);
        return;
      }
      throw new PermitContextError("could not set api context level");
    } catch (err) {
      if (import_axios37.default.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.getApiKeyScope(), err: ${JSON.stringify(
            (_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data
          )}`
        );
      }
      throw new PermitContextError(
        "could not fetch the api key scope in order to set the api context level"
      );
    }
  }
  /**
   * Ensure that the API Key has the necessary permissions to successfully call the API endpoint.
   * Note that this check is not foolproof, and the API may still throw 401.
   * @param requiredAccessLevel The required API Key Access level for the endpoint.
   * @throws PermitContextError If the currently set API key access level does not match the required access level.
   */
  async ensureAccessLevel(requiredAccessLevel) {
    if (this.config.apiContext.contextLevel === 0 /* WAIT_FOR_INIT */ || this.config.apiContext.permittedAccessLevel === "WAIT_FOR_INIT" /* WAIT_FOR_INIT */) {
      await this.setContextFromApiKey();
    }
    if (requiredAccessLevel !== this.config.apiContext.permittedAccessLevel) {
      if (API_ACCESS_LEVELS.indexOf(requiredAccessLevel) < API_ACCESS_LEVELS.indexOf(this.config.apiContext.permittedAccessLevel)) {
        throw new PermitContextError(
          `You're trying to use an SDK method that requires an API Key with access level: ${requiredAccessLevel}, however the SDK is running with an API key with level ${this.config.apiContext.permittedAccessLevel}.`
        );
      }
    }
  }
  /**
   * Ensure that the API context matches the required endpoint context.
   * @param requiredContext The required API context level for the endpoint.
   * @throws PermitContextError If the currently set API context level does not match the required context level.
   */
  async ensureContext(requiredContext) {
    if (this.config.apiContext.contextLevel === 0 /* WAIT_FOR_INIT */ || this.config.apiContext.permittedAccessLevel === "WAIT_FOR_INIT" /* WAIT_FOR_INIT */) {
      await this.setContextFromApiKey();
    }
    if (this.config.apiContext.contextLevel < requiredContext || this.config.apiContext.contextLevel === 0 /* WAIT_FOR_INIT */) {
      throw new PermitContextError(
        `You're trying to use an SDK method that requires an API context of ${ApiContextLevel[requiredContext]}, however the SDK is running in a less specific context level: ${ApiContextLevel[this.config.apiContext.contextLevel]}.`
      );
    }
  }
  handleApiError(err) {
    var _a, _b, _c;
    if (import_axios37.default.isAxiosError(err)) {
      const logMessage = `Got error status code: ${(_a = err.response) == null ? void 0 : _a.status}, err: ${JSON.stringify(
        (_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data
      )}`;
      const apiMessage = (_c = err.response) == null ? void 0 : _c.data.message;
      this.logger.error(logMessage);
      throw new PermitApiError(apiMessage, err);
    } else {
      throw err;
    }
  }
};
var BaseFactsPermitAPI = class extends BasePermitApi {
  constructor(config, logger) {
    super(config, logger);
    this.config = config;
    this.logger = logger;
    if (config.proxyFactsViaPdp) {
      this.openapiClientConfig = new Configuration({
        basePath: `${this.config.pdp}`,
        accessToken: this.config.token,
        baseOptions: {
          headers: {
            ...this.openapiClientConfig.baseOptions.headers,
            ...this.config.factsSyncTimeout !== null && {
              "X-Wait-Timeout": this.config.factsSyncTimeout.toString()
            },
            ...this.config.factsSyncTimeoutPolicy && {
              "X-Timeout-Policy": this.config.factsSyncTimeoutPolicy
            }
          }
        }
      });
    }
  }
  clone() {
    return new this.constructor(this.config, this.logger);
  }
  waitForSync(timeout, policy) {
    if (this.config.proxyFactsViaPdp) {
      const clone = this.clone();
      clone.openapiClientConfig.baseOptions.headers["X-Wait-Timeout"] = timeout === null ? "" : timeout.toString();
      const timeoutPolicy = policy || this.config.factsSyncTimeoutPolicy;
      if (timeoutPolicy) {
        clone.openapiClientConfig.baseOptions.headers["X-Timeout-Policy"] = timeoutPolicy;
      }
      return clone;
    } else {
      this.logger.warn(
        "Attempted to wait for sync, but 'proxyFactsViaPdp' is not enabled. Ignoring."
      );
      return this;
    }
  }
};

// src/api/condition-set-rules.ts
var ConditionSetRulesApi2 = class extends BasePermitApi {
  /**
   * Creates an instance of the ConditionSetRulesApi.
   * @param config - The configuration object for the Permit SDK.
   * @param logger - The logger instance for logging.
   */
  constructor(config, logger) {
    super(config, logger);
    this.setRules = new ConditionSetRulesApi(
      this.openapiClientConfig,
      BASE_PATH,
      this.config.axiosInstance
    );
  }
  /**
   * Retrieves a list of condition set rules based on the specified parameters.
   *
   * @param params - parameters for filtering and pagination, @see {@link IListConditionSetRules}
   * @returns A promise that resolves to an array of condition set rules.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async list(params) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    const { userSetKey, permissionKey, resourceSetKey, page = 1, perPage = 100 } = params;
    try {
      return (await this.setRules.listSetPermissions({
        ...this.config.apiContext.environmentContext,
        userSet: userSetKey,
        permission: permissionKey,
        resourceSet: resourceSetKey,
        page,
        perPage
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Creates a new condition set rule.
   *
   * @param rule - The condition set rule to create.
   * @returns A promise that resolves to the created condition set rule.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async create(rule) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.setRules.assignSetPermissions({
        ...this.config.apiContext.environmentContext,
        conditionSetRuleCreate: rule
      })).data[0];
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Deletes a condition set rule.
   *
   * @param rule - The condition set rule to delete.
   * @returns A promise that resolves when the condition set rule is deleted.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async delete(rule) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.setRules.unassignSetPermissions({
        ...this.config.apiContext.environmentContext,
        conditionSetRuleRemove: rule
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
};

// src/api/condition-sets.ts
var ConditionSetsApi2 = class extends BasePermitApi {
  /**
   * Creates an instance of the ConditionSetsApi.
   * @param config - The configuration object for the Permit SDK.
   * @param logger - The logger instance for logging.
   */
  constructor(config, logger) {
    super(config, logger);
    this.conditionSets = new ConditionSetsApi(
      this.openapiClientConfig,
      BASE_PATH,
      this.config.axiosInstance
    );
  }
  /**
   * Retrieves a list of condition sets.
   *
   * @param pagination The pagination options, @see {@link IPagination}
   * @returns A promise that resolves to an array of condition sets.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async list(pagination) {
    const { page = 1, perPage = 100 } = pagination ?? {};
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.conditionSets.listConditionSets({
        ...this.config.apiContext.environmentContext,
        page,
        perPage
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Retrieves a condition set by its key.
   *
   * @param conditionSetKey The key of the condition set.
   * @returns A promise that resolves to the condition set.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async get(conditionSetKey) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.conditionSets.getConditionSet({
        ...this.config.apiContext.environmentContext,
        conditionSetId: conditionSetKey
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Retrieves a condition set by its key.
   * Alias for the {@link get} method.
   *
   * @param conditionSetKey The key of the condition set.
   * @returns A promise that resolves to the condition set.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async getByKey(conditionSetKey) {
    return await this.get(conditionSetKey);
  }
  /**
   * Retrieves a condition set by its ID.
   * Alias for the {@link get} method.
   *
   * @param conditionSetId The ID of the condition set.
   * @returns A promise that resolves to the condition set.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async getById(conditionSetId) {
    return await this.get(conditionSetId);
  }
  /**
   * Creates a new condition set.
   *
   * @param conditionSetData The data for the new condition set.
   * @returns A promise that resolves to the created condition set.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async create(conditionSetData) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.conditionSets.createConditionSet({
        ...this.config.apiContext.environmentContext,
        conditionSetCreate: conditionSetData
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Updates a condition set.
   *
   * @param conditionSetKey The key of the condition set.
   * @param conditionSetData The updated data for the condition set.
   * @returns A promise that resolves to the updated condition set.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async update(conditionSetKey, conditionSetData) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.conditionSets.updateConditionSet({
        ...this.config.apiContext.environmentContext,
        conditionSetId: conditionSetKey,
        conditionSetUpdate: conditionSetData
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Deletes a condition set.
   *
   * @param conditionSetKey The key of the condition set to delete.
   * @returns A promise that resolves when the condition set is deleted.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async delete(conditionSetKey) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      await this.conditionSets.deleteConditionSet({
        ...this.config.apiContext.environmentContext,
        conditionSetId: conditionSetKey
      });
    } catch (err) {
      this.handleApiError(err);
    }
  }
};

// src/api/deprecated.ts
var import_axios38 = __toESM(require("axios"));
var DeprecatedApiClient = class extends BasePermitApi {
  /**
   * Creates an instance of DeprecatedApiClient.
   * @param config - The configuration object for the Permit SDK.
   * @param logger - The logger object for logging.
   */
  constructor(config, logger) {
    super(config, logger);
    this._users = new UsersApi(this.openapiClientConfig, BASE_PATH, this.config.axiosInstance);
    this._tenants = new TenantsApi(this.openapiClientConfig, BASE_PATH, this.config.axiosInstance);
    this._roles = new RolesApi(this.openapiClientConfig, BASE_PATH, this.config.axiosInstance);
    this._conditionSets = new ConditionSetsApi(
      this.openapiClientConfig,
      BASE_PATH,
      this.config.axiosInstance
    );
    this._conditionSetRules = new ConditionSetRulesApi(
      this.openapiClientConfig,
      BASE_PATH,
      this.config.axiosInstance
    );
    this._roleAssignments = new RoleAssignmentsApi(
      this.openapiClientConfig,
      BASE_PATH,
      this.config.axiosInstance
    );
    this._resources = new ResourcesApi(
      this.openapiClientConfig,
      BASE_PATH,
      this.config.axiosInstance
    );
  }
  /**
   * Retrieves a list of users.
   * @returns A promise that resolves to an array of UserRead objects representing the users.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.users.list()
   */
  async listUsers() {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._users.listUsers({
        ...this.config.apiContext.environmentContext
      });
      this.logger.debug(`[${response.status}] permit.api.listUsers()`);
      return response.data.data;
    } catch (err) {
      if (import_axios38.default.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.getUser(), err: ${JSON.stringify(
            (_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data
          )}`
        );
      }
      throw err;
    }
  }
  /**
   * Retrieves a list of roles.
   * @returns A promise that resolves to an array of RoleRead objects representing the roles.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.roles.list()
   */
  async listRoles() {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._roles.listRoles({
        ...this.config.apiContext.environmentContext
      });
      this.logger.debug(`[${response.status}] permit.api.listRoles()`);
      return response.data;
    } catch (err) {
      if (import_axios38.default.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.listRoles(), err: ${JSON.stringify(
            (_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data
          )}`
        );
      }
      throw err;
    }
  }
  /**
   * Retrieves a list of condition sets.
   * @param type - The type of the condition set, either `userset` or `resourceset`.
   * @param page - The page number.
   * @param perPage - The number of items per page.
   * @returns A promise that resolves to an array of ConditionSetRead objects representing the condition sets.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.conditionSets.list()
   */
  async listConditionSets(type, page, perPage) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._conditionSets.listConditionSets({
        ...this.config.apiContext.environmentContext,
        type,
        page,
        perPage
      });
      this.logger.debug(`[${response.status}] permit.api.listRoles()`);
      return response.data;
    } catch (err) {
      if (import_axios38.default.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.listRoles(), err: ${JSON.stringify(
            (_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data
          )}`
        );
      }
      throw err;
    }
  }
  /**
   * Retrieves a list of condition set rules.
   * @param page - The page number.
   * @param perPage - The number of items per page.
   * @returns A promise that resolves to an array of ConditionSetRuleRead objects representing the condition set rules.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.conditionSetRules.list()
   */
  async listConditionSetsRules(page, perPage) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._conditionSetRules.listSetPermissions({
        ...this.config.apiContext.environmentContext,
        page,
        perPage
      });
      this.logger.debug(`[${response.status}] permit.api.listRoles()`);
      return response.data;
    } catch (err) {
      if (import_axios38.default.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.listRoles(), err: ${JSON.stringify(
            (_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data
          )}`
        );
      }
      throw err;
    }
  }
  /**
   * Retrieves a user by ID or key
   * @param userId - The ID or the key of the user.
   * @returns A promise that resolves to a UserRead object representing the user.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.users.get()
   */
  async getUser(userId) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._users.getUser({
        ...this.config.apiContext.environmentContext,
        userId
      });
      this.logger.debug(`[${response.status}] permit.api.getUser(${userId})`);
      return response.data;
    } catch (err) {
      if (import_axios38.default.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.getUser(${userId}), err: ${JSON.stringify(
            (_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data
          )}`
        );
      }
      throw err;
    }
  }
  /**
   * Retrieves a tenant by ID or key.
   * @param tenantId - The ID or the key of the tenant.
   * @returns A promise that resolves to a TenantRead object representing the tenant.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.tenants.get()
   */
  async getTenant(tenantId) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._tenants.getTenant({
        ...this.config.apiContext.environmentContext,
        tenantId
      });
      this.logger.debug(`[${response.status}] permit.api.getTenant(${tenantId})`);
      return response.data;
    } catch (err) {
      if (import_axios38.default.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.getTenant(${tenantId}), err: ${JSON.stringify(
            (_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data
          )}`
        );
      }
      throw err;
    }
  }
  /**
   * Retrieves a list of tenants.
   * @param page - The page number.
   * @returns A promise that resolves to an array of TenantRead objects representing the tenants.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.tenants.list()
   */
  async listTenants(page) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._tenants.listTenants({
        ...this.config.apiContext.environmentContext,
        page
      });
      this.logger.debug(`[${response.status}] permit.api.listTenants(${page ?? ""})`);
      return response.data;
    } catch (err) {
      if (import_axios38.default.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.listTenants(${page ?? ""}), err: ${JSON.stringify(
            (_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data
          )}`
        );
      }
      throw err;
    }
  }
  /**
   * Retrieves a role by ID or key.
   * @param roleId - The ID or the key of the role.
   * @returns A promise that resolves to a RoleRead object representing the role.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.roles.get()
   */
  async getRole(roleId) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._roles.getRole({
        ...this.config.apiContext.environmentContext,
        roleId
      });
      this.logger.debug(`[${response.status}] permit.api.getRole(${roleId})`);
      return response.data;
    } catch (err) {
      if (import_axios38.default.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.getRole(${roleId}), err: ${JSON.stringify(
            (_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data
          )}`
        );
      }
      throw err;
    }
  }
  /**
   * Retrieves the assigned roles for a user (either in a single tenant or in all tenants).
   * @param user - The ID or key of the user.
   * @param tenant - The ID or key of the tenant, optional. If provided, only roles assigned within this tenant will be returned.
   * @returns A promise that resolves to an array of RoleAssignmentRead objects representing the assigned roles.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.users.getAssignedRoles()
   */
  async getAssignedRoles(user, tenant) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._roleAssignments.listRoleAssignments({
        ...this.config.apiContext.environmentContext,
        user,
        tenant
      });
      this.logger.debug(
        `[${response.status}] permit.api.getAssignedRoles(${user}, ${tenant ?? "all tenants"})`
      );
      return response.data;
    } catch (err) {
      if (import_axios38.default.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.getAssignedRoles(${user}, ${tenant ?? "all tenants"}), err: ${JSON.stringify((_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data)}`
        );
      }
      throw err;
    }
  }
  /**
   * Creates a new resource.
   * @param resource - The resource to create.
   * @returns A promise that resolves to a ResourceRead object representing the created resource.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.resources.create()
   */
  async createResource(resource) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._resources.createResource({
        ...this.config.apiContext.environmentContext,
        resourceCreate: resource
      });
      this.logger.debug(
        `[${response.status}] permit.api.createResource(${JSON.stringify(resource)})`
      );
      return response.data;
    } catch (err) {
      if (import_axios38.default.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.createResource(${JSON.stringify(
            resource
          )}), err: ${JSON.stringify((_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data)}`
        );
      }
      throw err;
    }
  }
  /**
   * Updates an existing resource.
   * @param resourceId - The ID or key of the resource to update.
   * @param resource - The updated resource data.
   * @returns A promise that resolves to a ResourceRead object representing the updated resource.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.resources.update()
   */
  async updateResource(resourceId, resource) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._resources.updateResource({
        ...this.config.apiContext.environmentContext,
        resourceId,
        resourceUpdate: resource
      });
      this.logger.debug(
        `[${response.status}] permit.api.updateResource(${resourceId}, ${JSON.stringify(
          resource
        )})`
      );
      return response.data;
    } catch (err) {
      if (import_axios38.default.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.updateResource(${resourceId}, ${JSON.stringify(
            resource
          )}), err: ${JSON.stringify((_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data)}`
        );
      }
      throw err;
    }
  }
  /**
   * Deletes a resource.
   * @param resourceId - The ID or key of the resource to delete.
   * @returns A promise that resolves when the resource is deleted.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.resources.delete()
   */
  async deleteResource(resourceId) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._resources.deleteResource({
        ...this.config.apiContext.environmentContext,
        resourceId
      });
      this.logger.debug(`[${response.status}] permit.api.deleteResource(${resourceId})`);
      return response;
    } catch (err) {
      if (import_axios38.default.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.deleteResource(${resourceId}), err: ${JSON.stringify((_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data)}`
        );
      }
      throw err;
    }
  }
  /**
   * Creates a new user.
   * @param user - The user to create.
   * @returns A promise that resolves to a UserRead object representing the created user.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.users.create()
   */
  async createUser(user) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._users.createUser({
        ...this.config.apiContext.environmentContext,
        userCreate: user
      });
      this.logger.debug(`[${response.status}] permit.api.createUser(${JSON.stringify(user)})`);
      return response.data;
    } catch (err) {
      if (import_axios38.default.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.createUser(${JSON.stringify(
            user
          )}), err: ${JSON.stringify((_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data)}`
        );
      }
      throw err;
    }
  }
  /**
   * Creates or Updates in place a user.
   * @param user - The user to create or update.
   * @returns A promise that resolves to a UserRead object representing the synced user.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.users.sync()
   */
  async syncUser(user) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._users.replaceUser({
        ...this.config.apiContext.environmentContext,
        userId: user.key,
        userCreate: user
      });
      this.logger.debug(`[${response.status}] permit.api.syncUser(${JSON.stringify(user)})`);
      return response.data;
    } catch (err) {
      if (import_axios38.default.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.syncUser(${JSON.stringify(
            user
          )}), err: ${JSON.stringify((_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data)}`
        );
      }
      throw err;
    }
  }
  /**
   * Updates an existing user.
   * @param userId - The ID or key of the user to update.
   * @param user - The updated user data.
   * @returns A promise that resolves to a UserRead object representing the updated user.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.users.update()
   */
  async updateUser(userId, user) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._users.updateUser({
        ...this.config.apiContext.environmentContext,
        userId,
        userUpdate: user
      });
      this.logger.debug(`[${response.status}] permit.api.updateUser(${JSON.stringify(user)})`);
      return response.data;
    } catch (err) {
      if (import_axios38.default.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.updateUser(${JSON.stringify(
            user
          )}), err: ${JSON.stringify((_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data)}`
        );
      }
      throw err;
    }
  }
  /**
   * Deletes a user.
   * @param userId - The ID or key of the user to delete.
   * @returns A promise that resolves when the user is deleted.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.users.delete()
   */
  async deleteUser(userId) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._users.deleteUser({
        ...this.config.apiContext.environmentContext,
        userId
        // user id or key
      });
      this.logger.debug(`[${response.status}] permit.api.deleteUser(${userId})`);
      return response;
    } catch (err) {
      if (import_axios38.default.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.deleteUser(${userId}), err: ${JSON.stringify(
            (_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data
          )}`
        );
      }
      throw err;
    }
  }
  /**
   * Creates a new tenant.
   * @param tenant - The tenant to create.
   * @returns A promise that resolves to a TenantRead object representing the created tenant.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.tenants.create()
   */
  async createTenant(tenant) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._tenants.createTenant({
        ...this.config.apiContext.environmentContext,
        tenantCreate: tenant
      });
      this.logger.debug(`[${response.status}] permit.api.createTenant(${JSON.stringify(tenant)})`);
      return response.data;
    } catch (err) {
      if (import_axios38.default.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.createTenant(${JSON.stringify(
            tenant
          )}), err: ${JSON.stringify((_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data)}`
        );
      }
      throw err;
    }
  }
  /**
   * Updates an existing tenant.
   * @param tenantId - The ID or key of the tenant to update.
   * @param tenant - The updated tenant data.
   * @returns A promise that resolves to a TenantRead object representing the updated tenant.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.tenants.update()
   */
  async updateTenant(tenantId, tenant) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._tenants.updateTenant({
        ...this.config.apiContext.environmentContext,
        tenantId,
        tenantUpdate: tenant
      });
      this.logger.debug(
        `[${response.status}] permit.api.updateTenant(${tenantId}, ${JSON.stringify(tenant)})`
      );
      return response.data;
    } catch (err) {
      if (import_axios38.default.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.updateTenant(${tenantId}, ${JSON.stringify(
            tenant
          )}), err: ${JSON.stringify((_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data)}`
        );
      }
      throw err;
    }
  }
  /**
   * Deletes a tenant.
   * @param tenantId - The ID or key of the tenant to delete.
   * @returns A promise that resolves when the tenant is deleted.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.tenants.delete()
   */
  async deleteTenant(tenantId) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._tenants.deleteTenant({
        ...this.config.apiContext.environmentContext,
        tenantId
      });
      this.logger.debug(`[${response.status}] permit.api.deleteTenant(${tenantId})`);
      return response;
    } catch (err) {
      if (import_axios38.default.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.deleteTenant(${tenantId}), err: ${JSON.stringify(
            (_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data
          )}`
        );
      }
      throw err;
    }
  }
  /**
   * Creates a new role.
   * @param role - The role to create.
   * @returns A promise that resolves to a RoleRead object representing the created role.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.roles.create()
   */
  async createRole(role) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._roles.createRole({
        ...this.config.apiContext.environmentContext,
        roleCreate: role
      });
      this.logger.debug(`[${response.status}] permit.api.createRole(${JSON.stringify(role)})`);
      return response.data;
    } catch (err) {
      if (import_axios38.default.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.createRole(${JSON.stringify(
            role
          )}), err: ${JSON.stringify((_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data)}`
        );
      }
      throw err;
    }
  }
  /**
   * Updates an existing role.
   * @param roleId - The ID or key of the role to update.
   * @param role - The updated role data.
   * @returns A promise that resolves to a RoleRead object representing the updated role.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.roles.update()
   */
  async updateRole(roleId, role) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._roles.updateRole({
        ...this.config.apiContext.environmentContext,
        roleId,
        roleUpdate: role
      });
      this.logger.debug(
        `[${response.status}] permit.api.updateRole(${roleId}, ${JSON.stringify(role)})`
      );
      return response.data;
    } catch (err) {
      if (import_axios38.default.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.updateRole(${roleId}, ${JSON.stringify(
            role
          )}), err: ${JSON.stringify((_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data)}`
        );
      }
      throw err;
    }
  }
  /**
   * Deletes a role.
   * @param roleId - The ID or key of the role to delete.
   * @returns A promise that resolves when the role is deleted.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.roles.delete()
   */
  async deleteRole(roleId) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._roles.deleteRole({
        ...this.config.apiContext.environmentContext,
        roleId
      });
      this.logger.debug(`[${response.status}] permit.api.deleteRole(${roleId})`);
      return response;
    } catch (err) {
      if (import_axios38.default.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.deleteRole(${roleId}), err: ${JSON.stringify(
            (_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data
          )}`
        );
      }
      throw err;
    }
  }
  /**
   * Assigns a role to a user.
   * @param assignedRole - The role assignment data.
   * @returns A promise that resolves to a RoleAssignmentRead object representing the assigned role.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.users.assignRole()
   */
  async assignRole(assignedRole) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._roleAssignments.assignRole({
        ...this.config.apiContext.environmentContext,
        roleAssignmentCreate: assignedRole
      });
      this.logger.debug(
        `[${response.status}] permit.api.assignRole(${JSON.stringify(assignedRole)})`
      );
      return response.data;
    } catch (err) {
      if (import_axios38.default.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.assignRole(${JSON.stringify(
            assignedRole
          )}), err: ${JSON.stringify((_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data)}`
        );
      }
      throw err;
    }
  }
  /**
   * Unassigns a role from a user.
   * @param removedRole - The role unassignment data.
   * @returns A promise that resolves when the role is unassigned.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.users.unassignRole()
   */
  async unassignRole(removedRole) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._roleAssignments.unassignRole({
        ...this.config.apiContext.environmentContext,
        roleAssignmentRemove: removedRole
      });
      this.logger.debug(
        `[${response.status}] permit.api.unassignRole(${JSON.stringify(removedRole)})`
      );
      return response;
    } catch (err) {
      if (import_axios38.default.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.unassignRole(${JSON.stringify(
            removedRole
          )}), err: ${JSON.stringify((_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data)}`
        );
      }
      throw err;
    }
  }
  /**
   * Creates a new condition set.
   * @param conditionSet - The condition set to create.
   * @returns A promise that resolves to a ConditionSetRead object representing the created condition set.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.conditionSets.create()
   */
  async createConditionSet(conditionSet) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._conditionSets.createConditionSet({
        ...this.config.apiContext.environmentContext,
        conditionSetCreate: conditionSet
      });
      this.logger.debug(
        `[${response.status}] permit.api.createConditionSet(${JSON.stringify(conditionSet)})`
      );
      return response.data;
    } catch (err) {
      if (import_axios38.default.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.createConditionSet(${JSON.stringify(
            conditionSet
          )}), err: ${JSON.stringify((_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data)}`
        );
      }
      throw err;
    }
  }
  /**
   * Updates an existing condition set.
   * @param conditionSetId - The ID or key of the condition set to update.
   * @param conditionSet - The updated condition set data.
   * @returns A promise that resolves to a ConditionSetRead object representing the updated condition set.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.conditionSets.update()
   */
  async updateConditionSet(conditionSetId, conditionSet) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._conditionSets.updateConditionSet({
        ...this.config.apiContext.environmentContext,
        conditionSetId,
        conditionSetUpdate: conditionSet
      });
      this.logger.debug(
        `[${response.status}] permit.api.updateConditionSet(${conditionSetId}, ${JSON.stringify(
          conditionSet
        )})`
      );
      return response.data;
    } catch (err) {
      if (import_axios38.default.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.updateConditionSet(${conditionSetId}, ${JSON.stringify(
            conditionSet
          )}), err: ${JSON.stringify((_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data)}`
        );
      }
      throw err;
    }
  }
  /**
   * Deletes a condition set.
   * @param conditionSetId - The ID or key of the condition set to delete.
   * @returns A promise that resolves when the condition set is deleted.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.conditionSets.delete()
   */
  async deleteConditionSet(conditionSetId) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._conditionSets.deleteConditionSet({
        ...this.config.apiContext.environmentContext,
        conditionSetId
      });
      this.logger.debug(`[${response.status}] permit.api.deleteConditionSet(${conditionSetId})`);
      return response;
    } catch (err) {
      if (import_axios38.default.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.deleteConditionSet(${conditionSetId}), err: ${JSON.stringify(
            (_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data
          )}`
        );
      }
      throw err;
    }
  }
  /**
   * Creates a condition set rule (i.e: grants permission to a userset to act on a resourceset).
   * @param conditionSetRule - The condition set rule data.
   * @returns A promise that resolves to a ConditionSetRuleRead object representing the assigned condition set rule.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.conditionSetRules.create()
   */
  async assignConditionSetRule(conditionSetRule) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._conditionSetRules.assignSetPermissions({
        ...this.config.apiContext.environmentContext,
        conditionSetRuleCreate: conditionSetRule
      });
      this.logger.debug(
        `[${response.status}] permit.api.createConditionSetRule(${JSON.stringify(
          conditionSetRule
        )})`
      );
      return response.data;
    } catch (err) {
      if (import_axios38.default.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.createConditionSetRule(${JSON.stringify(
            conditionSetRule
          )}), err: ${JSON.stringify((_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data)}`
        );
      }
      throw err;
    }
  }
  /**
   * Removes a condition set rule (i.e: unassigns permission from a userset to act on a resourceset).
   * @param conditionSetRuleId - The ID or key of the condition set rule to remove.
   * @returns A promise that resolves when the condition set rule is deleted.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.conditionSetRules.delete()
   */
  async unassignConditionSetRule(conditionSetRule) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._conditionSetRules.unassignSetPermissions({
        ...this.config.apiContext.environmentContext,
        conditionSetRuleRemove: conditionSetRule
      });
      this.logger.debug(
        `[${response.status}] permit.api.deleteConditionSetRule(${JSON.stringify(
          conditionSetRule
        )})`
      );
      return response;
    } catch (err) {
      if (import_axios38.default.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.deleteConditionSetRule(${JSON.stringify(
            conditionSetRule
          )}), err: ${JSON.stringify((_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data)}`
        );
      }
      throw err;
    }
  }
  getMethods() {
    return {
      listUsers: this.listUsers.bind(this),
      listRoles: this.listRoles.bind(this),
      listConditionSets: this.listConditionSets.bind(this),
      listConditionSetsRules: this.listConditionSetsRules.bind(this),
      updateUser: this.updateUser.bind(this),
      getUser: this.getUser.bind(this),
      getTenant: this.getTenant.bind(this),
      getRole: this.getRole.bind(this),
      getAssignedRoles: this.getAssignedRoles.bind(this),
      createResource: this.createResource.bind(this),
      updateResource: this.updateResource.bind(this),
      deleteResource: this.deleteResource.bind(this),
      createUser: this.createUser.bind(this),
      syncUser: this.syncUser.bind(this),
      deleteUser: this.deleteUser.bind(this),
      createTenant: this.createTenant.bind(this),
      updateTenant: this.updateTenant.bind(this),
      deleteTenant: this.deleteTenant.bind(this),
      listTenants: this.listTenants.bind(this),
      createRole: this.createRole.bind(this),
      updateRole: this.updateRole.bind(this),
      deleteRole: this.deleteRole.bind(this),
      assignRole: this.assignRole.bind(this),
      unassignRole: this.unassignRole.bind(this),
      createConditionSet: this.createConditionSet.bind(this),
      updateConditionSet: this.updateConditionSet.bind(this),
      deleteConditionSet: this.deleteConditionSet.bind(this),
      assignConditionSetRule: this.assignConditionSetRule.bind(this),
      unassignConditionSetRule: this.unassignConditionSetRule.bind(this)
    };
  }
};

// src/api/environments.ts
var EnvironmentsApi2 = class extends BasePermitApi {
  /**
   * Creates an instance of the EnvironmentsApi.
   * @param config - The configuration object for the Permit SDK.
   * @param logger - The logger instance for logging.
   */
  constructor(config, logger) {
    super(config, logger);
    this.environments = new EnvironmentsApi(
      this.openapiClientConfig,
      BASE_PATH,
      this.config.axiosInstance
    );
    this.apiKeys = new APIKeysApi(
      this.openapiClientConfig,
      BASE_PATH,
      this.config.axiosInstance
    );
  }
  /**
   * Retrieves a list of environments.
   *
   * @param params - the filters and pagination options, @see {@link IListEnvironments}
   * @returns A promise that resolves to an array of EnvironmentRead objects representing the listed environments.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async list(params) {
    const { projectKey, page = 1, perPage = 100 } = params;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(1 /* ORGANIZATION */);
    try {
      return (await this.environments.listEnvironments({
        projId: projectKey,
        page,
        perPage
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Gets an environment by project key and environment key.
   *
   * @param projectKey - The project key.
   * @param environmentKey - The environment key.
   * @returns A promise that resolves to an EnvironmentRead object representing the retrieved environment.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async get(projectKey, environmentKey) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(1 /* ORGANIZATION */);
    try {
      return (await this.environments.getEnvironment({
        projId: projectKey,
        envId: environmentKey
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Gets an environment by project key and environment key.
   * Alias for the {@link get} method.
   *
   * @param projectKey - The project key.
   * @param environmentKey - The environment key.
   * @returns A promise that resolves to an EnvironmentRead object representing the retrieved environment.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async getByKey(projectKey, environmentKey) {
    return await this.get(projectKey, environmentKey);
  }
  /**
   * Gets an environment by project ID and environment ID.
   * Alias for the {@link get} method.
   *
   * @param projectId - The project ID.
   * @param environmentId - The environment ID.
   * @returns A promise that resolves to an EnvironmentRead object representing the retrieved environment.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async getById(projectId, environmentId) {
    return await this.get(projectId, environmentId);
  }
  /**
   * Retrieves statistics and metadata for an environment.
   *
   * @param projectKey - The project key.
   * @param environmentKey - The environment key.
   * @returns A promise that resolves to an EnvironmentStats object representing the statistics data.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async getStats(projectKey, environmentKey) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(1 /* ORGANIZATION */);
    try {
      return (await this.environments.statsEnvironments({
        projId: projectKey,
        envId: environmentKey
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Retrieves the API key that grants access for an environment (and only the requested environment).
   * Must be requested with an organization-level api key.
   *
   * @param projectKey - The project key.
   * @param environmentKey - The environment key.
   * @returns A promise that resolves to an APIKeyRead object containing the API key and its metadata.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async getApiKey(projectKey, environmentKey) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(1 /* ORGANIZATION */);
    try {
      return (await this.apiKeys.getEnvironmentApiKey({
        projId: projectKey,
        envId: environmentKey
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Creates a new environment.
   *
   * @param projectKey - The project key.
   * @param environmentData - The data for creating the environment.
   * @returns A promise that resolves to an EnvironmentRead object representing the created environment.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async create(projectKey, environmentData) {
    await this.ensureAccessLevel("PROJECT_LEVEL_API_KEY" /* PROJECT_LEVEL_API_KEY */);
    await this.ensureContext(1 /* ORGANIZATION */);
    try {
      return (await this.environments.createEnvironment({
        projId: projectKey,
        environmentCreate: environmentData
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Updates an existing environment.
   *
   * @param projectKey - The project key.
   * @param environmentKey - The environment key.
   * @param environmentData - The data for updating the environment.
   * @returns A promise that resolves to an EnvironmentRead object representing the updated environment.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async update(projectKey, environmentKey, environmentData) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(1 /* ORGANIZATION */);
    try {
      return (await this.environments.updateEnvironment({
        projId: projectKey,
        envId: environmentKey,
        environmentUpdate: environmentData
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Clones data (creates a copy) from a source specified environment into a different target
   * environment in the same project. The target environment can be a new environment or an existing
   * environment. For existing environments, the user must specify a conflict strategy - meaning what
   * the system should do in case a copied object conflicts with an existing object (with the same key)
   * in the target environment. The system can overwrite all the conflicting objects, or fail (and
   * cancel the copy) when encountering the first conflict.
   *
   * @param projectKey - The project key.
   * @param environmentKey - The environment key.
   * @param copyParams - The parameters for copying the environment.
   * @returns A promise that resolves to an EnvironmentRead object representing the copied environment.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async copy(projectKey, environmentKey, copyParams) {
    await this.ensureAccessLevel("PROJECT_LEVEL_API_KEY" /* PROJECT_LEVEL_API_KEY */);
    await this.ensureContext(1 /* ORGANIZATION */);
    try {
      return (await this.environments.copyEnvironment({
        projId: projectKey,
        envId: environmentKey,
        environmentCopy: copyParams
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Deletes an environment.
   *
   * @param projectKey - The project key.
   * @param environmentKey - The environment key.
   * @returns A promise that resolves when the environment is successfully deleted.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async delete(projectKey, environmentKey) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(1 /* ORGANIZATION */);
    try {
      await this.environments.deleteEnvironment({
        projId: projectKey,
        envId: environmentKey
      });
    } catch (err) {
      this.handleApiError(err);
    }
  }
};

// src/api/projects.ts
var ProjectsApi2 = class extends BasePermitApi {
  /**
   * Creates an instance of the ProjectsApi.
   * @param config - The configuration object for the Permit SDK.
   * @param logger - The logger instance for logging.
   */
  constructor(config, logger) {
    super(config, logger);
    this.projects = new ProjectsApi(
      this.openapiClientConfig,
      BASE_PATH,
      this.config.axiosInstance
    );
  }
  /**
   * Retrieves a list of projects.
   *
   * @param pagination The pagination options, @see {@link IPagination}
   * @returns A promise that resolves to an array of projects.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async list(pagination) {
    const { page = 1, perPage = 100 } = pagination ?? {};
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(1 /* ORGANIZATION */);
    try {
      return (await this.projects.listProjects({
        page,
        perPage
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Retrieves a project by its key.
   *
   * @param projectKey The key of the project.
   * @returns A promise that resolves to the project.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async get(projectKey) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(1 /* ORGANIZATION */);
    try {
      return (await this.projects.getProject({
        projId: projectKey
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Retrieves a project by its key.
   * Alias for the {@link get} method.
   *
   * @param projectKey The key of the project.
   * @returns A promise that resolves to the project.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async getByKey(projectKey) {
    return await this.get(projectKey);
  }
  /**
   * Retrieves a project by its ID.
   * Alias for the {@link get} method.
   *
   * @param projectId The ID of the project.
   * @returns A promise that resolves to the project.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async getById(projectId) {
    return await this.get(projectId);
  }
  /**
   * Creates a new project.
   *
   * @param projectData The data for the new project.
   * @returns A promise that resolves to the created project.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async create(projectData) {
    await this.ensureAccessLevel("ORGANIZATION_LEVEL_API_KEY" /* ORGANIZATION_LEVEL_API_KEY */);
    await this.ensureContext(1 /* ORGANIZATION */);
    try {
      return (await this.projects.createProject({
        projectCreate: projectData
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Updates a project.
   *
   * @param projectKey The key of the project.
   * @param projectData The updated data for the project.
   * @returns A promise that resolves to the updated project.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async update(projectKey, projectData) {
    await this.ensureAccessLevel("PROJECT_LEVEL_API_KEY" /* PROJECT_LEVEL_API_KEY */);
    await this.ensureContext(1 /* ORGANIZATION */);
    try {
      return (await this.projects.updateProject({
        projId: projectKey,
        projectUpdate: projectData
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Deletes a project.
   *
   * @param projectKey The key of the project to delete.
   * @returns A promise that resolves when the project is deleted.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async delete(projectKey) {
    await this.ensureAccessLevel("PROJECT_LEVEL_API_KEY" /* PROJECT_LEVEL_API_KEY */);
    await this.ensureContext(1 /* ORGANIZATION */);
    try {
      await this.projects.deleteProject({
        projId: projectKey
      });
    } catch (err) {
      this.handleApiError(err);
    }
  }
};

// src/api/relationship-tuples.ts
var RelationshipTuplesApi2 = class extends BaseFactsPermitAPI {
  /**
   * Creates an instance of the RelationshipTuplesApi.
   * @param config - The configuration object for the Permit SDK.
   * @param logger - The logger instance for logging.
   */
  constructor(config, logger) {
    super(config, logger);
    this.relationshipTuples = new RelationshipTuplesApi(
      this.openapiClientConfig,
      BASE_PATH,
      this.config.axiosInstance
    );
  }
  /**
   * Retrieves a list of role createments based on the specified filters.
   *
   * @param params - The filters and pagination options for listing role createments.
   * @returns A promise that resolves with an array of role createments.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async list(params) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.relationshipTuples.listRelationshipTuples({
        ...params,
        ...this.config.apiContext.environmentContext
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Creates a new relationship tuple, that states that a relationship (of type: relation)
   * exists between two resource instances: the subject and the object.
   *
   * @param tuple - The tuple to create
   * @returns A promise that resolves to the created relationship tuple.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async create(tuple) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.relationshipTuples.createRelationshipTuple({
        ...this.config.apiContext.environmentContext,
        relationshipTupleCreate: tuple
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Removes a relationship tuple.
   *
   * @param tuple - The tuple to delete
   * @returns A promise that resolves when the tuple is successfully deleted.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async delete(tuple) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.relationshipTuples.deleteRelationshipTuple({
        ...this.config.apiContext.environmentContext,
        relationshipTupleDelete: tuple
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Creates a new relationship tuple, that states that a relationship (of type: relation)
   * exists between two resource instances: the subject and the object.
   *
   * @returns A promise that resolves to the created relationship tuple.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @param tuples
   */
  async bulkRelationshipTuples(tuples) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.relationshipTuples.bulkCreateRelationshipTuples({
        ...this.config.apiContext.environmentContext,
        relationshipTupleCreateBulkOperation: {
          operations: tuples
        }
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Deletes multiple relationship tuples at once using the provided tuple data.
   * Each tuple object is of type RelationshipTupleDelete and is essentially a tuple of (subject, relation, object).
   *
   * @param tuples - he relationship tuples to delete.
   * @returns A promise that resolves with the bulk un relationship tuples report.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async bulkUnRelationshipTuples(tuples) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.relationshipTuples.bulkDeleteRelationshipTuples({
        ...this.config.apiContext.environmentContext,
        relationshipTupleDeleteBulkOperation: {
          idents: tuples
        }
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
};

// src/api/resource-action-groups.ts
var ResourceActionGroupsApi2 = class extends BasePermitApi {
  /**
   * Creates an instance of the ResourceActionGroupsApi.
   * @param config - The configuration object for the Permit SDK.
   * @param logger - The logger instance for logging.
   */
  constructor(config, logger) {
    super(config, logger);
    this.groupsApi = new ResourceActionGroupsApi(
      this.openapiClientConfig,
      BASE_PATH,
      this.config.axiosInstance
    );
  }
  /**
   * Retrieves a list of all action groups that are defined for a given resource.
   * @param params - pagination and filtering params, @see {@link IListActionGroups}
   * @returns A promise that resolves to an array of ResourceActionGroupRead objects representing the action groups.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async list(params) {
    const { resourceKey, page = 1, perPage = 100 } = params;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.groupsApi.listResourceActionGroups({
        ...this.config.apiContext.environmentContext,
        resourceId: resourceKey,
        page,
        perPage
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Retrieves an action group based on the resource key and the group key.
   *
   * @param resourceKey - The resource key.
   * @param groupKey - The group key.
   * @returns A promise that resolves to a ResourceActionGroupRead object representing the action group.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async get(resourceKey, groupKey) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.groupsApi.getResourceActionGroup({
        ...this.config.apiContext.environmentContext,
        resourceId: resourceKey,
        actionGroupId: groupKey
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Retrieves an action group based on the resource key and the group key.
   * Alias for the {@link get} method.
   *
   * @param resourceKey - The resource key.
   * @param groupKey - The group key.
   * @returns A promise that resolves to a ResourceActionGroupRead object representing the action group.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async getByKey(resourceKey, groupKey) {
    return await this.get(resourceKey, groupKey);
  }
  /**
   * Retrieves an action group based on the resource ID and the group ID.
   * Alias for the {@link get} method.
   *
   * @param resourceId - The resource ID.
   * @param groupId - The group ID.
   * @returns A promise that resolves to a ResourceActionGroupRead object representing the action group.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async getById(resourceId, groupId) {
    return await this.get(resourceId, groupId);
  }
  /**
   * Creates a new action group.
   * @param resourceKey - The resource key.
   * @param groupData - The action group data.
   * @returns A promise that resolves to a ResourceActionGroupRead object representing the created action group.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async create(resourceKey, groupData) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.groupsApi.createResourceActionGroup({
        ...this.config.apiContext.environmentContext,
        resourceId: resourceKey,
        resourceActionGroupCreate: groupData
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Updates an action group.
   * @param resourceKey - The resource key.
   * @param groupKey - The group key.
   * @param groupData - The action group data.
   * @returns A promise that resolves to a ResourceActionGroupRead object representing the updated action group.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async update(resourceKey, groupKey, groupData) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.groupsApi.updateResourceActionGroup({
        ...this.config.apiContext.environmentContext,
        resourceId: resourceKey,
        actionGroupId: groupKey,
        resourceActionGroupUpdate: groupData
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Deletes a action group based on the resource key and group key.
   * @param resourceKey - The resource key.
   * @param groupKey - The group key.
   * @returns A promise that resolves when the action group is successfully deleted.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async delete(resourceKey, groupKey) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      await this.groupsApi.deleteResourceActionGroup({
        ...this.config.apiContext.environmentContext,
        resourceId: resourceKey,
        actionGroupId: groupKey
      });
    } catch (err) {
      this.handleApiError(err);
    }
  }
};

// src/api/resource-actions.ts
var ResourceActionsApi2 = class extends BasePermitApi {
  /**
   * Creates an instance of the ResourceActionsApi.
   * @param config - The configuration object for the Permit SDK.
   * @param logger - The logger instance for logging.
   */
  constructor(config, logger) {
    super(config, logger);
    this.actionsApi = new ResourceActionsApi(
      this.openapiClientConfig,
      BASE_PATH,
      this.config.axiosInstance
    );
  }
  /**
   * Retrieves a list of all actions that are defined for a given resource.
   * @param params - pagination and filtering params, @see {@link IListActions}
   * @returns A promise that resolves to an array of ResourceActionRead objects representing the actions.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async list(params) {
    const { resourceKey, page = 1, perPage = 100 } = params;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.actionsApi.listResourceActions({
        ...this.config.apiContext.environmentContext,
        resourceId: resourceKey,
        page,
        perPage
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Retrieves an action based on the resource key and the action key.
   *
   * @param resourceKey - The resource key.
   * @param actionKey - The action key.
   * @returns A promise that resolves to a ResourceActionRead object representing the action.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async get(resourceKey, actionKey) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.actionsApi.getResourceAction({
        ...this.config.apiContext.environmentContext,
        resourceId: resourceKey,
        actionId: actionKey
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Retrieves an action based on the resource key and the action key.
   * Alias for the {@link get} method.
   *
   * @param resourceKey - The resource key.
   * @param actionKey - The action key.
   * @returns A promise that resolves to a ResourceActionRead object representing the action.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async getByKey(resourceKey, actionKey) {
    return await this.get(resourceKey, actionKey);
  }
  /**
   * Retrieves an action based on the resource ID and the action ID.
   * Alias for the {@link get} method.
   *
   * @param resourceId - The resource ID.
   * @param actionId - The action ID.
   * @returns A promise that resolves to a ResourceActionRead object representing the action.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async getById(resourceId, actionId) {
    return await this.get(resourceId, actionId);
  }
  /**
   * Creates a new action.
   *
   * @param resourceKey - The resource key.
   * @param actionData - The action data.
   * @returns A promise that resolves to a ResourceActionRead object representing the created action.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async create(resourceKey, actionData) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.actionsApi.createResourceAction({
        ...this.config.apiContext.environmentContext,
        resourceId: resourceKey,
        resourceActionCreate: actionData
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Updates an existing action.
   *
   * @param resourceKey - The resource key.
   * @param actionKey - The key of the action to modify.
   * @param actionData - The data for updating the action.
   * @returns A promise that resolves to a ResourceActionRead object representing the updated action.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async update(resourceKey, actionKey, actionData) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.actionsApi.updateResourceAction({
        ...this.config.apiContext.environmentContext,
        resourceId: resourceKey,
        actionId: actionKey,
        resourceActionUpdate: actionData
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Deletes a action based on the resource key and action key.
   * @param resourceKey - The resource key.
   * @param actionKey - The action key.
   * @returns A promise that resolves when the action is successfully deleted.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async delete(resourceKey, actionKey) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      await this.actionsApi.deleteResourceAction({
        ...this.config.apiContext.environmentContext,
        resourceId: resourceKey,
        actionId: actionKey
      });
    } catch (err) {
      this.handleApiError(err);
    }
  }
};

// src/api/resource-attributes.ts
var ResourceAttributesApi2 = class extends BasePermitApi {
  /**
   * Creates an instance of the ResourceAttributesApi.
   * @param config - The configuration object for the Permit SDK.
   * @param logger - The logger instance for logging.
   */
  constructor(config, logger) {
    super(config, logger);
    this.attributesApi = new ResourceAttributesApi(
      this.openapiClientConfig,
      BASE_PATH,
      this.config.axiosInstance
    );
  }
  /**
   * Retrieves a list of all attributes that are defined for a given resource.
   * @param params - pagination and filtering params, @see {@link IListAttributes}
   * @returns A promise that resolves to an array of ResourceAttributeRead objects representing the attributes.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async list(params) {
    const { resourceKey, page = 1, perPage = 100 } = params;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.attributesApi.listResourceAttributes({
        ...this.config.apiContext.environmentContext,
        resourceId: resourceKey,
        page,
        perPage
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Retrieves an attribute based on the resource key and the attribute key.
   *
   * @param resourceKey - The resource key.
   * @param attributeKey - The attribute key.
   * @returns A promise that resolves to a ResourceAttributeRead object representing the attribute.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async get(resourceKey, attributeKey) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.attributesApi.getResourceAttribute({
        ...this.config.apiContext.environmentContext,
        resourceId: resourceKey,
        attributeId: attributeKey
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Retrieves an attribute based on the resource key and the attribute key.
   * Alias for the {@link get} method.
   *
   * @param resourceKey - The resource key.
   * @param attributeKey - The attribute key.
   * @returns A promise that resolves to a ResourceAttributeRead object representing the attribute.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async getByKey(resourceKey, attributeKey) {
    return await this.get(resourceKey, attributeKey);
  }
  /**
   * Retrieves an attribute based on the resource ID and the attribute ID.
   * Alias for the {@link get} method.
   *
   * @param resourceId - The resource ID.
   * @param attributeId - The attribute ID.
   * @returns A promise that resolves to a ResourceAttributeRead object representing the attribute.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async getById(resourceId, attributeId) {
    return await this.get(resourceId, attributeId);
  }
  /**
   * Creates a new attribute.
   *
   * @param resourceKey - The resource key.
   * @param attributeData - The attribute data.
   * @returns A promise that resolves to a ResourceAttributeRead object representing the created attribute.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async create(resourceKey, attributeData) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.attributesApi.createResourceAttribute({
        ...this.config.apiContext.environmentContext,
        resourceId: resourceKey,
        resourceAttributeCreate: attributeData
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Updates an existing attribute.
   *
   * @param resourceKey - The resource key.
   * @param attributeKey - The key of the attribute to modify.
   * @param attributeData - The data for updating the attribute.
   * @returns A promise that resolves to a ResourceAttributeRead object representing the updated attribute.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async update(resourceKey, attributeKey, attributeData) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.attributesApi.updateResourceAttribute({
        ...this.config.apiContext.environmentContext,
        resourceId: resourceKey,
        attributeId: attributeKey,
        resourceAttributeUpdate: attributeData
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Deletes a attribute based on the resource key and attribute key.
   * @param resourceKey - The resource key.
   * @param attributeKey - The attribute key.
   * @returns A promise that resolves when the attribute is successfully deleted.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async delete(resourceKey, attributeKey) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      await this.attributesApi.deleteResourceAttribute({
        ...this.config.apiContext.environmentContext,
        resourceId: resourceKey,
        attributeId: attributeKey
      });
    } catch (err) {
      this.handleApiError(err);
    }
  }
};

// src/api/resource-instances.ts
var ResourceInstancesApi2 = class extends BaseFactsPermitAPI {
  /**
   * Creates an instance of the ResourceInstancesApi.
   * @param config - The configuration object for the Permit SDK.
   * @param logger - The logger instance for logging.
   */
  constructor(config, logger) {
    super(config, logger);
    this.instances = new ResourceInstancesApi(
      this.openapiClientConfig,
      BASE_PATH,
      this.config.axiosInstance
    );
  }
  /**
   * Retrieves a list of resource instances.
   *
   * @param params Filtering and pagination options, @see {@link IListResourceInstanceParams}
   * @returns A promise that resolves to an array of resource instances.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async list(params) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.instances.listResourceInstances({
        ...params,
        ...this.config.apiContext.environmentContext
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Retrieves a instance by its key.
   *
   * @param instanceKey The key of the resource instance.
   * @returns A promise that resolves to the resource instance.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async get(instanceKey) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.instances.getResourceInstance({
        ...this.config.apiContext.environmentContext,
        instanceId: instanceKey
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Retrieves a instance by its key.
   * Alias for the {@link get} method.
   *
   * @param instanceKey The key of the resource instance.
   * @returns A promise that resolves to the resource instance.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async getByKey(instanceKey) {
    return await this.get(instanceKey);
  }
  /**
   * Retrieves a instance by its ID.
   * Alias for the {@link get} method.
   *
   * @param instanceId The ID of the resource instance.
   * @returns A promise that resolves to the resource instance.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async getById(instanceId) {
    return await this.get(instanceId);
  }
  /**
   * Creates a new instance.
   *
   * @param instanceData The data for the new instance.
   * @returns A promise that resolves to the created instance.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async create(instanceData) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.instances.createResourceInstance({
        ...this.config.apiContext.environmentContext,
        resourceInstanceCreate: instanceData
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Updates a instance.
   *
   * @param instanceKey The key of the resource instance.
   * @param instanceData The updated data for the resource instance.
   * @returns A promise that resolves to the updated instance.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async update(instanceKey, instanceData) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.instances.updateResourceInstance({
        ...this.config.apiContext.environmentContext,
        instanceId: instanceKey,
        resourceInstanceUpdate: instanceData
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Deletes a instance.
   *
   * @param instanceKey The key of the resource instance to delete.
   * @returns A promise that resolves when the resource instance is deleted.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async delete(instanceKey) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      await this.instances.deleteResourceInstance({
        ...this.config.apiContext.environmentContext,
        instanceId: instanceKey
      });
    } catch (err) {
      this.handleApiError(err);
    }
  }
};

// src/api/resource-relations.ts
var ResourceRelationsApi2 = class extends BasePermitApi {
  /**
   * Creates an instance of the ResourceRelationsApi.
   * @param config - The configuration object for the Permit SDK.
   * @param logger - The logger instance for logging.
   */
  constructor(config, logger) {
    super(config, logger);
    this.relationsApi = new ResourceRelationsApi(
      this.openapiClientConfig,
      BASE_PATH,
      this.config.axiosInstance
    );
  }
  /**
   * Retrieves a list of all resource relations that are defined for a given resource.
   * @param params - pagination and filtering params, @see {@link IListRelations}
   * @returns A promise that resolves to an array of RelationRead objects representing the relations.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async list(params) {
    const { resourceKey, page = 1, perPage = 100 } = params;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.relationsApi.listResourceRelations({
        ...this.config.apiContext.environmentContext,
        resourceId: resourceKey,
        page,
        perPage
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Retrieves a resource relation based on the resource key and the relation key.
   *
   * @param resourceKey - The resource key.
   * @param relationKey - The relation key.
   * @returns A promise that resolves to a RelationRead object representing the relation.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async get(resourceKey, relationKey) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.relationsApi.getResourceRelation({
        ...this.config.apiContext.environmentContext,
        resourceId: resourceKey,
        relationId: relationKey
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Retrieves an relation based on the resource key and the relation key.
   * Alias for the {@link get} method.
   *
   * @param resourceKey - The resource key.
   * @param relationKey - The relation key.
   * @returns A promise that resolves to a RelationRead object representing the relation.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async getByKey(resourceKey, relationKey) {
    return await this.get(resourceKey, relationKey);
  }
  /**
   * Retrieves an relation based on the resource ID and the relation ID.
   * Alias for the {@link get} method.
   *
   * @param resourceId - The resource ID.
   * @param relationId - The relation ID.
   * @returns A promise that resolves to a RelationRead object representing the relation.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async getById(resourceId, relationId) {
    return await this.get(resourceId, relationId);
  }
  /**
   * Creates a new resource relation.
   *
   * @param resourceKey - The resource key.
   * @param RelationData - The relation data.
   * @returns A promise that resolves to a RelationRead object representing the created relation.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async create(resourceKey, RelationData) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.relationsApi.createResourceRelation({
        ...this.config.apiContext.environmentContext,
        resourceId: resourceKey,
        relationCreate: RelationData
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Deletes a relation based on the resource key and relation key.
   * @param resourceKey - The resource key.
   * @param relationKey - The relation key.
   * @returns A promise that resolves when the relation is successfully deleted.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async delete(resourceKey, relationKey) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      await this.relationsApi.deleteResourceRelation({
        ...this.config.apiContext.environmentContext,
        resourceId: resourceKey,
        relationId: relationKey
      });
    } catch (err) {
      this.handleApiError(err);
    }
  }
};

// src/api/resource-roles.ts
var ResourceRolesApi2 = class extends BasePermitApi {
  /**
   * Creates an instance of the ResourceRolesApi.
   * @param config - The configuration object for the Permit SDK.
   * @param logger - The logger instance for logging.
   */
  constructor(config, logger) {
    super(config, logger);
    this.resourceRoles = new ResourceRolesApi(
      this.openapiClientConfig,
      BASE_PATH,
      this.config.axiosInstance
    );
    this.roleDerivations = new ImplicitGrantsApi(
      this.openapiClientConfig,
      BASE_PATH,
      this.config.axiosInstance
    );
  }
  /**
   * Retrieves a list of resource roles.
   *
   * @param params - pagination and filtering params, @see {@link IListResourceRoles}
   * @returns A promise that resolves to an array of roles.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async list(params) {
    const { resourceKey, page = 1, perPage = 100 } = params;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.resourceRoles.listResourceRoles({
        ...this.config.apiContext.environmentContext,
        page,
        perPage,
        resourceId: resourceKey
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Retrieves a resource role by its key.
   *
   * @param resourceKey The key of the resource.
   * @param roleKey The key of the role.
   * @returns A promise that resolves to the role.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async get(resourceKey, roleKey) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.resourceRoles.getResourceRole({
        ...this.config.apiContext.environmentContext,
        resourceId: resourceKey,
        roleId: roleKey
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Retrieves a resource role by its key.
   * Alias for the {@link get} method.
   *
   * @param resourceKey The key of the resource.
   * @param roleKey The key of the role.
   * @returns A promise that resolves to the role.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async getByKey(resourceKey, roleKey) {
    return await this.get(resourceKey, roleKey);
  }
  /**
   * Retrieves a resource role by its ID.
   * Alias for the {@link get} method.
   *
   * @param resourceId The ID of the resource.
   * @param roleId The ID of the role.
   * @returns A promise that resolves to the role.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async getById(resourceId, roleId) {
    return await this.get(resourceId, roleId);
  }
  /**
   * Creates a new role.
   *
   * @param resourceKey The key of the resource.
   * @param roleData The data for the new role.
   * @returns A promise that resolves to the created role.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async create(resourceKey, roleData) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.resourceRoles.createResourceRole({
        ...this.config.apiContext.environmentContext,
        resourceId: resourceKey,
        resourceRoleCreate: roleData
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Updates a resource role.
   *
   * @param resourceKey The key of the resource.
   * @param roleKey The key of the role.
   * @param roleData The updated data for the role.
   * @returns A promise that resolves to the updated role.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async update(resourceKey, roleKey, roleData) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.resourceRoles.updateResourceRole({
        ...this.config.apiContext.environmentContext,
        resourceId: resourceKey,
        roleId: roleKey,
        resourceRoleUpdate: roleData
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Deletes a resource role.
   *
   * @param resourceKey The key of the resource.
   * @param roleKey The key of the role to delete.
   * @returns A promise that resolves when the role is deleted.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async delete(resourceKey, roleKey) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      await this.resourceRoles.deleteResourceRole({
        ...this.config.apiContext.environmentContext,
        resourceId: resourceKey,
        roleId: roleKey
      });
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Assigns permissions to a resource role.
   *
   * @param resourceKey The key of the resource.
   * @param roleKey - The key of the role.
   * @param permissions - An array of permission keys (<resourceKey:actionKey>) to be assigned to the role.
   * @returns A promise that resolves to a ResourceRoleRead object representing the updated role.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async assignPermissions(resourceKey, roleKey, permissions) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.resourceRoles.assignPermissionsToResourceRole({
        ...this.config.apiContext.environmentContext,
        resourceId: resourceKey,
        roleId: roleKey,
        addRolePermissions: {
          permissions
        }
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Removes permissions from a resource role.
   *
   * @param resourceKey The key of the resource.
   * @param roleKey - The key of the role.
   * @param permissions - An array of permission keys (<resourceKey:actionKey>) to be removed from the role.
   * @returns A promise that resolves to a ResourceRoleRead object representing the updated role.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async removePermissions(resourceKey, roleKey, permissions) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.resourceRoles.removePermissionsFromResourceRole({
        ...this.config.apiContext.environmentContext,
        resourceId: resourceKey,
        roleId: roleKey,
        removeRolePermissions: {
          permissions
        }
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Create a conditional derivation from another role.
   * The derivation states that users with some other role on a related object will implicitly also be granted this role.
   *
   * @param resourceKey - The key of the resource the role belongs to.
   * @param roleKey - The key of the role.
   * @param derivationRule - A rule when to derived this role from another related role.
   * @returns A DerivedRoleRuleRead object representing the newly created role derivation.
   * @throws PermitApiError - If the API returns an error HTTP status code.
   * @throws PermitContextError - If the configured ApiContext does not match the required endpoint context.
   */
  async createRoleDerivation(resourceKey, roleKey, derivationRule) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.roleDerivations.createImplicitGrant({
        ...this.config.apiContext.environmentContext,
        resourceId: resourceKey,
        roleId: roleKey,
        derivedRoleRuleCreate: derivationRule
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Delete a role derivation.
   *
   * @param resourceKey - The key of the resource the role belongs to.
   * @param roleKey - The key of the role.
   * @param derivationRule - The details of the derivation rule to delete.
   * @throws PermitApiError - If the API returns an error HTTP status code.
   * @throws PermitContextError - If the configured ApiContext does not match the required endpoint context.
   */
  async deleteRoleDerivation(resourceKey, roleKey, derivationRule) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.roleDerivations.deleteImplicitGrant({
        ...this.config.apiContext.environmentContext,
        resourceId: resourceKey,
        roleId: roleKey,
        derivedRoleRuleDelete: derivationRule
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Update the optional (ABAC) conditions when to derive this role from other roles.
   *
   * @param resourceKey - The key of the resource the role belongs to.
   * @param roleKey - The key of the role.
   * @param conditions - The conditions object.
   * @returns The updated PermitBackendSchemasSchemaDerivedRoleDerivedRoleSettings.
   * @throws PermitApiError - If the API returns an error HTTP status code.
   * @throws PermitContextError - If the configured ApiContext does not match the required endpoint context.
   */
  async updateRoleDerivationConditions(resourceKey, roleKey, conditions) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.roleDerivations.updateImplicitGrantsConditions({
        ...this.config.apiContext.environmentContext,
        resourceId: resourceKey,
        roleId: roleKey,
        permitBackendSchemasSchemaDerivedRoleDerivedRoleSettings: conditions
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
};

// src/api/resources.ts
var ResourcesApi2 = class extends BasePermitApi {
  /**
   * Creates an instance of the ResourcesApi.
   * @param config - The configuration object for the Permit SDK.
   * @param logger - The logger instance for logging.
   */
  constructor(config, logger) {
    super(config, logger);
    this.resources = new ResourcesApi(
      this.openapiClientConfig,
      BASE_PATH,
      this.config.axiosInstance
    );
  }
  async list(pagination) {
    const { page = 1, perPage = 100, includeTotalCount } = pagination ?? {};
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.resources.listResources({
        ...this.config.apiContext.environmentContext,
        page,
        perPage,
        includeTotalCount
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Retrieves a resource by its key.
   *
   * @param resourceKey The key of the resource.
   * @returns A promise that resolves to the resource.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async get(resourceKey) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.resources.getResource({
        ...this.config.apiContext.environmentContext,
        resourceId: resourceKey
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Retrieves a resource by its key.
   * Alias for the {@link get} method.
   *
   * @param resourceKey The key of the resource.
   * @returns A promise that resolves to the resource.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async getByKey(resourceKey) {
    return await this.get(resourceKey);
  }
  /**
   * Retrieves a resource by its ID.
   * Alias for the {@link get} method.
   *
   * @param resourceId The ID of the resource.
   * @returns A promise that resolves to the resource.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async getById(resourceId) {
    return await this.get(resourceId);
  }
  /**
   * Creates a new resource.
   *
   * @param resourceData The data for the new resource.
   * @returns A promise that resolves to the created resource.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async create(resourceData) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.resources.createResource({
        ...this.config.apiContext.environmentContext,
        resourceCreate: resourceData
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Creates a resource if such a resource does not exists, otherwise completely replaces the resource configuration.
   *
   * @param resourceKey The key of the resource.
   * @param resourceData The updated data for the resource.
   * @returns A promise that resolves to the updated resource.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async replace(resourceKey, resourceData) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.resources.replaceResource({
        ...this.config.apiContext.environmentContext,
        resourceId: resourceKey,
        resourceReplace: resourceData
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Updates a resource.
   *
   * @param resourceKey The key of the resource.
   * @param resourceData The updated data for the resource.
   * @returns A promise that resolves to the updated resource.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async update(resourceKey, resourceData) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.resources.updateResource({
        ...this.config.apiContext.environmentContext,
        resourceId: resourceKey,
        resourceUpdate: resourceData
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Deletes a resource.
   *
   * @param resourceKey The key of the resource to delete.
   * @returns A promise that resolves when the resource is deleted.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async delete(resourceKey) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      await this.resources.deleteResource({
        ...this.config.apiContext.environmentContext,
        resourceId: resourceKey
      });
    } catch (err) {
      this.handleApiError(err);
    }
  }
};

// src/api/role-assignments.ts
var RoleAssignmentsApi2 = class extends BaseFactsPermitAPI {
  /**
   * Creates an instance of the RoleAssignmentsApi.
   * @param config - The configuration object for the Permit SDK.
   * @param logger - The logger instance for logging.
   */
  constructor(config, logger) {
    super(config, logger);
    this.roleAssignments = new RoleAssignmentsApi(
      this.openapiClientConfig,
      BASE_PATH,
      this.config.axiosInstance
    );
  }
  async list(params) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    const {
      user,
      tenant,
      role,
      resourceInstance,
      page = 1,
      perPage = 100,
      detailed,
      includeTotalCount
    } = params;
    try {
      return (await this.roleAssignments.listRoleAssignments({
        ...this.config.apiContext.environmentContext,
        user,
        tenant,
        role,
        resourceInstance,
        detailed,
        page,
        perPage,
        includeTotalCount
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Assigns a role to a user in the scope of a given tenant.
   *
   * @param assignment - The role assignment details.
   * @returns A promise that resolves with the assigned role.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async assign(assignment) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.roleAssignments.assignRole({
        ...this.config.apiContext.environmentContext,
        roleAssignmentCreate: assignment
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Unassigns a role from a user in the scope of a given tenant.
   *
   * @param unassignment - The role unassignment details.
   * @returns A promise that resolves when the role is successfully unassigned.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async unassign(unassignment) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.roleAssignments.unassignRole({
        ...this.config.apiContext.environmentContext,
        roleAssignmentRemove: unassignment
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Assigns multiple roles in bulk using the provided role assignments data.
   * Each role assignment is a tuple of (user, role, tenant).
   *
   * @param assignments - The role assignments to be performed in bulk.
   * @returns A promise that resolves with the bulk assignment report.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async bulkAssign(assignments) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.roleAssignments.bulkAssignRole({
        ...this.config.apiContext.environmentContext,
        roleAssignmentCreate: assignments
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Removes multiple role assignments in bulk using the provided unassignment data.
   * Each role to unassign is a tuple of (user, role, tenant).
   *
   * @param unassignments - The role unassignments to be performed in bulk.
   * @returns A promise that resolves with the bulk unassignment report.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async bulkUnassign(unassignments) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.roleAssignments.bulkUnassignRole({
        ...this.config.apiContext.environmentContext,
        roleAssignmentRemove: unassignments
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
};

// src/api/roles.ts
var RolesApi2 = class extends BasePermitApi {
  /**
   * Creates an instance of the RolesApi.
   * @param config - The configuration object for the Permit SDK.
   * @param logger - The logger instance for logging.
   */
  constructor(config, logger) {
    super(config, logger);
    this.roles = new RolesApi(
      this.openapiClientConfig,
      BASE_PATH,
      this.config.axiosInstance
    );
  }
  async list(pagination) {
    const { page = 1, perPage = 100, includeTotalCount } = pagination ?? {};
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.roles.listRoles({
        ...this.config.apiContext.environmentContext,
        page,
        perPage,
        includeTotalCount
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Retrieves a role by its key.
   *
   * @param roleKey The key of the role.
   * @returns A promise that resolves to the role.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async get(roleKey) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.roles.getRole({
        ...this.config.apiContext.environmentContext,
        roleId: roleKey
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Retrieves a role by its key.
   * Alias for the {@link get} method.
   *
   * @param roleKey The key of the role.
   * @returns A promise that resolves to the role.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async getByKey(roleKey) {
    return await this.get(roleKey);
  }
  /**
   * Retrieves a role by its ID.
   * Alias for the {@link get} method.
   *
   * @param roleId The ID of the role.
   * @returns A promise that resolves to the role.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async getById(roleId) {
    return await this.get(roleId);
  }
  /**
   * Creates a new role.
   *
   * @param roleData The data for the new role.
   * @returns A promise that resolves to the created role.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async create(roleData) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.roles.createRole({
        ...this.config.apiContext.environmentContext,
        roleCreate: roleData
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Updates a role.
   *
   * @param roleKey The key of the role.
   * @param roleData The updated data for the role.
   * @returns A promise that resolves to the updated role.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async update(roleKey, roleData) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.roles.updateRole({
        ...this.config.apiContext.environmentContext,
        roleId: roleKey,
        roleUpdate: roleData
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Deletes a role.
   *
   * @param roleKey The key of the role to delete.
   * @returns A promise that resolves when the role is deleted.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async delete(roleKey) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      await this.roles.deleteRole({
        ...this.config.apiContext.environmentContext,
        roleId: roleKey
      });
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Assigns permissions to a role.
   * @param roleKey - The key of the role.
   * @param permissions - An array of permission keys (<resourceKey:actionKey>) to be assigned to the role.
   * @returns A promise that resolves to a RoleRead object representing the updated role.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async assignPermissions(roleKey, permissions) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.roles.assignPermissionsToRole({
        ...this.config.apiContext.environmentContext,
        roleId: roleKey,
        addRolePermissions: {
          permissions
        }
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Removes permissions from a role.
   * @param roleKey - The key of the role.
   * @param permissions - An array of permission keys (<resourceKey:actionKey>) to be removed from the role.
   * @returns A promise that resolves to a RoleRead object representing the updated role.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async removePermissions(roleKey, permissions) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.roles.removePermissionsFromRole({
        ...this.config.apiContext.environmentContext,
        roleId: roleKey,
        removeRolePermissions: {
          permissions
        }
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
};

// src/api/tenants.ts
var TenantsApi2 = class extends BaseFactsPermitAPI {
  /**
   * Creates an instance of the TenantsApi.
   * @param config - The configuration object for the Permit SDK.
   * @param logger - The logger instance for logging.
   */
  constructor(config, logger) {
    super(config, logger);
    this.tenants = new TenantsApi(
      this.openapiClientConfig,
      BASE_PATH,
      this.config.axiosInstance
    );
  }
  /**
   * Retrieves a list of tenants.
   *
   * @param params Filtering and pagination options, @see {@link IListTenantsParams}
   * @returns A promise that resolves to an array of tenants.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async list(params) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.tenants.listTenants({
        ...params,
        ...this.config.apiContext.environmentContext
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Retrieves a list of users for a given tenant.
   *
   * @param tenantKey - The key of the tenant for which to list users.
   * @param params - pagination and filtering params.
   * @returns A promise that resolves to a PaginatedResultUserRead object containing the list of tenant users.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async listTenantUsers({
    tenantKey,
    ...params
  }) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.tenants.listTenantUsers({
        ...params,
        ...this.config.apiContext.environmentContext,
        tenantId: tenantKey
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Retrieves a tenant by its key.
   *
   * @param tenantKey The key of the tenant.
   * @returns A promise that resolves to the tenant.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async get(tenantKey) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.tenants.getTenant({
        ...this.config.apiContext.environmentContext,
        tenantId: tenantKey
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Retrieves a tenant by its key.
   * Alias for the {@link get} method.
   *
   * @param tenantKey The key of the tenant.
   * @returns A promise that resolves to the tenant.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async getByKey(tenantKey) {
    return await this.get(tenantKey);
  }
  /**
   * Retrieves a tenant by its ID.
   * Alias for the {@link get} method.
   *
   * @param tenantId The ID of the tenant.
   * @returns A promise that resolves to the tenant.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async getById(tenantId) {
    return await this.get(tenantId);
  }
  /**
   * Creates a new tenant.
   *
   * @param tenantData The data for the new tenant.
   * @returns A promise that resolves to the created tenant.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async create(tenantData) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.tenants.createTenant({
        ...this.config.apiContext.environmentContext,
        tenantCreate: tenantData
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Updates a tenant.
   *
   * @param tenantKey The key of the tenant.
   * @param tenantData The updated data for the tenant.
   * @returns A promise that resolves to the updated tenant.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async update(tenantKey, tenantData) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.tenants.updateTenant({
        ...this.config.apiContext.environmentContext,
        tenantId: tenantKey,
        tenantUpdate: tenantData
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Deletes a tenant.
   *
   * @param tenantKey The key of the tenant to delete.
   * @returns A promise that resolves when the tenant is deleted.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async delete(tenantKey) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      await this.tenants.deleteTenant({
        ...this.config.apiContext.environmentContext,
        tenantId: tenantKey
      });
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Deletes a user from a given tenant (also removes all roles granted to the user in that tenant).
   *
   * @param tenantKey - The key of the tenant from which the user will be deleted.
   * @param userKey - The key of the user to be deleted.
   * @returns A promise that resolves when the user is successfully deleted.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async deleteTenantUser(tenantKey, userKey) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      await this.tenants.deleteTenantUser({
        ...this.config.apiContext.environmentContext,
        tenantId: tenantKey,
        userId: userKey
      });
    } catch (err) {
      this.handleApiError(err);
    }
  }
};

// src/openapi/api/bulk-operations-api.ts
var import_axios39 = __toESM(require("axios"));
var BulkOperationsApiAxiosParamCreator = function(configuration) {
  return {
    /**
     *
     * @summary Bulk Create Tenants
     * @param {any} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {any} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {any} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkCreateTenants: async (projId, envId, requestBody, options = {}) => {
      assertParamExists("bulkCreateTenants", "projId", projId);
      assertParamExists("bulkCreateTenants", "envId", envId);
      assertParamExists("bulkCreateTenants", "requestBody", requestBody);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/bulk/tenants`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBody,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Bulk Create Users
     * @param {any} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {any} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param userCreateBulkOperation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkCreateUsers: async (projId, envId, userCreateBulkOperation, options = {}) => {
      assertParamExists("bulkCreateUsers", "projId", projId);
      assertParamExists("bulkCreateUsers", "envId", envId);
      assertParamExists("bulkCreateUsers", "requestBody", userCreateBulkOperation);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/bulk/users`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userCreateBulkOperation,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes many Resource Instances.
     * @summary Bulk Delete Resource Instances
     * @param {any} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {any} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ResourceInstanceDeleteBulkOperation} resourceInstanceDeleteBulkOperation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkDeleteResourceInstances: async (projId, envId, resourceInstanceDeleteBulkOperation, options = {}) => {
      assertParamExists("bulkDeleteResourceInstances", "projId", projId);
      assertParamExists("bulkDeleteResourceInstances", "envId", envId);
      assertParamExists(
        "bulkDeleteResourceInstances",
        "resourceInstanceDeleteBulkOperation",
        resourceInstanceDeleteBulkOperation
      );
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/bulk/resource_instances`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        resourceInstanceDeleteBulkOperation,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Bulk Delete Tenants
     * @param {any} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {any} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {any} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkDeleteTenants: async (projId, envId, requestBody, options = {}) => {
      assertParamExists("bulkDeleteTenants", "projId", projId);
      assertParamExists("bulkDeleteTenants", "envId", envId);
      assertParamExists("bulkDeleteTenants", "requestBody", requestBody);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/bulk/tenants`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBody,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Bulk Delete Users
     * @param {any} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {any} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param userDeleteBulkOperation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkDeleteUsers: async (projId, envId, userDeleteBulkOperation, options = {}) => {
      assertParamExists("bulkDeleteUsers", "projId", projId);
      assertParamExists("bulkDeleteUsers", "envId", envId);
      assertParamExists("bulkDeleteUsers", "requestBody", userDeleteBulkOperation);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/bulk/users`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userDeleteBulkOperation,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Creates or replaces Resource Instances. If a resource instance with `key` and `resource` already exists, it will be replaced.
     * @summary Bulk Replace Resource Instances
     * @param {any} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {any} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ResourceInstanceCreateBulkOperation} resourceInstanceCreateBulkOperation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkReplaceResourceInstances: async (projId, envId, resourceInstanceCreateBulkOperation, options = {}) => {
      assertParamExists("bulkReplaceResourceInstances", "projId", projId);
      assertParamExists("bulkReplaceResourceInstances", "envId", envId);
      assertParamExists(
        "bulkReplaceResourceInstances",
        "resourceInstanceCreateBulkOperation",
        resourceInstanceCreateBulkOperation
      );
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/bulk/resource_instances`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        resourceInstanceCreateBulkOperation,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Bulk Replace Users
     * @param {any} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {any} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param userReplaceBulkOperation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkReplaceUsers: async (projId, envId, userReplaceBulkOperation, options = {}) => {
      assertParamExists("bulkReplaceUsers", "projId", projId);
      assertParamExists("bulkReplaceUsers", "envId", envId);
      assertParamExists("bulkReplaceUsers", "requestBody", userReplaceBulkOperation);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/bulk/users`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userReplaceBulkOperation,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var BulkOperationsApiFp = function(configuration) {
  const localVarAxiosParamCreator = BulkOperationsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Bulk Create Tenants
     * @param {any} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {any} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {{ [key: string]: any; }} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bulkCreateTenants(projId, envId, requestBody, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.bulkCreateTenants(
        projId,
        envId,
        requestBody,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios39.default, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Bulk Create Users
     * @param {any} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {any} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param userCreateBulkOperation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bulkCreateUsers(projId, envId, userCreateBulkOperation, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.bulkCreateUsers(
        projId,
        envId,
        userCreateBulkOperation,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios39.default, BASE_PATH, configuration);
    },
    /**
     * Deletes many Resource Instances.
     * @summary Bulk Delete Resource Instances
     * @param {any} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {any} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ResourceInstanceDeleteBulkOperation} resourceInstanceDeleteBulkOperation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bulkDeleteResourceInstances(projId, envId, resourceInstanceDeleteBulkOperation, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.bulkDeleteResourceInstances(
        projId,
        envId,
        resourceInstanceDeleteBulkOperation,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios39.default, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Bulk Delete Tenants
     * @param {any} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {any} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {{ [key: string]: any; }} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bulkDeleteTenants(projId, envId, requestBody, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.bulkDeleteTenants(
        projId,
        envId,
        requestBody,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios39.default, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Bulk Delete Users
     * @param {any} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {any} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param userDeleteBulkOperation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bulkDeleteUsers(projId, envId, userDeleteBulkOperation, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.bulkDeleteUsers(
        projId,
        envId,
        userDeleteBulkOperation,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios39.default, BASE_PATH, configuration);
    },
    /**
     * Creates or replaces Resource Instances. If a resource instance with `key` and `resource` already exists, it will be replaced.
     * @summary Bulk Replace Resource Instances
     * @param {any} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {any} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ResourceInstanceCreateBulkOperation} resourceInstanceCreateBulkOperation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bulkReplaceResourceInstances(projId, envId, resourceInstanceCreateBulkOperation, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.bulkReplaceResourceInstances(
        projId,
        envId,
        resourceInstanceCreateBulkOperation,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios39.default, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Bulk Replace Users
     * @param {any} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {any} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param userReplaceBulkOperation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bulkReplaceUsers(projId, envId, userReplaceBulkOperation, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.bulkReplaceUsers(
        projId,
        envId,
        userReplaceBulkOperation,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios39.default, BASE_PATH, configuration);
    }
  };
};
var BulkOperationsApi = class extends BaseAPI {
  /**
   *
   * @summary Bulk Create Tenants
   * @param {BulkOpertionsApiBulkCreateTenantsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BulkOperationsApi
   */
  bulkCreateTenants(requestParameters, options) {
    return BulkOperationsApiFp(this.configuration).bulkCreateTenants(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.requestBody,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Bulk Create Users
   * @param {BulkOperationsApiBulkCreateUsersRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BulkOperationsApi
   */
  bulkCreateUsers(requestParameters, options) {
    return BulkOperationsApiFp(this.configuration).bulkCreateUsers(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.userCreateBulkOperations,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Deletes many Resource Instances.
   * @summary Bulk Delete Resource Instances
   * @param {BulkOperationsApiBulkDeleteResourceInstancesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BulkOperationsApi
   */
  bulkDeleteResourceInstances(requestParameters, options) {
    return BulkOperationsApiFp(this.configuration).bulkDeleteResourceInstances(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceInstanceDeleteBulkOperation,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Bulk Delete Tenants
   * @param {BulkOperationsApiBulkDeleteTenantsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BulkOperationsApi
   */
  bulkDeleteTenants(requestParameters, options) {
    return BulkOperationsApiFp(this.configuration).bulkDeleteTenants(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.requestBody,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Bulk Delete Users
   * @param {BulkOperationsApiBulkDeleteUsersRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BulkOperationsApi
   */
  async bulkDeleteUsers(requestParameters, options) {
    let request = await BulkOperationsApiFp(this.configuration).bulkDeleteUsers(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.userDeleteBulkOperation,
      options
    );
    return request(this.axios, this.basePath);
  }
  /**
   * Creates or replaces Resource Instances. If a resource instance with `key` and `resource` already exists, it will be replaced.
   * @summary Bulk Replace Resource Instances
   * @param {BulkOperationsApiBulkReplaceResourceInstancesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BulkOperationsApi
   */
  bulkReplaceResourceInstances(requestParameters, options) {
    return BulkOperationsApiFp(this.configuration).bulkReplaceResourceInstances(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceInstanceCreateBulkOperation,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Bulk Replace Users
   * @param {BulkOperationsApiBulkReplaceUsersRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BulkOperationsApi
   */
  bulkReplaceUsers(requestParameters, options) {
    return BulkOperationsApiFp(this.configuration).bulkReplaceUsers(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.userReplaceBulkOperation,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
};

// src/api/users.ts
var UsersApi2 = class extends BaseFactsPermitAPI {
  /**
   * Creates an instance of the UsersApi.
   * @param config - The configuration object for the Permit SDK.
   * @param logger - The logger instance for logging.
   */
  constructor(config, logger) {
    super(config, logger);
    this.users = new UsersApi(
      this.openapiClientConfig,
      BASE_PATH,
      this.config.axiosInstance
    );
    this.roleAssignments = new RoleAssignmentsApi(
      this.openapiClientConfig,
      BASE_PATH,
      this.config.axiosInstance
    );
    this.bulkOperationsApi = new BulkOperationsApi(
      this.openapiClientConfig,
      BASE_PATH,
      this.config.axiosInstance
    );
  }
  /**
   * Retrieves a list of users.
   *
   * @param params Filtering and pagination options, @see {@link IUsersListParams}
   * @returns A promise that resolves to a PaginatedResultUserRead object containing the list of users.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async list(params) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.users.listUsers({
        ...params,
        ...this.config.apiContext.environmentContext
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Retrieves a user by its key.
   *
   * @param userKey The key of the user.
   * @returns A promise that resolves to the user.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async get(userKey) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.users.getUser({
        ...this.config.apiContext.environmentContext,
        userId: userKey
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Retrieves a user by its key.
   * Alias for the {@link get} method.
   *
   * @param userKey The key of the user.
   * @returns A promise that resolves to the user.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async getByKey(userKey) {
    return await this.get(userKey);
  }
  /**
   * Retrieves a user by its ID.
   * Alias for the {@link get} method.
   *
   * @param userId The ID of the user.
   * @returns A promise that resolves to the user.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async getById(userId) {
    return await this.get(userId);
  }
  /**
   * Creates a new user.
   *
   * @param userData The data for the new user.
   * @returns A promise that resolves to the created user.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async create(userData) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.users.createUser({
        ...this.config.apiContext.environmentContext,
        userCreate: userData
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Updates a user.
   *
   * @param userKey The key of the user.
   * @param userData The updated data for the user.
   * @returns A promise that resolves to the updated user.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async update(userKey, userData) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.users.updateUser({
        ...this.config.apiContext.environmentContext,
        userId: userKey,
        userUpdate: userData
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Synchronizes user data by creating or updating a user.
   *
   * @param userData - The data of the user to be synchronized.
   * @returns A promise that resolves with the result of the user creation or update operation.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async sync(userData) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this.users.replaceUser({
        ...this.config.apiContext.environmentContext,
        userId: userData.key,
        userCreate: userData
      });
      return {
        user: response.data,
        created: response.status === 201
      };
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Deletes a user.
   *
   * @param userKey The key of the user to delete.
   * @returns A promise that resolves when the user is deleted.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async delete(userKey) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      await this.users.deleteUser({
        ...this.config.apiContext.environmentContext,
        userId: userKey
      });
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Assigns a role to a user in the scope of a given tenant.
   *
   * @param assignment - The role assignment details.
   * @returns A promise that resolves with the assigned role.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async assignRole(assignment) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.roleAssignments.assignRole({
        ...this.config.apiContext.environmentContext,
        roleAssignmentCreate: assignment
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Unassigns a role from a user in the scope of a given tenant.
   *
   * @param unassignment - The role unassignment details.
   * @returns A promise that resolves when the role is successfully unassigned from the user.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async unassignRole(unassignment) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.roleAssignments.unassignRole({
        ...this.config.apiContext.environmentContext,
        roleAssignmentRemove: unassignment
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Creates users in bulk.
   *
   * @param users The array of users to create.
   * @returns A promise that resolves to the bulk creation result.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async bulkUserCreate(users) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.bulkOperationsApi.bulkCreateUsers({
        ...this.config.apiContext.environmentContext,
        userCreateBulkOperations: {
          operations: users
        }
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Deletes users in bulk.
   *
   * @param userKeys The array of user keys to delete.
   * @returns A promise that resolves to the bulk deletion result.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async bulkUserDelete(userKeys) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.bulkOperationsApi.bulkDeleteUsers({
        ...this.config.apiContext.environmentContext,
        userDeleteBulkOperation: {
          idents: userKeys
        }
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Replaces users in bulk.
   *
   * If a user exists, it will be replaced. Otherwise, it will be created.
   *
   * @param users The array of users to replace.
   * @returns A promise that resolves to the bulk replacement result.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async bulkUserReplace(users) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.bulkOperationsApi.bulkReplaceUsers({
        ...this.config.apiContext.environmentContext,
        userReplaceBulkOperation: {
          operations: users
        }
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  async getAssignedRoles({
    user,
    tenant,
    page = 1,
    perPage = 100,
    detailed = false,
    includeTotalCount = false
  }) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.roleAssignments.listRoleAssignments({
        ...this.config.apiContext.environmentContext,
        user,
        tenant,
        page,
        perPage,
        detailed,
        includeTotalCount
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
};

// src/api/api-client.ts
var ApiClient = class extends DeprecatedApiClient {
  /**
   * Constructs a new instance of the ApiClient class with the specified configuration and logger.
   *
   * @param config - The configuration for the Permit API client.
   * @param logger - The logger instance.
   */
  constructor(config, logger) {
    super(config, logger);
    this.conditionSetRules = new ConditionSetRulesApi2(config, logger);
    this.conditionSets = new ConditionSetsApi2(config, logger);
    this.projects = new ProjectsApi2(config, logger);
    this.environments = new EnvironmentsApi2(config, logger);
    this.actionGroups = new ResourceActionGroupsApi2(config, logger);
    this.resourceActions = new ResourceActionsApi2(config, logger);
    this.resourceAttributes = new ResourceAttributesApi2(config, logger);
    this.resourceRoles = new ResourceRolesApi2(config, logger);
    this.resourceRelations = new ResourceRelationsApi2(config, logger);
    this.resourceInstances = new ResourceInstancesApi2(config, logger);
    this.resources = new ResourcesApi2(config, logger);
    this.roleAssignments = new RoleAssignmentsApi2(config, logger);
    this.roles = new RolesApi2(config, logger);
    this.relationshipTuples = new RelationshipTuplesApi2(config, logger);
    this.tenants = new TenantsApi2(config, logger);
    this.users = new UsersApi2(config, logger);
  }
};

// src/api/elements.ts
var ElementsApiErrors = /* @__PURE__ */ ((ElementsApiErrors2) => {
  ElementsApiErrors2["USER_NOT_FOUND"] = "User not found";
  ElementsApiErrors2["TENANT_NOT_FOUND"] = "Tenant not found";
  ElementsApiErrors2["INVALID_PERMISSION_LEVEL"] = "Invalid user permission level";
  ElementsApiErrors2["FORBIDDEN_ACCESS"] = "Forbidden access";
  return ElementsApiErrors2;
})(ElementsApiErrors || {});
var ElementsClient = class extends BasePermitApi {
  /**
   * Creates an instance of the ElementsClient.
   * @param config - The configuration object for the Permit SDK.
   * @param logger - The logger instance for logging.
   */
  constructor(config, logger) {
    super(config, logger);
    this.authApi = new AuthenticationApi(
      this.openapiClientConfig,
      BASE_PATH,
      this.config.axiosInstance
    );
  }
  /**
   * Logs in as a user in the context of a specific tenant.
   * @param loginData - The login data containing the user key and tenant key.
   * @returns The embedded login authentication session data.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async loginAs({
    userId,
    tenantId
  }) {
    try {
      const response = await this.authApi.elementsLoginAs({
        userLoginRequestInput: {
          user_id: userId,
          tenant_id: tenantId
        }
      });
      return {
        ...response.data,
        content: { url: response.data.redirect_url }
      };
    } catch (err) {
      this.handleApiError(err);
    }
  }
};

// src/config.ts
var import_axios40 = __toESM(require("axios"));
var import_lodash = __toESM(require("lodash"));
var ConfigFactory = class _ConfigFactory {
  /**
   * @returns the default SDK configuration
   */
  static defaults() {
    return {
      token: import_lodash.default.get(process.env, "PERMIT_API_KEY", ""),
      pdp: import_lodash.default.get(process.env, "PERMIT_PDP_URL", "http://localhost:7766"),
      apiUrl: import_lodash.default.get(process.env, "PERMIT_API_URL", "https://api.permit.io"),
      log: {
        // log level, default is warn (warnings and errors)
        level: import_lodash.default.get(process.env, "PERMIT_LOG_LEVEL", "warn"),
        // Label added to logs
        label: import_lodash.default.get(process.env, "PERMIT_LOG_LABEL", "Permit.io"),
        // When logging - dump full data to console as JSON
        json: JSON.parse(import_lodash.default.get(process.env, "PERMIT_LOG_JSON", "false"))
      },
      multiTenancy: {
        defaultTenant: "default",
        useDefaultTenantIfEmpty: true
      },
      timeout: void 0,
      throwOnError: true,
      apiContext: new ApiContext(),
      axiosInstance: import_axios40.default.create(),
      proxyFactsViaPdp: false,
      factsSyncTimeout: null,
      factsSyncTimeoutPolicy: null
    };
  }
  /**
   * Builds the Permit SDK configuration from the values provided by the SDK user
   * and from the default SDK configuration when no specific values are set.
   *
   * @param options - a partial configuration
   * @returns the SDK configuration (for unset values returns the default config)
   */
  static build(options) {
    const config = import_lodash.default.merge(import_lodash.default.assign({}, _ConfigFactory.defaults()), options);
    return config;
  }
};

// src/enforcement/enforcer.ts
var import_axios41 = __toESM(require("axios"));
var import_url_parse = __toESM(require("url-parse"));

// src/utils/context.ts
var ContextStore = class {
  constructor() {
    this.baseContext = {};
    // cross-query context (global context)
    this.transforms = [];
  }
  /**
   * add context to the base context
   */
  add(context) {
    this.baseContext = Object.assign(this.baseContext, context);
  }
  registerTransform(transform) {
    this.transforms.push(transform);
  }
  /**
   * merges the global context (this.context) with the context
   * provided for this specific query (context). the specific
   * context overrides the base (global) context.
   */
  getDerivedContext(context) {
    return Object.assign({}, this.baseContext, context);
  }
  transform(initialContext) {
    let context = { ...initialContext };
    for (const transform of this.transforms) {
      context = transform(context);
    }
    return context;
  }
};

// src/utils/http-logger.ts
var AxiosLoggingInterceptor = class {
  static setupInterceptor(axiosInstance, logger) {
    axiosInstance.interceptors.request.use(
      function(request) {
        var _a;
        request.headers = request.headers || {};
        logger.debug(`Sending HTTP request: ${(_a = request == null ? void 0 : request.method) == null ? void 0 : _a.toUpperCase()} ${request == null ? void 0 : request.url}`);
        return request;
      },
      function(error) {
        return Promise.reject(error);
      }
    );
    axiosInstance.interceptors.response.use(
      function(response) {
        var _a, _b, _c;
        logger.debug(
          `Received HTTP response: ${(_b = (_a = response == null ? void 0 : response.config) == null ? void 0 : _a.method) == null ? void 0 : _b.toUpperCase()} ${(_c = response == null ? void 0 : response.config) == null ? void 0 : _c.url}, status: ${response == null ? void 0 : response.status}`
        );
        return response;
      },
      function(error) {
        return Promise.reject(error);
      }
    );
  }
};

// src/enforcement/interfaces.ts
function isOpaGetUserPermissionsResult(obj) {
  return "result" in obj;
}

// src/enforcement/enforcer.ts
var RESOURCE_DELIMITER = ":";
function isString(x) {
  return typeof x === "string";
}
var PermitError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "PermitError";
  }
};
var PermitConnectionError = class extends PermitError {
  constructor(message) {
    super(message);
    this.name = "PermitConnectionError";
  }
};
var PermitPDPStatusError = class extends PermitError {
  constructor(message) {
    super(message);
    this.name = "PermitPDPStatusError";
  }
};
var Enforcer = class _Enforcer {
  /**
   * Creates an instance of the Enforcer class.
   * @param config - The configuration object for the Permit SDK.
   * @param logger - The logger instance for logging.
   */
  constructor(config, logger) {
    this.config = config;
    this.logger = logger;
    const opaBaseUrl = new import_url_parse.default(this.config.pdp);
    opaBaseUrl.set("port", "8181");
    opaBaseUrl.set("pathname", `${opaBaseUrl.pathname}v1/data/permit/`);
    const version = process.env.npm_package_version ?? "unknown";
    if (config.axiosInstance) {
      this.client = config.axiosInstance;
      this.client.defaults.baseURL = `${this.config.pdp}/`;
      this.client.defaults.headers.common["X-Permit-SDK-Version"] = `node:${version}`;
    } else {
      this.client = import_axios41.default.create({
        baseURL: `${this.config.pdp}/`,
        headers: {
          "X-Permit-SDK-Version": `node:${version}`
        }
      });
    }
    if (config.opaAxiosInstance) {
      this.opaClient = config.opaAxiosInstance;
      this.opaClient.defaults.baseURL = opaBaseUrl.toString();
      this.opaClient.defaults.headers.common["X-Permit-SDK-Version"] = `node:${version}`;
    } else {
      this.opaClient = import_axios41.default.create({
        baseURL: opaBaseUrl.toString(),
        headers: {
          "X-Permit-SDK-Version": `node:${version}`
        }
      });
    }
    this.logger = logger;
    AxiosLoggingInterceptor.setupInterceptor(this.client, this.logger);
    this.contextStore = new ContextStore();
  }
  async getUserPermissions(user, tenants, resources, resource_types, config = {}) {
    return await this.getUserPermissionsWithExceptions(
      user,
      tenants,
      resources,
      resource_types,
      config
    ).catch((err) => {
      const shouldThrow = config.throwOnError === void 0 ? this.config.throwOnError : config.throwOnError;
      if (shouldThrow) {
        throw err;
      } else {
        this.logger.error(err);
        return {};
      }
    });
  }
  async getUserPermissionsWithExceptions(user, tenants, resources, resource_types, config = {}) {
    const checkTimeout = config.timeout || this.config.timeout;
    const input = {
      user: isString(user) ? { key: user } : user,
      tenants,
      resources,
      resource_types
    };
    return await this.client.post("user-permissions", input, {
      headers: {
        Authorization: `Bearer ${this.config.token}`
      },
      timeout: checkTimeout
    }).then((response) => {
      if (response.status !== 200) {
        throw new PermitPDPStatusError(`Permit.getUserPermissions() got an unexpected status code: ${response.status}, please check your SDK init and make sure the PDP sidecar is configured correctly. 
            Read more about setting up the PDP at https://docs.permit.io`);
      }
      const permissions = (isOpaGetUserPermissionsResult(response.data) ? response.data.result.permissions : response.data) || {};
      this.logger.info(
        `permit.getUserPermissions(${_Enforcer.userRepr(input.user)}) = ${JSON.stringify(
          permissions
        )}`
      );
      return permissions;
    }).catch((error) => {
      var _a, _b;
      const errorMessage = `Error in permit.getUserPermissions(${_Enforcer.userRepr(input.user)})`;
      if (import_axios41.default.isAxiosError(error)) {
        const errorStatusCode = ((_a = error.response) == null ? void 0 : _a.status.toString()) || "";
        const errorDetails = ((_b = error == null ? void 0 : error.response) == null ? void 0 : _b.data) ? JSON.stringify(error.response.data) : error.message;
        this.logger.error(`[${errorStatusCode}] ${errorMessage}, err: ${errorDetails}`);
      } else {
        this.logger.error(`${errorMessage}
${error}`);
      }
      throw new PermitConnectionError(`Permit SDK got error: 
 ${error.message} 

          and cannot connect to the PDP, please check your configuration and make sure the
          PDP is running at ${this.config.pdp} and accepting requests. 

          Read more about setting up the PDP at https://docs.permit.io`);
    });
  }
  async bulkCheck(checks, context = {}, config = {}) {
    return await this.bulkCheckWithExceptions(checks, context, config).catch((err) => {
      const shouldThrow = config.throwOnError === void 0 ? this.config.throwOnError : config.throwOnError;
      if (shouldThrow) {
        throw err;
      } else {
        this.logger.error(err);
        return [];
      }
    });
  }
  buildCheckInput(user, action, resource, context = {}) {
    const normalizedUser = isString(user) ? { key: user } : user;
    const resourceObj = isString(resource) ? _Enforcer.resourceFromString(resource) : resource;
    const normalizedResource = this.normalizeResource(resourceObj);
    const queryContext = this.contextStore.getDerivedContext(context);
    return {
      user: normalizedUser,
      action,
      resource: normalizedResource,
      context: queryContext
    };
  }
  checkInputRepr(checkInput) {
    return `${_Enforcer.userRepr(checkInput.user)}, ${checkInput.action}, ${_Enforcer.resourceRepr(
      checkInput.resource
    )}`;
  }
  async bulkCheckWithExceptions(checks, context = {}, config = {}) {
    const checkTimeout = config.timeout || this.config.timeout;
    const inputs = [];
    checks.forEach((check) => {
      const input = this.buildCheckInput(check.user, check.action, check.resource, context);
      inputs.push(input);
    });
    return await this.client.post("allowed/bulk", inputs, {
      headers: {
        Authorization: `Bearer ${this.config.token}`
      },
      timeout: checkTimeout
    }).then((response) => {
      if (response.status !== 200) {
        throw new PermitPDPStatusError(`Permit.bulkCheck() got an unexpected status code: ${response.status}, please check your SDK init and make sure the PDP sidecar is configured correctly. 
            Read more about setting up the PDP at https://docs.permit.io`);
      }
      const decisions = (("allow" in response.data ? response.data.allow : response.data.result.allow) || []).map((decision) => decision.allow || false);
      this.logger.info(
        `permit.bulkCheck(${inputs.map((input) => this.checkInputRepr(input))}) = ${decisions}`
      );
      return decisions;
    }).catch((error) => {
      var _a, _b;
      const errorMessage = `Error in permit.bulkCheck(${inputs.map(
        (input) => this.checkInputRepr(input)
      )})`;
      if (import_axios41.default.isAxiosError(error)) {
        const errorStatusCode = ((_a = error.response) == null ? void 0 : _a.status.toString()) || "";
        const errorDetails = ((_b = error == null ? void 0 : error.response) == null ? void 0 : _b.data) ? JSON.stringify(error.response.data) : error.message;
        this.logger.error(`[${errorStatusCode}] ${errorMessage}, err: ${errorDetails}`);
      } else {
        this.logger.error(`${errorMessage}
${error}`);
      }
      throw new PermitConnectionError(`Permit SDK got error: 
 ${error.message} 

          and cannot connect to the PDP, please check your configuration and make sure the
          PDP is running at ${this.config.pdp} and accepting requests. 

          Read more about setting up the PDP at https://docs.permit.io`);
    });
  }
  async checkAllTenants(user, action, resource, context = {}, sdk = "node") {
    try {
      const response = await this.client.post("/allowed/all-tenants", {
        headers: {
          Authorization: `Bearer ${this.config.token}`,
          "X-Permit-Sdk-Language": sdk
        },
        params: {
          user,
          action,
          resource,
          context
        }
      });
      return response.data.allowedTenants.map((item) => item.tenant);
    } catch (error) {
      this.logger.error("Error fetching all tenants:", error);
      throw error;
    }
  }
  async check(user, action, resource, context = {}, config = {}) {
    return await this.checkWithExceptions(user, action, resource, context, config).catch((err) => {
      const shouldThrow = config.throwOnError === void 0 ? this.config.throwOnError : config.throwOnError;
      if (shouldThrow) {
        throw err;
      } else {
        this.logger.error(err);
        return false;
      }
    });
  }
  //check
  async checkWithExceptions(user, action, resource, context = {}, config = {}) {
    let input = this.buildCheckInput(user, action, resource, context);
    const client = (config == null ? void 0 : config.useOpa) ? this.opaClient : this.client;
    const path = (config == null ? void 0 : config.useOpa) ? "root" : "allowed";
    if (config == null ? void 0 : config.useOpa) {
      input = { input };
    }
    const checkTimeout = config.timeout || this.config.timeout;
    return await client.post(path, input, {
      headers: {
        Authorization: `Bearer ${this.config.token}`
      },
      timeout: checkTimeout
    }).then((response) => {
      if (response.status !== 200) {
        throw new PermitPDPStatusError(`Permit.check() got an unexpected status code: ${response.status}, please check your SDK init and make sure the PDP sidecar is configured correctly. 
            Read more about setting up the PDP at https://docs.permit.io`);
      }
      const decision = ("allow" in response.data ? response.data.allow : response.data.result.allow) || false;
      this.logger.info(
        `permit.check(${this.checkInputRepr(input.input || input)}) = ${decision}`
      );
      return decision;
    }).catch((error) => {
      var _a, _b;
      const errorMessage = `Error in permit.check(${this.checkInputRepr(
        input.input || input
      )})`;
      if (import_axios41.default.isAxiosError(error)) {
        const errorStatusCode = ((_a = error.response) == null ? void 0 : _a.status.toString()) || "";
        const errorDetails = ((_b = error == null ? void 0 : error.response) == null ? void 0 : _b.data) ? JSON.stringify(error.response.data) : error.message;
        this.logger.error(`[${errorStatusCode}] ${errorMessage}, err: ${errorDetails}`);
      } else {
        this.logger.error(`${errorMessage}
${error}`);
      }
      throw new PermitConnectionError(`Permit SDK got error: 
 ${error.message} 

          and cannot connect to the PDP, please check your configuration and make sure the PDP is running at ${this.config.pdp} and accepting requests. 

          Read more about setting up the PDP at https://docs.permit.io`);
    });
  }
  // TODO: remove this eventually, once we decide on finalized structure of AuthzQuery
  normalizeResource(resource) {
    const normalizedResource = Object.assign({}, resource);
    if (!normalizedResource.tenant && this.config.multiTenancy.useDefaultTenantIfEmpty) {
      normalizedResource.tenant = this.config.multiTenancy.defaultTenant;
    }
    return normalizedResource;
  }
  static userRepr(user) {
    if (user.attributes || user.email) {
      return JSON.stringify(user);
    }
    return user.key;
  }
  static resourceRepr(resource) {
    if (resource.attributes && resource.attributes.length > 0) {
      return JSON.stringify(resource);
    }
    let resourceRepr = "";
    if (resource.tenant) {
      resourceRepr += `${resource.tenant}/`;
    }
    resourceRepr += `${resource.type}:${resource.key ?? "*"}`;
    return resourceRepr;
  }
  static resourceFromString(resource) {
    const parts = resource.split(RESOURCE_DELIMITER);
    if (parts.length < 1 || parts.length > 2) {
      throw Error(`permit.check() got invalid resource string: '${resource}'`);
    }
    return {
      type: parts[0],
      key: parts.length > 1 ? parts[1] : void 0
    };
  }
  getMethods() {
    return {
      check: this.check.bind(this),
      bulkCheck: this.bulkCheck.bind(this),
      getUserPermissions: this.getUserPermissions.bind(this),
      checkAllTenants: this.checkAllTenants.bind(this)
    };
  }
};

// src/logger.ts
var import_pino = __toESM(require("pino"));
var LoggerFactory = class {
  static createLogger(config) {
    return (0, import_pino.default)({
      level: config.log.level,
      prettyPrint: config.log.json ? { levelFirst: true } : false,
      base: { label: config.log.label },
      timestamp: import_pino.default.stdTimeFunctions.isoTime
    });
  }
};

// src/index.ts
var Permit = class {
  /**
   * Constructs a new instance of the {@link Permit} class with the specified configuration.
   *
   * @param config - The configuration for the Permit SDK.
   */
  constructor(config) {
    this.config = ConfigFactory.build(config);
    this.logger = LoggerFactory.createLogger(this.config);
    AxiosLoggingInterceptor.setupInterceptor(this.config.axiosInstance, this.logger);
    this.api = new ApiClient(this.config, this.logger);
    this.enforcer = new Enforcer(this.config, this.logger);
    this.elements = new ElementsClient(this.config, this.logger);
    this.logger.debug(
      `Permit.io SDK initialized with config:
${JSON.stringify(this.config, void 0, 2)}`
    );
  }
  /**
   * Checks if a `user` is authorized to perform an `action` on a `resource` within the specified context.
   *
   * @param user     - The user object representing the user.
   * @param action   - The action to be performed on the resource.
   * @param resource - The resource object representing the resource.
   * @param context  - The context object representing the context in which the action is performed.
   * @returns `true` if the user is authorized, `false` otherwise.
   * @throws {@link PermitConnectionError} if an error occurs while sending the authorization request to the PDP.
   * @throws {@link PermitPDPStatusError} if received a response with unexpected status code from the PDP.
   */
  async check(user, action, resource, context, config) {
    return await this.enforcer.check(user, action, resource, context, config);
  }
  /**
   * Checks multiple requests within the specified context.
   *
   * @param checks   - The check requests.
   * @param context  - The context object representing the context in which the action is performed.
   * @returns array containing `true` if the user is authorized, `false` otherwise for each check request.
   * @throws {@link PermitConnectionError} if an error occurs while sending the authorization request to the PDP.
   * @throws {@link PermitPDPStatusError} if received a response with unexpected status code from the PDP.
   */
  async bulkCheck(checks, context, config) {
    return await this.enforcer.bulkCheck(checks, context, config);
  }
  /**
   * Get all tenants available in the system.
   * @returns An array of TenantDetails representing all tenants.
   */
  /**
   * Get all tenants available in the system.
   * @returns An array of TenantDetails representing all tenants.
   */
  async checkAllTenants(user, action, resource, context, sdk) {
    try {
      return await this.enforcer.checkAllTenants(user, action, resource, context, sdk);
    } catch (error) {
      this.logger.error("Error fetching all tenants:", error);
      throw error;
    }
  }
  /**
   * Get all permissions for the specified user.
   *
   * @param user     - The user object representing the user.
   * @param tenants  - The list of tenants to filter the permissions on ( given by roles ).
   * @param resources - The list of resources to filter the permissions on ( given by resource roles ).
   * @param resource_types - The list of resource types to filter the permissions on ( given by resource roles ).
   * @returns object with key as the resource identifier and value as the resource details and permissions.
   * @throws {@link PermitConnectionError} if an error occurs while sending the authorization request to the PDP.
   * @throws {@link PermitPDPStatusError} if received a response with unexpected status code from the PDP.
   */
  async getUserPermissions(user, tenants, resources, resource_types, config) {
    return await this.enforcer.getUserPermissions(user, tenants, resources, resource_types, config);
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  APIKeyOwnerType,
  ApiClient,
  ApiContext,
  ApiKeyLevel,
  AttributeType,
  ConditionSetRulesApi,
  ConditionSetType,
  ConditionSetsApi,
  DeprecatedApiClient,
  ElementsApiErrors,
  ElementsClient,
  EnvironmentCopyConflictStrategyEnum,
  EnvironmentsApi,
  MemberAccessLevel,
  MemberAccessObj,
  Permit,
  PermitApiError,
  PermitConnectionError,
  PermitContextError,
  PermitError,
  PermitPDPStatusError,
  ProjectsApi,
  ResourceActionGroupsApi,
  ResourceActionsApi,
  ResourceAttributesApi,
  ResourcesApi,
  RoleAssignmentsApi,
  RolesApi,
  TenantsApi,
  UsersApi
});
//# sourceMappingURL=index.js.map