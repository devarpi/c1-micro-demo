"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/enforcement/enforcer.ts
var enforcer_exports = {};
__export(enforcer_exports, {
  Enforcer: () => Enforcer,
  PermitConnectionError: () => PermitConnectionError,
  PermitError: () => PermitError,
  PermitPDPStatusError: () => PermitPDPStatusError
});
module.exports = __toCommonJS(enforcer_exports);
var import_axios = __toESM(require("axios"));
var import_url_parse = __toESM(require("url-parse"));

// src/utils/context.ts
var ContextStore = class {
  constructor() {
    this.baseContext = {};
    // cross-query context (global context)
    this.transforms = [];
  }
  /**
   * add context to the base context
   */
  add(context) {
    this.baseContext = Object.assign(this.baseContext, context);
  }
  registerTransform(transform) {
    this.transforms.push(transform);
  }
  /**
   * merges the global context (this.context) with the context
   * provided for this specific query (context). the specific
   * context overrides the base (global) context.
   */
  getDerivedContext(context) {
    return Object.assign({}, this.baseContext, context);
  }
  transform(initialContext) {
    let context = { ...initialContext };
    for (const transform of this.transforms) {
      context = transform(context);
    }
    return context;
  }
};

// src/utils/http-logger.ts
var AxiosLoggingInterceptor = class {
  static setupInterceptor(axiosInstance, logger) {
    axiosInstance.interceptors.request.use(
      function(request) {
        var _a;
        request.headers = request.headers || {};
        logger.debug(`Sending HTTP request: ${(_a = request == null ? void 0 : request.method) == null ? void 0 : _a.toUpperCase()} ${request == null ? void 0 : request.url}`);
        return request;
      },
      function(error) {
        return Promise.reject(error);
      }
    );
    axiosInstance.interceptors.response.use(
      function(response) {
        var _a, _b, _c;
        logger.debug(
          `Received HTTP response: ${(_b = (_a = response == null ? void 0 : response.config) == null ? void 0 : _a.method) == null ? void 0 : _b.toUpperCase()} ${(_c = response == null ? void 0 : response.config) == null ? void 0 : _c.url}, status: ${response == null ? void 0 : response.status}`
        );
        return response;
      },
      function(error) {
        return Promise.reject(error);
      }
    );
  }
};

// src/enforcement/interfaces.ts
function isOpaGetUserPermissionsResult(obj) {
  return "result" in obj;
}

// src/enforcement/enforcer.ts
var RESOURCE_DELIMITER = ":";
function isString(x) {
  return typeof x === "string";
}
var PermitError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "PermitError";
  }
};
var PermitConnectionError = class extends PermitError {
  constructor(message) {
    super(message);
    this.name = "PermitConnectionError";
  }
};
var PermitPDPStatusError = class extends PermitError {
  constructor(message) {
    super(message);
    this.name = "PermitPDPStatusError";
  }
};
var Enforcer = class _Enforcer {
  /**
   * Creates an instance of the Enforcer class.
   * @param config - The configuration object for the Permit SDK.
   * @param logger - The logger instance for logging.
   */
  constructor(config, logger) {
    this.config = config;
    this.logger = logger;
    const opaBaseUrl = new import_url_parse.default(this.config.pdp);
    opaBaseUrl.set("port", "8181");
    opaBaseUrl.set("pathname", `${opaBaseUrl.pathname}v1/data/permit/`);
    const version = process.env.npm_package_version ?? "unknown";
    if (config.axiosInstance) {
      this.client = config.axiosInstance;
      this.client.defaults.baseURL = `${this.config.pdp}/`;
      this.client.defaults.headers.common["X-Permit-SDK-Version"] = `node:${version}`;
    } else {
      this.client = import_axios.default.create({
        baseURL: `${this.config.pdp}/`,
        headers: {
          "X-Permit-SDK-Version": `node:${version}`
        }
      });
    }
    if (config.opaAxiosInstance) {
      this.opaClient = config.opaAxiosInstance;
      this.opaClient.defaults.baseURL = opaBaseUrl.toString();
      this.opaClient.defaults.headers.common["X-Permit-SDK-Version"] = `node:${version}`;
    } else {
      this.opaClient = import_axios.default.create({
        baseURL: opaBaseUrl.toString(),
        headers: {
          "X-Permit-SDK-Version": `node:${version}`
        }
      });
    }
    this.logger = logger;
    AxiosLoggingInterceptor.setupInterceptor(this.client, this.logger);
    this.contextStore = new ContextStore();
  }
  async getUserPermissions(user, tenants, resources, resource_types, config = {}) {
    return await this.getUserPermissionsWithExceptions(
      user,
      tenants,
      resources,
      resource_types,
      config
    ).catch((err) => {
      const shouldThrow = config.throwOnError === void 0 ? this.config.throwOnError : config.throwOnError;
      if (shouldThrow) {
        throw err;
      } else {
        this.logger.error(err);
        return {};
      }
    });
  }
  async getUserPermissionsWithExceptions(user, tenants, resources, resource_types, config = {}) {
    const checkTimeout = config.timeout || this.config.timeout;
    const input = {
      user: isString(user) ? { key: user } : user,
      tenants,
      resources,
      resource_types
    };
    return await this.client.post("user-permissions", input, {
      headers: {
        Authorization: `Bearer ${this.config.token}`
      },
      timeout: checkTimeout
    }).then((response) => {
      if (response.status !== 200) {
        throw new PermitPDPStatusError(`Permit.getUserPermissions() got an unexpected status code: ${response.status}, please check your SDK init and make sure the PDP sidecar is configured correctly. 
            Read more about setting up the PDP at https://docs.permit.io`);
      }
      const permissions = (isOpaGetUserPermissionsResult(response.data) ? response.data.result.permissions : response.data) || {};
      this.logger.info(
        `permit.getUserPermissions(${_Enforcer.userRepr(input.user)}) = ${JSON.stringify(
          permissions
        )}`
      );
      return permissions;
    }).catch((error) => {
      var _a, _b;
      const errorMessage = `Error in permit.getUserPermissions(${_Enforcer.userRepr(input.user)})`;
      if (import_axios.default.isAxiosError(error)) {
        const errorStatusCode = ((_a = error.response) == null ? void 0 : _a.status.toString()) || "";
        const errorDetails = ((_b = error == null ? void 0 : error.response) == null ? void 0 : _b.data) ? JSON.stringify(error.response.data) : error.message;
        this.logger.error(`[${errorStatusCode}] ${errorMessage}, err: ${errorDetails}`);
      } else {
        this.logger.error(`${errorMessage}
${error}`);
      }
      throw new PermitConnectionError(`Permit SDK got error: 
 ${error.message} 

          and cannot connect to the PDP, please check your configuration and make sure the
          PDP is running at ${this.config.pdp} and accepting requests. 

          Read more about setting up the PDP at https://docs.permit.io`);
    });
  }
  async bulkCheck(checks, context = {}, config = {}) {
    return await this.bulkCheckWithExceptions(checks, context, config).catch((err) => {
      const shouldThrow = config.throwOnError === void 0 ? this.config.throwOnError : config.throwOnError;
      if (shouldThrow) {
        throw err;
      } else {
        this.logger.error(err);
        return [];
      }
    });
  }
  buildCheckInput(user, action, resource, context = {}) {
    const normalizedUser = isString(user) ? { key: user } : user;
    const resourceObj = isString(resource) ? _Enforcer.resourceFromString(resource) : resource;
    const normalizedResource = this.normalizeResource(resourceObj);
    const queryContext = this.contextStore.getDerivedContext(context);
    return {
      user: normalizedUser,
      action,
      resource: normalizedResource,
      context: queryContext
    };
  }
  checkInputRepr(checkInput) {
    return `${_Enforcer.userRepr(checkInput.user)}, ${checkInput.action}, ${_Enforcer.resourceRepr(
      checkInput.resource
    )}`;
  }
  async bulkCheckWithExceptions(checks, context = {}, config = {}) {
    const checkTimeout = config.timeout || this.config.timeout;
    const inputs = [];
    checks.forEach((check) => {
      const input = this.buildCheckInput(check.user, check.action, check.resource, context);
      inputs.push(input);
    });
    return await this.client.post("allowed/bulk", inputs, {
      headers: {
        Authorization: `Bearer ${this.config.token}`
      },
      timeout: checkTimeout
    }).then((response) => {
      if (response.status !== 200) {
        throw new PermitPDPStatusError(`Permit.bulkCheck() got an unexpected status code: ${response.status}, please check your SDK init and make sure the PDP sidecar is configured correctly. 
            Read more about setting up the PDP at https://docs.permit.io`);
      }
      const decisions = (("allow" in response.data ? response.data.allow : response.data.result.allow) || []).map((decision) => decision.allow || false);
      this.logger.info(
        `permit.bulkCheck(${inputs.map((input) => this.checkInputRepr(input))}) = ${decisions}`
      );
      return decisions;
    }).catch((error) => {
      var _a, _b;
      const errorMessage = `Error in permit.bulkCheck(${inputs.map(
        (input) => this.checkInputRepr(input)
      )})`;
      if (import_axios.default.isAxiosError(error)) {
        const errorStatusCode = ((_a = error.response) == null ? void 0 : _a.status.toString()) || "";
        const errorDetails = ((_b = error == null ? void 0 : error.response) == null ? void 0 : _b.data) ? JSON.stringify(error.response.data) : error.message;
        this.logger.error(`[${errorStatusCode}] ${errorMessage}, err: ${errorDetails}`);
      } else {
        this.logger.error(`${errorMessage}
${error}`);
      }
      throw new PermitConnectionError(`Permit SDK got error: 
 ${error.message} 

          and cannot connect to the PDP, please check your configuration and make sure the
          PDP is running at ${this.config.pdp} and accepting requests. 

          Read more about setting up the PDP at https://docs.permit.io`);
    });
  }
  async checkAllTenants(user, action, resource, context = {}, sdk = "node") {
    try {
      const response = await this.client.post("/allowed/all-tenants", {
        headers: {
          Authorization: `Bearer ${this.config.token}`,
          "X-Permit-Sdk-Language": sdk
        },
        params: {
          user,
          action,
          resource,
          context
        }
      });
      return response.data.allowedTenants.map((item) => item.tenant);
    } catch (error) {
      this.logger.error("Error fetching all tenants:", error);
      throw error;
    }
  }
  async check(user, action, resource, context = {}, config = {}) {
    return await this.checkWithExceptions(user, action, resource, context, config).catch((err) => {
      const shouldThrow = config.throwOnError === void 0 ? this.config.throwOnError : config.throwOnError;
      if (shouldThrow) {
        throw err;
      } else {
        this.logger.error(err);
        return false;
      }
    });
  }
  //check
  async checkWithExceptions(user, action, resource, context = {}, config = {}) {
    let input = this.buildCheckInput(user, action, resource, context);
    const client = (config == null ? void 0 : config.useOpa) ? this.opaClient : this.client;
    const path = (config == null ? void 0 : config.useOpa) ? "root" : "allowed";
    if (config == null ? void 0 : config.useOpa) {
      input = { input };
    }
    const checkTimeout = config.timeout || this.config.timeout;
    return await client.post(path, input, {
      headers: {
        Authorization: `Bearer ${this.config.token}`
      },
      timeout: checkTimeout
    }).then((response) => {
      if (response.status !== 200) {
        throw new PermitPDPStatusError(`Permit.check() got an unexpected status code: ${response.status}, please check your SDK init and make sure the PDP sidecar is configured correctly. 
            Read more about setting up the PDP at https://docs.permit.io`);
      }
      const decision = ("allow" in response.data ? response.data.allow : response.data.result.allow) || false;
      this.logger.info(
        `permit.check(${this.checkInputRepr(input.input || input)}) = ${decision}`
      );
      return decision;
    }).catch((error) => {
      var _a, _b;
      const errorMessage = `Error in permit.check(${this.checkInputRepr(
        input.input || input
      )})`;
      if (import_axios.default.isAxiosError(error)) {
        const errorStatusCode = ((_a = error.response) == null ? void 0 : _a.status.toString()) || "";
        const errorDetails = ((_b = error == null ? void 0 : error.response) == null ? void 0 : _b.data) ? JSON.stringify(error.response.data) : error.message;
        this.logger.error(`[${errorStatusCode}] ${errorMessage}, err: ${errorDetails}`);
      } else {
        this.logger.error(`${errorMessage}
${error}`);
      }
      throw new PermitConnectionError(`Permit SDK got error: 
 ${error.message} 

          and cannot connect to the PDP, please check your configuration and make sure the PDP is running at ${this.config.pdp} and accepting requests. 

          Read more about setting up the PDP at https://docs.permit.io`);
    });
  }
  // TODO: remove this eventually, once we decide on finalized structure of AuthzQuery
  normalizeResource(resource) {
    const normalizedResource = Object.assign({}, resource);
    if (!normalizedResource.tenant && this.config.multiTenancy.useDefaultTenantIfEmpty) {
      normalizedResource.tenant = this.config.multiTenancy.defaultTenant;
    }
    return normalizedResource;
  }
  static userRepr(user) {
    if (user.attributes || user.email) {
      return JSON.stringify(user);
    }
    return user.key;
  }
  static resourceRepr(resource) {
    if (resource.attributes && resource.attributes.length > 0) {
      return JSON.stringify(resource);
    }
    let resourceRepr = "";
    if (resource.tenant) {
      resourceRepr += `${resource.tenant}/`;
    }
    resourceRepr += `${resource.type}:${resource.key ?? "*"}`;
    return resourceRepr;
  }
  static resourceFromString(resource) {
    const parts = resource.split(RESOURCE_DELIMITER);
    if (parts.length < 1 || parts.length > 2) {
      throw Error(`permit.check() got invalid resource string: '${resource}'`);
    }
    return {
      type: parts[0],
      key: parts.length > 1 ? parts[1] : void 0
    };
  }
  getMethods() {
    return {
      check: this.check.bind(this),
      bulkCheck: this.bulkCheck.bind(this),
      getUserPermissions: this.getUserPermissions.bind(this),
      checkAllTenants: this.checkAllTenants.bind(this)
    };
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Enforcer,
  PermitConnectionError,
  PermitError,
  PermitPDPStatusError
});
//# sourceMappingURL=enforcer.js.map