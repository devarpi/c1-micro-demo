"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/array-find-index/index.js
var require_array_find_index = __commonJS({
  "node_modules/array-find-index/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function(arr, predicate, ctx) {
      if (typeof Array.prototype.findIndex === "function") {
        return arr.findIndex(predicate, ctx);
      }
      if (typeof predicate !== "function") {
        throw new TypeError("predicate must be a function");
      }
      var list = Object(arr);
      var len = list.length;
      if (len === 0) {
        return -1;
      }
      for (var i = 0; i < len; i++) {
        if (predicate.call(ctx, list[i], i, list)) {
          return i;
        }
      }
      return -1;
    };
  }
});

// node_modules/currently-unhandled/core.js
var require_core = __commonJS({
  "node_modules/currently-unhandled/core.js"(exports2, module2) {
    "use strict";
    var arrayFindIndex = require_array_find_index();
    module2.exports = function() {
      var unhandledRejections = [];
      function onUnhandledRejection(reason, promise) {
        unhandledRejections.push({ reason, promise });
      }
      function onRejectionHandled(promise) {
        var index = arrayFindIndex(unhandledRejections, function(x) {
          return x.promise === promise;
        });
        unhandledRejections.splice(index, 1);
      }
      function currentlyUnhandled() {
        return unhandledRejections.map(function(entry) {
          return {
            reason: entry.reason,
            promise: entry.promise
          };
        });
      }
      return {
        onUnhandledRejection,
        onRejectionHandled,
        currentlyUnhandled
      };
    };
  }
});

// node_modules/currently-unhandled/index.js
var require_currently_unhandled = __commonJS({
  "node_modules/currently-unhandled/index.js"(exports2, module2) {
    "use strict";
    var core = require_core();
    module2.exports = function(p) {
      p = p || process;
      var c = core();
      p.on("unhandledRejection", c.onUnhandledRejection);
      p.on("rejectionHandled", c.onRejectionHandled);
      return c.currentlyUnhandled;
    };
  }
});

// node_modules/color-name/index.js
var require_color_name = __commonJS({
  "node_modules/color-name/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// node_modules/color-convert/conversions.js
var require_conversions = __commonJS({
  "node_modules/color-convert/conversions.js"(exports2, module2) {
    "use strict";
    var cssKeywords = require_color_name();
    var reverseKeywords = {};
    for (const key of Object.keys(cssKeywords)) {
      reverseKeywords[cssKeywords[key]] = key;
    }
    var convert = {
      rgb: { channels: 3, labels: "rgb" },
      hsl: { channels: 3, labels: "hsl" },
      hsv: { channels: 3, labels: "hsv" },
      hwb: { channels: 3, labels: "hwb" },
      cmyk: { channels: 4, labels: "cmyk" },
      xyz: { channels: 3, labels: "xyz" },
      lab: { channels: 3, labels: "lab" },
      lch: { channels: 3, labels: "lch" },
      hex: { channels: 1, labels: ["hex"] },
      keyword: { channels: 1, labels: ["keyword"] },
      ansi16: { channels: 1, labels: ["ansi16"] },
      ansi256: { channels: 1, labels: ["ansi256"] },
      hcg: { channels: 3, labels: ["h", "c", "g"] },
      apple: { channels: 3, labels: ["r16", "g16", "b16"] },
      gray: { channels: 1, labels: ["gray"] }
    };
    module2.exports = convert;
    for (const model of Object.keys(convert)) {
      if (!("channels" in convert[model])) {
        throw new Error("missing channels property: " + model);
      }
      if (!("labels" in convert[model])) {
        throw new Error("missing channel labels property: " + model);
      }
      if (convert[model].labels.length !== convert[model].channels) {
        throw new Error("channel and label counts mismatch: " + model);
      }
      const { channels, labels } = convert[model];
      delete convert[model].channels;
      delete convert[model].labels;
      Object.defineProperty(convert[model], "channels", { value: channels });
      Object.defineProperty(convert[model], "labels", { value: labels });
    }
    convert.rgb.hsl = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const min = Math.min(r, g, b);
      const max = Math.max(r, g, b);
      const delta = max - min;
      let h;
      let s;
      if (max === min) {
        h = 0;
      } else if (r === max) {
        h = (g - b) / delta;
      } else if (g === max) {
        h = 2 + (b - r) / delta;
      } else if (b === max) {
        h = 4 + (r - g) / delta;
      }
      h = Math.min(h * 60, 360);
      if (h < 0) {
        h += 360;
      }
      const l = (min + max) / 2;
      if (max === min) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max + min);
      } else {
        s = delta / (2 - max - min);
      }
      return [h, s * 100, l * 100];
    };
    convert.rgb.hsv = function(rgb) {
      let rdif;
      let gdif;
      let bdif;
      let h;
      let s;
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const v = Math.max(r, g, b);
      const diff = v - Math.min(r, g, b);
      const diffc = function(c) {
        return (v - c) / 6 / diff + 1 / 2;
      };
      if (diff === 0) {
        h = 0;
        s = 0;
      } else {
        s = diff / v;
        rdif = diffc(r);
        gdif = diffc(g);
        bdif = diffc(b);
        if (r === v) {
          h = bdif - gdif;
        } else if (g === v) {
          h = 1 / 3 + rdif - bdif;
        } else if (b === v) {
          h = 2 / 3 + gdif - rdif;
        }
        if (h < 0) {
          h += 1;
        } else if (h > 1) {
          h -= 1;
        }
      }
      return [
        h * 360,
        s * 100,
        v * 100
      ];
    };
    convert.rgb.hwb = function(rgb) {
      const r = rgb[0];
      const g = rgb[1];
      let b = rgb[2];
      const h = convert.rgb.hsl(rgb)[0];
      const w = 1 / 255 * Math.min(r, Math.min(g, b));
      b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
      return [h, w * 100, b * 100];
    };
    convert.rgb.cmyk = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const k = Math.min(1 - r, 1 - g, 1 - b);
      const c = (1 - r - k) / (1 - k) || 0;
      const m = (1 - g - k) / (1 - k) || 0;
      const y = (1 - b - k) / (1 - k) || 0;
      return [c * 100, m * 100, y * 100, k * 100];
    };
    function comparativeDistance(x, y) {
      return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
    }
    convert.rgb.keyword = function(rgb) {
      const reversed = reverseKeywords[rgb];
      if (reversed) {
        return reversed;
      }
      let currentClosestDistance = Infinity;
      let currentClosestKeyword;
      for (const keyword of Object.keys(cssKeywords)) {
        const value2 = cssKeywords[keyword];
        const distance = comparativeDistance(rgb, value2);
        if (distance < currentClosestDistance) {
          currentClosestDistance = distance;
          currentClosestKeyword = keyword;
        }
      }
      return currentClosestKeyword;
    };
    convert.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert.rgb.xyz = function(rgb) {
      let r = rgb[0] / 255;
      let g = rgb[1] / 255;
      let b = rgb[2] / 255;
      r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
      g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
      b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
      const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
      const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
      const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x * 100, y * 100, z * 100];
    };
    convert.rgb.lab = function(rgb) {
      const xyz = convert.rgb.xyz(rgb);
      let x = xyz[0];
      let y = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y - 16;
      const a = 500 * (x - y);
      const b = 200 * (y - z);
      return [l, a, b];
    };
    convert.hsl.rgb = function(hsl) {
      const h = hsl[0] / 360;
      const s = hsl[1] / 100;
      const l = hsl[2] / 100;
      let t2;
      let t3;
      let val;
      if (s === 0) {
        val = l * 255;
        return [val, val, val];
      }
      if (l < 0.5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }
      const t1 = 2 * l - t2;
      const rgb = [0, 0, 0];
      for (let i = 0; i < 3; i++) {
        t3 = h + 1 / 3 * -(i - 1);
        if (t3 < 0) {
          t3++;
        }
        if (t3 > 1) {
          t3--;
        }
        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }
        rgb[i] = val * 255;
      }
      return rgb;
    };
    convert.hsl.hsv = function(hsl) {
      const h = hsl[0];
      let s = hsl[1] / 100;
      let l = hsl[2] / 100;
      let smin = s;
      const lmin = Math.max(l, 0.01);
      l *= 2;
      s *= l <= 1 ? l : 2 - l;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      const v = (l + s) / 2;
      const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
      return [h, sv * 100, v * 100];
    };
    convert.hsv.rgb = function(hsv) {
      const h = hsv[0] / 60;
      const s = hsv[1] / 100;
      let v = hsv[2] / 100;
      const hi = Math.floor(h) % 6;
      const f = h - Math.floor(h);
      const p = 255 * v * (1 - s);
      const q = 255 * v * (1 - s * f);
      const t = 255 * v * (1 - s * (1 - f));
      v *= 255;
      switch (hi) {
        case 0:
          return [v, t, p];
        case 1:
          return [q, v, p];
        case 2:
          return [p, v, t];
        case 3:
          return [p, q, v];
        case 4:
          return [t, p, v];
        case 5:
          return [v, p, q];
      }
    };
    convert.hsv.hsl = function(hsv) {
      const h = hsv[0];
      const s = hsv[1] / 100;
      const v = hsv[2] / 100;
      const vmin = Math.max(v, 0.01);
      let sl;
      let l;
      l = (2 - s) * v;
      const lmin = (2 - s) * vmin;
      sl = s * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l /= 2;
      return [h, sl * 100, l * 100];
    };
    convert.hwb.rgb = function(hwb) {
      const h = hwb[0] / 360;
      let wh = hwb[1] / 100;
      let bl = hwb[2] / 100;
      const ratio = wh + bl;
      let f;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      const i = Math.floor(6 * h);
      const v = 1 - bl;
      f = 6 * h - i;
      if ((i & 1) !== 0) {
        f = 1 - f;
      }
      const n = wh + f * (v - wh);
      let r;
      let g;
      let b;
      switch (i) {
        default:
        case 6:
        case 0:
          r = v;
          g = n;
          b = wh;
          break;
        case 1:
          r = n;
          g = v;
          b = wh;
          break;
        case 2:
          r = wh;
          g = v;
          b = n;
          break;
        case 3:
          r = wh;
          g = n;
          b = v;
          break;
        case 4:
          r = n;
          g = wh;
          b = v;
          break;
        case 5:
          r = v;
          g = wh;
          b = n;
          break;
      }
      return [r * 255, g * 255, b * 255];
    };
    convert.cmyk.rgb = function(cmyk) {
      const c = cmyk[0] / 100;
      const m = cmyk[1] / 100;
      const y = cmyk[2] / 100;
      const k = cmyk[3] / 100;
      const r = 1 - Math.min(1, c * (1 - k) + k);
      const g = 1 - Math.min(1, m * (1 - k) + k);
      const b = 1 - Math.min(1, y * (1 - k) + k);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.rgb = function(xyz) {
      const x = xyz[0] / 100;
      const y = xyz[1] / 100;
      const z = xyz[2] / 100;
      let r;
      let g;
      let b;
      r = x * 3.2406 + y * -1.5372 + z * -0.4986;
      g = x * -0.9689 + y * 1.8758 + z * 0.0415;
      b = x * 0.0557 + y * -0.204 + z * 1.057;
      r = r > 31308e-7 ? 1.055 * r ** (1 / 2.4) - 0.055 : r * 12.92;
      g = g > 31308e-7 ? 1.055 * g ** (1 / 2.4) - 0.055 : g * 12.92;
      b = b > 31308e-7 ? 1.055 * b ** (1 / 2.4) - 0.055 : b * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.lab = function(xyz) {
      let x = xyz[0];
      let y = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y - 16;
      const a = 500 * (x - y);
      const b = 200 * (y - z);
      return [l, a, b];
    };
    convert.lab.xyz = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let x;
      let y;
      let z;
      y = (l + 16) / 116;
      x = a / 500 + y;
      z = y - b / 200;
      const y2 = y ** 3;
      const x2 = x ** 3;
      const z2 = z ** 3;
      y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
      x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
      z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
      x *= 95.047;
      y *= 100;
      z *= 108.883;
      return [x, y, z];
    };
    convert.lab.lch = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let h;
      const hr = Math.atan2(b, a);
      h = hr * 360 / 2 / Math.PI;
      if (h < 0) {
        h += 360;
      }
      const c = Math.sqrt(a * a + b * b);
      return [l, c, h];
    };
    convert.lch.lab = function(lch) {
      const l = lch[0];
      const c = lch[1];
      const h = lch[2];
      const hr = h / 360 * 2 * Math.PI;
      const a = c * Math.cos(hr);
      const b = c * Math.sin(hr);
      return [l, a, b];
    };
    convert.rgb.ansi16 = function(args, saturation = null) {
      const [r, g, b] = args;
      let value2 = saturation === null ? convert.rgb.hsv(args)[2] : saturation;
      value2 = Math.round(value2 / 50);
      if (value2 === 0) {
        return 30;
      }
      let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
      if (value2 === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert.hsv.ansi16 = function(args) {
      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
    };
    convert.rgb.ansi256 = function(args) {
      const r = args[0];
      const g = args[1];
      const b = args[2];
      if (r === g && g === b) {
        if (r < 8) {
          return 16;
        }
        if (r > 248) {
          return 231;
        }
        return Math.round((r - 8) / 247 * 24) + 232;
      }
      const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
      return ansi;
    };
    convert.ansi16.rgb = function(args) {
      let color = args % 10;
      if (color === 0 || color === 7) {
        if (args > 50) {
          color += 3.5;
        }
        color = color / 10.5 * 255;
        return [color, color, color];
      }
      const mult = (~~(args > 50) + 1) * 0.5;
      const r = (color & 1) * mult * 255;
      const g = (color >> 1 & 1) * mult * 255;
      const b = (color >> 2 & 1) * mult * 255;
      return [r, g, b];
    };
    convert.ansi256.rgb = function(args) {
      if (args >= 232) {
        const c = (args - 232) * 10 + 8;
        return [c, c, c];
      }
      args -= 16;
      let rem;
      const r = Math.floor(args / 36) / 5 * 255;
      const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
      const b = rem % 6 / 5 * 255;
      return [r, g, b];
    };
    convert.rgb.hex = function(args) {
      const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.hex.rgb = function(args) {
      const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match) {
        return [0, 0, 0];
      }
      let colorString = match[0];
      if (match[0].length === 3) {
        colorString = colorString.split("").map((char) => {
          return char + char;
        }).join("");
      }
      const integer = parseInt(colorString, 16);
      const r = integer >> 16 & 255;
      const g = integer >> 8 & 255;
      const b = integer & 255;
      return [r, g, b];
    };
    convert.rgb.hcg = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const max = Math.max(Math.max(r, g), b);
      const min = Math.min(Math.min(r, g), b);
      const chroma = max - min;
      let grayscale;
      let hue;
      if (chroma < 1) {
        grayscale = min / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue = 0;
      } else if (max === r) {
        hue = (g - b) / chroma % 6;
      } else if (max === g) {
        hue = 2 + (b - r) / chroma;
      } else {
        hue = 4 + (r - g) / chroma;
      }
      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };
    convert.hsl.hcg = function(hsl) {
      const s = hsl[1] / 100;
      const l = hsl[2] / 100;
      const c = l < 0.5 ? 2 * s * l : 2 * s * (1 - l);
      let f = 0;
      if (c < 1) {
        f = (l - 0.5 * c) / (1 - c);
      }
      return [hsl[0], c * 100, f * 100];
    };
    convert.hsv.hcg = function(hsv) {
      const s = hsv[1] / 100;
      const v = hsv[2] / 100;
      const c = s * v;
      let f = 0;
      if (c < 1) {
        f = (v - c) / (1 - c);
      }
      return [hsv[0], c * 100, f * 100];
    };
    convert.hcg.rgb = function(hcg) {
      const h = hcg[0] / 360;
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      if (c === 0) {
        return [g * 255, g * 255, g * 255];
      }
      const pure = [0, 0, 0];
      const hi = h % 1 * 6;
      const v = hi % 1;
      const w = 1 - v;
      let mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w;
      }
      mg = (1 - c) * g;
      return [
        (c * pure[0] + mg) * 255,
        (c * pure[1] + mg) * 255,
        (c * pure[2] + mg) * 255
      ];
    };
    convert.hcg.hsv = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c + g * (1 - c);
      let f = 0;
      if (v > 0) {
        f = c / v;
      }
      return [hcg[0], f * 100, v * 100];
    };
    convert.hcg.hsl = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const l = g * (1 - c) + 0.5 * c;
      let s = 0;
      if (l > 0 && l < 0.5) {
        s = c / (2 * l);
      } else if (l >= 0.5 && l < 1) {
        s = c / (2 * (1 - l));
      }
      return [hcg[0], s * 100, l * 100];
    };
    convert.hcg.hwb = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c + g * (1 - c);
      return [hcg[0], (v - c) * 100, (1 - v) * 100];
    };
    convert.hwb.hcg = function(hwb) {
      const w = hwb[1] / 100;
      const b = hwb[2] / 100;
      const v = 1 - b;
      const c = v - w;
      let g = 0;
      if (c < 1) {
        g = (v - c) / (1 - c);
      }
      return [hwb[0], c * 100, g * 100];
    };
    convert.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert.rgb.apple = function(rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };
    convert.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };
    convert.gray.hsl = function(args) {
      return [0, 0, args[0]];
    };
    convert.gray.hsv = convert.gray.hsl;
    convert.gray.hwb = function(gray) {
      return [0, 100, gray[0]];
    };
    convert.gray.cmyk = function(gray) {
      return [0, 0, 0, gray[0]];
    };
    convert.gray.lab = function(gray) {
      return [gray[0], 0, 0];
    };
    convert.gray.hex = function(gray) {
      const val = Math.round(gray[0] / 100 * 255) & 255;
      const integer = (val << 16) + (val << 8) + val;
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.rgb.gray = function(rgb) {
      const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [val / 255 * 100];
    };
  }
});

// node_modules/color-convert/route.js
var require_route = __commonJS({
  "node_modules/color-convert/route.js"(exports2, module2) {
    "use strict";
    var conversions = require_conversions();
    function buildGraph() {
      const graph = {};
      const models = Object.keys(conversions);
      for (let len = models.length, i = 0; i < len; i++) {
        graph[models[i]] = {
          // http://jsperf.com/1-vs-infinity
          // micro-opt, but this is simple.
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    function deriveBFS(fromModel) {
      const graph = buildGraph();
      const queue = [fromModel];
      graph[fromModel].distance = 0;
      while (queue.length) {
        const current = queue.pop();
        const adjacents = Object.keys(conversions[current]);
        for (let len = adjacents.length, i = 0; i < len; i++) {
          const adjacent = adjacents[i];
          const node = graph[adjacent];
          if (node.distance === -1) {
            node.distance = graph[current].distance + 1;
            node.parent = current;
            queue.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    function link(from, to) {
      return function(args) {
        return to(from(args));
      };
    }
    function wrapConversion(toModel, graph) {
      const path = [graph[toModel].parent, toModel];
      let fn = conversions[graph[toModel].parent][toModel];
      let cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path.unshift(graph[cur].parent);
        fn = link(conversions[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
      }
      fn.conversion = path;
      return fn;
    }
    module2.exports = function(fromModel) {
      const graph = deriveBFS(fromModel);
      const conversion = {};
      const models = Object.keys(graph);
      for (let len = models.length, i = 0; i < len; i++) {
        const toModel = models[i];
        const node = graph[toModel];
        if (node.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
  }
});

// node_modules/color-convert/index.js
var require_color_convert = __commonJS({
  "node_modules/color-convert/index.js"(exports2, module2) {
    "use strict";
    var conversions = require_conversions();
    var route = require_route();
    var convert = {};
    var models = Object.keys(conversions);
    function wrapRaw(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        return fn(args);
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    function wrapRounded(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        const result = fn(args);
        if (typeof result === "object") {
          for (let len = result.length, i = 0; i < len; i++) {
            result[i] = Math.round(result[i]);
          }
        }
        return result;
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    models.forEach((fromModel) => {
      convert[fromModel] = {};
      Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
      Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
      const routes = route(fromModel);
      const routeModels = Object.keys(routes);
      routeModels.forEach((toModel) => {
        const fn = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn);
        convert[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    module2.exports = convert;
  }
});

// node_modules/ansi-styles/index.js
var require_ansi_styles = __commonJS({
  "node_modules/ansi-styles/index.js"(exports2, module2) {
    "use strict";
    var wrapAnsi16 = (fn, offset) => (...args) => {
      const code = fn(...args);
      return `\x1B[${code + offset}m`;
    };
    var wrapAnsi256 = (fn, offset) => (...args) => {
      const code = fn(...args);
      return `\x1B[${38 + offset};5;${code}m`;
    };
    var wrapAnsi16m = (fn, offset) => (...args) => {
      const rgb = fn(...args);
      return `\x1B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
    };
    var ansi2ansi = (n) => n;
    var rgb2rgb = (r, g, b) => [r, g, b];
    var setLazyProperty = (object, property, get) => {
      Object.defineProperty(object, property, {
        get: () => {
          const value2 = get();
          Object.defineProperty(object, property, {
            value: value2,
            enumerable: true,
            configurable: true
          });
          return value2;
        },
        enumerable: true,
        configurable: true
      });
    };
    var colorConvert;
    var makeDynamicStyles = (wrap, targetSpace, identity, isBackground) => {
      if (colorConvert === void 0) {
        colorConvert = require_color_convert();
      }
      const offset = isBackground ? 10 : 0;
      const styles = {};
      for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
        const name = sourceSpace === "ansi16" ? "ansi" : sourceSpace;
        if (sourceSpace === targetSpace) {
          styles[name] = wrap(identity, offset);
        } else if (typeof suite === "object") {
          styles[name] = wrap(suite[targetSpace], offset);
        }
      }
      return styles;
    };
    function assembleStyles() {
      const codes = /* @__PURE__ */ new Map();
      const styles = {
        modifier: {
          reset: [0, 0],
          // 21 isn't widely supported and 22 does the same thing
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          // Bright color
          blackBright: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          // Bright color
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      styles.color.gray = styles.color.blackBright;
      styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
      styles.color.grey = styles.color.blackBright;
      styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
      for (const [groupName, group] of Object.entries(styles)) {
        for (const [styleName, style] of Object.entries(group)) {
          styles[styleName] = {
            open: `\x1B[${style[0]}m`,
            close: `\x1B[${style[1]}m`
          };
          group[styleName] = styles[styleName];
          codes.set(style[0], style[1]);
        }
        Object.defineProperty(styles, groupName, {
          value: group,
          enumerable: false
        });
      }
      Object.defineProperty(styles, "codes", {
        value: codes,
        enumerable: false
      });
      styles.color.close = "\x1B[39m";
      styles.bgColor.close = "\x1B[49m";
      setLazyProperty(styles.color, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, false));
      setLazyProperty(styles.color, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, false));
      setLazyProperty(styles.color, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, false));
      setLazyProperty(styles.bgColor, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, true));
      setLazyProperty(styles.bgColor, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, true));
      setLazyProperty(styles.bgColor, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, true));
      return styles;
    }
    Object.defineProperty(module2, "exports", {
      enumerable: true,
      get: assembleStyles
    });
  }
});

// node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "node_modules/has-flag/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (flag, argv = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position = argv.indexOf(prefix + flag);
      const terminatorPosition = argv.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  }
});

// node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "node_modules/supports-color/index.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var tty = require("tty");
    var hasFlag = require_has_flag();
    var { env } = process;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      forceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = 1;
    }
    if ("FORCE_COLOR" in env) {
      if (env.FORCE_COLOR === "true") {
        forceColor = 1;
      } else if (env.FORCE_COLOR === "false") {
        forceColor = 0;
      } else {
        forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(haveStream, streamIsTTY) {
      if (forceColor === 0) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min = forceColor || 0;
      if (env.TERM === "dumb") {
        return min;
      }
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env) {
        const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      return min;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream, stream && stream.isTTY);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: translateLevel(supportsColor(true, tty.isatty(1))),
      stderr: translateLevel(supportsColor(true, tty.isatty(2)))
    };
  }
});

// node_modules/chalk/source/util.js
var require_util = __commonJS({
  "node_modules/chalk/source/util.js"(exports2, module2) {
    "use strict";
    var stringReplaceAll = (string, substring, replacer) => {
      let index = string.indexOf(substring);
      if (index === -1) {
        return string;
      }
      const substringLength = substring.length;
      let endIndex = 0;
      let returnValue = "";
      do {
        returnValue += string.substr(endIndex, index - endIndex) + substring + replacer;
        endIndex = index + substringLength;
        index = string.indexOf(substring, endIndex);
      } while (index !== -1);
      returnValue += string.substr(endIndex);
      return returnValue;
    };
    var stringEncaseCRLFWithFirstIndex = (string, prefix, postfix, index) => {
      let endIndex = 0;
      let returnValue = "";
      do {
        const gotCR = string[index - 1] === "\r";
        returnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
        endIndex = index + 1;
        index = string.indexOf("\n", endIndex);
      } while (index !== -1);
      returnValue += string.substr(endIndex);
      return returnValue;
    };
    module2.exports = {
      stringReplaceAll,
      stringEncaseCRLFWithFirstIndex
    };
  }
});

// node_modules/chalk/source/templates.js
var require_templates = __commonJS({
  "node_modules/chalk/source/templates.js"(exports2, module2) {
    "use strict";
    var TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
    var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
    var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
    var ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi;
    var ESCAPES = /* @__PURE__ */ new Map([
      ["n", "\n"],
      ["r", "\r"],
      ["t", "	"],
      ["b", "\b"],
      ["f", "\f"],
      ["v", "\v"],
      ["0", "\0"],
      ["\\", "\\"],
      ["e", "\x1B"],
      ["a", "\x07"]
    ]);
    function unescape2(c) {
      const u = c[0] === "u";
      const bracket = c[1] === "{";
      if (u && !bracket && c.length === 5 || c[0] === "x" && c.length === 3) {
        return String.fromCharCode(parseInt(c.slice(1), 16));
      }
      if (u && bracket) {
        return String.fromCodePoint(parseInt(c.slice(2, -1), 16));
      }
      return ESCAPES.get(c) || c;
    }
    function parseArguments(name, arguments_) {
      const results = [];
      const chunks = arguments_.trim().split(/\s*,\s*/g);
      let matches;
      for (const chunk of chunks) {
        const number = Number(chunk);
        if (!Number.isNaN(number)) {
          results.push(number);
        } else if (matches = chunk.match(STRING_REGEX)) {
          results.push(matches[2].replace(ESCAPE_REGEX, (m, escape2, character) => escape2 ? unescape2(escape2) : character));
        } else {
          throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
        }
      }
      return results;
    }
    function parseStyle(style) {
      STYLE_REGEX.lastIndex = 0;
      const results = [];
      let matches;
      while ((matches = STYLE_REGEX.exec(style)) !== null) {
        const name = matches[1];
        if (matches[2]) {
          const args = parseArguments(name, matches[2]);
          results.push([name].concat(args));
        } else {
          results.push([name]);
        }
      }
      return results;
    }
    function buildStyle(chalk, styles) {
      const enabled = {};
      for (const layer of styles) {
        for (const style of layer.styles) {
          enabled[style[0]] = layer.inverse ? null : style.slice(1);
        }
      }
      let current = chalk;
      for (const [styleName, styles2] of Object.entries(enabled)) {
        if (!Array.isArray(styles2)) {
          continue;
        }
        if (!(styleName in current)) {
          throw new Error(`Unknown Chalk style: ${styleName}`);
        }
        current = styles2.length > 0 ? current[styleName](...styles2) : current[styleName];
      }
      return current;
    }
    module2.exports = (chalk, temporary) => {
      const styles = [];
      const chunks = [];
      let chunk = [];
      temporary.replace(TEMPLATE_REGEX, (m, escapeCharacter, inverse, style, close, character) => {
        if (escapeCharacter) {
          chunk.push(unescape2(escapeCharacter));
        } else if (style) {
          const string = chunk.join("");
          chunk = [];
          chunks.push(styles.length === 0 ? string : buildStyle(chalk, styles)(string));
          styles.push({ inverse, styles: parseStyle(style) });
        } else if (close) {
          if (styles.length === 0) {
            throw new Error("Found extraneous } in Chalk template literal");
          }
          chunks.push(buildStyle(chalk, styles)(chunk.join("")));
          chunk = [];
          styles.pop();
        } else {
          chunk.push(character);
        }
      });
      chunks.push(chunk.join(""));
      if (styles.length > 0) {
        const errMessage = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
        throw new Error(errMessage);
      }
      return chunks.join("");
    };
  }
});

// node_modules/chalk/source/index.js
var require_source = __commonJS({
  "node_modules/chalk/source/index.js"(exports2, module2) {
    "use strict";
    var ansiStyles = require_ansi_styles();
    var { stdout: stdoutColor, stderr: stderrColor } = require_supports_color();
    var {
      stringReplaceAll,
      stringEncaseCRLFWithFirstIndex
    } = require_util();
    var { isArray } = Array;
    var levelMapping = [
      "ansi",
      "ansi",
      "ansi256",
      "ansi16m"
    ];
    var styles = /* @__PURE__ */ Object.create(null);
    var applyOptions = (object, options = {}) => {
      if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
        throw new Error("The `level` option should be an integer from 0 to 3");
      }
      const colorLevel = stdoutColor ? stdoutColor.level : 0;
      object.level = options.level === void 0 ? colorLevel : options.level;
    };
    var ChalkClass = class {
      constructor(options) {
        return chalkFactory(options);
      }
    };
    var chalkFactory = (options) => {
      const chalk2 = {};
      applyOptions(chalk2, options);
      chalk2.template = (...arguments_) => chalkTag(chalk2.template, ...arguments_);
      Object.setPrototypeOf(chalk2, Chalk.prototype);
      Object.setPrototypeOf(chalk2.template, chalk2);
      chalk2.template.constructor = () => {
        throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
      };
      chalk2.template.Instance = ChalkClass;
      return chalk2.template;
    };
    function Chalk(options) {
      return chalkFactory(options);
    }
    for (const [styleName, style] of Object.entries(ansiStyles)) {
      styles[styleName] = {
        get() {
          const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
          Object.defineProperty(this, styleName, { value: builder });
          return builder;
        }
      };
    }
    styles.visible = {
      get() {
        const builder = createBuilder(this, this._styler, true);
        Object.defineProperty(this, "visible", { value: builder });
        return builder;
      }
    };
    var usedModels = ["rgb", "hex", "keyword", "hsl", "hsv", "hwb", "ansi", "ansi256"];
    for (const model of usedModels) {
      styles[model] = {
        get() {
          const { level } = this;
          return function(...arguments_) {
            const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
            return createBuilder(this, styler, this._isEmpty);
          };
        }
      };
    }
    for (const model of usedModels) {
      const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
      styles[bgModel] = {
        get() {
          const { level } = this;
          return function(...arguments_) {
            const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
            return createBuilder(this, styler, this._isEmpty);
          };
        }
      };
    }
    var proto = Object.defineProperties(() => {
    }, {
      ...styles,
      level: {
        enumerable: true,
        get() {
          return this._generator.level;
        },
        set(level) {
          this._generator.level = level;
        }
      }
    });
    var createStyler = (open, close, parent) => {
      let openAll;
      let closeAll;
      if (parent === void 0) {
        openAll = open;
        closeAll = close;
      } else {
        openAll = parent.openAll + open;
        closeAll = close + parent.closeAll;
      }
      return {
        open,
        close,
        openAll,
        closeAll,
        parent
      };
    };
    var createBuilder = (self2, _styler, _isEmpty) => {
      const builder = (...arguments_) => {
        if (isArray(arguments_[0]) && isArray(arguments_[0].raw)) {
          return applyStyle(builder, chalkTag(builder, ...arguments_));
        }
        return applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
      };
      Object.setPrototypeOf(builder, proto);
      builder._generator = self2;
      builder._styler = _styler;
      builder._isEmpty = _isEmpty;
      return builder;
    };
    var applyStyle = (self2, string) => {
      if (self2.level <= 0 || !string) {
        return self2._isEmpty ? "" : string;
      }
      let styler = self2._styler;
      if (styler === void 0) {
        return string;
      }
      const { openAll, closeAll } = styler;
      if (string.indexOf("\x1B") !== -1) {
        while (styler !== void 0) {
          string = stringReplaceAll(string, styler.close, styler.open);
          styler = styler.parent;
        }
      }
      const lfIndex = string.indexOf("\n");
      if (lfIndex !== -1) {
        string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
      }
      return openAll + string + closeAll;
    };
    var template;
    var chalkTag = (chalk2, ...strings) => {
      const [firstString] = strings;
      if (!isArray(firstString) || !isArray(firstString.raw)) {
        return strings.join(" ");
      }
      const arguments_ = strings.slice(1);
      const parts = [firstString.raw[0]];
      for (let i = 1; i < firstString.length; i++) {
        parts.push(
          String(arguments_[i - 1]).replace(/[{}\\]/g, "\\$&"),
          String(firstString.raw[i])
        );
      }
      if (template === void 0) {
        template = require_templates();
      }
      return template(chalk2, parts.join(""));
    };
    Object.defineProperties(Chalk.prototype, styles);
    var chalk = Chalk();
    chalk.supportsColor = stdoutColor;
    chalk.stderr = Chalk({ level: stderrColor ? stderrColor.level : 0 });
    chalk.stderr.supportsColor = stderrColor;
    module2.exports = chalk;
  }
});

// node_modules/ava/lib/worker/ensure-forked.js
var require_ensure_forked = __commonJS({
  "node_modules/ava/lib/worker/ensure-forked.js"() {
    "use strict";
    var path = require("path");
    var chalk = require_source();
    var isForked = typeof process.send === "function";
    if (!isForked) {
      if (process.argv[1]) {
        const fp = path.relative(".", process.argv[1]);
        console.log();
        console.error(`Test files must be run with the AVA CLI:

    ${chalk.grey.dim("$")} ${chalk.cyan("ava " + fp)}
`);
        process.exit(1);
      } else {
        throw new Error("The \u2019ava\u2019 module can only be imported in test files");
      }
    }
  }
});

// node_modules/p-finally/index.js
var require_p_finally = __commonJS({
  "node_modules/p-finally/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (promise, onFinally) => {
      onFinally = onFinally || (() => {
      });
      return promise.then(
        (val) => new Promise((resolve) => {
          resolve(onFinally());
        }).then(() => val),
        (err) => new Promise((resolve) => {
          resolve(onFinally());
        }).then(() => {
          throw err;
        })
      );
    };
  }
});

// node_modules/p-timeout/index.js
var require_p_timeout = __commonJS({
  "node_modules/p-timeout/index.js"(exports2, module2) {
    "use strict";
    var pFinally = require_p_finally();
    var TimeoutError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "TimeoutError";
      }
    };
    var pTimeout = (promise, milliseconds, fallback) => new Promise((resolve, reject) => {
      if (typeof milliseconds !== "number" || milliseconds < 0) {
        throw new TypeError("Expected `milliseconds` to be a positive number");
      }
      if (milliseconds === Infinity) {
        resolve(promise);
        return;
      }
      const timer = setTimeout(() => {
        if (typeof fallback === "function") {
          try {
            resolve(fallback());
          } catch (error) {
            reject(error);
          }
          return;
        }
        const message = typeof fallback === "string" ? fallback : `Promise timed out after ${milliseconds} milliseconds`;
        const timeoutError = fallback instanceof Error ? fallback : new TimeoutError(message);
        if (typeof promise.cancel === "function") {
          promise.cancel();
        }
        reject(timeoutError);
      }, milliseconds);
      pFinally(
        // eslint-disable-next-line promise/prefer-await-to-then
        promise.then(resolve, reject),
        () => {
          clearTimeout(timer);
        }
      );
    });
    module2.exports = pTimeout;
    module2.exports.default = pTimeout;
    module2.exports.TimeoutError = TimeoutError;
  }
});

// node_modules/p-event/index.js
var require_p_event = __commonJS({
  "node_modules/p-event/index.js"(exports2, module2) {
    "use strict";
    var pTimeout = require_p_timeout();
    var symbolAsyncIterator = Symbol.asyncIterator || "@@asyncIterator";
    var normalizeEmitter = (emitter) => {
      const addListener = emitter.on || emitter.addListener || emitter.addEventListener;
      const removeListener = emitter.off || emitter.removeListener || emitter.removeEventListener;
      if (!addListener || !removeListener) {
        throw new TypeError("Emitter is not compatible");
      }
      return {
        addListener: addListener.bind(emitter),
        removeListener: removeListener.bind(emitter)
      };
    };
    var toArray = (value2) => Array.isArray(value2) ? value2 : [value2];
    var multiple = (emitter, event, options) => {
      let cancel;
      const ret = new Promise((resolve, reject) => {
        options = {
          rejectionEvents: ["error"],
          multiArgs: false,
          resolveImmediately: false,
          ...options
        };
        if (!(options.count >= 0 && (options.count === Infinity || Number.isInteger(options.count)))) {
          throw new TypeError("The `count` option should be at least 0 or more");
        }
        const events = toArray(event);
        const items = [];
        const { addListener, removeListener } = normalizeEmitter(emitter);
        const onItem = (...args) => {
          const value2 = options.multiArgs ? args : args[0];
          if (options.filter && !options.filter(value2)) {
            return;
          }
          items.push(value2);
          if (options.count === items.length) {
            cancel();
            resolve(items);
          }
        };
        const rejectHandler = (error) => {
          cancel();
          reject(error);
        };
        cancel = () => {
          for (const event2 of events) {
            removeListener(event2, onItem);
          }
          for (const rejectionEvent of options.rejectionEvents) {
            removeListener(rejectionEvent, rejectHandler);
          }
        };
        for (const event2 of events) {
          addListener(event2, onItem);
        }
        for (const rejectionEvent of options.rejectionEvents) {
          addListener(rejectionEvent, rejectHandler);
        }
        if (options.resolveImmediately) {
          resolve(items);
        }
      });
      ret.cancel = cancel;
      if (typeof options.timeout === "number") {
        const timeout = pTimeout(ret, options.timeout);
        timeout.cancel = cancel;
        return timeout;
      }
      return ret;
    };
    var pEvent = (emitter, event, options) => {
      if (typeof options === "function") {
        options = { filter: options };
      }
      options = {
        ...options,
        count: 1,
        resolveImmediately: false
      };
      const arrayPromise = multiple(emitter, event, options);
      const promise = arrayPromise.then((array) => array[0]);
      promise.cancel = arrayPromise.cancel;
      return promise;
    };
    module2.exports = pEvent;
    module2.exports.default = pEvent;
    module2.exports.multiple = multiple;
    module2.exports.iterator = (emitter, event, options) => {
      if (typeof options === "function") {
        options = { filter: options };
      }
      const events = toArray(event);
      options = {
        rejectionEvents: ["error"],
        resolutionEvents: [],
        limit: Infinity,
        multiArgs: false,
        ...options
      };
      const { limit } = options;
      const isValidLimit = limit >= 0 && (limit === Infinity || Number.isInteger(limit));
      if (!isValidLimit) {
        throw new TypeError("The `limit` option should be a non-negative integer or Infinity");
      }
      if (limit === 0) {
        return {
          [Symbol.asyncIterator]() {
            return this;
          },
          async next() {
            return {
              done: true,
              value: void 0
            };
          }
        };
      }
      const { addListener, removeListener } = normalizeEmitter(emitter);
      let isDone = false;
      let error;
      let hasPendingError = false;
      const nextQueue = [];
      const valueQueue = [];
      let eventCount = 0;
      let isLimitReached = false;
      const valueHandler = (...args) => {
        eventCount++;
        isLimitReached = eventCount === limit;
        const value2 = options.multiArgs ? args : args[0];
        if (nextQueue.length > 0) {
          const { resolve } = nextQueue.shift();
          resolve({ done: false, value: value2 });
          if (isLimitReached) {
            cancel();
          }
          return;
        }
        valueQueue.push(value2);
        if (isLimitReached) {
          cancel();
        }
      };
      const cancel = () => {
        isDone = true;
        for (const event2 of events) {
          removeListener(event2, valueHandler);
        }
        for (const rejectionEvent of options.rejectionEvents) {
          removeListener(rejectionEvent, rejectHandler);
        }
        for (const resolutionEvent of options.resolutionEvents) {
          removeListener(resolutionEvent, resolveHandler);
        }
        while (nextQueue.length > 0) {
          const { resolve } = nextQueue.shift();
          resolve({ done: true, value: void 0 });
        }
      };
      const rejectHandler = (...args) => {
        error = options.multiArgs ? args : args[0];
        if (nextQueue.length > 0) {
          const { reject } = nextQueue.shift();
          reject(error);
        } else {
          hasPendingError = true;
        }
        cancel();
      };
      const resolveHandler = (...args) => {
        const value2 = options.multiArgs ? args : args[0];
        if (options.filter && !options.filter(value2)) {
          return;
        }
        if (nextQueue.length > 0) {
          const { resolve } = nextQueue.shift();
          resolve({ done: true, value: value2 });
        } else {
          valueQueue.push(value2);
        }
        cancel();
      };
      for (const event2 of events) {
        addListener(event2, valueHandler);
      }
      for (const rejectionEvent of options.rejectionEvents) {
        addListener(rejectionEvent, rejectHandler);
      }
      for (const resolutionEvent of options.resolutionEvents) {
        addListener(resolutionEvent, resolveHandler);
      }
      return {
        [symbolAsyncIterator]() {
          return this;
        },
        async next() {
          if (valueQueue.length > 0) {
            const value2 = valueQueue.shift();
            return {
              done: isDone && valueQueue.length === 0 && !isLimitReached,
              value: value2
            };
          }
          if (hasPendingError) {
            hasPendingError = false;
            throw error;
          }
          if (isDone) {
            return {
              done: true,
              value: void 0
            };
          }
          return new Promise((resolve, reject) => nextQueue.push({ resolve, reject }));
        },
        async return(value2) {
          cancel();
          return {
            done: isDone,
            value: value2
          };
        }
      };
    };
    module2.exports.TimeoutError = pTimeout.TimeoutError;
  }
});

// node_modules/ava/lib/ipc-flow-control.js
var require_ipc_flow_control = __commonJS({
  "node_modules/ava/lib/ipc-flow-control.js"(exports2) {
    "use strict";
    function controlFlow(channel) {
      let errored = false;
      let deliverImmediately = true;
      const backlog = [];
      const deliverNext = (error) => {
        if (error !== null) {
          errored = true;
        }
        if (errored || !channel.connected) {
          backlog.length = 0;
          return;
        }
        let ok = true;
        while (ok && backlog.length > 0) {
          ok = channel.send(backlog.shift(), deliverNext);
        }
        deliverImmediately = ok && backlog.length === 0;
      };
      return (message) => {
        if (errored || !channel.connected) {
          return;
        }
        if (deliverImmediately) {
          deliverImmediately = channel.send(message, deliverNext);
        } else {
          backlog.push(message);
        }
      };
    }
    exports2.controlFlow = controlFlow;
  }
});

// node_modules/ava/lib/worker/options.js
var require_options = __commonJS({
  "node_modules/ava/lib/worker/options.js"(exports2) {
    "use strict";
    var options = null;
    exports2.get = () => {
      if (!options) {
        throw new Error("Options have not yet been set");
      }
      return options;
    };
    exports2.set = (newOptions) => {
      if (options) {
        throw new Error("Options have already been set");
      }
      options = newOptions;
    };
  }
});

// node_modules/ava/lib/worker/ipc.js
var require_ipc = __commonJS({
  "node_modules/ava/lib/worker/ipc.js"(exports2) {
    "use strict";
    var events = require("events");
    var pEvent = require_p_event();
    var { controlFlow } = require_ipc_flow_control();
    var { get: getOptions } = require_options();
    var selectAvaMessage = (type) => (message) => message.ava && message.ava.type === type;
    exports2.options = pEvent(process, "message", selectAvaMessage("options")).then((message) => message.ava.options);
    exports2.peerFailed = pEvent(process, "message", selectAvaMessage("peer-failed"));
    var bufferedSend = controlFlow(process);
    function send(evt) {
      bufferedSend({ ava: evt });
    }
    exports2.send = send;
    var refs = 1;
    function ref() {
      if (++refs === 1) {
        process.channel.ref();
      }
    }
    function unref() {
      if (refs > 0 && --refs === 0) {
        process.channel.unref();
      }
    }
    exports2.unref = unref;
    var pendingPings = Promise.resolve();
    async function flush() {
      ref();
      const promise = pendingPings.then(async () => {
        send({ type: "ping" });
        await pEvent(process, "message", selectAvaMessage("pong"));
        if (promise === pendingPings) {
          unref();
        }
      });
      pendingPings = promise;
      await promise;
    }
    exports2.flush = flush;
    var channelCounter = 0;
    var messageCounter = 0;
    var channelEmitters = /* @__PURE__ */ new Map();
    function createChannelEmitter(channelId) {
      if (channelEmitters.size === 0) {
        process.on("message", (message) => {
          if (!message.ava) {
            return;
          }
          const { channelId: channelId2, type, ...payload } = message.ava;
          if (type === "shared-worker-error" || type === "shared-worker-message" || type === "shared-worker-ready") {
            const emitter2 = channelEmitters.get(channelId2);
            if (emitter2 !== void 0) {
              emitter2.emit(type, payload);
            }
          }
        });
      }
      const emitter = new events.EventEmitter();
      channelEmitters.set(channelId, emitter);
      return [emitter, () => channelEmitters.delete(channelId)];
    }
    function registerSharedWorker(filename, initialData) {
      const channelId = `${getOptions().forkId}/channel/${++channelCounter}`;
      const [channelEmitter, unsubscribe] = createChannelEmitter(channelId);
      let forcedUnref = false;
      let refs2 = 0;
      const forceUnref = () => {
        if (forcedUnref) {
          return;
        }
        forcedUnref = true;
        if (refs2 > 0) {
          unref();
        }
      };
      const refChannel = () => {
        if (!forcedUnref && ++refs2 === 1) {
          ref();
        }
      };
      const unrefChannel = () => {
        if (!forcedUnref && refs2 > 0 && --refs2 === 0) {
          unref();
        }
      };
      send({
        type: "shared-worker-connect",
        channelId,
        filename,
        initialData
      });
      let currentlyAvailable = false;
      let error = null;
      refChannel();
      const ready = pEvent(channelEmitter, "shared-worker-ready").then(() => {
        currentlyAvailable = error === null;
      }).finally(unrefChannel);
      const messageEmitters = /* @__PURE__ */ new Set();
      const handleMessage = (message) => {
        setImmediate(() => {
          for (const emitter of messageEmitters) {
            emitter.emit("message", message);
          }
        });
      };
      channelEmitter.on("shared-worker-message", handleMessage);
      pEvent(channelEmitter, "shared-worker-error").then(() => {
        unsubscribe();
        forceUnref();
        error = new Error("The shared worker is no longer available");
        currentlyAvailable = false;
        for (const emitter of messageEmitters) {
          emitter.emit("error", error);
        }
      });
      return {
        forceUnref,
        ready,
        channel: {
          available: ready,
          get currentlyAvailable() {
            return currentlyAvailable;
          },
          async *receive() {
            if (error !== null) {
              throw error;
            }
            const emitter = new events.EventEmitter();
            messageEmitters.add(emitter);
            try {
              refChannel();
              for await (const [message] of events.on(emitter, "message")) {
                yield message;
              }
            } finally {
              unrefChannel();
              messageEmitters.delete(emitter);
            }
          },
          post(serializedData, replyTo) {
            if (error !== null) {
              throw error;
            }
            if (!currentlyAvailable) {
              throw new Error("Shared worker is not yet available");
            }
            const messageId = `${channelId}/message/${++messageCounter}`;
            send({
              type: "shared-worker-message",
              channelId,
              messageId,
              replyTo,
              serializedData
            });
            return messageId;
          }
        }
      };
    }
    exports2.registerSharedWorker = registerSharedWorker;
  }
});

// <data:text/javascript,>
var require_javascript = __commonJS({
  "<data:text/javascript,>"() {
    "use strict";
  }
});

// node_modules/ava/lib/chalk.js
var require_chalk = __commonJS({
  "node_modules/ava/lib/chalk.js"(exports2) {
    "use strict";
    var chalk = require_source();
    var ctx = null;
    exports2.get = () => {
      if (!ctx) {
        throw new Error("Chalk has not yet been configured");
      }
      return ctx;
    };
    exports2.set = (options) => {
      if (ctx) {
        throw new Error("Chalk has already been configured");
      }
      ctx = new chalk.Instance(options);
      return ctx;
    };
  }
});

// node_modules/ava/lib/now-and-timers.js
var require_now_and_timers = __commonJS({
  "node_modules/ava/lib/now-and-timers.js"(exports2) {
    "use strict";
    var timers = require("timers");
    Object.assign(exports2, timers);
    exports2.now = Date.now;
  }
});

// node_modules/ava/package.json
var require_package = __commonJS({
  "node_modules/ava/package.json"(exports2, module2) {
    module2.exports = {
      name: "ava",
      version: "3.15.0",
      description: "Node.js test runner that lets you develop with confidence.",
      license: "MIT",
      repository: "avajs/ava",
      homepage: "https://avajs.dev",
      bin: "cli.js",
      engines: {
        node: ">=10.18.0 <11 || >=12.14.0 <12.17.0 || >=12.17.0 <13 || >=14.0.0 <15 || >=15"
      },
      scripts: {
        cover: "c8 --report=none tap && c8 --report=none --no-clean test-ava && c8 report",
        test: "xo && tsd && npm run -s cover"
      },
      files: [
        "lib",
        "*.js",
        "!*.config.js",
        "index.d.ts",
        "*.d.ts"
      ],
      keywords: [
        "\u{1F984}",
        "test",
        "runner",
        "testing",
        "ava",
        "concurrent",
        "parallel",
        "fast",
        "tdd",
        "cli-app",
        "cli",
        "jest",
        "mocha",
        "tape",
        "tap",
        "qunit",
        "jasmine",
        "babel",
        "assert",
        "assertion",
        "promise",
        "promises",
        "async",
        "function",
        "await",
        "generator",
        "generators",
        "yield",
        "observable",
        "observables",
        "unit",
        "snapshot",
        "expect",
        "typescript"
      ],
      dependencies: {
        "@concordance/react": "^2.0.0",
        acorn: "^8.0.4",
        "acorn-walk": "^8.0.0",
        "ansi-styles": "^5.0.0",
        arrgv: "^1.0.2",
        arrify: "^2.0.1",
        callsites: "^3.1.0",
        chalk: "^4.1.0",
        chokidar: "^3.4.3",
        chunkd: "^2.0.1",
        "ci-info": "^2.0.0",
        "ci-parallel-vars": "^1.0.1",
        "clean-yaml-object": "^0.1.0",
        "cli-cursor": "^3.1.0",
        "cli-truncate": "^2.1.0",
        "code-excerpt": "^3.0.0",
        "common-path-prefix": "^3.0.0",
        concordance: "^5.0.1",
        "convert-source-map": "^1.7.0",
        "currently-unhandled": "^0.4.1",
        debug: "^4.3.1",
        del: "^6.0.0",
        emittery: "^0.8.0",
        "equal-length": "^1.0.0",
        figures: "^3.2.0",
        globby: "^11.0.1",
        "ignore-by-default": "^2.0.0",
        "import-local": "^3.0.2",
        "indent-string": "^4.0.0",
        "is-error": "^2.2.2",
        "is-plain-object": "^5.0.0",
        "is-promise": "^4.0.0",
        lodash: "^4.17.20",
        matcher: "^3.0.0",
        "md5-hex": "^3.0.1",
        mem: "^8.0.0",
        ms: "^2.1.3",
        ora: "^5.2.0",
        "p-event": "^4.2.0",
        "p-map": "^4.0.0",
        picomatch: "^2.2.2",
        "pkg-conf": "^3.1.0",
        plur: "^4.0.0",
        "pretty-ms": "^7.0.1",
        "read-pkg": "^5.2.0",
        "resolve-cwd": "^3.0.0",
        slash: "^3.0.0",
        "source-map-support": "^0.5.19",
        "stack-utils": "^2.0.3",
        "strip-ansi": "^6.0.0",
        supertap: "^2.0.0",
        "temp-dir": "^2.0.0",
        "trim-off-newlines": "^1.0.1",
        "update-notifier": "^5.0.1",
        "write-file-atomic": "^3.0.3",
        yargs: "^16.2.0"
      },
      devDependencies: {
        "@ava/babel": "^1.0.1",
        "@ava/test": "github:avajs/test",
        "@babel/plugin-proposal-do-expressions": "^7.12.1",
        "@sinonjs/fake-timers": "^6.0.1",
        "ansi-escapes": "^4.3.1",
        c8: "^7.4.0",
        delay: "^4.4.0",
        esm: "^3.2.25",
        execa: "^5.0.0",
        "fs-extra": "^9.0.1",
        "get-stream": "^6.0.0",
        "it-first": "^1.0.4",
        proxyquire: "^2.1.3",
        react: "^16.14.0",
        "react-test-renderer": "^16.14.0",
        "replace-string": "^3.1.0",
        sinon: "^9.2.2",
        "source-map-fixtures": "^2.1.0",
        tap: "^14.11.0",
        "temp-write": "^4.0.0",
        tempy: "^1.0.0",
        touch: "^3.1.0",
        tsd: "^0.14.0",
        typescript: "^4.1.3",
        xo: "^0.36.1",
        "zen-observable": "^0.8.15"
      }
    };
  }
});

// node_modules/array-union/index.js
var require_array_union = __commonJS({
  "node_modules/array-union/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (...arguments_) => {
      return [...new Set([].concat(...arguments_))];
    };
  }
});

// node_modules/merge2/index.js
var require_merge2 = __commonJS({
  "node_modules/merge2/index.js"(exports2, module2) {
    "use strict";
    var Stream = require("stream");
    var PassThrough = Stream.PassThrough;
    var slice = Array.prototype.slice;
    module2.exports = merge2;
    function merge2() {
      const streamsQueue = [];
      const args = slice.call(arguments);
      let merging = false;
      let options = args[args.length - 1];
      if (options && !Array.isArray(options) && options.pipe == null) {
        args.pop();
      } else {
        options = {};
      }
      const doEnd = options.end !== false;
      const doPipeError = options.pipeError === true;
      if (options.objectMode == null) {
        options.objectMode = true;
      }
      if (options.highWaterMark == null) {
        options.highWaterMark = 64 * 1024;
      }
      const mergedStream = PassThrough(options);
      function addStream() {
        for (let i = 0, len = arguments.length; i < len; i++) {
          streamsQueue.push(pauseStreams(arguments[i], options));
        }
        mergeStream();
        return this;
      }
      function mergeStream() {
        if (merging) {
          return;
        }
        merging = true;
        let streams = streamsQueue.shift();
        if (!streams) {
          process.nextTick(endStream);
          return;
        }
        if (!Array.isArray(streams)) {
          streams = [streams];
        }
        let pipesCount = streams.length + 1;
        function next() {
          if (--pipesCount > 0) {
            return;
          }
          merging = false;
          mergeStream();
        }
        function pipe(stream) {
          function onend() {
            stream.removeListener("merge2UnpipeEnd", onend);
            stream.removeListener("end", onend);
            if (doPipeError) {
              stream.removeListener("error", onerror);
            }
            next();
          }
          function onerror(err) {
            mergedStream.emit("error", err);
          }
          if (stream._readableState.endEmitted) {
            return next();
          }
          stream.on("merge2UnpipeEnd", onend);
          stream.on("end", onend);
          if (doPipeError) {
            stream.on("error", onerror);
          }
          stream.pipe(mergedStream, { end: false });
          stream.resume();
        }
        for (let i = 0; i < streams.length; i++) {
          pipe(streams[i]);
        }
        next();
      }
      function endStream() {
        merging = false;
        mergedStream.emit("queueDrain");
        if (doEnd) {
          mergedStream.end();
        }
      }
      mergedStream.setMaxListeners(0);
      mergedStream.add = addStream;
      mergedStream.on("unpipe", function(stream) {
        stream.emit("merge2UnpipeEnd");
      });
      if (args.length) {
        addStream.apply(null, args);
      }
      return mergedStream;
    }
    function pauseStreams(streams, options) {
      if (!Array.isArray(streams)) {
        if (!streams._readableState && streams.pipe) {
          streams = streams.pipe(PassThrough(options));
        }
        if (!streams._readableState || !streams.pause || !streams.pipe) {
          throw new Error("Only readable stream can be merged.");
        }
        streams.pause();
      } else {
        for (let i = 0, len = streams.length; i < len; i++) {
          streams[i] = pauseStreams(streams[i], options);
        }
      }
      return streams;
    }
  }
});

// node_modules/fast-glob/out/utils/array.js
var require_array = __commonJS({
  "node_modules/fast-glob/out/utils/array.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.splitWhen = exports2.flatten = void 0;
    function flatten(items) {
      return items.reduce((collection, item) => [].concat(collection, item), []);
    }
    exports2.flatten = flatten;
    function splitWhen(items, predicate) {
      const result = [[]];
      let groupIndex = 0;
      for (const item of items) {
        if (predicate(item)) {
          groupIndex++;
          result[groupIndex] = [];
        } else {
          result[groupIndex].push(item);
        }
      }
      return result;
    }
    exports2.splitWhen = splitWhen;
  }
});

// node_modules/fast-glob/out/utils/errno.js
var require_errno = __commonJS({
  "node_modules/fast-glob/out/utils/errno.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isEnoentCodeError = void 0;
    function isEnoentCodeError(error) {
      return error.code === "ENOENT";
    }
    exports2.isEnoentCodeError = isEnoentCodeError;
  }
});

// node_modules/fast-glob/out/utils/fs.js
var require_fs = __commonJS({
  "node_modules/fast-glob/out/utils/fs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createDirentFromStats = void 0;
    var DirentFromStats = class {
      constructor(name, stats) {
        this.name = name;
        this.isBlockDevice = stats.isBlockDevice.bind(stats);
        this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
        this.isDirectory = stats.isDirectory.bind(stats);
        this.isFIFO = stats.isFIFO.bind(stats);
        this.isFile = stats.isFile.bind(stats);
        this.isSocket = stats.isSocket.bind(stats);
        this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
      }
    };
    function createDirentFromStats(name, stats) {
      return new DirentFromStats(name, stats);
    }
    exports2.createDirentFromStats = createDirentFromStats;
  }
});

// node_modules/fast-glob/out/utils/path.js
var require_path = __commonJS({
  "node_modules/fast-glob/out/utils/path.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.convertPosixPathToPattern = exports2.convertWindowsPathToPattern = exports2.convertPathToPattern = exports2.escapePosixPath = exports2.escapeWindowsPath = exports2.escape = exports2.removeLeadingDotSegment = exports2.makeAbsolute = exports2.unixify = void 0;
    var os = require("os");
    var path = require("path");
    var IS_WINDOWS_PLATFORM = os.platform() === "win32";
    var LEADING_DOT_SEGMENT_CHARACTERS_COUNT = 2;
    var POSIX_UNESCAPED_GLOB_SYMBOLS_RE = /(\\?)([()*?[\]{|}]|^!|[!+@](?=\()|\\(?![!()*+?@[\]{|}]))/g;
    var WINDOWS_UNESCAPED_GLOB_SYMBOLS_RE = /(\\?)([(){}]|^!|[!+@](?=\())/g;
    var DOS_DEVICE_PATH_RE = /^\\\\([.?])/;
    var WINDOWS_BACKSLASHES_RE = /\\(?![!()+@{}])/g;
    function unixify(filepath) {
      return filepath.replace(/\\/g, "/");
    }
    exports2.unixify = unixify;
    function makeAbsolute(cwd, filepath) {
      return path.resolve(cwd, filepath);
    }
    exports2.makeAbsolute = makeAbsolute;
    function removeLeadingDotSegment(entry) {
      if (entry.charAt(0) === ".") {
        const secondCharactery = entry.charAt(1);
        if (secondCharactery === "/" || secondCharactery === "\\") {
          return entry.slice(LEADING_DOT_SEGMENT_CHARACTERS_COUNT);
        }
      }
      return entry;
    }
    exports2.removeLeadingDotSegment = removeLeadingDotSegment;
    exports2.escape = IS_WINDOWS_PLATFORM ? escapeWindowsPath : escapePosixPath;
    function escapeWindowsPath(pattern) {
      return pattern.replace(WINDOWS_UNESCAPED_GLOB_SYMBOLS_RE, "\\$2");
    }
    exports2.escapeWindowsPath = escapeWindowsPath;
    function escapePosixPath(pattern) {
      return pattern.replace(POSIX_UNESCAPED_GLOB_SYMBOLS_RE, "\\$2");
    }
    exports2.escapePosixPath = escapePosixPath;
    exports2.convertPathToPattern = IS_WINDOWS_PLATFORM ? convertWindowsPathToPattern : convertPosixPathToPattern;
    function convertWindowsPathToPattern(filepath) {
      return escapeWindowsPath(filepath).replace(DOS_DEVICE_PATH_RE, "//$1").replace(WINDOWS_BACKSLASHES_RE, "/");
    }
    exports2.convertWindowsPathToPattern = convertWindowsPathToPattern;
    function convertPosixPathToPattern(filepath) {
      return escapePosixPath(filepath);
    }
    exports2.convertPosixPathToPattern = convertPosixPathToPattern;
  }
});

// node_modules/is-extglob/index.js
var require_is_extglob = __commonJS({
  "node_modules/is-extglob/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function isExtglob(str) {
      if (typeof str !== "string" || str === "") {
        return false;
      }
      var match;
      while (match = /(\\).|([@?!+*]\(.*\))/g.exec(str)) {
        if (match[2]) return true;
        str = str.slice(match.index + match[0].length);
      }
      return false;
    };
  }
});

// node_modules/is-glob/index.js
var require_is_glob = __commonJS({
  "node_modules/is-glob/index.js"(exports2, module2) {
    "use strict";
    var isExtglob = require_is_extglob();
    var chars = { "{": "}", "(": ")", "[": "]" };
    var strictCheck = function(str) {
      if (str[0] === "!") {
        return true;
      }
      var index = 0;
      var pipeIndex = -2;
      var closeSquareIndex = -2;
      var closeCurlyIndex = -2;
      var closeParenIndex = -2;
      var backSlashIndex = -2;
      while (index < str.length) {
        if (str[index] === "*") {
          return true;
        }
        if (str[index + 1] === "?" && /[\].+)]/.test(str[index])) {
          return true;
        }
        if (closeSquareIndex !== -1 && str[index] === "[" && str[index + 1] !== "]") {
          if (closeSquareIndex < index) {
            closeSquareIndex = str.indexOf("]", index);
          }
          if (closeSquareIndex > index) {
            if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
              return true;
            }
            backSlashIndex = str.indexOf("\\", index);
            if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
              return true;
            }
          }
        }
        if (closeCurlyIndex !== -1 && str[index] === "{" && str[index + 1] !== "}") {
          closeCurlyIndex = str.indexOf("}", index);
          if (closeCurlyIndex > index) {
            backSlashIndex = str.indexOf("\\", index);
            if (backSlashIndex === -1 || backSlashIndex > closeCurlyIndex) {
              return true;
            }
          }
        }
        if (closeParenIndex !== -1 && str[index] === "(" && str[index + 1] === "?" && /[:!=]/.test(str[index + 2]) && str[index + 3] !== ")") {
          closeParenIndex = str.indexOf(")", index);
          if (closeParenIndex > index) {
            backSlashIndex = str.indexOf("\\", index);
            if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
              return true;
            }
          }
        }
        if (pipeIndex !== -1 && str[index] === "(" && str[index + 1] !== "|") {
          if (pipeIndex < index) {
            pipeIndex = str.indexOf("|", index);
          }
          if (pipeIndex !== -1 && str[pipeIndex + 1] !== ")") {
            closeParenIndex = str.indexOf(")", pipeIndex);
            if (closeParenIndex > pipeIndex) {
              backSlashIndex = str.indexOf("\\", pipeIndex);
              if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
                return true;
              }
            }
          }
        }
        if (str[index] === "\\") {
          var open = str[index + 1];
          index += 2;
          var close = chars[open];
          if (close) {
            var n = str.indexOf(close, index);
            if (n !== -1) {
              index = n + 1;
            }
          }
          if (str[index] === "!") {
            return true;
          }
        } else {
          index++;
        }
      }
      return false;
    };
    var relaxedCheck = function(str) {
      if (str[0] === "!") {
        return true;
      }
      var index = 0;
      while (index < str.length) {
        if (/[*?{}()[\]]/.test(str[index])) {
          return true;
        }
        if (str[index] === "\\") {
          var open = str[index + 1];
          index += 2;
          var close = chars[open];
          if (close) {
            var n = str.indexOf(close, index);
            if (n !== -1) {
              index = n + 1;
            }
          }
          if (str[index] === "!") {
            return true;
          }
        } else {
          index++;
        }
      }
      return false;
    };
    module2.exports = function isGlob(str, options) {
      if (typeof str !== "string" || str === "") {
        return false;
      }
      if (isExtglob(str)) {
        return true;
      }
      var check = strictCheck;
      if (options && options.strict === false) {
        check = relaxedCheck;
      }
      return check(str);
    };
  }
});

// node_modules/glob-parent/index.js
var require_glob_parent = __commonJS({
  "node_modules/glob-parent/index.js"(exports2, module2) {
    "use strict";
    var isGlob = require_is_glob();
    var pathPosixDirname = require("path").posix.dirname;
    var isWin32 = require("os").platform() === "win32";
    var slash = "/";
    var backslash = /\\/g;
    var enclosure = /[\{\[].*[\}\]]$/;
    var globby = /(^|[^\\])([\{\[]|\([^\)]+$)/;
    var escaped = /\\([\!\*\?\|\[\]\(\)\{\}])/g;
    module2.exports = function globParent(str, opts) {
      var options = Object.assign({ flipBackslashes: true }, opts);
      if (options.flipBackslashes && isWin32 && str.indexOf(slash) < 0) {
        str = str.replace(backslash, slash);
      }
      if (enclosure.test(str)) {
        str += slash;
      }
      str += "a";
      do {
        str = pathPosixDirname(str);
      } while (isGlob(str) || globby.test(str));
      return str.replace(escaped, "$1");
    };
  }
});

// node_modules/braces/lib/utils.js
var require_utils = __commonJS({
  "node_modules/braces/lib/utils.js"(exports2) {
    "use strict";
    exports2.isInteger = (num) => {
      if (typeof num === "number") {
        return Number.isInteger(num);
      }
      if (typeof num === "string" && num.trim() !== "") {
        return Number.isInteger(Number(num));
      }
      return false;
    };
    exports2.find = (node, type) => node.nodes.find((node2) => node2.type === type);
    exports2.exceedsLimit = (min, max, step = 1, limit) => {
      if (limit === false) return false;
      if (!exports2.isInteger(min) || !exports2.isInteger(max)) return false;
      return (Number(max) - Number(min)) / Number(step) >= limit;
    };
    exports2.escapeNode = (block, n = 0, type) => {
      let node = block.nodes[n];
      if (!node) return;
      if (type && node.type === type || node.type === "open" || node.type === "close") {
        if (node.escaped !== true) {
          node.value = "\\" + node.value;
          node.escaped = true;
        }
      }
    };
    exports2.encloseBrace = (node) => {
      if (node.type !== "brace") return false;
      if (node.commas >> 0 + node.ranges >> 0 === 0) {
        node.invalid = true;
        return true;
      }
      return false;
    };
    exports2.isInvalidBrace = (block) => {
      if (block.type !== "brace") return false;
      if (block.invalid === true || block.dollar) return true;
      if (block.commas >> 0 + block.ranges >> 0 === 0) {
        block.invalid = true;
        return true;
      }
      if (block.open !== true || block.close !== true) {
        block.invalid = true;
        return true;
      }
      return false;
    };
    exports2.isOpenOrClose = (node) => {
      if (node.type === "open" || node.type === "close") {
        return true;
      }
      return node.open === true || node.close === true;
    };
    exports2.reduce = (nodes) => nodes.reduce((acc, node) => {
      if (node.type === "text") acc.push(node.value);
      if (node.type === "range") node.type = "text";
      return acc;
    }, []);
    exports2.flatten = (...args) => {
      const result = [];
      const flat = (arr) => {
        for (let i = 0; i < arr.length; i++) {
          let ele = arr[i];
          Array.isArray(ele) ? flat(ele, result) : ele !== void 0 && result.push(ele);
        }
        return result;
      };
      flat(args);
      return result;
    };
  }
});

// node_modules/braces/lib/stringify.js
var require_stringify = __commonJS({
  "node_modules/braces/lib/stringify.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    module2.exports = (ast, options = {}) => {
      let stringify = (node, parent = {}) => {
        let invalidBlock = options.escapeInvalid && utils.isInvalidBrace(parent);
        let invalidNode = node.invalid === true && options.escapeInvalid === true;
        let output = "";
        if (node.value) {
          if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {
            return "\\" + node.value;
          }
          return node.value;
        }
        if (node.value) {
          return node.value;
        }
        if (node.nodes) {
          for (let child of node.nodes) {
            output += stringify(child);
          }
        }
        return output;
      };
      return stringify(ast);
    };
  }
});

// node_modules/is-number/index.js
var require_is_number = __commonJS({
  "node_modules/is-number/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function(num) {
      if (typeof num === "number") {
        return num - num === 0;
      }
      if (typeof num === "string" && num.trim() !== "") {
        return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
      }
      return false;
    };
  }
});

// node_modules/to-regex-range/index.js
var require_to_regex_range = __commonJS({
  "node_modules/to-regex-range/index.js"(exports2, module2) {
    "use strict";
    var isNumber = require_is_number();
    var toRegexRange = (min, max, options) => {
      if (isNumber(min) === false) {
        throw new TypeError("toRegexRange: expected the first argument to be a number");
      }
      if (max === void 0 || min === max) {
        return String(min);
      }
      if (isNumber(max) === false) {
        throw new TypeError("toRegexRange: expected the second argument to be a number.");
      }
      let opts = { relaxZeros: true, ...options };
      if (typeof opts.strictZeros === "boolean") {
        opts.relaxZeros = opts.strictZeros === false;
      }
      let relax = String(opts.relaxZeros);
      let shorthand = String(opts.shorthand);
      let capture = String(opts.capture);
      let wrap = String(opts.wrap);
      let cacheKey = min + ":" + max + "=" + relax + shorthand + capture + wrap;
      if (toRegexRange.cache.hasOwnProperty(cacheKey)) {
        return toRegexRange.cache[cacheKey].result;
      }
      let a = Math.min(min, max);
      let b = Math.max(min, max);
      if (Math.abs(a - b) === 1) {
        let result = min + "|" + max;
        if (opts.capture) {
          return `(${result})`;
        }
        if (opts.wrap === false) {
          return result;
        }
        return `(?:${result})`;
      }
      let isPadded = hasPadding(min) || hasPadding(max);
      let state = { min, max, a, b };
      let positives = [];
      let negatives = [];
      if (isPadded) {
        state.isPadded = isPadded;
        state.maxLen = String(state.max).length;
      }
      if (a < 0) {
        let newMin = b < 0 ? Math.abs(b) : 1;
        negatives = splitToPatterns(newMin, Math.abs(a), state, opts);
        a = state.a = 0;
      }
      if (b >= 0) {
        positives = splitToPatterns(a, b, state, opts);
      }
      state.negatives = negatives;
      state.positives = positives;
      state.result = collatePatterns(negatives, positives, opts);
      if (opts.capture === true) {
        state.result = `(${state.result})`;
      } else if (opts.wrap !== false && positives.length + negatives.length > 1) {
        state.result = `(?:${state.result})`;
      }
      toRegexRange.cache[cacheKey] = state;
      return state.result;
    };
    function collatePatterns(neg, pos, options) {
      let onlyNegative = filterPatterns(neg, pos, "-", false, options) || [];
      let onlyPositive = filterPatterns(pos, neg, "", false, options) || [];
      let intersected = filterPatterns(neg, pos, "-?", true, options) || [];
      let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
      return subpatterns.join("|");
    }
    function splitToRanges(min, max) {
      let nines = 1;
      let zeros = 1;
      let stop = countNines(min, nines);
      let stops = /* @__PURE__ */ new Set([max]);
      while (min <= stop && stop <= max) {
        stops.add(stop);
        nines += 1;
        stop = countNines(min, nines);
      }
      stop = countZeros(max + 1, zeros) - 1;
      while (min < stop && stop <= max) {
        stops.add(stop);
        zeros += 1;
        stop = countZeros(max + 1, zeros) - 1;
      }
      stops = [...stops];
      stops.sort(compare);
      return stops;
    }
    function rangeToPattern(start, stop, options) {
      if (start === stop) {
        return { pattern: start, count: [], digits: 0 };
      }
      let zipped = zip(start, stop);
      let digits = zipped.length;
      let pattern = "";
      let count = 0;
      for (let i = 0; i < digits; i++) {
        let [startDigit, stopDigit] = zipped[i];
        if (startDigit === stopDigit) {
          pattern += startDigit;
        } else if (startDigit !== "0" || stopDigit !== "9") {
          pattern += toCharacterClass(startDigit, stopDigit, options);
        } else {
          count++;
        }
      }
      if (count) {
        pattern += options.shorthand === true ? "\\d" : "[0-9]";
      }
      return { pattern, count: [count], digits };
    }
    function splitToPatterns(min, max, tok, options) {
      let ranges = splitToRanges(min, max);
      let tokens = [];
      let start = min;
      let prev;
      for (let i = 0; i < ranges.length; i++) {
        let max2 = ranges[i];
        let obj = rangeToPattern(String(start), String(max2), options);
        let zeros = "";
        if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
          if (prev.count.length > 1) {
            prev.count.pop();
          }
          prev.count.push(obj.count[0]);
          prev.string = prev.pattern + toQuantifier(prev.count);
          start = max2 + 1;
          continue;
        }
        if (tok.isPadded) {
          zeros = padZeros(max2, tok, options);
        }
        obj.string = zeros + obj.pattern + toQuantifier(obj.count);
        tokens.push(obj);
        start = max2 + 1;
        prev = obj;
      }
      return tokens;
    }
    function filterPatterns(arr, comparison, prefix, intersection, options) {
      let result = [];
      for (let ele of arr) {
        let { string } = ele;
        if (!intersection && !contains(comparison, "string", string)) {
          result.push(prefix + string);
        }
        if (intersection && contains(comparison, "string", string)) {
          result.push(prefix + string);
        }
      }
      return result;
    }
    function zip(a, b) {
      let arr = [];
      for (let i = 0; i < a.length; i++) arr.push([a[i], b[i]]);
      return arr;
    }
    function compare(a, b) {
      return a > b ? 1 : b > a ? -1 : 0;
    }
    function contains(arr, key, val) {
      return arr.some((ele) => ele[key] === val);
    }
    function countNines(min, len) {
      return Number(String(min).slice(0, -len) + "9".repeat(len));
    }
    function countZeros(integer, zeros) {
      return integer - integer % Math.pow(10, zeros);
    }
    function toQuantifier(digits) {
      let [start = 0, stop = ""] = digits;
      if (stop || start > 1) {
        return `{${start + (stop ? "," + stop : "")}}`;
      }
      return "";
    }
    function toCharacterClass(a, b, options) {
      return `[${a}${b - a === 1 ? "" : "-"}${b}]`;
    }
    function hasPadding(str) {
      return /^-?(0+)\d/.test(str);
    }
    function padZeros(value2, tok, options) {
      if (!tok.isPadded) {
        return value2;
      }
      let diff = Math.abs(tok.maxLen - String(value2).length);
      let relax = options.relaxZeros !== false;
      switch (diff) {
        case 0:
          return "";
        case 1:
          return relax ? "0?" : "0";
        case 2:
          return relax ? "0{0,2}" : "00";
        default: {
          return relax ? `0{0,${diff}}` : `0{${diff}}`;
        }
      }
    }
    toRegexRange.cache = {};
    toRegexRange.clearCache = () => toRegexRange.cache = {};
    module2.exports = toRegexRange;
  }
});

// node_modules/fill-range/index.js
var require_fill_range = __commonJS({
  "node_modules/fill-range/index.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var toRegexRange = require_to_regex_range();
    var isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    var transform = (toNumber) => {
      return (value2) => toNumber === true ? Number(value2) : String(value2);
    };
    var isValidValue = (value2) => {
      return typeof value2 === "number" || typeof value2 === "string" && value2 !== "";
    };
    var isNumber = (num) => Number.isInteger(+num);
    var zeros = (input) => {
      let value2 = `${input}`;
      let index = -1;
      if (value2[0] === "-") value2 = value2.slice(1);
      if (value2 === "0") return false;
      while (value2[++index] === "0") ;
      return index > 0;
    };
    var stringify = (start, end, options) => {
      if (typeof start === "string" || typeof end === "string") {
        return true;
      }
      return options.stringify === true;
    };
    var pad = (input, maxLength, toNumber) => {
      if (maxLength > 0) {
        let dash = input[0] === "-" ? "-" : "";
        if (dash) input = input.slice(1);
        input = dash + input.padStart(dash ? maxLength - 1 : maxLength, "0");
      }
      if (toNumber === false) {
        return String(input);
      }
      return input;
    };
    var toMaxLen = (input, maxLength) => {
      let negative = input[0] === "-" ? "-" : "";
      if (negative) {
        input = input.slice(1);
        maxLength--;
      }
      while (input.length < maxLength) input = "0" + input;
      return negative ? "-" + input : input;
    };
    var toSequence = (parts, options) => {
      parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
      parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
      let prefix = options.capture ? "" : "?:";
      let positives = "";
      let negatives = "";
      let result;
      if (parts.positives.length) {
        positives = parts.positives.join("|");
      }
      if (parts.negatives.length) {
        negatives = `-(${prefix}${parts.negatives.join("|")})`;
      }
      if (positives && negatives) {
        result = `${positives}|${negatives}`;
      } else {
        result = positives || negatives;
      }
      if (options.wrap) {
        return `(${prefix}${result})`;
      }
      return result;
    };
    var toRange = (a, b, isNumbers, options) => {
      if (isNumbers) {
        return toRegexRange(a, b, { wrap: false, ...options });
      }
      let start = String.fromCharCode(a);
      if (a === b) return start;
      let stop = String.fromCharCode(b);
      return `[${start}-${stop}]`;
    };
    var toRegex = (start, end, options) => {
      if (Array.isArray(start)) {
        let wrap = options.wrap === true;
        let prefix = options.capture ? "" : "?:";
        return wrap ? `(${prefix}${start.join("|")})` : start.join("|");
      }
      return toRegexRange(start, end, options);
    };
    var rangeError = (...args) => {
      return new RangeError("Invalid range arguments: " + util.inspect(...args));
    };
    var invalidRange = (start, end, options) => {
      if (options.strictRanges === true) throw rangeError([start, end]);
      return [];
    };
    var invalidStep = (step, options) => {
      if (options.strictRanges === true) {
        throw new TypeError(`Expected step "${step}" to be a number`);
      }
      return [];
    };
    var fillNumbers = (start, end, step = 1, options = {}) => {
      let a = Number(start);
      let b = Number(end);
      if (!Number.isInteger(a) || !Number.isInteger(b)) {
        if (options.strictRanges === true) throw rangeError([start, end]);
        return [];
      }
      if (a === 0) a = 0;
      if (b === 0) b = 0;
      let descending = a > b;
      let startString = String(start);
      let endString = String(end);
      let stepString = String(step);
      step = Math.max(Math.abs(step), 1);
      let padded = zeros(startString) || zeros(endString) || zeros(stepString);
      let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
      let toNumber = padded === false && stringify(start, end, options) === false;
      let format = options.transform || transform(toNumber);
      if (options.toRegex && step === 1) {
        return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);
      }
      let parts = { negatives: [], positives: [] };
      let push = (num) => parts[num < 0 ? "negatives" : "positives"].push(Math.abs(num));
      let range = [];
      let index = 0;
      while (descending ? a >= b : a <= b) {
        if (options.toRegex === true && step > 1) {
          push(a);
        } else {
          range.push(pad(format(a, index), maxLen, toNumber));
        }
        a = descending ? a - step : a + step;
        index++;
      }
      if (options.toRegex === true) {
        return step > 1 ? toSequence(parts, options) : toRegex(range, null, { wrap: false, ...options });
      }
      return range;
    };
    var fillLetters = (start, end, step = 1, options = {}) => {
      if (!isNumber(start) && start.length > 1 || !isNumber(end) && end.length > 1) {
        return invalidRange(start, end, options);
      }
      let format = options.transform || ((val) => String.fromCharCode(val));
      let a = `${start}`.charCodeAt(0);
      let b = `${end}`.charCodeAt(0);
      let descending = a > b;
      let min = Math.min(a, b);
      let max = Math.max(a, b);
      if (options.toRegex && step === 1) {
        return toRange(min, max, false, options);
      }
      let range = [];
      let index = 0;
      while (descending ? a >= b : a <= b) {
        range.push(format(a, index));
        a = descending ? a - step : a + step;
        index++;
      }
      if (options.toRegex === true) {
        return toRegex(range, null, { wrap: false, options });
      }
      return range;
    };
    var fill = (start, end, step, options = {}) => {
      if (end == null && isValidValue(start)) {
        return [start];
      }
      if (!isValidValue(start) || !isValidValue(end)) {
        return invalidRange(start, end, options);
      }
      if (typeof step === "function") {
        return fill(start, end, 1, { transform: step });
      }
      if (isObject(step)) {
        return fill(start, end, 0, step);
      }
      let opts = { ...options };
      if (opts.capture === true) opts.wrap = true;
      step = step || opts.step || 1;
      if (!isNumber(step)) {
        if (step != null && !isObject(step)) return invalidStep(step, opts);
        return fill(start, end, 1, step);
      }
      if (isNumber(start) && isNumber(end)) {
        return fillNumbers(start, end, step, opts);
      }
      return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);
    };
    module2.exports = fill;
  }
});

// node_modules/braces/lib/compile.js
var require_compile = __commonJS({
  "node_modules/braces/lib/compile.js"(exports2, module2) {
    "use strict";
    var fill = require_fill_range();
    var utils = require_utils();
    var compile = (ast, options = {}) => {
      let walk = (node, parent = {}) => {
        let invalidBlock = utils.isInvalidBrace(parent);
        let invalidNode = node.invalid === true && options.escapeInvalid === true;
        let invalid = invalidBlock === true || invalidNode === true;
        let prefix = options.escapeInvalid === true ? "\\" : "";
        let output = "";
        if (node.isOpen === true) {
          return prefix + node.value;
        }
        if (node.isClose === true) {
          return prefix + node.value;
        }
        if (node.type === "open") {
          return invalid ? prefix + node.value : "(";
        }
        if (node.type === "close") {
          return invalid ? prefix + node.value : ")";
        }
        if (node.type === "comma") {
          return node.prev.type === "comma" ? "" : invalid ? node.value : "|";
        }
        if (node.value) {
          return node.value;
        }
        if (node.nodes && node.ranges > 0) {
          let args = utils.reduce(node.nodes);
          let range = fill(...args, { ...options, wrap: false, toRegex: true });
          if (range.length !== 0) {
            return args.length > 1 && range.length > 1 ? `(${range})` : range;
          }
        }
        if (node.nodes) {
          for (let child of node.nodes) {
            output += walk(child, node);
          }
        }
        return output;
      };
      return walk(ast);
    };
    module2.exports = compile;
  }
});

// node_modules/braces/lib/expand.js
var require_expand = __commonJS({
  "node_modules/braces/lib/expand.js"(exports2, module2) {
    "use strict";
    var fill = require_fill_range();
    var stringify = require_stringify();
    var utils = require_utils();
    var append = (queue = "", stash = "", enclose = false) => {
      let result = [];
      queue = [].concat(queue);
      stash = [].concat(stash);
      if (!stash.length) return queue;
      if (!queue.length) {
        return enclose ? utils.flatten(stash).map((ele) => `{${ele}}`) : stash;
      }
      for (let item of queue) {
        if (Array.isArray(item)) {
          for (let value2 of item) {
            result.push(append(value2, stash, enclose));
          }
        } else {
          for (let ele of stash) {
            if (enclose === true && typeof ele === "string") ele = `{${ele}}`;
            result.push(Array.isArray(ele) ? append(item, ele, enclose) : item + ele);
          }
        }
      }
      return utils.flatten(result);
    };
    var expand = (ast, options = {}) => {
      let rangeLimit = options.rangeLimit === void 0 ? 1e3 : options.rangeLimit;
      let walk = (node, parent = {}) => {
        node.queue = [];
        let p = parent;
        let q = parent.queue;
        while (p.type !== "brace" && p.type !== "root" && p.parent) {
          p = p.parent;
          q = p.queue;
        }
        if (node.invalid || node.dollar) {
          q.push(append(q.pop(), stringify(node, options)));
          return;
        }
        if (node.type === "brace" && node.invalid !== true && node.nodes.length === 2) {
          q.push(append(q.pop(), ["{}"]));
          return;
        }
        if (node.nodes && node.ranges > 0) {
          let args = utils.reduce(node.nodes);
          if (utils.exceedsLimit(...args, options.step, rangeLimit)) {
            throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.");
          }
          let range = fill(...args, options);
          if (range.length === 0) {
            range = stringify(node, options);
          }
          q.push(append(q.pop(), range));
          node.nodes = [];
          return;
        }
        let enclose = utils.encloseBrace(node);
        let queue = node.queue;
        let block = node;
        while (block.type !== "brace" && block.type !== "root" && block.parent) {
          block = block.parent;
          queue = block.queue;
        }
        for (let i = 0; i < node.nodes.length; i++) {
          let child = node.nodes[i];
          if (child.type === "comma" && node.type === "brace") {
            if (i === 1) queue.push("");
            queue.push("");
            continue;
          }
          if (child.type === "close") {
            q.push(append(q.pop(), queue, enclose));
            continue;
          }
          if (child.value && child.type !== "open") {
            queue.push(append(queue.pop(), child.value));
            continue;
          }
          if (child.nodes) {
            walk(child, node);
          }
        }
        return queue;
      };
      return utils.flatten(walk(ast));
    };
    module2.exports = expand;
  }
});

// node_modules/braces/lib/constants.js
var require_constants = __commonJS({
  "node_modules/braces/lib/constants.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      MAX_LENGTH: 1024 * 64,
      // Digits
      CHAR_0: "0",
      /* 0 */
      CHAR_9: "9",
      /* 9 */
      // Alphabet chars.
      CHAR_UPPERCASE_A: "A",
      /* A */
      CHAR_LOWERCASE_A: "a",
      /* a */
      CHAR_UPPERCASE_Z: "Z",
      /* Z */
      CHAR_LOWERCASE_Z: "z",
      /* z */
      CHAR_LEFT_PARENTHESES: "(",
      /* ( */
      CHAR_RIGHT_PARENTHESES: ")",
      /* ) */
      CHAR_ASTERISK: "*",
      /* * */
      // Non-alphabetic chars.
      CHAR_AMPERSAND: "&",
      /* & */
      CHAR_AT: "@",
      /* @ */
      CHAR_BACKSLASH: "\\",
      /* \ */
      CHAR_BACKTICK: "`",
      /* ` */
      CHAR_CARRIAGE_RETURN: "\r",
      /* \r */
      CHAR_CIRCUMFLEX_ACCENT: "^",
      /* ^ */
      CHAR_COLON: ":",
      /* : */
      CHAR_COMMA: ",",
      /* , */
      CHAR_DOLLAR: "$",
      /* . */
      CHAR_DOT: ".",
      /* . */
      CHAR_DOUBLE_QUOTE: '"',
      /* " */
      CHAR_EQUAL: "=",
      /* = */
      CHAR_EXCLAMATION_MARK: "!",
      /* ! */
      CHAR_FORM_FEED: "\f",
      /* \f */
      CHAR_FORWARD_SLASH: "/",
      /* / */
      CHAR_HASH: "#",
      /* # */
      CHAR_HYPHEN_MINUS: "-",
      /* - */
      CHAR_LEFT_ANGLE_BRACKET: "<",
      /* < */
      CHAR_LEFT_CURLY_BRACE: "{",
      /* { */
      CHAR_LEFT_SQUARE_BRACKET: "[",
      /* [ */
      CHAR_LINE_FEED: "\n",
      /* \n */
      CHAR_NO_BREAK_SPACE: "\xA0",
      /* \u00A0 */
      CHAR_PERCENT: "%",
      /* % */
      CHAR_PLUS: "+",
      /* + */
      CHAR_QUESTION_MARK: "?",
      /* ? */
      CHAR_RIGHT_ANGLE_BRACKET: ">",
      /* > */
      CHAR_RIGHT_CURLY_BRACE: "}",
      /* } */
      CHAR_RIGHT_SQUARE_BRACKET: "]",
      /* ] */
      CHAR_SEMICOLON: ";",
      /* ; */
      CHAR_SINGLE_QUOTE: "'",
      /* ' */
      CHAR_SPACE: " ",
      /*   */
      CHAR_TAB: "	",
      /* \t */
      CHAR_UNDERSCORE: "_",
      /* _ */
      CHAR_VERTICAL_LINE: "|",
      /* | */
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: "\uFEFF"
      /* \uFEFF */
    };
  }
});

// node_modules/braces/lib/parse.js
var require_parse = __commonJS({
  "node_modules/braces/lib/parse.js"(exports2, module2) {
    "use strict";
    var stringify = require_stringify();
    var {
      MAX_LENGTH,
      CHAR_BACKSLASH,
      /* \ */
      CHAR_BACKTICK,
      /* ` */
      CHAR_COMMA,
      /* , */
      CHAR_DOT,
      /* . */
      CHAR_LEFT_PARENTHESES,
      /* ( */
      CHAR_RIGHT_PARENTHESES,
      /* ) */
      CHAR_LEFT_CURLY_BRACE,
      /* { */
      CHAR_RIGHT_CURLY_BRACE,
      /* } */
      CHAR_LEFT_SQUARE_BRACKET,
      /* [ */
      CHAR_RIGHT_SQUARE_BRACKET,
      /* ] */
      CHAR_DOUBLE_QUOTE,
      /* " */
      CHAR_SINGLE_QUOTE,
      /* ' */
      CHAR_NO_BREAK_SPACE,
      CHAR_ZERO_WIDTH_NOBREAK_SPACE
    } = require_constants();
    var parse = (input, options = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      let opts = options || {};
      let max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      if (input.length > max) {
        throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);
      }
      let ast = { type: "root", input, nodes: [] };
      let stack = [ast];
      let block = ast;
      let prev = ast;
      let brackets = 0;
      let length = input.length;
      let index = 0;
      let depth = 0;
      let value2;
      let memo = {};
      const advance = () => input[index++];
      const push = (node) => {
        if (node.type === "text" && prev.type === "dot") {
          prev.type = "text";
        }
        if (prev && prev.type === "text" && node.type === "text") {
          prev.value += node.value;
          return;
        }
        block.nodes.push(node);
        node.parent = block;
        node.prev = prev;
        prev = node;
        return node;
      };
      push({ type: "bos" });
      while (index < length) {
        block = stack[stack.length - 1];
        value2 = advance();
        if (value2 === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value2 === CHAR_NO_BREAK_SPACE) {
          continue;
        }
        if (value2 === CHAR_BACKSLASH) {
          push({ type: "text", value: (options.keepEscaping ? value2 : "") + advance() });
          continue;
        }
        if (value2 === CHAR_RIGHT_SQUARE_BRACKET) {
          push({ type: "text", value: "\\" + value2 });
          continue;
        }
        if (value2 === CHAR_LEFT_SQUARE_BRACKET) {
          brackets++;
          let closed = true;
          let next;
          while (index < length && (next = advance())) {
            value2 += next;
            if (next === CHAR_LEFT_SQUARE_BRACKET) {
              brackets++;
              continue;
            }
            if (next === CHAR_BACKSLASH) {
              value2 += advance();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET) {
              brackets--;
              if (brackets === 0) {
                break;
              }
            }
          }
          push({ type: "text", value: value2 });
          continue;
        }
        if (value2 === CHAR_LEFT_PARENTHESES) {
          block = push({ type: "paren", nodes: [] });
          stack.push(block);
          push({ type: "text", value: value2 });
          continue;
        }
        if (value2 === CHAR_RIGHT_PARENTHESES) {
          if (block.type !== "paren") {
            push({ type: "text", value: value2 });
            continue;
          }
          block = stack.pop();
          push({ type: "text", value: value2 });
          block = stack[stack.length - 1];
          continue;
        }
        if (value2 === CHAR_DOUBLE_QUOTE || value2 === CHAR_SINGLE_QUOTE || value2 === CHAR_BACKTICK) {
          let open = value2;
          let next;
          if (options.keepQuotes !== true) {
            value2 = "";
          }
          while (index < length && (next = advance())) {
            if (next === CHAR_BACKSLASH) {
              value2 += next + advance();
              continue;
            }
            if (next === open) {
              if (options.keepQuotes === true) value2 += next;
              break;
            }
            value2 += next;
          }
          push({ type: "text", value: value2 });
          continue;
        }
        if (value2 === CHAR_LEFT_CURLY_BRACE) {
          depth++;
          let dollar = prev.value && prev.value.slice(-1) === "$" || block.dollar === true;
          let brace = {
            type: "brace",
            open: true,
            close: false,
            dollar,
            depth,
            commas: 0,
            ranges: 0,
            nodes: []
          };
          block = push(brace);
          stack.push(block);
          push({ type: "open", value: value2 });
          continue;
        }
        if (value2 === CHAR_RIGHT_CURLY_BRACE) {
          if (block.type !== "brace") {
            push({ type: "text", value: value2 });
            continue;
          }
          let type = "close";
          block = stack.pop();
          block.close = true;
          push({ type, value: value2 });
          depth--;
          block = stack[stack.length - 1];
          continue;
        }
        if (value2 === CHAR_COMMA && depth > 0) {
          if (block.ranges > 0) {
            block.ranges = 0;
            let open = block.nodes.shift();
            block.nodes = [open, { type: "text", value: stringify(block) }];
          }
          push({ type: "comma", value: value2 });
          block.commas++;
          continue;
        }
        if (value2 === CHAR_DOT && depth > 0 && block.commas === 0) {
          let siblings = block.nodes;
          if (depth === 0 || siblings.length === 0) {
            push({ type: "text", value: value2 });
            continue;
          }
          if (prev.type === "dot") {
            block.range = [];
            prev.value += value2;
            prev.type = "range";
            if (block.nodes.length !== 3 && block.nodes.length !== 5) {
              block.invalid = true;
              block.ranges = 0;
              prev.type = "text";
              continue;
            }
            block.ranges++;
            block.args = [];
            continue;
          }
          if (prev.type === "range") {
            siblings.pop();
            let before = siblings[siblings.length - 1];
            before.value += prev.value + value2;
            prev = before;
            block.ranges--;
            continue;
          }
          push({ type: "dot", value: value2 });
          continue;
        }
        push({ type: "text", value: value2 });
      }
      do {
        block = stack.pop();
        if (block.type !== "root") {
          block.nodes.forEach((node) => {
            if (!node.nodes) {
              if (node.type === "open") node.isOpen = true;
              if (node.type === "close") node.isClose = true;
              if (!node.nodes) node.type = "text";
              node.invalid = true;
            }
          });
          let parent = stack[stack.length - 1];
          let index2 = parent.nodes.indexOf(block);
          parent.nodes.splice(index2, 1, ...block.nodes);
        }
      } while (stack.length > 0);
      push({ type: "eos" });
      return ast;
    };
    module2.exports = parse;
  }
});

// node_modules/braces/index.js
var require_braces = __commonJS({
  "node_modules/braces/index.js"(exports2, module2) {
    "use strict";
    var stringify = require_stringify();
    var compile = require_compile();
    var expand = require_expand();
    var parse = require_parse();
    var braces = (input, options = {}) => {
      let output = [];
      if (Array.isArray(input)) {
        for (let pattern of input) {
          let result = braces.create(pattern, options);
          if (Array.isArray(result)) {
            output.push(...result);
          } else {
            output.push(result);
          }
        }
      } else {
        output = [].concat(braces.create(input, options));
      }
      if (options && options.expand === true && options.nodupes === true) {
        output = [...new Set(output)];
      }
      return output;
    };
    braces.parse = (input, options = {}) => parse(input, options);
    braces.stringify = (input, options = {}) => {
      if (typeof input === "string") {
        return stringify(braces.parse(input, options), options);
      }
      return stringify(input, options);
    };
    braces.compile = (input, options = {}) => {
      if (typeof input === "string") {
        input = braces.parse(input, options);
      }
      return compile(input, options);
    };
    braces.expand = (input, options = {}) => {
      if (typeof input === "string") {
        input = braces.parse(input, options);
      }
      let result = expand(input, options);
      if (options.noempty === true) {
        result = result.filter(Boolean);
      }
      if (options.nodupes === true) {
        result = [...new Set(result)];
      }
      return result;
    };
    braces.create = (input, options = {}) => {
      if (input === "" || input.length < 3) {
        return [input];
      }
      return options.expand !== true ? braces.compile(input, options) : braces.expand(input, options);
    };
    module2.exports = braces;
  }
});

// node_modules/picomatch/lib/constants.js
var require_constants2 = __commonJS({
  "node_modules/picomatch/lib/constants.js"(exports2, module2) {
    "use strict";
    var path = require("path");
    var WIN_SLASH = "\\\\/";
    var WIN_NO_SLASH = `[^${WIN_SLASH}]`;
    var DOT_LITERAL = "\\.";
    var PLUS_LITERAL = "\\+";
    var QMARK_LITERAL = "\\?";
    var SLASH_LITERAL = "\\/";
    var ONE_CHAR = "(?=.)";
    var QMARK = "[^/]";
    var END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
    var START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
    var DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
    var NO_DOT = `(?!${DOT_LITERAL})`;
    var NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
    var NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
    var NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
    var QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
    var STAR = `${QMARK}*?`;
    var POSIX_CHARS = {
      DOT_LITERAL,
      PLUS_LITERAL,
      QMARK_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      QMARK,
      END_ANCHOR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOTS,
      NO_DOT_SLASH,
      NO_DOTS_SLASH,
      QMARK_NO_DOT,
      STAR,
      START_ANCHOR
    };
    var WINDOWS_CHARS = {
      ...POSIX_CHARS,
      SLASH_LITERAL: `[${WIN_SLASH}]`,
      QMARK: WIN_NO_SLASH,
      STAR: `${WIN_NO_SLASH}*?`,
      DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
      NO_DOT: `(?!${DOT_LITERAL})`,
      NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
      NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
      START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
      END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
    };
    var POSIX_REGEX_SOURCE = {
      alnum: "a-zA-Z0-9",
      alpha: "a-zA-Z",
      ascii: "\\x00-\\x7F",
      blank: " \\t",
      cntrl: "\\x00-\\x1F\\x7F",
      digit: "0-9",
      graph: "\\x21-\\x7E",
      lower: "a-z",
      print: "\\x20-\\x7E ",
      punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
      space: " \\t\\r\\n\\v\\f",
      upper: "A-Z",
      word: "A-Za-z0-9_",
      xdigit: "A-Fa-f0-9"
    };
    module2.exports = {
      MAX_LENGTH: 1024 * 64,
      POSIX_REGEX_SOURCE,
      // regular expressions
      REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
      REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
      REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
      REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
      REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
      REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
      // Replace globs with equivalent patterns to reduce parsing time.
      REPLACEMENTS: {
        "***": "*",
        "**/**": "**",
        "**/**/**": "**"
      },
      // Digits
      CHAR_0: 48,
      /* 0 */
      CHAR_9: 57,
      /* 9 */
      // Alphabet chars.
      CHAR_UPPERCASE_A: 65,
      /* A */
      CHAR_LOWERCASE_A: 97,
      /* a */
      CHAR_UPPERCASE_Z: 90,
      /* Z */
      CHAR_LOWERCASE_Z: 122,
      /* z */
      CHAR_LEFT_PARENTHESES: 40,
      /* ( */
      CHAR_RIGHT_PARENTHESES: 41,
      /* ) */
      CHAR_ASTERISK: 42,
      /* * */
      // Non-alphabetic chars.
      CHAR_AMPERSAND: 38,
      /* & */
      CHAR_AT: 64,
      /* @ */
      CHAR_BACKWARD_SLASH: 92,
      /* \ */
      CHAR_CARRIAGE_RETURN: 13,
      /* \r */
      CHAR_CIRCUMFLEX_ACCENT: 94,
      /* ^ */
      CHAR_COLON: 58,
      /* : */
      CHAR_COMMA: 44,
      /* , */
      CHAR_DOT: 46,
      /* . */
      CHAR_DOUBLE_QUOTE: 34,
      /* " */
      CHAR_EQUAL: 61,
      /* = */
      CHAR_EXCLAMATION_MARK: 33,
      /* ! */
      CHAR_FORM_FEED: 12,
      /* \f */
      CHAR_FORWARD_SLASH: 47,
      /* / */
      CHAR_GRAVE_ACCENT: 96,
      /* ` */
      CHAR_HASH: 35,
      /* # */
      CHAR_HYPHEN_MINUS: 45,
      /* - */
      CHAR_LEFT_ANGLE_BRACKET: 60,
      /* < */
      CHAR_LEFT_CURLY_BRACE: 123,
      /* { */
      CHAR_LEFT_SQUARE_BRACKET: 91,
      /* [ */
      CHAR_LINE_FEED: 10,
      /* \n */
      CHAR_NO_BREAK_SPACE: 160,
      /* \u00A0 */
      CHAR_PERCENT: 37,
      /* % */
      CHAR_PLUS: 43,
      /* + */
      CHAR_QUESTION_MARK: 63,
      /* ? */
      CHAR_RIGHT_ANGLE_BRACKET: 62,
      /* > */
      CHAR_RIGHT_CURLY_BRACE: 125,
      /* } */
      CHAR_RIGHT_SQUARE_BRACKET: 93,
      /* ] */
      CHAR_SEMICOLON: 59,
      /* ; */
      CHAR_SINGLE_QUOTE: 39,
      /* ' */
      CHAR_SPACE: 32,
      /*   */
      CHAR_TAB: 9,
      /* \t */
      CHAR_UNDERSCORE: 95,
      /* _ */
      CHAR_VERTICAL_LINE: 124,
      /* | */
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
      /* \uFEFF */
      SEP: path.sep,
      /**
       * Create EXTGLOB_CHARS
       */
      extglobChars(chars) {
        return {
          "!": { type: "negate", open: "(?:(?!(?:", close: `))${chars.STAR})` },
          "?": { type: "qmark", open: "(?:", close: ")?" },
          "+": { type: "plus", open: "(?:", close: ")+" },
          "*": { type: "star", open: "(?:", close: ")*" },
          "@": { type: "at", open: "(?:", close: ")" }
        };
      },
      /**
       * Create GLOB_CHARS
       */
      globChars(win32) {
        return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;
      }
    };
  }
});

// node_modules/picomatch/lib/utils.js
var require_utils2 = __commonJS({
  "node_modules/picomatch/lib/utils.js"(exports2) {
    "use strict";
    var path = require("path");
    var win32 = process.platform === "win32";
    var {
      REGEX_BACKSLASH,
      REGEX_REMOVE_BACKSLASH,
      REGEX_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_GLOBAL
    } = require_constants2();
    exports2.isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    exports2.hasRegexChars = (str) => REGEX_SPECIAL_CHARS.test(str);
    exports2.isRegexChar = (str) => str.length === 1 && exports2.hasRegexChars(str);
    exports2.escapeRegex = (str) => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
    exports2.toPosixSlashes = (str) => str.replace(REGEX_BACKSLASH, "/");
    exports2.removeBackslashes = (str) => {
      return str.replace(REGEX_REMOVE_BACKSLASH, (match) => {
        return match === "\\" ? "" : match;
      });
    };
    exports2.supportsLookbehinds = () => {
      const segs = process.version.slice(1).split(".").map(Number);
      if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {
        return true;
      }
      return false;
    };
    exports2.isWindows = (options) => {
      if (options && typeof options.windows === "boolean") {
        return options.windows;
      }
      return win32 === true || path.sep === "\\";
    };
    exports2.escapeLast = (input, char, lastIdx) => {
      const idx = input.lastIndexOf(char, lastIdx);
      if (idx === -1) return input;
      if (input[idx - 1] === "\\") return exports2.escapeLast(input, char, idx - 1);
      return `${input.slice(0, idx)}\\${input.slice(idx)}`;
    };
    exports2.removePrefix = (input, state = {}) => {
      let output = input;
      if (output.startsWith("./")) {
        output = output.slice(2);
        state.prefix = "./";
      }
      return output;
    };
    exports2.wrapOutput = (input, state = {}, options = {}) => {
      const prepend = options.contains ? "" : "^";
      const append = options.contains ? "" : "$";
      let output = `${prepend}(?:${input})${append}`;
      if (state.negated === true) {
        output = `(?:^(?!${output}).*$)`;
      }
      return output;
    };
  }
});

// node_modules/picomatch/lib/scan.js
var require_scan = __commonJS({
  "node_modules/picomatch/lib/scan.js"(exports2, module2) {
    "use strict";
    var utils = require_utils2();
    var {
      CHAR_ASTERISK,
      /* * */
      CHAR_AT,
      /* @ */
      CHAR_BACKWARD_SLASH,
      /* \ */
      CHAR_COMMA,
      /* , */
      CHAR_DOT,
      /* . */
      CHAR_EXCLAMATION_MARK,
      /* ! */
      CHAR_FORWARD_SLASH,
      /* / */
      CHAR_LEFT_CURLY_BRACE,
      /* { */
      CHAR_LEFT_PARENTHESES,
      /* ( */
      CHAR_LEFT_SQUARE_BRACKET,
      /* [ */
      CHAR_PLUS,
      /* + */
      CHAR_QUESTION_MARK,
      /* ? */
      CHAR_RIGHT_CURLY_BRACE,
      /* } */
      CHAR_RIGHT_PARENTHESES,
      /* ) */
      CHAR_RIGHT_SQUARE_BRACKET
      /* ] */
    } = require_constants2();
    var isPathSeparator = (code) => {
      return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
    };
    var depth = (token) => {
      if (token.isPrefix !== true) {
        token.depth = token.isGlobstar ? Infinity : 1;
      }
    };
    var scan = (input, options) => {
      const opts = options || {};
      const length = input.length - 1;
      const scanToEnd = opts.parts === true || opts.scanToEnd === true;
      const slashes = [];
      const tokens = [];
      const parts = [];
      let str = input;
      let index = -1;
      let start = 0;
      let lastIndex = 0;
      let isBrace = false;
      let isBracket = false;
      let isGlob = false;
      let isExtglob = false;
      let isGlobstar = false;
      let braceEscaped = false;
      let backslashes = false;
      let negated = false;
      let negatedExtglob = false;
      let finished = false;
      let braces = 0;
      let prev;
      let code;
      let token = { value: "", depth: 0, isGlob: false };
      const eos = () => index >= length;
      const peek = () => str.charCodeAt(index + 1);
      const advance = () => {
        prev = code;
        return str.charCodeAt(++index);
      };
      while (index < length) {
        code = advance();
        let next;
        if (code === CHAR_BACKWARD_SLASH) {
          backslashes = token.backslashes = true;
          code = advance();
          if (code === CHAR_LEFT_CURLY_BRACE) {
            braceEscaped = true;
          }
          continue;
        }
        if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
          braces++;
          while (eos() !== true && (code = advance())) {
            if (code === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance();
              continue;
            }
            if (code === CHAR_LEFT_CURLY_BRACE) {
              braces++;
              continue;
            }
            if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
              isBrace = token.isBrace = true;
              isGlob = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (braceEscaped !== true && code === CHAR_COMMA) {
              isBrace = token.isBrace = true;
              isGlob = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (code === CHAR_RIGHT_CURLY_BRACE) {
              braces--;
              if (braces === 0) {
                braceEscaped = false;
                isBrace = token.isBrace = true;
                finished = true;
                break;
              }
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_FORWARD_SLASH) {
          slashes.push(index);
          tokens.push(token);
          token = { value: "", depth: 0, isGlob: false };
          if (finished === true) continue;
          if (prev === CHAR_DOT && index === start + 1) {
            start += 2;
            continue;
          }
          lastIndex = index + 1;
          continue;
        }
        if (opts.noext !== true) {
          const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;
          if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
            isGlob = token.isGlob = true;
            isExtglob = token.isExtglob = true;
            finished = true;
            if (code === CHAR_EXCLAMATION_MARK && index === start) {
              negatedExtglob = true;
            }
            if (scanToEnd === true) {
              while (eos() !== true && (code = advance())) {
                if (code === CHAR_BACKWARD_SLASH) {
                  backslashes = token.backslashes = true;
                  code = advance();
                  continue;
                }
                if (code === CHAR_RIGHT_PARENTHESES) {
                  isGlob = token.isGlob = true;
                  finished = true;
                  break;
                }
              }
              continue;
            }
            break;
          }
        }
        if (code === CHAR_ASTERISK) {
          if (prev === CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;
          isGlob = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_QUESTION_MARK) {
          isGlob = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_LEFT_SQUARE_BRACKET) {
          while (eos() !== true && (next = advance())) {
            if (next === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET) {
              isBracket = token.isBracket = true;
              isGlob = token.isGlob = true;
              finished = true;
              break;
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {
          negated = token.negated = true;
          start++;
          continue;
        }
        if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
          isGlob = token.isGlob = true;
          if (scanToEnd === true) {
            while (eos() !== true && (code = advance())) {
              if (code === CHAR_LEFT_PARENTHESES) {
                backslashes = token.backslashes = true;
                code = advance();
                continue;
              }
              if (code === CHAR_RIGHT_PARENTHESES) {
                finished = true;
                break;
              }
            }
            continue;
          }
          break;
        }
        if (isGlob === true) {
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
      }
      if (opts.noext === true) {
        isExtglob = false;
        isGlob = false;
      }
      let base = str;
      let prefix = "";
      let glob = "";
      if (start > 0) {
        prefix = str.slice(0, start);
        str = str.slice(start);
        lastIndex -= start;
      }
      if (base && isGlob === true && lastIndex > 0) {
        base = str.slice(0, lastIndex);
        glob = str.slice(lastIndex);
      } else if (isGlob === true) {
        base = "";
        glob = str;
      } else {
        base = str;
      }
      if (base && base !== "" && base !== "/" && base !== str) {
        if (isPathSeparator(base.charCodeAt(base.length - 1))) {
          base = base.slice(0, -1);
        }
      }
      if (opts.unescape === true) {
        if (glob) glob = utils.removeBackslashes(glob);
        if (base && backslashes === true) {
          base = utils.removeBackslashes(base);
        }
      }
      const state = {
        prefix,
        input,
        start,
        base,
        glob,
        isBrace,
        isBracket,
        isGlob,
        isExtglob,
        isGlobstar,
        negated,
        negatedExtglob
      };
      if (opts.tokens === true) {
        state.maxDepth = 0;
        if (!isPathSeparator(code)) {
          tokens.push(token);
        }
        state.tokens = tokens;
      }
      if (opts.parts === true || opts.tokens === true) {
        let prevIndex;
        for (let idx = 0; idx < slashes.length; idx++) {
          const n = prevIndex ? prevIndex + 1 : start;
          const i = slashes[idx];
          const value2 = input.slice(n, i);
          if (opts.tokens) {
            if (idx === 0 && start !== 0) {
              tokens[idx].isPrefix = true;
              tokens[idx].value = prefix;
            } else {
              tokens[idx].value = value2;
            }
            depth(tokens[idx]);
            state.maxDepth += tokens[idx].depth;
          }
          if (idx !== 0 || value2 !== "") {
            parts.push(value2);
          }
          prevIndex = i;
        }
        if (prevIndex && prevIndex + 1 < input.length) {
          const value2 = input.slice(prevIndex + 1);
          parts.push(value2);
          if (opts.tokens) {
            tokens[tokens.length - 1].value = value2;
            depth(tokens[tokens.length - 1]);
            state.maxDepth += tokens[tokens.length - 1].depth;
          }
        }
        state.slashes = slashes;
        state.parts = parts;
      }
      return state;
    };
    module2.exports = scan;
  }
});

// node_modules/picomatch/lib/parse.js
var require_parse2 = __commonJS({
  "node_modules/picomatch/lib/parse.js"(exports2, module2) {
    "use strict";
    var constants = require_constants2();
    var utils = require_utils2();
    var {
      MAX_LENGTH,
      POSIX_REGEX_SOURCE,
      REGEX_NON_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_BACKREF,
      REPLACEMENTS
    } = constants;
    var expandRange = (args, options) => {
      if (typeof options.expandRange === "function") {
        return options.expandRange(...args, options);
      }
      args.sort();
      const value2 = `[${args.join("-")}]`;
      try {
        new RegExp(value2);
      } catch (ex) {
        return args.map((v) => utils.escapeRegex(v)).join("..");
      }
      return value2;
    };
    var syntaxError = (type, char) => {
      return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
    };
    var parse = (input, options) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      input = REPLACEMENTS[input] || input;
      const opts = { ...options };
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      let len = input.length;
      if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      }
      const bos = { type: "bos", value: "", output: opts.prepend || "" };
      const tokens = [bos];
      const capture = opts.capture ? "" : "?:";
      const win32 = utils.isWindows(options);
      const PLATFORM_CHARS = constants.globChars(win32);
      const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);
      const {
        DOT_LITERAL,
        PLUS_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOT_SLASH,
        NO_DOTS_SLASH,
        QMARK,
        QMARK_NO_DOT,
        STAR,
        START_ANCHOR
      } = PLATFORM_CHARS;
      const globstar = (opts2) => {
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const nodot = opts.dot ? "" : NO_DOT;
      const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
      let star = opts.bash === true ? globstar(opts) : STAR;
      if (opts.capture) {
        star = `(${star})`;
      }
      if (typeof opts.noext === "boolean") {
        opts.noextglob = opts.noext;
      }
      const state = {
        input,
        index: -1,
        start: 0,
        dot: opts.dot === true,
        consumed: "",
        output: "",
        prefix: "",
        backtrack: false,
        negated: false,
        brackets: 0,
        braces: 0,
        parens: 0,
        quotes: 0,
        globstar: false,
        tokens
      };
      input = utils.removePrefix(input, state);
      len = input.length;
      const extglobs = [];
      const braces = [];
      const stack = [];
      let prev = bos;
      let value2;
      const eos = () => state.index === len - 1;
      const peek = state.peek = (n = 1) => input[state.index + n];
      const advance = state.advance = () => input[++state.index] || "";
      const remaining = () => input.slice(state.index + 1);
      const consume = (value3 = "", num = 0) => {
        state.consumed += value3;
        state.index += num;
      };
      const append = (token) => {
        state.output += token.output != null ? token.output : token.value;
        consume(token.value);
      };
      const negate = () => {
        let count = 1;
        while (peek() === "!" && (peek(2) !== "(" || peek(3) === "?")) {
          advance();
          state.start++;
          count++;
        }
        if (count % 2 === 0) {
          return false;
        }
        state.negated = true;
        state.start++;
        return true;
      };
      const increment = (type) => {
        state[type]++;
        stack.push(type);
      };
      const decrement = (type) => {
        state[type]--;
        stack.pop();
      };
      const push = (tok) => {
        if (prev.type === "globstar") {
          const isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace");
          const isExtglob = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
          if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob) {
            state.output = state.output.slice(0, -prev.output.length);
            prev.type = "star";
            prev.value = "*";
            prev.output = star;
            state.output += prev.output;
          }
        }
        if (extglobs.length && tok.type !== "paren") {
          extglobs[extglobs.length - 1].inner += tok.value;
        }
        if (tok.value || tok.output) append(tok);
        if (prev && prev.type === "text" && tok.type === "text") {
          prev.value += tok.value;
          prev.output = (prev.output || "") + tok.value;
          return;
        }
        tok.prev = prev;
        tokens.push(tok);
        prev = tok;
      };
      const extglobOpen = (type, value3) => {
        const token = { ...EXTGLOB_CHARS[value3], conditions: 1, inner: "" };
        token.prev = prev;
        token.parens = state.parens;
        token.output = state.output;
        const output = (opts.capture ? "(" : "") + token.open;
        increment("parens");
        push({ type, value: value3, output: state.output ? "" : ONE_CHAR });
        push({ type: "paren", extglob: true, value: advance(), output });
        extglobs.push(token);
      };
      const extglobClose = (token) => {
        let output = token.close + (opts.capture ? ")" : "");
        let rest;
        if (token.type === "negate") {
          let extglobStar = star;
          if (token.inner && token.inner.length > 1 && token.inner.includes("/")) {
            extglobStar = globstar(opts);
          }
          if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
            output = token.close = `)$))${extglobStar}`;
          }
          if (token.inner.includes("*") && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
            const expression = parse(rest, { ...options, fastpaths: false }).output;
            output = token.close = `)${expression})${extglobStar})`;
          }
          if (token.prev.type === "bos") {
            state.negatedExtglob = true;
          }
        }
        push({ type: "paren", extglob: true, value: value2, output });
        decrement("parens");
      };
      if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
        let backslashes = false;
        let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {
          if (first === "\\") {
            backslashes = true;
            return m;
          }
          if (first === "?") {
            if (esc) {
              return esc + first + (rest ? QMARK.repeat(rest.length) : "");
            }
            if (index === 0) {
              return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : "");
            }
            return QMARK.repeat(chars.length);
          }
          if (first === ".") {
            return DOT_LITERAL.repeat(chars.length);
          }
          if (first === "*") {
            if (esc) {
              return esc + first + (rest ? star : "");
            }
            return star;
          }
          return esc ? m : `\\${m}`;
        });
        if (backslashes === true) {
          if (opts.unescape === true) {
            output = output.replace(/\\/g, "");
          } else {
            output = output.replace(/\\+/g, (m) => {
              return m.length % 2 === 0 ? "\\\\" : m ? "\\" : "";
            });
          }
        }
        if (output === input && opts.contains === true) {
          state.output = input;
          return state;
        }
        state.output = utils.wrapOutput(output, state, options);
        return state;
      }
      while (!eos()) {
        value2 = advance();
        if (value2 === "\0") {
          continue;
        }
        if (value2 === "\\") {
          const next = peek();
          if (next === "/" && opts.bash !== true) {
            continue;
          }
          if (next === "." || next === ";") {
            continue;
          }
          if (!next) {
            value2 += "\\";
            push({ type: "text", value: value2 });
            continue;
          }
          const match = /^\\+/.exec(remaining());
          let slashes = 0;
          if (match && match[0].length > 2) {
            slashes = match[0].length;
            state.index += slashes;
            if (slashes % 2 !== 0) {
              value2 += "\\";
            }
          }
          if (opts.unescape === true) {
            value2 = advance();
          } else {
            value2 += advance();
          }
          if (state.brackets === 0) {
            push({ type: "text", value: value2 });
            continue;
          }
        }
        if (state.brackets > 0 && (value2 !== "]" || prev.value === "[" || prev.value === "[^")) {
          if (opts.posix !== false && value2 === ":") {
            const inner = prev.value.slice(1);
            if (inner.includes("[")) {
              prev.posix = true;
              if (inner.includes(":")) {
                const idx = prev.value.lastIndexOf("[");
                const pre = prev.value.slice(0, idx);
                const rest2 = prev.value.slice(idx + 2);
                const posix = POSIX_REGEX_SOURCE[rest2];
                if (posix) {
                  prev.value = pre + posix;
                  state.backtrack = true;
                  advance();
                  if (!bos.output && tokens.indexOf(prev) === 1) {
                    bos.output = ONE_CHAR;
                  }
                  continue;
                }
              }
            }
          }
          if (value2 === "[" && peek() !== ":" || value2 === "-" && peek() === "]") {
            value2 = `\\${value2}`;
          }
          if (value2 === "]" && (prev.value === "[" || prev.value === "[^")) {
            value2 = `\\${value2}`;
          }
          if (opts.posix === true && value2 === "!" && prev.value === "[") {
            value2 = "^";
          }
          prev.value += value2;
          append({ value: value2 });
          continue;
        }
        if (state.quotes === 1 && value2 !== '"') {
          value2 = utils.escapeRegex(value2);
          prev.value += value2;
          append({ value: value2 });
          continue;
        }
        if (value2 === '"') {
          state.quotes = state.quotes === 1 ? 0 : 1;
          if (opts.keepQuotes === true) {
            push({ type: "text", value: value2 });
          }
          continue;
        }
        if (value2 === "(") {
          increment("parens");
          push({ type: "paren", value: value2 });
          continue;
        }
        if (value2 === ")") {
          if (state.parens === 0 && opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError("opening", "("));
          }
          const extglob = extglobs[extglobs.length - 1];
          if (extglob && state.parens === extglob.parens + 1) {
            extglobClose(extglobs.pop());
            continue;
          }
          push({ type: "paren", value: value2, output: state.parens ? ")" : "\\)" });
          decrement("parens");
          continue;
        }
        if (value2 === "[") {
          if (opts.nobracket === true || !remaining().includes("]")) {
            if (opts.nobracket !== true && opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("closing", "]"));
            }
            value2 = `\\${value2}`;
          } else {
            increment("brackets");
          }
          push({ type: "bracket", value: value2 });
          continue;
        }
        if (value2 === "]") {
          if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
            push({ type: "text", value: value2, output: `\\${value2}` });
            continue;
          }
          if (state.brackets === 0) {
            if (opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("opening", "["));
            }
            push({ type: "text", value: value2, output: `\\${value2}` });
            continue;
          }
          decrement("brackets");
          const prevValue = prev.value.slice(1);
          if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) {
            value2 = `/${value2}`;
          }
          prev.value += value2;
          append({ value: value2 });
          if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
            continue;
          }
          const escaped = utils.escapeRegex(prev.value);
          state.output = state.output.slice(0, -prev.value.length);
          if (opts.literalBrackets === true) {
            state.output += escaped;
            prev.value = escaped;
            continue;
          }
          prev.value = `(${capture}${escaped}|${prev.value})`;
          state.output += prev.value;
          continue;
        }
        if (value2 === "{" && opts.nobrace !== true) {
          increment("braces");
          const open = {
            type: "brace",
            value: value2,
            output: "(",
            outputIndex: state.output.length,
            tokensIndex: state.tokens.length
          };
          braces.push(open);
          push(open);
          continue;
        }
        if (value2 === "}") {
          const brace = braces[braces.length - 1];
          if (opts.nobrace === true || !brace) {
            push({ type: "text", value: value2, output: value2 });
            continue;
          }
          let output = ")";
          if (brace.dots === true) {
            const arr = tokens.slice();
            const range = [];
            for (let i = arr.length - 1; i >= 0; i--) {
              tokens.pop();
              if (arr[i].type === "brace") {
                break;
              }
              if (arr[i].type !== "dots") {
                range.unshift(arr[i].value);
              }
            }
            output = expandRange(range, opts);
            state.backtrack = true;
          }
          if (brace.comma !== true && brace.dots !== true) {
            const out = state.output.slice(0, brace.outputIndex);
            const toks = state.tokens.slice(brace.tokensIndex);
            brace.value = brace.output = "\\{";
            value2 = output = "\\}";
            state.output = out;
            for (const t of toks) {
              state.output += t.output || t.value;
            }
          }
          push({ type: "brace", value: value2, output });
          decrement("braces");
          braces.pop();
          continue;
        }
        if (value2 === "|") {
          if (extglobs.length > 0) {
            extglobs[extglobs.length - 1].conditions++;
          }
          push({ type: "text", value: value2 });
          continue;
        }
        if (value2 === ",") {
          let output = value2;
          const brace = braces[braces.length - 1];
          if (brace && stack[stack.length - 1] === "braces") {
            brace.comma = true;
            output = "|";
          }
          push({ type: "comma", value: value2, output });
          continue;
        }
        if (value2 === "/") {
          if (prev.type === "dot" && state.index === state.start + 1) {
            state.start = state.index + 1;
            state.consumed = "";
            state.output = "";
            tokens.pop();
            prev = bos;
            continue;
          }
          push({ type: "slash", value: value2, output: SLASH_LITERAL });
          continue;
        }
        if (value2 === ".") {
          if (state.braces > 0 && prev.type === "dot") {
            if (prev.value === ".") prev.output = DOT_LITERAL;
            const brace = braces[braces.length - 1];
            prev.type = "dots";
            prev.output += value2;
            prev.value += value2;
            brace.dots = true;
            continue;
          }
          if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
            push({ type: "text", value: value2, output: DOT_LITERAL });
            continue;
          }
          push({ type: "dot", value: value2, output: DOT_LITERAL });
          continue;
        }
        if (value2 === "?") {
          const isGroup = prev && prev.value === "(";
          if (!isGroup && opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("qmark", value2);
            continue;
          }
          if (prev && prev.type === "paren") {
            const next = peek();
            let output = value2;
            if (next === "<" && !utils.supportsLookbehinds()) {
              throw new Error("Node.js v10 or higher is required for regex lookbehinds");
            }
            if (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\w+>)/.test(remaining())) {
              output = `\\${value2}`;
            }
            push({ type: "text", value: value2, output });
            continue;
          }
          if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
            push({ type: "qmark", value: value2, output: QMARK_NO_DOT });
            continue;
          }
          push({ type: "qmark", value: value2, output: QMARK });
          continue;
        }
        if (value2 === "!") {
          if (opts.noextglob !== true && peek() === "(") {
            if (peek(2) !== "?" || !/[!=<:]/.test(peek(3))) {
              extglobOpen("negate", value2);
              continue;
            }
          }
          if (opts.nonegate !== true && state.index === 0) {
            negate();
            continue;
          }
        }
        if (value2 === "+") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("plus", value2);
            continue;
          }
          if (prev && prev.value === "(" || opts.regex === false) {
            push({ type: "plus", value: value2, output: PLUS_LITERAL });
            continue;
          }
          if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
            push({ type: "plus", value: value2 });
            continue;
          }
          push({ type: "plus", value: PLUS_LITERAL });
          continue;
        }
        if (value2 === "@") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            push({ type: "at", extglob: true, value: value2, output: "" });
            continue;
          }
          push({ type: "text", value: value2 });
          continue;
        }
        if (value2 !== "*") {
          if (value2 === "$" || value2 === "^") {
            value2 = `\\${value2}`;
          }
          const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
          if (match) {
            value2 += match[0];
            state.index += match[0].length;
          }
          push({ type: "text", value: value2 });
          continue;
        }
        if (prev && (prev.type === "globstar" || prev.star === true)) {
          prev.type = "star";
          prev.star = true;
          prev.value += value2;
          prev.output = star;
          state.backtrack = true;
          state.globstar = true;
          consume(value2);
          continue;
        }
        let rest = remaining();
        if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
          extglobOpen("star", value2);
          continue;
        }
        if (prev.type === "star") {
          if (opts.noglobstar === true) {
            consume(value2);
            continue;
          }
          const prior = prev.prev;
          const before = prior.prev;
          const isStart = prior.type === "slash" || prior.type === "bos";
          const afterStar = before && (before.type === "star" || before.type === "globstar");
          if (opts.bash === true && (!isStart || rest[0] && rest[0] !== "/")) {
            push({ type: "star", value: value2, output: "" });
            continue;
          }
          const isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace");
          const isExtglob = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
          if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob) {
            push({ type: "star", value: value2, output: "" });
            continue;
          }
          while (rest.slice(0, 3) === "/**") {
            const after = input[state.index + 4];
            if (after && after !== "/") {
              break;
            }
            rest = rest.slice(3);
            consume("/**", 3);
          }
          if (prior.type === "bos" && eos()) {
            prev.type = "globstar";
            prev.value += value2;
            prev.output = globstar(opts);
            state.output = prev.output;
            state.globstar = true;
            consume(value2);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");
            prev.value += value2;
            state.globstar = true;
            state.output += prior.output + prev.output;
            consume(value2);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {
            const end = rest[1] !== void 0 ? "|$" : "";
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
            prev.value += value2;
            state.output += prior.output + prev.output;
            state.globstar = true;
            consume(value2 + advance());
            push({ type: "slash", value: "/", output: "" });
            continue;
          }
          if (prior.type === "bos" && rest[0] === "/") {
            prev.type = "globstar";
            prev.value += value2;
            prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
            state.output = prev.output;
            state.globstar = true;
            consume(value2 + advance());
            push({ type: "slash", value: "/", output: "" });
            continue;
          }
          state.output = state.output.slice(0, -prev.output.length);
          prev.type = "globstar";
          prev.output = globstar(opts);
          prev.value += value2;
          state.output += prev.output;
          state.globstar = true;
          consume(value2);
          continue;
        }
        const token = { type: "star", value: value2, output: star };
        if (opts.bash === true) {
          token.output = ".*?";
          if (prev.type === "bos" || prev.type === "slash") {
            token.output = nodot + token.output;
          }
          push(token);
          continue;
        }
        if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {
          token.output = value2;
          push(token);
          continue;
        }
        if (state.index === state.start || prev.type === "slash" || prev.type === "dot") {
          if (prev.type === "dot") {
            state.output += NO_DOT_SLASH;
            prev.output += NO_DOT_SLASH;
          } else if (opts.dot === true) {
            state.output += NO_DOTS_SLASH;
            prev.output += NO_DOTS_SLASH;
          } else {
            state.output += nodot;
            prev.output += nodot;
          }
          if (peek() !== "*") {
            state.output += ONE_CHAR;
            prev.output += ONE_CHAR;
          }
        }
        push(token);
      }
      while (state.brackets > 0) {
        if (opts.strictBrackets === true) throw new SyntaxError(syntaxError("closing", "]"));
        state.output = utils.escapeLast(state.output, "[");
        decrement("brackets");
      }
      while (state.parens > 0) {
        if (opts.strictBrackets === true) throw new SyntaxError(syntaxError("closing", ")"));
        state.output = utils.escapeLast(state.output, "(");
        decrement("parens");
      }
      while (state.braces > 0) {
        if (opts.strictBrackets === true) throw new SyntaxError(syntaxError("closing", "}"));
        state.output = utils.escapeLast(state.output, "{");
        decrement("braces");
      }
      if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) {
        push({ type: "maybe_slash", value: "", output: `${SLASH_LITERAL}?` });
      }
      if (state.backtrack === true) {
        state.output = "";
        for (const token of state.tokens) {
          state.output += token.output != null ? token.output : token.value;
          if (token.suffix) {
            state.output += token.suffix;
          }
        }
      }
      return state;
    };
    parse.fastpaths = (input, options) => {
      const opts = { ...options };
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      const len = input.length;
      if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      }
      input = REPLACEMENTS[input] || input;
      const win32 = utils.isWindows(options);
      const {
        DOT_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOTS,
        NO_DOTS_SLASH,
        STAR,
        START_ANCHOR
      } = constants.globChars(win32);
      const nodot = opts.dot ? NO_DOTS : NO_DOT;
      const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
      const capture = opts.capture ? "" : "?:";
      const state = { negated: false, prefix: "" };
      let star = opts.bash === true ? ".*?" : STAR;
      if (opts.capture) {
        star = `(${star})`;
      }
      const globstar = (opts2) => {
        if (opts2.noglobstar === true) return star;
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const create = (str) => {
        switch (str) {
          case "*":
            return `${nodot}${ONE_CHAR}${star}`;
          case ".*":
            return `${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*.*":
            return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*/*":
            return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;
          case "**":
            return nodot + globstar(opts);
          case "**/*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;
          case "**/*.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "**/.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;
          default: {
            const match = /^(.*?)\.(\w+)$/.exec(str);
            if (!match) return;
            const source2 = create(match[1]);
            if (!source2) return;
            return source2 + DOT_LITERAL + match[2];
          }
        }
      };
      const output = utils.removePrefix(input, state);
      let source = create(output);
      if (source && opts.strictSlashes !== true) {
        source += `${SLASH_LITERAL}?`;
      }
      return source;
    };
    module2.exports = parse;
  }
});

// node_modules/picomatch/lib/picomatch.js
var require_picomatch = __commonJS({
  "node_modules/picomatch/lib/picomatch.js"(exports2, module2) {
    "use strict";
    var path = require("path");
    var scan = require_scan();
    var parse = require_parse2();
    var utils = require_utils2();
    var constants = require_constants2();
    var isObject = (val) => val && typeof val === "object" && !Array.isArray(val);
    var picomatch = (glob, options, returnState = false) => {
      if (Array.isArray(glob)) {
        const fns = glob.map((input) => picomatch(input, options, returnState));
        const arrayMatcher = (str) => {
          for (const isMatch of fns) {
            const state2 = isMatch(str);
            if (state2) return state2;
          }
          return false;
        };
        return arrayMatcher;
      }
      const isState = isObject(glob) && glob.tokens && glob.input;
      if (glob === "" || typeof glob !== "string" && !isState) {
        throw new TypeError("Expected pattern to be a non-empty string");
      }
      const opts = options || {};
      const posix = utils.isWindows(options);
      const regex = isState ? picomatch.compileRe(glob, options) : picomatch.makeRe(glob, options, false, true);
      const state = regex.state;
      delete regex.state;
      let isIgnored = () => false;
      if (opts.ignore) {
        const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };
        isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
      }
      const matcher = (input, returnObject = false) => {
        const { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix });
        const result = { glob, state, regex, posix, input, output, match, isMatch };
        if (typeof opts.onResult === "function") {
          opts.onResult(result);
        }
        if (isMatch === false) {
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (isIgnored(input)) {
          if (typeof opts.onIgnore === "function") {
            opts.onIgnore(result);
          }
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (typeof opts.onMatch === "function") {
          opts.onMatch(result);
        }
        return returnObject ? result : true;
      };
      if (returnState) {
        matcher.state = state;
      }
      return matcher;
    };
    picomatch.test = (input, regex, options, { glob, posix } = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected input to be a string");
      }
      if (input === "") {
        return { isMatch: false, output: "" };
      }
      const opts = options || {};
      const format = opts.format || (posix ? utils.toPosixSlashes : null);
      let match = input === glob;
      let output = match && format ? format(input) : input;
      if (match === false) {
        output = format ? format(input) : input;
        match = output === glob;
      }
      if (match === false || opts.capture === true) {
        if (opts.matchBase === true || opts.basename === true) {
          match = picomatch.matchBase(input, regex, options, posix);
        } else {
          match = regex.exec(output);
        }
      }
      return { isMatch: Boolean(match), match, output };
    };
    picomatch.matchBase = (input, glob, options, posix = utils.isWindows(options)) => {
      const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);
      return regex.test(path.basename(input));
    };
    picomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
    picomatch.parse = (pattern, options) => {
      if (Array.isArray(pattern)) return pattern.map((p) => picomatch.parse(p, options));
      return parse(pattern, { ...options, fastpaths: false });
    };
    picomatch.scan = (input, options) => scan(input, options);
    picomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {
      if (returnOutput === true) {
        return state.output;
      }
      const opts = options || {};
      const prepend = opts.contains ? "" : "^";
      const append = opts.contains ? "" : "$";
      let source = `${prepend}(?:${state.output})${append}`;
      if (state && state.negated === true) {
        source = `^(?!${source}).*$`;
      }
      const regex = picomatch.toRegex(source, options);
      if (returnState === true) {
        regex.state = state;
      }
      return regex;
    };
    picomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {
      if (!input || typeof input !== "string") {
        throw new TypeError("Expected a non-empty string");
      }
      let parsed = { negated: false, fastpaths: true };
      if (options.fastpaths !== false && (input[0] === "." || input[0] === "*")) {
        parsed.output = parse.fastpaths(input, options);
      }
      if (!parsed.output) {
        parsed = parse(input, options);
      }
      return picomatch.compileRe(parsed, options, returnOutput, returnState);
    };
    picomatch.toRegex = (source, options) => {
      try {
        const opts = options || {};
        return new RegExp(source, opts.flags || (opts.nocase ? "i" : ""));
      } catch (err) {
        if (options && options.debug === true) throw err;
        return /$^/;
      }
    };
    picomatch.constants = constants;
    module2.exports = picomatch;
  }
});

// node_modules/picomatch/index.js
var require_picomatch2 = __commonJS({
  "node_modules/picomatch/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_picomatch();
  }
});

// node_modules/micromatch/index.js
var require_micromatch = __commonJS({
  "node_modules/micromatch/index.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var braces = require_braces();
    var picomatch = require_picomatch2();
    var utils = require_utils2();
    var isEmptyString = (val) => val === "" || val === "./";
    var micromatch = (list, patterns, options) => {
      patterns = [].concat(patterns);
      list = [].concat(list);
      let omit = /* @__PURE__ */ new Set();
      let keep = /* @__PURE__ */ new Set();
      let items = /* @__PURE__ */ new Set();
      let negatives = 0;
      let onResult = (state) => {
        items.add(state.output);
        if (options && options.onResult) {
          options.onResult(state);
        }
      };
      for (let i = 0; i < patterns.length; i++) {
        let isMatch = picomatch(String(patterns[i]), { ...options, onResult }, true);
        let negated = isMatch.state.negated || isMatch.state.negatedExtglob;
        if (negated) negatives++;
        for (let item of list) {
          let matched = isMatch(item, true);
          let match = negated ? !matched.isMatch : matched.isMatch;
          if (!match) continue;
          if (negated) {
            omit.add(matched.output);
          } else {
            omit.delete(matched.output);
            keep.add(matched.output);
          }
        }
      }
      let result = negatives === patterns.length ? [...items] : [...keep];
      let matches = result.filter((item) => !omit.has(item));
      if (options && matches.length === 0) {
        if (options.failglob === true) {
          throw new Error(`No matches found for "${patterns.join(", ")}"`);
        }
        if (options.nonull === true || options.nullglob === true) {
          return options.unescape ? patterns.map((p) => p.replace(/\\/g, "")) : patterns;
        }
      }
      return matches;
    };
    micromatch.match = micromatch;
    micromatch.matcher = (pattern, options) => picomatch(pattern, options);
    micromatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
    micromatch.any = micromatch.isMatch;
    micromatch.not = (list, patterns, options = {}) => {
      patterns = [].concat(patterns).map(String);
      let result = /* @__PURE__ */ new Set();
      let items = [];
      let onResult = (state) => {
        if (options.onResult) options.onResult(state);
        items.push(state.output);
      };
      let matches = new Set(micromatch(list, patterns, { ...options, onResult }));
      for (let item of items) {
        if (!matches.has(item)) {
          result.add(item);
        }
      }
      return [...result];
    };
    micromatch.contains = (str, pattern, options) => {
      if (typeof str !== "string") {
        throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
      }
      if (Array.isArray(pattern)) {
        return pattern.some((p) => micromatch.contains(str, p, options));
      }
      if (typeof pattern === "string") {
        if (isEmptyString(str) || isEmptyString(pattern)) {
          return false;
        }
        if (str.includes(pattern) || str.startsWith("./") && str.slice(2).includes(pattern)) {
          return true;
        }
      }
      return micromatch.isMatch(str, pattern, { ...options, contains: true });
    };
    micromatch.matchKeys = (obj, patterns, options) => {
      if (!utils.isObject(obj)) {
        throw new TypeError("Expected the first argument to be an object");
      }
      let keys = micromatch(Object.keys(obj), patterns, options);
      let res = {};
      for (let key of keys) res[key] = obj[key];
      return res;
    };
    micromatch.some = (list, patterns, options) => {
      let items = [].concat(list);
      for (let pattern of [].concat(patterns)) {
        let isMatch = picomatch(String(pattern), options);
        if (items.some((item) => isMatch(item))) {
          return true;
        }
      }
      return false;
    };
    micromatch.every = (list, patterns, options) => {
      let items = [].concat(list);
      for (let pattern of [].concat(patterns)) {
        let isMatch = picomatch(String(pattern), options);
        if (!items.every((item) => isMatch(item))) {
          return false;
        }
      }
      return true;
    };
    micromatch.all = (str, patterns, options) => {
      if (typeof str !== "string") {
        throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
      }
      return [].concat(patterns).every((p) => picomatch(p, options)(str));
    };
    micromatch.capture = (glob, input, options) => {
      let posix = utils.isWindows(options);
      let regex = picomatch.makeRe(String(glob), { ...options, capture: true });
      let match = regex.exec(posix ? utils.toPosixSlashes(input) : input);
      if (match) {
        return match.slice(1).map((v) => v === void 0 ? "" : v);
      }
    };
    micromatch.makeRe = (...args) => picomatch.makeRe(...args);
    micromatch.scan = (...args) => picomatch.scan(...args);
    micromatch.parse = (patterns, options) => {
      let res = [];
      for (let pattern of [].concat(patterns || [])) {
        for (let str of braces(String(pattern), options)) {
          res.push(picomatch.parse(str, options));
        }
      }
      return res;
    };
    micromatch.braces = (pattern, options) => {
      if (typeof pattern !== "string") throw new TypeError("Expected a string");
      if (options && options.nobrace === true || !/\{.*\}/.test(pattern)) {
        return [pattern];
      }
      return braces(pattern, options);
    };
    micromatch.braceExpand = (pattern, options) => {
      if (typeof pattern !== "string") throw new TypeError("Expected a string");
      return micromatch.braces(pattern, { ...options, expand: true });
    };
    module2.exports = micromatch;
  }
});

// node_modules/fast-glob/out/utils/pattern.js
var require_pattern = __commonJS({
  "node_modules/fast-glob/out/utils/pattern.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.removeDuplicateSlashes = exports2.matchAny = exports2.convertPatternsToRe = exports2.makeRe = exports2.getPatternParts = exports2.expandBraceExpansion = exports2.expandPatternsWithBraceExpansion = exports2.isAffectDepthOfReadingPattern = exports2.endsWithSlashGlobStar = exports2.hasGlobStar = exports2.getBaseDirectory = exports2.isPatternRelatedToParentDirectory = exports2.getPatternsOutsideCurrentDirectory = exports2.getPatternsInsideCurrentDirectory = exports2.getPositivePatterns = exports2.getNegativePatterns = exports2.isPositivePattern = exports2.isNegativePattern = exports2.convertToNegativePattern = exports2.convertToPositivePattern = exports2.isDynamicPattern = exports2.isStaticPattern = void 0;
    var path = require("path");
    var globParent = require_glob_parent();
    var micromatch = require_micromatch();
    var GLOBSTAR = "**";
    var ESCAPE_SYMBOL = "\\";
    var COMMON_GLOB_SYMBOLS_RE = /[*?]|^!/;
    var REGEX_CHARACTER_CLASS_SYMBOLS_RE = /\[[^[]*]/;
    var REGEX_GROUP_SYMBOLS_RE = /(?:^|[^!*+?@])\([^(]*\|[^|]*\)/;
    var GLOB_EXTENSION_SYMBOLS_RE = /[!*+?@]\([^(]*\)/;
    var BRACE_EXPANSION_SEPARATORS_RE = /,|\.\./;
    var DOUBLE_SLASH_RE = /(?!^)\/{2,}/g;
    function isStaticPattern(pattern, options = {}) {
      return !isDynamicPattern(pattern, options);
    }
    exports2.isStaticPattern = isStaticPattern;
    function isDynamicPattern(pattern, options = {}) {
      if (pattern === "") {
        return false;
      }
      if (options.caseSensitiveMatch === false || pattern.includes(ESCAPE_SYMBOL)) {
        return true;
      }
      if (COMMON_GLOB_SYMBOLS_RE.test(pattern) || REGEX_CHARACTER_CLASS_SYMBOLS_RE.test(pattern) || REGEX_GROUP_SYMBOLS_RE.test(pattern)) {
        return true;
      }
      if (options.extglob !== false && GLOB_EXTENSION_SYMBOLS_RE.test(pattern)) {
        return true;
      }
      if (options.braceExpansion !== false && hasBraceExpansion(pattern)) {
        return true;
      }
      return false;
    }
    exports2.isDynamicPattern = isDynamicPattern;
    function hasBraceExpansion(pattern) {
      const openingBraceIndex = pattern.indexOf("{");
      if (openingBraceIndex === -1) {
        return false;
      }
      const closingBraceIndex = pattern.indexOf("}", openingBraceIndex + 1);
      if (closingBraceIndex === -1) {
        return false;
      }
      const braceContent = pattern.slice(openingBraceIndex, closingBraceIndex);
      return BRACE_EXPANSION_SEPARATORS_RE.test(braceContent);
    }
    function convertToPositivePattern(pattern) {
      return isNegativePattern(pattern) ? pattern.slice(1) : pattern;
    }
    exports2.convertToPositivePattern = convertToPositivePattern;
    function convertToNegativePattern(pattern) {
      return "!" + pattern;
    }
    exports2.convertToNegativePattern = convertToNegativePattern;
    function isNegativePattern(pattern) {
      return pattern.startsWith("!") && pattern[1] !== "(";
    }
    exports2.isNegativePattern = isNegativePattern;
    function isPositivePattern(pattern) {
      return !isNegativePattern(pattern);
    }
    exports2.isPositivePattern = isPositivePattern;
    function getNegativePatterns(patterns) {
      return patterns.filter(isNegativePattern);
    }
    exports2.getNegativePatterns = getNegativePatterns;
    function getPositivePatterns(patterns) {
      return patterns.filter(isPositivePattern);
    }
    exports2.getPositivePatterns = getPositivePatterns;
    function getPatternsInsideCurrentDirectory(patterns) {
      return patterns.filter((pattern) => !isPatternRelatedToParentDirectory(pattern));
    }
    exports2.getPatternsInsideCurrentDirectory = getPatternsInsideCurrentDirectory;
    function getPatternsOutsideCurrentDirectory(patterns) {
      return patterns.filter(isPatternRelatedToParentDirectory);
    }
    exports2.getPatternsOutsideCurrentDirectory = getPatternsOutsideCurrentDirectory;
    function isPatternRelatedToParentDirectory(pattern) {
      return pattern.startsWith("..") || pattern.startsWith("./..");
    }
    exports2.isPatternRelatedToParentDirectory = isPatternRelatedToParentDirectory;
    function getBaseDirectory(pattern) {
      return globParent(pattern, { flipBackslashes: false });
    }
    exports2.getBaseDirectory = getBaseDirectory;
    function hasGlobStar(pattern) {
      return pattern.includes(GLOBSTAR);
    }
    exports2.hasGlobStar = hasGlobStar;
    function endsWithSlashGlobStar(pattern) {
      return pattern.endsWith("/" + GLOBSTAR);
    }
    exports2.endsWithSlashGlobStar = endsWithSlashGlobStar;
    function isAffectDepthOfReadingPattern(pattern) {
      const basename = path.basename(pattern);
      return endsWithSlashGlobStar(pattern) || isStaticPattern(basename);
    }
    exports2.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern;
    function expandPatternsWithBraceExpansion(patterns) {
      return patterns.reduce((collection, pattern) => {
        return collection.concat(expandBraceExpansion(pattern));
      }, []);
    }
    exports2.expandPatternsWithBraceExpansion = expandPatternsWithBraceExpansion;
    function expandBraceExpansion(pattern) {
      const patterns = micromatch.braces(pattern, { expand: true, nodupes: true });
      patterns.sort((a, b) => a.length - b.length);
      return patterns.filter((pattern2) => pattern2 !== "");
    }
    exports2.expandBraceExpansion = expandBraceExpansion;
    function getPatternParts(pattern, options) {
      let { parts } = micromatch.scan(pattern, Object.assign(Object.assign({}, options), { parts: true }));
      if (parts.length === 0) {
        parts = [pattern];
      }
      if (parts[0].startsWith("/")) {
        parts[0] = parts[0].slice(1);
        parts.unshift("");
      }
      return parts;
    }
    exports2.getPatternParts = getPatternParts;
    function makeRe(pattern, options) {
      return micromatch.makeRe(pattern, options);
    }
    exports2.makeRe = makeRe;
    function convertPatternsToRe(patterns, options) {
      return patterns.map((pattern) => makeRe(pattern, options));
    }
    exports2.convertPatternsToRe = convertPatternsToRe;
    function matchAny(entry, patternsRe) {
      return patternsRe.some((patternRe) => patternRe.test(entry));
    }
    exports2.matchAny = matchAny;
    function removeDuplicateSlashes(pattern) {
      return pattern.replace(DOUBLE_SLASH_RE, "/");
    }
    exports2.removeDuplicateSlashes = removeDuplicateSlashes;
  }
});

// node_modules/fast-glob/out/utils/stream.js
var require_stream = __commonJS({
  "node_modules/fast-glob/out/utils/stream.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.merge = void 0;
    var merge2 = require_merge2();
    function merge(streams) {
      const mergedStream = merge2(streams);
      streams.forEach((stream) => {
        stream.once("error", (error) => mergedStream.emit("error", error));
      });
      mergedStream.once("close", () => propagateCloseEventToSources(streams));
      mergedStream.once("end", () => propagateCloseEventToSources(streams));
      return mergedStream;
    }
    exports2.merge = merge;
    function propagateCloseEventToSources(streams) {
      streams.forEach((stream) => stream.emit("close"));
    }
  }
});

// node_modules/fast-glob/out/utils/string.js
var require_string = __commonJS({
  "node_modules/fast-glob/out/utils/string.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isEmpty = exports2.isString = void 0;
    function isString2(input) {
      return typeof input === "string";
    }
    exports2.isString = isString2;
    function isEmpty(input) {
      return input === "";
    }
    exports2.isEmpty = isEmpty;
  }
});

// node_modules/fast-glob/out/utils/index.js
var require_utils3 = __commonJS({
  "node_modules/fast-glob/out/utils/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.string = exports2.stream = exports2.pattern = exports2.path = exports2.fs = exports2.errno = exports2.array = void 0;
    var array = require_array();
    exports2.array = array;
    var errno = require_errno();
    exports2.errno = errno;
    var fs = require_fs();
    exports2.fs = fs;
    var path = require_path();
    exports2.path = path;
    var pattern = require_pattern();
    exports2.pattern = pattern;
    var stream = require_stream();
    exports2.stream = stream;
    var string = require_string();
    exports2.string = string;
  }
});

// node_modules/fast-glob/out/managers/tasks.js
var require_tasks = __commonJS({
  "node_modules/fast-glob/out/managers/tasks.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.convertPatternGroupToTask = exports2.convertPatternGroupsToTasks = exports2.groupPatternsByBaseDirectory = exports2.getNegativePatternsAsPositive = exports2.getPositivePatterns = exports2.convertPatternsToTasks = exports2.generate = void 0;
    var utils = require_utils3();
    function generate(input, settings) {
      const patterns = processPatterns(input, settings);
      const ignore = processPatterns(settings.ignore, settings);
      const positivePatterns = getPositivePatterns(patterns);
      const negativePatterns = getNegativePatternsAsPositive(patterns, ignore);
      const staticPatterns = positivePatterns.filter((pattern) => utils.pattern.isStaticPattern(pattern, settings));
      const dynamicPatterns = positivePatterns.filter((pattern) => utils.pattern.isDynamicPattern(pattern, settings));
      const staticTasks = convertPatternsToTasks(
        staticPatterns,
        negativePatterns,
        /* dynamic */
        false
      );
      const dynamicTasks = convertPatternsToTasks(
        dynamicPatterns,
        negativePatterns,
        /* dynamic */
        true
      );
      return staticTasks.concat(dynamicTasks);
    }
    exports2.generate = generate;
    function processPatterns(input, settings) {
      let patterns = input;
      if (settings.braceExpansion) {
        patterns = utils.pattern.expandPatternsWithBraceExpansion(patterns);
      }
      if (settings.baseNameMatch) {
        patterns = patterns.map((pattern) => pattern.includes("/") ? pattern : `**/${pattern}`);
      }
      return patterns.map((pattern) => utils.pattern.removeDuplicateSlashes(pattern));
    }
    function convertPatternsToTasks(positive, negative, dynamic) {
      const tasks = [];
      const patternsOutsideCurrentDirectory = utils.pattern.getPatternsOutsideCurrentDirectory(positive);
      const patternsInsideCurrentDirectory = utils.pattern.getPatternsInsideCurrentDirectory(positive);
      const outsideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsOutsideCurrentDirectory);
      const insideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsInsideCurrentDirectory);
      tasks.push(...convertPatternGroupsToTasks(outsideCurrentDirectoryGroup, negative, dynamic));
      if ("." in insideCurrentDirectoryGroup) {
        tasks.push(convertPatternGroupToTask(".", patternsInsideCurrentDirectory, negative, dynamic));
      } else {
        tasks.push(...convertPatternGroupsToTasks(insideCurrentDirectoryGroup, negative, dynamic));
      }
      return tasks;
    }
    exports2.convertPatternsToTasks = convertPatternsToTasks;
    function getPositivePatterns(patterns) {
      return utils.pattern.getPositivePatterns(patterns);
    }
    exports2.getPositivePatterns = getPositivePatterns;
    function getNegativePatternsAsPositive(patterns, ignore) {
      const negative = utils.pattern.getNegativePatterns(patterns).concat(ignore);
      const positive = negative.map(utils.pattern.convertToPositivePattern);
      return positive;
    }
    exports2.getNegativePatternsAsPositive = getNegativePatternsAsPositive;
    function groupPatternsByBaseDirectory(patterns) {
      const group = {};
      return patterns.reduce((collection, pattern) => {
        const base = utils.pattern.getBaseDirectory(pattern);
        if (base in collection) {
          collection[base].push(pattern);
        } else {
          collection[base] = [pattern];
        }
        return collection;
      }, group);
    }
    exports2.groupPatternsByBaseDirectory = groupPatternsByBaseDirectory;
    function convertPatternGroupsToTasks(positive, negative, dynamic) {
      return Object.keys(positive).map((base) => {
        return convertPatternGroupToTask(base, positive[base], negative, dynamic);
      });
    }
    exports2.convertPatternGroupsToTasks = convertPatternGroupsToTasks;
    function convertPatternGroupToTask(base, positive, negative, dynamic) {
      return {
        dynamic,
        positive,
        negative,
        base,
        patterns: [].concat(positive, negative.map(utils.pattern.convertToNegativePattern))
      };
    }
    exports2.convertPatternGroupToTask = convertPatternGroupToTask;
  }
});

// node_modules/@nodelib/fs.stat/out/providers/async.js
var require_async = __commonJS({
  "node_modules/@nodelib/fs.stat/out/providers/async.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.read = void 0;
    function read(path, settings, callback) {
      settings.fs.lstat(path, (lstatError, lstat) => {
        if (lstatError !== null) {
          callFailureCallback(callback, lstatError);
          return;
        }
        if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {
          callSuccessCallback(callback, lstat);
          return;
        }
        settings.fs.stat(path, (statError, stat) => {
          if (statError !== null) {
            if (settings.throwErrorOnBrokenSymbolicLink) {
              callFailureCallback(callback, statError);
              return;
            }
            callSuccessCallback(callback, lstat);
            return;
          }
          if (settings.markSymbolicLink) {
            stat.isSymbolicLink = () => true;
          }
          callSuccessCallback(callback, stat);
        });
      });
    }
    exports2.read = read;
    function callFailureCallback(callback, error) {
      callback(error);
    }
    function callSuccessCallback(callback, result) {
      callback(null, result);
    }
  }
});

// node_modules/@nodelib/fs.stat/out/providers/sync.js
var require_sync = __commonJS({
  "node_modules/@nodelib/fs.stat/out/providers/sync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.read = void 0;
    function read(path, settings) {
      const lstat = settings.fs.lstatSync(path);
      if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {
        return lstat;
      }
      try {
        const stat = settings.fs.statSync(path);
        if (settings.markSymbolicLink) {
          stat.isSymbolicLink = () => true;
        }
        return stat;
      } catch (error) {
        if (!settings.throwErrorOnBrokenSymbolicLink) {
          return lstat;
        }
        throw error;
      }
    }
    exports2.read = read;
  }
});

// node_modules/@nodelib/fs.stat/out/adapters/fs.js
var require_fs2 = __commonJS({
  "node_modules/@nodelib/fs.stat/out/adapters/fs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createFileSystemAdapter = exports2.FILE_SYSTEM_ADAPTER = void 0;
    var fs = require("fs");
    exports2.FILE_SYSTEM_ADAPTER = {
      lstat: fs.lstat,
      stat: fs.stat,
      lstatSync: fs.lstatSync,
      statSync: fs.statSync
    };
    function createFileSystemAdapter(fsMethods) {
      if (fsMethods === void 0) {
        return exports2.FILE_SYSTEM_ADAPTER;
      }
      return Object.assign(Object.assign({}, exports2.FILE_SYSTEM_ADAPTER), fsMethods);
    }
    exports2.createFileSystemAdapter = createFileSystemAdapter;
  }
});

// node_modules/@nodelib/fs.stat/out/settings.js
var require_settings = __commonJS({
  "node_modules/@nodelib/fs.stat/out/settings.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var fs = require_fs2();
    var Settings = class {
      constructor(_options = {}) {
        this._options = _options;
        this.followSymbolicLink = this._getValue(this._options.followSymbolicLink, true);
        this.fs = fs.createFileSystemAdapter(this._options.fs);
        this.markSymbolicLink = this._getValue(this._options.markSymbolicLink, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
      }
      _getValue(option, value2) {
        return option !== null && option !== void 0 ? option : value2;
      }
    };
    exports2.default = Settings;
  }
});

// node_modules/@nodelib/fs.stat/out/index.js
var require_out = __commonJS({
  "node_modules/@nodelib/fs.stat/out/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.statSync = exports2.stat = exports2.Settings = void 0;
    var async = require_async();
    var sync = require_sync();
    var settings_1 = require_settings();
    exports2.Settings = settings_1.default;
    function stat(path, optionsOrSettingsOrCallback, callback) {
      if (typeof optionsOrSettingsOrCallback === "function") {
        async.read(path, getSettings(), optionsOrSettingsOrCallback);
        return;
      }
      async.read(path, getSettings(optionsOrSettingsOrCallback), callback);
    }
    exports2.stat = stat;
    function statSync(path, optionsOrSettings) {
      const settings = getSettings(optionsOrSettings);
      return sync.read(path, settings);
    }
    exports2.statSync = statSync;
    function getSettings(settingsOrOptions = {}) {
      if (settingsOrOptions instanceof settings_1.default) {
        return settingsOrOptions;
      }
      return new settings_1.default(settingsOrOptions);
    }
  }
});

// node_modules/queue-microtask/index.js
var require_queue_microtask = __commonJS({
  "node_modules/queue-microtask/index.js"(exports2, module2) {
    "use strict";
    var promise;
    module2.exports = typeof queueMicrotask === "function" ? queueMicrotask.bind(typeof window !== "undefined" ? window : global) : (cb) => (promise || (promise = Promise.resolve())).then(cb).catch((err) => setTimeout(() => {
      throw err;
    }, 0));
  }
});

// node_modules/run-parallel/index.js
var require_run_parallel = __commonJS({
  "node_modules/run-parallel/index.js"(exports2, module2) {
    "use strict";
    module2.exports = runParallel;
    var queueMicrotask2 = require_queue_microtask();
    function runParallel(tasks, cb) {
      let results, pending, keys;
      let isSync = true;
      if (Array.isArray(tasks)) {
        results = [];
        pending = tasks.length;
      } else {
        keys = Object.keys(tasks);
        results = {};
        pending = keys.length;
      }
      function done(err) {
        function end() {
          if (cb) cb(err, results);
          cb = null;
        }
        if (isSync) queueMicrotask2(end);
        else end();
      }
      function each(i, err, result) {
        results[i] = result;
        if (--pending === 0 || err) {
          done(err);
        }
      }
      if (!pending) {
        done(null);
      } else if (keys) {
        keys.forEach(function(key) {
          tasks[key](function(err, result) {
            each(key, err, result);
          });
        });
      } else {
        tasks.forEach(function(task, i) {
          task(function(err, result) {
            each(i, err, result);
          });
        });
      }
      isSync = false;
    }
  }
});

// node_modules/@nodelib/fs.scandir/out/constants.js
var require_constants3 = __commonJS({
  "node_modules/@nodelib/fs.scandir/out/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IS_SUPPORT_READDIR_WITH_FILE_TYPES = void 0;
    var NODE_PROCESS_VERSION_PARTS = process.versions.node.split(".");
    if (NODE_PROCESS_VERSION_PARTS[0] === void 0 || NODE_PROCESS_VERSION_PARTS[1] === void 0) {
      throw new Error(`Unexpected behavior. The 'process.versions.node' variable has invalid value: ${process.versions.node}`);
    }
    var MAJOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[0], 10);
    var MINOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[1], 10);
    var SUPPORTED_MAJOR_VERSION = 10;
    var SUPPORTED_MINOR_VERSION = 10;
    var IS_MATCHED_BY_MAJOR = MAJOR_VERSION > SUPPORTED_MAJOR_VERSION;
    var IS_MATCHED_BY_MAJOR_AND_MINOR = MAJOR_VERSION === SUPPORTED_MAJOR_VERSION && MINOR_VERSION >= SUPPORTED_MINOR_VERSION;
    exports2.IS_SUPPORT_READDIR_WITH_FILE_TYPES = IS_MATCHED_BY_MAJOR || IS_MATCHED_BY_MAJOR_AND_MINOR;
  }
});

// node_modules/@nodelib/fs.scandir/out/utils/fs.js
var require_fs3 = __commonJS({
  "node_modules/@nodelib/fs.scandir/out/utils/fs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createDirentFromStats = void 0;
    var DirentFromStats = class {
      constructor(name, stats) {
        this.name = name;
        this.isBlockDevice = stats.isBlockDevice.bind(stats);
        this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
        this.isDirectory = stats.isDirectory.bind(stats);
        this.isFIFO = stats.isFIFO.bind(stats);
        this.isFile = stats.isFile.bind(stats);
        this.isSocket = stats.isSocket.bind(stats);
        this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
      }
    };
    function createDirentFromStats(name, stats) {
      return new DirentFromStats(name, stats);
    }
    exports2.createDirentFromStats = createDirentFromStats;
  }
});

// node_modules/@nodelib/fs.scandir/out/utils/index.js
var require_utils4 = __commonJS({
  "node_modules/@nodelib/fs.scandir/out/utils/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fs = void 0;
    var fs = require_fs3();
    exports2.fs = fs;
  }
});

// node_modules/@nodelib/fs.scandir/out/providers/common.js
var require_common = __commonJS({
  "node_modules/@nodelib/fs.scandir/out/providers/common.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.joinPathSegments = void 0;
    function joinPathSegments(a, b, separator) {
      if (a.endsWith(separator)) {
        return a + b;
      }
      return a + separator + b;
    }
    exports2.joinPathSegments = joinPathSegments;
  }
});

// node_modules/@nodelib/fs.scandir/out/providers/async.js
var require_async2 = __commonJS({
  "node_modules/@nodelib/fs.scandir/out/providers/async.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.readdir = exports2.readdirWithFileTypes = exports2.read = void 0;
    var fsStat = require_out();
    var rpl = require_run_parallel();
    var constants_1 = require_constants3();
    var utils = require_utils4();
    var common = require_common();
    function read(directory, settings, callback) {
      if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
        readdirWithFileTypes(directory, settings, callback);
        return;
      }
      readdir(directory, settings, callback);
    }
    exports2.read = read;
    function readdirWithFileTypes(directory, settings, callback) {
      settings.fs.readdir(directory, { withFileTypes: true }, (readdirError, dirents) => {
        if (readdirError !== null) {
          callFailureCallback(callback, readdirError);
          return;
        }
        const entries = dirents.map((dirent) => ({
          dirent,
          name: dirent.name,
          path: common.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)
        }));
        if (!settings.followSymbolicLinks) {
          callSuccessCallback(callback, entries);
          return;
        }
        const tasks = entries.map((entry) => makeRplTaskEntry(entry, settings));
        rpl(tasks, (rplError, rplEntries) => {
          if (rplError !== null) {
            callFailureCallback(callback, rplError);
            return;
          }
          callSuccessCallback(callback, rplEntries);
        });
      });
    }
    exports2.readdirWithFileTypes = readdirWithFileTypes;
    function makeRplTaskEntry(entry, settings) {
      return (done) => {
        if (!entry.dirent.isSymbolicLink()) {
          done(null, entry);
          return;
        }
        settings.fs.stat(entry.path, (statError, stats) => {
          if (statError !== null) {
            if (settings.throwErrorOnBrokenSymbolicLink) {
              done(statError);
              return;
            }
            done(null, entry);
            return;
          }
          entry.dirent = utils.fs.createDirentFromStats(entry.name, stats);
          done(null, entry);
        });
      };
    }
    function readdir(directory, settings, callback) {
      settings.fs.readdir(directory, (readdirError, names) => {
        if (readdirError !== null) {
          callFailureCallback(callback, readdirError);
          return;
        }
        const tasks = names.map((name) => {
          const path = common.joinPathSegments(directory, name, settings.pathSegmentSeparator);
          return (done) => {
            fsStat.stat(path, settings.fsStatSettings, (error, stats) => {
              if (error !== null) {
                done(error);
                return;
              }
              const entry = {
                name,
                path,
                dirent: utils.fs.createDirentFromStats(name, stats)
              };
              if (settings.stats) {
                entry.stats = stats;
              }
              done(null, entry);
            });
          };
        });
        rpl(tasks, (rplError, entries) => {
          if (rplError !== null) {
            callFailureCallback(callback, rplError);
            return;
          }
          callSuccessCallback(callback, entries);
        });
      });
    }
    exports2.readdir = readdir;
    function callFailureCallback(callback, error) {
      callback(error);
    }
    function callSuccessCallback(callback, result) {
      callback(null, result);
    }
  }
});

// node_modules/@nodelib/fs.scandir/out/providers/sync.js
var require_sync2 = __commonJS({
  "node_modules/@nodelib/fs.scandir/out/providers/sync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.readdir = exports2.readdirWithFileTypes = exports2.read = void 0;
    var fsStat = require_out();
    var constants_1 = require_constants3();
    var utils = require_utils4();
    var common = require_common();
    function read(directory, settings) {
      if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
        return readdirWithFileTypes(directory, settings);
      }
      return readdir(directory, settings);
    }
    exports2.read = read;
    function readdirWithFileTypes(directory, settings) {
      const dirents = settings.fs.readdirSync(directory, { withFileTypes: true });
      return dirents.map((dirent) => {
        const entry = {
          dirent,
          name: dirent.name,
          path: common.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)
        };
        if (entry.dirent.isSymbolicLink() && settings.followSymbolicLinks) {
          try {
            const stats = settings.fs.statSync(entry.path);
            entry.dirent = utils.fs.createDirentFromStats(entry.name, stats);
          } catch (error) {
            if (settings.throwErrorOnBrokenSymbolicLink) {
              throw error;
            }
          }
        }
        return entry;
      });
    }
    exports2.readdirWithFileTypes = readdirWithFileTypes;
    function readdir(directory, settings) {
      const names = settings.fs.readdirSync(directory);
      return names.map((name) => {
        const entryPath = common.joinPathSegments(directory, name, settings.pathSegmentSeparator);
        const stats = fsStat.statSync(entryPath, settings.fsStatSettings);
        const entry = {
          name,
          path: entryPath,
          dirent: utils.fs.createDirentFromStats(name, stats)
        };
        if (settings.stats) {
          entry.stats = stats;
        }
        return entry;
      });
    }
    exports2.readdir = readdir;
  }
});

// node_modules/@nodelib/fs.scandir/out/adapters/fs.js
var require_fs4 = __commonJS({
  "node_modules/@nodelib/fs.scandir/out/adapters/fs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createFileSystemAdapter = exports2.FILE_SYSTEM_ADAPTER = void 0;
    var fs = require("fs");
    exports2.FILE_SYSTEM_ADAPTER = {
      lstat: fs.lstat,
      stat: fs.stat,
      lstatSync: fs.lstatSync,
      statSync: fs.statSync,
      readdir: fs.readdir,
      readdirSync: fs.readdirSync
    };
    function createFileSystemAdapter(fsMethods) {
      if (fsMethods === void 0) {
        return exports2.FILE_SYSTEM_ADAPTER;
      }
      return Object.assign(Object.assign({}, exports2.FILE_SYSTEM_ADAPTER), fsMethods);
    }
    exports2.createFileSystemAdapter = createFileSystemAdapter;
  }
});

// node_modules/@nodelib/fs.scandir/out/settings.js
var require_settings2 = __commonJS({
  "node_modules/@nodelib/fs.scandir/out/settings.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var path = require("path");
    var fsStat = require_out();
    var fs = require_fs4();
    var Settings = class {
      constructor(_options = {}) {
        this._options = _options;
        this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, false);
        this.fs = fs.createFileSystemAdapter(this._options.fs);
        this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path.sep);
        this.stats = this._getValue(this._options.stats, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
        this.fsStatSettings = new fsStat.Settings({
          followSymbolicLink: this.followSymbolicLinks,
          fs: this.fs,
          throwErrorOnBrokenSymbolicLink: this.throwErrorOnBrokenSymbolicLink
        });
      }
      _getValue(option, value2) {
        return option !== null && option !== void 0 ? option : value2;
      }
    };
    exports2.default = Settings;
  }
});

// node_modules/@nodelib/fs.scandir/out/index.js
var require_out2 = __commonJS({
  "node_modules/@nodelib/fs.scandir/out/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Settings = exports2.scandirSync = exports2.scandir = void 0;
    var async = require_async2();
    var sync = require_sync2();
    var settings_1 = require_settings2();
    exports2.Settings = settings_1.default;
    function scandir(path, optionsOrSettingsOrCallback, callback) {
      if (typeof optionsOrSettingsOrCallback === "function") {
        async.read(path, getSettings(), optionsOrSettingsOrCallback);
        return;
      }
      async.read(path, getSettings(optionsOrSettingsOrCallback), callback);
    }
    exports2.scandir = scandir;
    function scandirSync(path, optionsOrSettings) {
      const settings = getSettings(optionsOrSettings);
      return sync.read(path, settings);
    }
    exports2.scandirSync = scandirSync;
    function getSettings(settingsOrOptions = {}) {
      if (settingsOrOptions instanceof settings_1.default) {
        return settingsOrOptions;
      }
      return new settings_1.default(settingsOrOptions);
    }
  }
});

// node_modules/reusify/reusify.js
var require_reusify = __commonJS({
  "node_modules/reusify/reusify.js"(exports2, module2) {
    "use strict";
    function reusify(Constructor) {
      var head = new Constructor();
      var tail = head;
      function get() {
        var current = head;
        if (current.next) {
          head = current.next;
        } else {
          head = new Constructor();
          tail = head;
        }
        current.next = null;
        return current;
      }
      function release(obj) {
        tail.next = obj;
        tail = obj;
      }
      return {
        get,
        release
      };
    }
    module2.exports = reusify;
  }
});

// node_modules/fastq/queue.js
var require_queue = __commonJS({
  "node_modules/fastq/queue.js"(exports2, module2) {
    "use strict";
    var reusify = require_reusify();
    function fastqueue(context, worker, concurrency) {
      if (typeof context === "function") {
        concurrency = worker;
        worker = context;
        context = null;
      }
      if (concurrency < 1) {
        throw new Error("fastqueue concurrency must be greater than 1");
      }
      var cache = reusify(Task);
      var queueHead = null;
      var queueTail = null;
      var _running = 0;
      var errorHandler = null;
      var self2 = {
        push,
        drain: noop,
        saturated: noop,
        pause,
        paused: false,
        concurrency,
        running,
        resume,
        idle,
        length,
        getQueue,
        unshift,
        empty: noop,
        kill,
        killAndDrain,
        error
      };
      return self2;
      function running() {
        return _running;
      }
      function pause() {
        self2.paused = true;
      }
      function length() {
        var current = queueHead;
        var counter = 0;
        while (current) {
          current = current.next;
          counter++;
        }
        return counter;
      }
      function getQueue() {
        var current = queueHead;
        var tasks = [];
        while (current) {
          tasks.push(current.value);
          current = current.next;
        }
        return tasks;
      }
      function resume() {
        if (!self2.paused) return;
        self2.paused = false;
        for (var i = 0; i < self2.concurrency; i++) {
          _running++;
          release();
        }
      }
      function idle() {
        return _running === 0 && self2.length() === 0;
      }
      function push(value2, done) {
        var current = cache.get();
        current.context = context;
        current.release = release;
        current.value = value2;
        current.callback = done || noop;
        current.errorHandler = errorHandler;
        if (_running === self2.concurrency || self2.paused) {
          if (queueTail) {
            queueTail.next = current;
            queueTail = current;
          } else {
            queueHead = current;
            queueTail = current;
            self2.saturated();
          }
        } else {
          _running++;
          worker.call(context, current.value, current.worked);
        }
      }
      function unshift(value2, done) {
        var current = cache.get();
        current.context = context;
        current.release = release;
        current.value = value2;
        current.callback = done || noop;
        if (_running === self2.concurrency || self2.paused) {
          if (queueHead) {
            current.next = queueHead;
            queueHead = current;
          } else {
            queueHead = current;
            queueTail = current;
            self2.saturated();
          }
        } else {
          _running++;
          worker.call(context, current.value, current.worked);
        }
      }
      function release(holder) {
        if (holder) {
          cache.release(holder);
        }
        var next = queueHead;
        if (next) {
          if (!self2.paused) {
            if (queueTail === queueHead) {
              queueTail = null;
            }
            queueHead = next.next;
            next.next = null;
            worker.call(context, next.value, next.worked);
            if (queueTail === null) {
              self2.empty();
            }
          } else {
            _running--;
          }
        } else if (--_running === 0) {
          self2.drain();
        }
      }
      function kill() {
        queueHead = null;
        queueTail = null;
        self2.drain = noop;
      }
      function killAndDrain() {
        queueHead = null;
        queueTail = null;
        self2.drain();
        self2.drain = noop;
      }
      function error(handler) {
        errorHandler = handler;
      }
    }
    function noop() {
    }
    function Task() {
      this.value = null;
      this.callback = noop;
      this.next = null;
      this.release = noop;
      this.context = null;
      this.errorHandler = null;
      var self2 = this;
      this.worked = function worked(err, result) {
        var callback = self2.callback;
        var errorHandler = self2.errorHandler;
        var val = self2.value;
        self2.value = null;
        self2.callback = noop;
        if (self2.errorHandler) {
          errorHandler(err, val);
        }
        callback.call(self2.context, err, result);
        self2.release(self2);
      };
    }
    function queueAsPromised(context, worker, concurrency) {
      if (typeof context === "function") {
        concurrency = worker;
        worker = context;
        context = null;
      }
      function asyncWrapper(arg, cb) {
        worker.call(this, arg).then(function(res) {
          cb(null, res);
        }, cb);
      }
      var queue = fastqueue(context, asyncWrapper, concurrency);
      var pushCb = queue.push;
      var unshiftCb = queue.unshift;
      queue.push = push;
      queue.unshift = unshift;
      queue.drained = drained;
      return queue;
      function push(value2) {
        var p = new Promise(function(resolve, reject) {
          pushCb(value2, function(err, result) {
            if (err) {
              reject(err);
              return;
            }
            resolve(result);
          });
        });
        p.catch(noop);
        return p;
      }
      function unshift(value2) {
        var p = new Promise(function(resolve, reject) {
          unshiftCb(value2, function(err, result) {
            if (err) {
              reject(err);
              return;
            }
            resolve(result);
          });
        });
        p.catch(noop);
        return p;
      }
      function drained() {
        if (queue.idle()) {
          return new Promise(function(resolve) {
            resolve();
          });
        }
        var previousDrain = queue.drain;
        var p = new Promise(function(resolve) {
          queue.drain = function() {
            previousDrain();
            resolve();
          };
        });
        return p;
      }
    }
    module2.exports = fastqueue;
    module2.exports.promise = queueAsPromised;
  }
});

// node_modules/@nodelib/fs.walk/out/readers/common.js
var require_common2 = __commonJS({
  "node_modules/@nodelib/fs.walk/out/readers/common.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.joinPathSegments = exports2.replacePathSegmentSeparator = exports2.isAppliedFilter = exports2.isFatalError = void 0;
    function isFatalError(settings, error) {
      if (settings.errorFilter === null) {
        return true;
      }
      return !settings.errorFilter(error);
    }
    exports2.isFatalError = isFatalError;
    function isAppliedFilter(filter, value2) {
      return filter === null || filter(value2);
    }
    exports2.isAppliedFilter = isAppliedFilter;
    function replacePathSegmentSeparator(filepath, separator) {
      return filepath.split(/[/\\]/).join(separator);
    }
    exports2.replacePathSegmentSeparator = replacePathSegmentSeparator;
    function joinPathSegments(a, b, separator) {
      if (a === "") {
        return b;
      }
      if (a.endsWith(separator)) {
        return a + b;
      }
      return a + separator + b;
    }
    exports2.joinPathSegments = joinPathSegments;
  }
});

// node_modules/@nodelib/fs.walk/out/readers/reader.js
var require_reader = __commonJS({
  "node_modules/@nodelib/fs.walk/out/readers/reader.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var common = require_common2();
    var Reader = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._root = common.replacePathSegmentSeparator(_root, _settings.pathSegmentSeparator);
      }
    };
    exports2.default = Reader;
  }
});

// node_modules/@nodelib/fs.walk/out/readers/async.js
var require_async3 = __commonJS({
  "node_modules/@nodelib/fs.walk/out/readers/async.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var events_1 = require("events");
    var fsScandir = require_out2();
    var fastq = require_queue();
    var common = require_common2();
    var reader_1 = require_reader();
    var AsyncReader = class extends reader_1.default {
      constructor(_root, _settings) {
        super(_root, _settings);
        this._settings = _settings;
        this._scandir = fsScandir.scandir;
        this._emitter = new events_1.EventEmitter();
        this._queue = fastq(this._worker.bind(this), this._settings.concurrency);
        this._isFatalError = false;
        this._isDestroyed = false;
        this._queue.drain = () => {
          if (!this._isFatalError) {
            this._emitter.emit("end");
          }
        };
      }
      read() {
        this._isFatalError = false;
        this._isDestroyed = false;
        setImmediate(() => {
          this._pushToQueue(this._root, this._settings.basePath);
        });
        return this._emitter;
      }
      get isDestroyed() {
        return this._isDestroyed;
      }
      destroy() {
        if (this._isDestroyed) {
          throw new Error("The reader is already destroyed");
        }
        this._isDestroyed = true;
        this._queue.killAndDrain();
      }
      onEntry(callback) {
        this._emitter.on("entry", callback);
      }
      onError(callback) {
        this._emitter.once("error", callback);
      }
      onEnd(callback) {
        this._emitter.once("end", callback);
      }
      _pushToQueue(directory, base) {
        const queueItem = { directory, base };
        this._queue.push(queueItem, (error) => {
          if (error !== null) {
            this._handleError(error);
          }
        });
      }
      _worker(item, done) {
        this._scandir(item.directory, this._settings.fsScandirSettings, (error, entries) => {
          if (error !== null) {
            done(error, void 0);
            return;
          }
          for (const entry of entries) {
            this._handleEntry(entry, item.base);
          }
          done(null, void 0);
        });
      }
      _handleError(error) {
        if (this._isDestroyed || !common.isFatalError(this._settings, error)) {
          return;
        }
        this._isFatalError = true;
        this._isDestroyed = true;
        this._emitter.emit("error", error);
      }
      _handleEntry(entry, base) {
        if (this._isDestroyed || this._isFatalError) {
          return;
        }
        const fullpath = entry.path;
        if (base !== void 0) {
          entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);
        }
        if (common.isAppliedFilter(this._settings.entryFilter, entry)) {
          this._emitEntry(entry);
        }
        if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {
          this._pushToQueue(fullpath, base === void 0 ? void 0 : entry.path);
        }
      }
      _emitEntry(entry) {
        this._emitter.emit("entry", entry);
      }
    };
    exports2.default = AsyncReader;
  }
});

// node_modules/@nodelib/fs.walk/out/providers/async.js
var require_async4 = __commonJS({
  "node_modules/@nodelib/fs.walk/out/providers/async.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var async_1 = require_async3();
    var AsyncProvider = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new async_1.default(this._root, this._settings);
        this._storage = [];
      }
      read(callback) {
        this._reader.onError((error) => {
          callFailureCallback(callback, error);
        });
        this._reader.onEntry((entry) => {
          this._storage.push(entry);
        });
        this._reader.onEnd(() => {
          callSuccessCallback(callback, this._storage);
        });
        this._reader.read();
      }
    };
    exports2.default = AsyncProvider;
    function callFailureCallback(callback, error) {
      callback(error);
    }
    function callSuccessCallback(callback, entries) {
      callback(null, entries);
    }
  }
});

// node_modules/@nodelib/fs.walk/out/providers/stream.js
var require_stream2 = __commonJS({
  "node_modules/@nodelib/fs.walk/out/providers/stream.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var stream_1 = require("stream");
    var async_1 = require_async3();
    var StreamProvider = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new async_1.default(this._root, this._settings);
        this._stream = new stream_1.Readable({
          objectMode: true,
          read: () => {
          },
          destroy: () => {
            if (!this._reader.isDestroyed) {
              this._reader.destroy();
            }
          }
        });
      }
      read() {
        this._reader.onError((error) => {
          this._stream.emit("error", error);
        });
        this._reader.onEntry((entry) => {
          this._stream.push(entry);
        });
        this._reader.onEnd(() => {
          this._stream.push(null);
        });
        this._reader.read();
        return this._stream;
      }
    };
    exports2.default = StreamProvider;
  }
});

// node_modules/@nodelib/fs.walk/out/readers/sync.js
var require_sync3 = __commonJS({
  "node_modules/@nodelib/fs.walk/out/readers/sync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var fsScandir = require_out2();
    var common = require_common2();
    var reader_1 = require_reader();
    var SyncReader = class extends reader_1.default {
      constructor() {
        super(...arguments);
        this._scandir = fsScandir.scandirSync;
        this._storage = [];
        this._queue = /* @__PURE__ */ new Set();
      }
      read() {
        this._pushToQueue(this._root, this._settings.basePath);
        this._handleQueue();
        return this._storage;
      }
      _pushToQueue(directory, base) {
        this._queue.add({ directory, base });
      }
      _handleQueue() {
        for (const item of this._queue.values()) {
          this._handleDirectory(item.directory, item.base);
        }
      }
      _handleDirectory(directory, base) {
        try {
          const entries = this._scandir(directory, this._settings.fsScandirSettings);
          for (const entry of entries) {
            this._handleEntry(entry, base);
          }
        } catch (error) {
          this._handleError(error);
        }
      }
      _handleError(error) {
        if (!common.isFatalError(this._settings, error)) {
          return;
        }
        throw error;
      }
      _handleEntry(entry, base) {
        const fullpath = entry.path;
        if (base !== void 0) {
          entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);
        }
        if (common.isAppliedFilter(this._settings.entryFilter, entry)) {
          this._pushToStorage(entry);
        }
        if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {
          this._pushToQueue(fullpath, base === void 0 ? void 0 : entry.path);
        }
      }
      _pushToStorage(entry) {
        this._storage.push(entry);
      }
    };
    exports2.default = SyncReader;
  }
});

// node_modules/@nodelib/fs.walk/out/providers/sync.js
var require_sync4 = __commonJS({
  "node_modules/@nodelib/fs.walk/out/providers/sync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var sync_1 = require_sync3();
    var SyncProvider = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new sync_1.default(this._root, this._settings);
      }
      read() {
        return this._reader.read();
      }
    };
    exports2.default = SyncProvider;
  }
});

// node_modules/@nodelib/fs.walk/out/settings.js
var require_settings3 = __commonJS({
  "node_modules/@nodelib/fs.walk/out/settings.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var path = require("path");
    var fsScandir = require_out2();
    var Settings = class {
      constructor(_options = {}) {
        this._options = _options;
        this.basePath = this._getValue(this._options.basePath, void 0);
        this.concurrency = this._getValue(this._options.concurrency, Number.POSITIVE_INFINITY);
        this.deepFilter = this._getValue(this._options.deepFilter, null);
        this.entryFilter = this._getValue(this._options.entryFilter, null);
        this.errorFilter = this._getValue(this._options.errorFilter, null);
        this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path.sep);
        this.fsScandirSettings = new fsScandir.Settings({
          followSymbolicLinks: this._options.followSymbolicLinks,
          fs: this._options.fs,
          pathSegmentSeparator: this._options.pathSegmentSeparator,
          stats: this._options.stats,
          throwErrorOnBrokenSymbolicLink: this._options.throwErrorOnBrokenSymbolicLink
        });
      }
      _getValue(option, value2) {
        return option !== null && option !== void 0 ? option : value2;
      }
    };
    exports2.default = Settings;
  }
});

// node_modules/@nodelib/fs.walk/out/index.js
var require_out3 = __commonJS({
  "node_modules/@nodelib/fs.walk/out/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Settings = exports2.walkStream = exports2.walkSync = exports2.walk = void 0;
    var async_1 = require_async4();
    var stream_1 = require_stream2();
    var sync_1 = require_sync4();
    var settings_1 = require_settings3();
    exports2.Settings = settings_1.default;
    function walk(directory, optionsOrSettingsOrCallback, callback) {
      if (typeof optionsOrSettingsOrCallback === "function") {
        new async_1.default(directory, getSettings()).read(optionsOrSettingsOrCallback);
        return;
      }
      new async_1.default(directory, getSettings(optionsOrSettingsOrCallback)).read(callback);
    }
    exports2.walk = walk;
    function walkSync(directory, optionsOrSettings) {
      const settings = getSettings(optionsOrSettings);
      const provider = new sync_1.default(directory, settings);
      return provider.read();
    }
    exports2.walkSync = walkSync;
    function walkStream(directory, optionsOrSettings) {
      const settings = getSettings(optionsOrSettings);
      const provider = new stream_1.default(directory, settings);
      return provider.read();
    }
    exports2.walkStream = walkStream;
    function getSettings(settingsOrOptions = {}) {
      if (settingsOrOptions instanceof settings_1.default) {
        return settingsOrOptions;
      }
      return new settings_1.default(settingsOrOptions);
    }
  }
});

// node_modules/fast-glob/out/readers/reader.js
var require_reader2 = __commonJS({
  "node_modules/fast-glob/out/readers/reader.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var path = require("path");
    var fsStat = require_out();
    var utils = require_utils3();
    var Reader = class {
      constructor(_settings) {
        this._settings = _settings;
        this._fsStatSettings = new fsStat.Settings({
          followSymbolicLink: this._settings.followSymbolicLinks,
          fs: this._settings.fs,
          throwErrorOnBrokenSymbolicLink: this._settings.followSymbolicLinks
        });
      }
      _getFullEntryPath(filepath) {
        return path.resolve(this._settings.cwd, filepath);
      }
      _makeEntry(stats, pattern) {
        const entry = {
          name: pattern,
          path: pattern,
          dirent: utils.fs.createDirentFromStats(pattern, stats)
        };
        if (this._settings.stats) {
          entry.stats = stats;
        }
        return entry;
      }
      _isFatalError(error) {
        return !utils.errno.isEnoentCodeError(error) && !this._settings.suppressErrors;
      }
    };
    exports2.default = Reader;
  }
});

// node_modules/fast-glob/out/readers/stream.js
var require_stream3 = __commonJS({
  "node_modules/fast-glob/out/readers/stream.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var stream_1 = require("stream");
    var fsStat = require_out();
    var fsWalk = require_out3();
    var reader_1 = require_reader2();
    var ReaderStream = class extends reader_1.default {
      constructor() {
        super(...arguments);
        this._walkStream = fsWalk.walkStream;
        this._stat = fsStat.stat;
      }
      dynamic(root, options) {
        return this._walkStream(root, options);
      }
      static(patterns, options) {
        const filepaths = patterns.map(this._getFullEntryPath, this);
        const stream = new stream_1.PassThrough({ objectMode: true });
        stream._write = (index, _enc, done) => {
          return this._getEntry(filepaths[index], patterns[index], options).then((entry) => {
            if (entry !== null && options.entryFilter(entry)) {
              stream.push(entry);
            }
            if (index === filepaths.length - 1) {
              stream.end();
            }
            done();
          }).catch(done);
        };
        for (let i = 0; i < filepaths.length; i++) {
          stream.write(i);
        }
        return stream;
      }
      _getEntry(filepath, pattern, options) {
        return this._getStat(filepath).then((stats) => this._makeEntry(stats, pattern)).catch((error) => {
          if (options.errorFilter(error)) {
            return null;
          }
          throw error;
        });
      }
      _getStat(filepath) {
        return new Promise((resolve, reject) => {
          this._stat(filepath, this._fsStatSettings, (error, stats) => {
            return error === null ? resolve(stats) : reject(error);
          });
        });
      }
    };
    exports2.default = ReaderStream;
  }
});

// node_modules/fast-glob/out/readers/async.js
var require_async5 = __commonJS({
  "node_modules/fast-glob/out/readers/async.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var fsWalk = require_out3();
    var reader_1 = require_reader2();
    var stream_1 = require_stream3();
    var ReaderAsync = class extends reader_1.default {
      constructor() {
        super(...arguments);
        this._walkAsync = fsWalk.walk;
        this._readerStream = new stream_1.default(this._settings);
      }
      dynamic(root, options) {
        return new Promise((resolve, reject) => {
          this._walkAsync(root, options, (error, entries) => {
            if (error === null) {
              resolve(entries);
            } else {
              reject(error);
            }
          });
        });
      }
      async static(patterns, options) {
        const entries = [];
        const stream = this._readerStream.static(patterns, options);
        return new Promise((resolve, reject) => {
          stream.once("error", reject);
          stream.on("data", (entry) => entries.push(entry));
          stream.once("end", () => resolve(entries));
        });
      }
    };
    exports2.default = ReaderAsync;
  }
});

// node_modules/fast-glob/out/providers/matchers/matcher.js
var require_matcher = __commonJS({
  "node_modules/fast-glob/out/providers/matchers/matcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var utils = require_utils3();
    var Matcher = class {
      constructor(_patterns, _settings, _micromatchOptions) {
        this._patterns = _patterns;
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
        this._storage = [];
        this._fillStorage();
      }
      _fillStorage() {
        for (const pattern of this._patterns) {
          const segments = this._getPatternSegments(pattern);
          const sections = this._splitSegmentsIntoSections(segments);
          this._storage.push({
            complete: sections.length <= 1,
            pattern,
            segments,
            sections
          });
        }
      }
      _getPatternSegments(pattern) {
        const parts = utils.pattern.getPatternParts(pattern, this._micromatchOptions);
        return parts.map((part) => {
          const dynamic = utils.pattern.isDynamicPattern(part, this._settings);
          if (!dynamic) {
            return {
              dynamic: false,
              pattern: part
            };
          }
          return {
            dynamic: true,
            pattern: part,
            patternRe: utils.pattern.makeRe(part, this._micromatchOptions)
          };
        });
      }
      _splitSegmentsIntoSections(segments) {
        return utils.array.splitWhen(segments, (segment) => segment.dynamic && utils.pattern.hasGlobStar(segment.pattern));
      }
    };
    exports2.default = Matcher;
  }
});

// node_modules/fast-glob/out/providers/matchers/partial.js
var require_partial = __commonJS({
  "node_modules/fast-glob/out/providers/matchers/partial.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var matcher_1 = require_matcher();
    var PartialMatcher = class extends matcher_1.default {
      match(filepath) {
        const parts = filepath.split("/");
        const levels = parts.length;
        const patterns = this._storage.filter((info) => !info.complete || info.segments.length > levels);
        for (const pattern of patterns) {
          const section = pattern.sections[0];
          if (!pattern.complete && levels > section.length) {
            return true;
          }
          const match = parts.every((part, index) => {
            const segment = pattern.segments[index];
            if (segment.dynamic && segment.patternRe.test(part)) {
              return true;
            }
            if (!segment.dynamic && segment.pattern === part) {
              return true;
            }
            return false;
          });
          if (match) {
            return true;
          }
        }
        return false;
      }
    };
    exports2.default = PartialMatcher;
  }
});

// node_modules/fast-glob/out/providers/filters/deep.js
var require_deep = __commonJS({
  "node_modules/fast-glob/out/providers/filters/deep.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var utils = require_utils3();
    var partial_1 = require_partial();
    var DeepFilter = class {
      constructor(_settings, _micromatchOptions) {
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
      }
      getFilter(basePath, positive, negative) {
        const matcher = this._getMatcher(positive);
        const negativeRe = this._getNegativePatternsRe(negative);
        return (entry) => this._filter(basePath, entry, matcher, negativeRe);
      }
      _getMatcher(patterns) {
        return new partial_1.default(patterns, this._settings, this._micromatchOptions);
      }
      _getNegativePatternsRe(patterns) {
        const affectDepthOfReadingPatterns = patterns.filter(utils.pattern.isAffectDepthOfReadingPattern);
        return utils.pattern.convertPatternsToRe(affectDepthOfReadingPatterns, this._micromatchOptions);
      }
      _filter(basePath, entry, matcher, negativeRe) {
        if (this._isSkippedByDeep(basePath, entry.path)) {
          return false;
        }
        if (this._isSkippedSymbolicLink(entry)) {
          return false;
        }
        const filepath = utils.path.removeLeadingDotSegment(entry.path);
        if (this._isSkippedByPositivePatterns(filepath, matcher)) {
          return false;
        }
        return this._isSkippedByNegativePatterns(filepath, negativeRe);
      }
      _isSkippedByDeep(basePath, entryPath) {
        if (this._settings.deep === Infinity) {
          return false;
        }
        return this._getEntryLevel(basePath, entryPath) >= this._settings.deep;
      }
      _getEntryLevel(basePath, entryPath) {
        const entryPathDepth = entryPath.split("/").length;
        if (basePath === "") {
          return entryPathDepth;
        }
        const basePathDepth = basePath.split("/").length;
        return entryPathDepth - basePathDepth;
      }
      _isSkippedSymbolicLink(entry) {
        return !this._settings.followSymbolicLinks && entry.dirent.isSymbolicLink();
      }
      _isSkippedByPositivePatterns(entryPath, matcher) {
        return !this._settings.baseNameMatch && !matcher.match(entryPath);
      }
      _isSkippedByNegativePatterns(entryPath, patternsRe) {
        return !utils.pattern.matchAny(entryPath, patternsRe);
      }
    };
    exports2.default = DeepFilter;
  }
});

// node_modules/fast-glob/out/providers/filters/entry.js
var require_entry = __commonJS({
  "node_modules/fast-glob/out/providers/filters/entry.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var utils = require_utils3();
    var EntryFilter = class {
      constructor(_settings, _micromatchOptions) {
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
        this.index = /* @__PURE__ */ new Map();
      }
      getFilter(positive, negative) {
        const positiveRe = utils.pattern.convertPatternsToRe(positive, this._micromatchOptions);
        const negativeRe = utils.pattern.convertPatternsToRe(negative, Object.assign(Object.assign({}, this._micromatchOptions), { dot: true }));
        return (entry) => this._filter(entry, positiveRe, negativeRe);
      }
      _filter(entry, positiveRe, negativeRe) {
        const filepath = utils.path.removeLeadingDotSegment(entry.path);
        if (this._settings.unique && this._isDuplicateEntry(filepath)) {
          return false;
        }
        if (this._onlyFileFilter(entry) || this._onlyDirectoryFilter(entry)) {
          return false;
        }
        if (this._isSkippedByAbsoluteNegativePatterns(filepath, negativeRe)) {
          return false;
        }
        const isDirectory = entry.dirent.isDirectory();
        const isMatched = this._isMatchToPatterns(filepath, positiveRe, isDirectory) && !this._isMatchToPatterns(filepath, negativeRe, isDirectory);
        if (this._settings.unique && isMatched) {
          this._createIndexRecord(filepath);
        }
        return isMatched;
      }
      _isDuplicateEntry(filepath) {
        return this.index.has(filepath);
      }
      _createIndexRecord(filepath) {
        this.index.set(filepath, void 0);
      }
      _onlyFileFilter(entry) {
        return this._settings.onlyFiles && !entry.dirent.isFile();
      }
      _onlyDirectoryFilter(entry) {
        return this._settings.onlyDirectories && !entry.dirent.isDirectory();
      }
      _isSkippedByAbsoluteNegativePatterns(entryPath, patternsRe) {
        if (!this._settings.absolute) {
          return false;
        }
        const fullpath = utils.path.makeAbsolute(this._settings.cwd, entryPath);
        return utils.pattern.matchAny(fullpath, patternsRe);
      }
      _isMatchToPatterns(filepath, patternsRe, isDirectory) {
        const isMatched = utils.pattern.matchAny(filepath, patternsRe);
        if (!isMatched && isDirectory) {
          return utils.pattern.matchAny(filepath + "/", patternsRe);
        }
        return isMatched;
      }
    };
    exports2.default = EntryFilter;
  }
});

// node_modules/fast-glob/out/providers/filters/error.js
var require_error = __commonJS({
  "node_modules/fast-glob/out/providers/filters/error.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var utils = require_utils3();
    var ErrorFilter = class {
      constructor(_settings) {
        this._settings = _settings;
      }
      getFilter() {
        return (error) => this._isNonFatalError(error);
      }
      _isNonFatalError(error) {
        return utils.errno.isEnoentCodeError(error) || this._settings.suppressErrors;
      }
    };
    exports2.default = ErrorFilter;
  }
});

// node_modules/fast-glob/out/providers/transformers/entry.js
var require_entry2 = __commonJS({
  "node_modules/fast-glob/out/providers/transformers/entry.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var utils = require_utils3();
    var EntryTransformer = class {
      constructor(_settings) {
        this._settings = _settings;
      }
      getTransformer() {
        return (entry) => this._transform(entry);
      }
      _transform(entry) {
        let filepath = entry.path;
        if (this._settings.absolute) {
          filepath = utils.path.makeAbsolute(this._settings.cwd, filepath);
          filepath = utils.path.unixify(filepath);
        }
        if (this._settings.markDirectories && entry.dirent.isDirectory()) {
          filepath += "/";
        }
        if (!this._settings.objectMode) {
          return filepath;
        }
        return Object.assign(Object.assign({}, entry), { path: filepath });
      }
    };
    exports2.default = EntryTransformer;
  }
});

// node_modules/fast-glob/out/providers/provider.js
var require_provider = __commonJS({
  "node_modules/fast-glob/out/providers/provider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var path = require("path");
    var deep_1 = require_deep();
    var entry_1 = require_entry();
    var error_1 = require_error();
    var entry_2 = require_entry2();
    var Provider = class {
      constructor(_settings) {
        this._settings = _settings;
        this.errorFilter = new error_1.default(this._settings);
        this.entryFilter = new entry_1.default(this._settings, this._getMicromatchOptions());
        this.deepFilter = new deep_1.default(this._settings, this._getMicromatchOptions());
        this.entryTransformer = new entry_2.default(this._settings);
      }
      _getRootDirectory(task) {
        return path.resolve(this._settings.cwd, task.base);
      }
      _getReaderOptions(task) {
        const basePath = task.base === "." ? "" : task.base;
        return {
          basePath,
          pathSegmentSeparator: "/",
          concurrency: this._settings.concurrency,
          deepFilter: this.deepFilter.getFilter(basePath, task.positive, task.negative),
          entryFilter: this.entryFilter.getFilter(task.positive, task.negative),
          errorFilter: this.errorFilter.getFilter(),
          followSymbolicLinks: this._settings.followSymbolicLinks,
          fs: this._settings.fs,
          stats: this._settings.stats,
          throwErrorOnBrokenSymbolicLink: this._settings.throwErrorOnBrokenSymbolicLink,
          transform: this.entryTransformer.getTransformer()
        };
      }
      _getMicromatchOptions() {
        return {
          dot: this._settings.dot,
          matchBase: this._settings.baseNameMatch,
          nobrace: !this._settings.braceExpansion,
          nocase: !this._settings.caseSensitiveMatch,
          noext: !this._settings.extglob,
          noglobstar: !this._settings.globstar,
          posix: true,
          strictSlashes: false
        };
      }
    };
    exports2.default = Provider;
  }
});

// node_modules/fast-glob/out/providers/async.js
var require_async6 = __commonJS({
  "node_modules/fast-glob/out/providers/async.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var async_1 = require_async5();
    var provider_1 = require_provider();
    var ProviderAsync = class extends provider_1.default {
      constructor() {
        super(...arguments);
        this._reader = new async_1.default(this._settings);
      }
      async read(task) {
        const root = this._getRootDirectory(task);
        const options = this._getReaderOptions(task);
        const entries = await this.api(root, task, options);
        return entries.map((entry) => options.transform(entry));
      }
      api(root, task, options) {
        if (task.dynamic) {
          return this._reader.dynamic(root, options);
        }
        return this._reader.static(task.patterns, options);
      }
    };
    exports2.default = ProviderAsync;
  }
});

// node_modules/fast-glob/out/providers/stream.js
var require_stream4 = __commonJS({
  "node_modules/fast-glob/out/providers/stream.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var stream_1 = require("stream");
    var stream_2 = require_stream3();
    var provider_1 = require_provider();
    var ProviderStream = class extends provider_1.default {
      constructor() {
        super(...arguments);
        this._reader = new stream_2.default(this._settings);
      }
      read(task) {
        const root = this._getRootDirectory(task);
        const options = this._getReaderOptions(task);
        const source = this.api(root, task, options);
        const destination = new stream_1.Readable({ objectMode: true, read: () => {
        } });
        source.once("error", (error) => destination.emit("error", error)).on("data", (entry) => destination.emit("data", options.transform(entry))).once("end", () => destination.emit("end"));
        destination.once("close", () => source.destroy());
        return destination;
      }
      api(root, task, options) {
        if (task.dynamic) {
          return this._reader.dynamic(root, options);
        }
        return this._reader.static(task.patterns, options);
      }
    };
    exports2.default = ProviderStream;
  }
});

// node_modules/fast-glob/out/readers/sync.js
var require_sync5 = __commonJS({
  "node_modules/fast-glob/out/readers/sync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var fsStat = require_out();
    var fsWalk = require_out3();
    var reader_1 = require_reader2();
    var ReaderSync = class extends reader_1.default {
      constructor() {
        super(...arguments);
        this._walkSync = fsWalk.walkSync;
        this._statSync = fsStat.statSync;
      }
      dynamic(root, options) {
        return this._walkSync(root, options);
      }
      static(patterns, options) {
        const entries = [];
        for (const pattern of patterns) {
          const filepath = this._getFullEntryPath(pattern);
          const entry = this._getEntry(filepath, pattern, options);
          if (entry === null || !options.entryFilter(entry)) {
            continue;
          }
          entries.push(entry);
        }
        return entries;
      }
      _getEntry(filepath, pattern, options) {
        try {
          const stats = this._getStat(filepath);
          return this._makeEntry(stats, pattern);
        } catch (error) {
          if (options.errorFilter(error)) {
            return null;
          }
          throw error;
        }
      }
      _getStat(filepath) {
        return this._statSync(filepath, this._fsStatSettings);
      }
    };
    exports2.default = ReaderSync;
  }
});

// node_modules/fast-glob/out/providers/sync.js
var require_sync6 = __commonJS({
  "node_modules/fast-glob/out/providers/sync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var sync_1 = require_sync5();
    var provider_1 = require_provider();
    var ProviderSync = class extends provider_1.default {
      constructor() {
        super(...arguments);
        this._reader = new sync_1.default(this._settings);
      }
      read(task) {
        const root = this._getRootDirectory(task);
        const options = this._getReaderOptions(task);
        const entries = this.api(root, task, options);
        return entries.map(options.transform);
      }
      api(root, task, options) {
        if (task.dynamic) {
          return this._reader.dynamic(root, options);
        }
        return this._reader.static(task.patterns, options);
      }
    };
    exports2.default = ProviderSync;
  }
});

// node_modules/fast-glob/out/settings.js
var require_settings4 = __commonJS({
  "node_modules/fast-glob/out/settings.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DEFAULT_FILE_SYSTEM_ADAPTER = void 0;
    var fs = require("fs");
    var os = require("os");
    var CPU_COUNT = Math.max(os.cpus().length, 1);
    exports2.DEFAULT_FILE_SYSTEM_ADAPTER = {
      lstat: fs.lstat,
      lstatSync: fs.lstatSync,
      stat: fs.stat,
      statSync: fs.statSync,
      readdir: fs.readdir,
      readdirSync: fs.readdirSync
    };
    var Settings = class {
      constructor(_options = {}) {
        this._options = _options;
        this.absolute = this._getValue(this._options.absolute, false);
        this.baseNameMatch = this._getValue(this._options.baseNameMatch, false);
        this.braceExpansion = this._getValue(this._options.braceExpansion, true);
        this.caseSensitiveMatch = this._getValue(this._options.caseSensitiveMatch, true);
        this.concurrency = this._getValue(this._options.concurrency, CPU_COUNT);
        this.cwd = this._getValue(this._options.cwd, process.cwd());
        this.deep = this._getValue(this._options.deep, Infinity);
        this.dot = this._getValue(this._options.dot, false);
        this.extglob = this._getValue(this._options.extglob, true);
        this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, true);
        this.fs = this._getFileSystemMethods(this._options.fs);
        this.globstar = this._getValue(this._options.globstar, true);
        this.ignore = this._getValue(this._options.ignore, []);
        this.markDirectories = this._getValue(this._options.markDirectories, false);
        this.objectMode = this._getValue(this._options.objectMode, false);
        this.onlyDirectories = this._getValue(this._options.onlyDirectories, false);
        this.onlyFiles = this._getValue(this._options.onlyFiles, true);
        this.stats = this._getValue(this._options.stats, false);
        this.suppressErrors = this._getValue(this._options.suppressErrors, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, false);
        this.unique = this._getValue(this._options.unique, true);
        if (this.onlyDirectories) {
          this.onlyFiles = false;
        }
        if (this.stats) {
          this.objectMode = true;
        }
        this.ignore = [].concat(this.ignore);
      }
      _getValue(option, value2) {
        return option === void 0 ? value2 : option;
      }
      _getFileSystemMethods(methods = {}) {
        return Object.assign(Object.assign({}, exports2.DEFAULT_FILE_SYSTEM_ADAPTER), methods);
      }
    };
    exports2.default = Settings;
  }
});

// node_modules/fast-glob/out/index.js
var require_out4 = __commonJS({
  "node_modules/fast-glob/out/index.js"(exports2, module2) {
    "use strict";
    var taskManager = require_tasks();
    var async_1 = require_async6();
    var stream_1 = require_stream4();
    var sync_1 = require_sync6();
    var settings_1 = require_settings4();
    var utils = require_utils3();
    async function FastGlob(source, options) {
      assertPatternsInput(source);
      const works = getWorks(source, async_1.default, options);
      const result = await Promise.all(works);
      return utils.array.flatten(result);
    }
    (function(FastGlob2) {
      FastGlob2.glob = FastGlob2;
      FastGlob2.globSync = sync;
      FastGlob2.globStream = stream;
      FastGlob2.async = FastGlob2;
      function sync(source, options) {
        assertPatternsInput(source);
        const works = getWorks(source, sync_1.default, options);
        return utils.array.flatten(works);
      }
      FastGlob2.sync = sync;
      function stream(source, options) {
        assertPatternsInput(source);
        const works = getWorks(source, stream_1.default, options);
        return utils.stream.merge(works);
      }
      FastGlob2.stream = stream;
      function generateTasks(source, options) {
        assertPatternsInput(source);
        const patterns = [].concat(source);
        const settings = new settings_1.default(options);
        return taskManager.generate(patterns, settings);
      }
      FastGlob2.generateTasks = generateTasks;
      function isDynamicPattern(source, options) {
        assertPatternsInput(source);
        const settings = new settings_1.default(options);
        return utils.pattern.isDynamicPattern(source, settings);
      }
      FastGlob2.isDynamicPattern = isDynamicPattern;
      function escapePath(source) {
        assertPatternsInput(source);
        return utils.path.escape(source);
      }
      FastGlob2.escapePath = escapePath;
      function convertPathToPattern(source) {
        assertPatternsInput(source);
        return utils.path.convertPathToPattern(source);
      }
      FastGlob2.convertPathToPattern = convertPathToPattern;
      let posix;
      (function(posix2) {
        function escapePath2(source) {
          assertPatternsInput(source);
          return utils.path.escapePosixPath(source);
        }
        posix2.escapePath = escapePath2;
        function convertPathToPattern2(source) {
          assertPatternsInput(source);
          return utils.path.convertPosixPathToPattern(source);
        }
        posix2.convertPathToPattern = convertPathToPattern2;
      })(posix = FastGlob2.posix || (FastGlob2.posix = {}));
      let win32;
      (function(win322) {
        function escapePath2(source) {
          assertPatternsInput(source);
          return utils.path.escapeWindowsPath(source);
        }
        win322.escapePath = escapePath2;
        function convertPathToPattern2(source) {
          assertPatternsInput(source);
          return utils.path.convertWindowsPathToPattern(source);
        }
        win322.convertPathToPattern = convertPathToPattern2;
      })(win32 = FastGlob2.win32 || (FastGlob2.win32 = {}));
    })(FastGlob || (FastGlob = {}));
    function getWorks(source, _Provider, options) {
      const patterns = [].concat(source);
      const settings = new settings_1.default(options);
      const tasks = taskManager.generate(patterns, settings);
      const provider = new _Provider(settings);
      return tasks.map(provider.read, provider);
    }
    function assertPatternsInput(input) {
      const source = [].concat(input);
      const isValidSource = source.every((item) => utils.string.isString(item) && !utils.string.isEmpty(item));
      if (!isValidSource) {
        throw new TypeError("Patterns must be a string (non empty) or an array of strings");
      }
    }
    module2.exports = FastGlob;
  }
});

// node_modules/path-type/index.js
var require_path_type = __commonJS({
  "node_modules/path-type/index.js"(exports2) {
    "use strict";
    var { promisify } = require("util");
    var fs = require("fs");
    async function isType(fsStatType, statsMethodName, filePath) {
      if (typeof filePath !== "string") {
        throw new TypeError(`Expected a string, got ${typeof filePath}`);
      }
      try {
        const stats = await promisify(fs[fsStatType])(filePath);
        return stats[statsMethodName]();
      } catch (error) {
        if (error.code === "ENOENT") {
          return false;
        }
        throw error;
      }
    }
    function isTypeSync(fsStatType, statsMethodName, filePath) {
      if (typeof filePath !== "string") {
        throw new TypeError(`Expected a string, got ${typeof filePath}`);
      }
      try {
        return fs[fsStatType](filePath)[statsMethodName]();
      } catch (error) {
        if (error.code === "ENOENT") {
          return false;
        }
        throw error;
      }
    }
    exports2.isFile = isType.bind(null, "stat", "isFile");
    exports2.isDirectory = isType.bind(null, "stat", "isDirectory");
    exports2.isSymlink = isType.bind(null, "lstat", "isSymbolicLink");
    exports2.isFileSync = isTypeSync.bind(null, "statSync", "isFile");
    exports2.isDirectorySync = isTypeSync.bind(null, "statSync", "isDirectory");
    exports2.isSymlinkSync = isTypeSync.bind(null, "lstatSync", "isSymbolicLink");
  }
});

// node_modules/dir-glob/index.js
var require_dir_glob = __commonJS({
  "node_modules/dir-glob/index.js"(exports2, module2) {
    "use strict";
    var path = require("path");
    var pathType = require_path_type();
    var getExtensions = (extensions) => extensions.length > 1 ? `{${extensions.join(",")}}` : extensions[0];
    var getPath = (filepath, cwd) => {
      const pth = filepath[0] === "!" ? filepath.slice(1) : filepath;
      return path.isAbsolute(pth) ? pth : path.join(cwd, pth);
    };
    var addExtensions = (file, extensions) => {
      if (path.extname(file)) {
        return `**/${file}`;
      }
      return `**/${file}.${getExtensions(extensions)}`;
    };
    var getGlob = (directory, options) => {
      if (options.files && !Array.isArray(options.files)) {
        throw new TypeError(`Expected \`files\` to be of type \`Array\` but received type \`${typeof options.files}\``);
      }
      if (options.extensions && !Array.isArray(options.extensions)) {
        throw new TypeError(`Expected \`extensions\` to be of type \`Array\` but received type \`${typeof options.extensions}\``);
      }
      if (options.files && options.extensions) {
        return options.files.map((x) => path.posix.join(directory, addExtensions(x, options.extensions)));
      }
      if (options.files) {
        return options.files.map((x) => path.posix.join(directory, `**/${x}`));
      }
      if (options.extensions) {
        return [path.posix.join(directory, `**/*.${getExtensions(options.extensions)}`)];
      }
      return [path.posix.join(directory, "**")];
    };
    module2.exports = async (input, options) => {
      options = {
        cwd: process.cwd(),
        ...options
      };
      if (typeof options.cwd !== "string") {
        throw new TypeError(`Expected \`cwd\` to be of type \`string\` but received type \`${typeof options.cwd}\``);
      }
      const globs = await Promise.all([].concat(input).map(async (x) => {
        const isDirectory = await pathType.isDirectory(getPath(x, options.cwd));
        return isDirectory ? getGlob(x, options) : x;
      }));
      return [].concat.apply([], globs);
    };
    module2.exports.sync = (input, options) => {
      options = {
        cwd: process.cwd(),
        ...options
      };
      if (typeof options.cwd !== "string") {
        throw new TypeError(`Expected \`cwd\` to be of type \`string\` but received type \`${typeof options.cwd}\``);
      }
      const globs = [].concat(input).map((x) => pathType.isDirectorySync(getPath(x, options.cwd)) ? getGlob(x, options) : x);
      return [].concat.apply([], globs);
    };
  }
});

// node_modules/ignore/index.js
var require_ignore = __commonJS({
  "node_modules/ignore/index.js"(exports2, module2) {
    "use strict";
    function makeArray(subject) {
      return Array.isArray(subject) ? subject : [subject];
    }
    var EMPTY = "";
    var SPACE = " ";
    var ESCAPE = "\\";
    var REGEX_TEST_BLANK_LINE = /^\s+$/;
    var REGEX_INVALID_TRAILING_BACKSLASH = /(?:[^\\]|^)\\$/;
    var REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\!/;
    var REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\#/;
    var REGEX_SPLITALL_CRLF = /\r?\n/g;
    var REGEX_TEST_INVALID_PATH = /^\.*\/|^\.+$/;
    var SLASH = "/";
    var TMP_KEY_IGNORE = "node-ignore";
    if (typeof Symbol !== "undefined") {
      TMP_KEY_IGNORE = Symbol.for("node-ignore");
    }
    var KEY_IGNORE = TMP_KEY_IGNORE;
    var define2 = (object, key, value2) => Object.defineProperty(object, key, { value: value2 });
    var REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g;
    var RETURN_FALSE = () => false;
    var sanitizeRange = (range) => range.replace(
      REGEX_REGEXP_RANGE,
      (match, from, to) => from.charCodeAt(0) <= to.charCodeAt(0) ? match : EMPTY
    );
    var cleanRangeBackSlash = (slashes) => {
      const { length } = slashes;
      return slashes.slice(0, length - length % 2);
    };
    var REPLACERS = [
      // > Trailing spaces are ignored unless they are quoted with backslash ("\")
      [
        // (a\ ) -> (a )
        // (a  ) -> (a)
        // (a \ ) -> (a  )
        /\\?\s+$/,
        (match) => match.indexOf("\\") === 0 ? SPACE : EMPTY
      ],
      // replace (\ ) with ' '
      [
        /\\\s/g,
        () => SPACE
      ],
      // Escape metacharacters
      // which is written down by users but means special for regular expressions.
      // > There are 12 characters with special meanings:
      // > - the backslash \,
      // > - the caret ^,
      // > - the dollar sign $,
      // > - the period or dot .,
      // > - the vertical bar or pipe symbol |,
      // > - the question mark ?,
      // > - the asterisk or star *,
      // > - the plus sign +,
      // > - the opening parenthesis (,
      // > - the closing parenthesis ),
      // > - and the opening square bracket [,
      // > - the opening curly brace {,
      // > These special characters are often called "metacharacters".
      [
        /[\\$.|*+(){^]/g,
        (match) => `\\${match}`
      ],
      [
        // > a question mark (?) matches a single character
        /(?!\\)\?/g,
        () => "[^/]"
      ],
      // leading slash
      [
        // > A leading slash matches the beginning of the pathname.
        // > For example, "/*.c" matches "cat-file.c" but not "mozilla-sha1/sha1.c".
        // A leading slash matches the beginning of the pathname
        /^\//,
        () => "^"
      ],
      // replace special metacharacter slash after the leading slash
      [
        /\//g,
        () => "\\/"
      ],
      [
        // > A leading "**" followed by a slash means match in all directories.
        // > For example, "**/foo" matches file or directory "foo" anywhere,
        // > the same as pattern "foo".
        // > "**/foo/bar" matches file or directory "bar" anywhere that is directly
        // >   under directory "foo".
        // Notice that the '*'s have been replaced as '\\*'
        /^\^*\\\*\\\*\\\//,
        // '**/foo' <-> 'foo'
        () => "^(?:.*\\/)?"
      ],
      // starting
      [
        // there will be no leading '/'
        //   (which has been replaced by section "leading slash")
        // If starts with '**', adding a '^' to the regular expression also works
        /^(?=[^^])/,
        function startingReplacer() {
          return !/\/(?!$)/.test(this) ? "(?:^|\\/)" : "^";
        }
      ],
      // two globstars
      [
        // Use lookahead assertions so that we could match more than one `'/**'`
        /\\\/\\\*\\\*(?=\\\/|$)/g,
        // Zero, one or several directories
        // should not use '*', or it will be replaced by the next replacer
        // Check if it is not the last `'/**'`
        (_2, index, str) => index + 6 < str.length ? "(?:\\/[^\\/]+)*" : "\\/.+"
      ],
      // normal intermediate wildcards
      [
        // Never replace escaped '*'
        // ignore rule '\*' will match the path '*'
        // 'abc.*/' -> go
        // 'abc.*'  -> skip this rule,
        //    coz trailing single wildcard will be handed by [trailing wildcard]
        /(^|[^\\]+)(\\\*)+(?=.+)/g,
        // '*.js' matches '.js'
        // '*.js' doesn't match 'abc'
        (_2, p1, p2) => {
          const unescaped = p2.replace(/\\\*/g, "[^\\/]*");
          return p1 + unescaped;
        }
      ],
      [
        // unescape, revert step 3 except for back slash
        // For example, if a user escape a '\\*',
        // after step 3, the result will be '\\\\\\*'
        /\\\\\\(?=[$.|*+(){^])/g,
        () => ESCAPE
      ],
      [
        // '\\\\' -> '\\'
        /\\\\/g,
        () => ESCAPE
      ],
      [
        // > The range notation, e.g. [a-zA-Z],
        // > can be used to match one of the characters in a range.
        // `\` is escaped by step 3
        /(\\)?\[([^\]/]*?)(\\*)($|\])/g,
        (match, leadEscape, range, endEscape, close) => leadEscape === ESCAPE ? `\\[${range}${cleanRangeBackSlash(endEscape)}${close}` : close === "]" ? endEscape.length % 2 === 0 ? `[${sanitizeRange(range)}${endEscape}]` : "[]" : "[]"
      ],
      // ending
      [
        // 'js' will not match 'js.'
        // 'ab' will not match 'abc'
        /(?:[^*])$/,
        // WTF!
        // https://git-scm.com/docs/gitignore
        // changes in [2.22.1](https://git-scm.com/docs/gitignore/2.22.1)
        // which re-fixes #24, #38
        // > If there is a separator at the end of the pattern then the pattern
        // > will only match directories, otherwise the pattern can match both
        // > files and directories.
        // 'js*' will not match 'a.js'
        // 'js/' will not match 'a.js'
        // 'js' will match 'a.js' and 'a.js/'
        (match) => /\/$/.test(match) ? `${match}$` : `${match}(?=$|\\/$)`
      ],
      // trailing wildcard
      [
        /(\^|\\\/)?\\\*$/,
        (_2, p1) => {
          const prefix = p1 ? `${p1}[^/]+` : "[^/]*";
          return `${prefix}(?=$|\\/$)`;
        }
      ]
    ];
    var regexCache = /* @__PURE__ */ Object.create(null);
    var makeRegex = (pattern, ignoreCase) => {
      let source = regexCache[pattern];
      if (!source) {
        source = REPLACERS.reduce(
          (prev, current) => prev.replace(current[0], current[1].bind(pattern)),
          pattern
        );
        regexCache[pattern] = source;
      }
      return ignoreCase ? new RegExp(source, "i") : new RegExp(source);
    };
    var isString2 = (subject) => typeof subject === "string";
    var checkPattern = (pattern) => pattern && isString2(pattern) && !REGEX_TEST_BLANK_LINE.test(pattern) && !REGEX_INVALID_TRAILING_BACKSLASH.test(pattern) && pattern.indexOf("#") !== 0;
    var splitPattern = (pattern) => pattern.split(REGEX_SPLITALL_CRLF);
    var IgnoreRule = class {
      constructor(origin, pattern, negative, regex) {
        this.origin = origin;
        this.pattern = pattern;
        this.negative = negative;
        this.regex = regex;
      }
    };
    var createRule = (pattern, ignoreCase) => {
      const origin = pattern;
      let negative = false;
      if (pattern.indexOf("!") === 0) {
        negative = true;
        pattern = pattern.substr(1);
      }
      pattern = pattern.replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, "!").replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, "#");
      const regex = makeRegex(pattern, ignoreCase);
      return new IgnoreRule(
        origin,
        pattern,
        negative,
        regex
      );
    };
    var throwError = (message, Ctor) => {
      throw new Ctor(message);
    };
    var checkPath = (path, originalPath, doThrow) => {
      if (!isString2(path)) {
        return doThrow(
          `path must be a string, but got \`${originalPath}\``,
          TypeError
        );
      }
      if (!path) {
        return doThrow(`path must not be empty`, TypeError);
      }
      if (checkPath.isNotRelative(path)) {
        const r = "`path.relative()`d";
        return doThrow(
          `path should be a ${r} string, but got "${originalPath}"`,
          RangeError
        );
      }
      return true;
    };
    var isNotRelative = (path) => REGEX_TEST_INVALID_PATH.test(path);
    checkPath.isNotRelative = isNotRelative;
    checkPath.convert = (p) => p;
    var Ignore = class {
      constructor({
        ignorecase = true,
        ignoreCase = ignorecase,
        allowRelativePaths = false
      } = {}) {
        define2(this, KEY_IGNORE, true);
        this._rules = [];
        this._ignoreCase = ignoreCase;
        this._allowRelativePaths = allowRelativePaths;
        this._initCache();
      }
      _initCache() {
        this._ignoreCache = /* @__PURE__ */ Object.create(null);
        this._testCache = /* @__PURE__ */ Object.create(null);
      }
      _addPattern(pattern) {
        if (pattern && pattern[KEY_IGNORE]) {
          this._rules = this._rules.concat(pattern._rules);
          this._added = true;
          return;
        }
        if (checkPattern(pattern)) {
          const rule = createRule(pattern, this._ignoreCase);
          this._added = true;
          this._rules.push(rule);
        }
      }
      // @param {Array<string> | string | Ignore} pattern
      add(pattern) {
        this._added = false;
        makeArray(
          isString2(pattern) ? splitPattern(pattern) : pattern
        ).forEach(this._addPattern, this);
        if (this._added) {
          this._initCache();
        }
        return this;
      }
      // legacy
      addPattern(pattern) {
        return this.add(pattern);
      }
      //          |           ignored : unignored
      // negative |   0:0   |   0:1   |   1:0   |   1:1
      // -------- | ------- | ------- | ------- | --------
      //     0    |  TEST   |  TEST   |  SKIP   |    X
      //     1    |  TESTIF |  SKIP   |  TEST   |    X
      // - SKIP: always skip
      // - TEST: always test
      // - TESTIF: only test if checkUnignored
      // - X: that never happen
      // @param {boolean} whether should check if the path is unignored,
      //   setting `checkUnignored` to `false` could reduce additional
      //   path matching.
      // @returns {TestResult} true if a file is ignored
      _testOne(path, checkUnignored) {
        let ignored = false;
        let unignored = false;
        this._rules.forEach((rule) => {
          const { negative } = rule;
          if (unignored === negative && ignored !== unignored || negative && !ignored && !unignored && !checkUnignored) {
            return;
          }
          const matched = rule.regex.test(path);
          if (matched) {
            ignored = !negative;
            unignored = negative;
          }
        });
        return {
          ignored,
          unignored
        };
      }
      // @returns {TestResult}
      _test(originalPath, cache, checkUnignored, slices) {
        const path = originalPath && checkPath.convert(originalPath);
        checkPath(
          path,
          originalPath,
          this._allowRelativePaths ? RETURN_FALSE : throwError
        );
        return this._t(path, cache, checkUnignored, slices);
      }
      _t(path, cache, checkUnignored, slices) {
        if (path in cache) {
          return cache[path];
        }
        if (!slices) {
          slices = path.split(SLASH);
        }
        slices.pop();
        if (!slices.length) {
          return cache[path] = this._testOne(path, checkUnignored);
        }
        const parent = this._t(
          slices.join(SLASH) + SLASH,
          cache,
          checkUnignored,
          slices
        );
        return cache[path] = parent.ignored ? parent : this._testOne(path, checkUnignored);
      }
      ignores(path) {
        return this._test(path, this._ignoreCache, false).ignored;
      }
      createFilter() {
        return (path) => !this.ignores(path);
      }
      filter(paths) {
        return makeArray(paths).filter(this.createFilter());
      }
      // @returns {TestResult}
      test(path) {
        return this._test(path, this._testCache, true);
      }
    };
    var factory = (options) => new Ignore(options);
    var isPathValid = (path) => checkPath(path && checkPath.convert(path), path, RETURN_FALSE);
    factory.isPathValid = isPathValid;
    factory.default = factory;
    module2.exports = factory;
    if (
      // Detect `process` so that it can run in browsers.
      typeof process !== "undefined" && (process.env && process.env.IGNORE_TEST_WIN32 || process.platform === "win32")
    ) {
      const makePosix = (str) => /^\\\\\?\\/.test(str) || /["<>|\u0000-\u001F]+/u.test(str) ? str : str.replace(/\\/g, "/");
      checkPath.convert = makePosix;
      const REGIX_IS_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\//i;
      checkPath.isNotRelative = (path) => REGIX_IS_WINDOWS_PATH_ABSOLUTE.test(path) || isNotRelative(path);
    }
  }
});

// node_modules/slash/index.js
var require_slash = __commonJS({
  "node_modules/slash/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (path) => {
      const isExtendedLengthPath = /^\\\\\?\\/.test(path);
      const hasNonAscii = /[^\u0000-\u0080]+/.test(path);
      if (isExtendedLengthPath || hasNonAscii) {
        return path;
      }
      return path.replace(/\\/g, "/");
    };
  }
});

// node_modules/globby/gitignore.js
var require_gitignore = __commonJS({
  "node_modules/globby/gitignore.js"(exports2, module2) {
    "use strict";
    var { promisify } = require("util");
    var fs = require("fs");
    var path = require("path");
    var fastGlob = require_out4();
    var gitIgnore = require_ignore();
    var slash = require_slash();
    var DEFAULT_IGNORE = [
      "**/node_modules/**",
      "**/flow-typed/**",
      "**/coverage/**",
      "**/.git"
    ];
    var readFileP = promisify(fs.readFile);
    var mapGitIgnorePatternTo = (base) => (ignore) => {
      if (ignore.startsWith("!")) {
        return "!" + path.posix.join(base, ignore.slice(1));
      }
      return path.posix.join(base, ignore);
    };
    var parseGitIgnore = (content, options) => {
      const base = slash(path.relative(options.cwd, path.dirname(options.fileName)));
      return content.split(/\r?\n/).filter(Boolean).filter((line) => !line.startsWith("#")).map(mapGitIgnorePatternTo(base));
    };
    var reduceIgnore = (files) => {
      const ignores = gitIgnore();
      for (const file of files) {
        ignores.add(parseGitIgnore(file.content, {
          cwd: file.cwd,
          fileName: file.filePath
        }));
      }
      return ignores;
    };
    var ensureAbsolutePathForCwd = (cwd, p) => {
      cwd = slash(cwd);
      if (path.isAbsolute(p)) {
        if (slash(p).startsWith(cwd)) {
          return p;
        }
        throw new Error(`Path ${p} is not in cwd ${cwd}`);
      }
      return path.join(cwd, p);
    };
    var getIsIgnoredPredecate = (ignores, cwd) => {
      return (p) => ignores.ignores(slash(path.relative(cwd, ensureAbsolutePathForCwd(cwd, p.path || p))));
    };
    var getFile = async (file, cwd) => {
      const filePath = path.join(cwd, file);
      const content = await readFileP(filePath, "utf8");
      return {
        cwd,
        filePath,
        content
      };
    };
    var getFileSync = (file, cwd) => {
      const filePath = path.join(cwd, file);
      const content = fs.readFileSync(filePath, "utf8");
      return {
        cwd,
        filePath,
        content
      };
    };
    var normalizeOptions = ({
      ignore = [],
      cwd = slash(process.cwd())
    } = {}) => {
      return { ignore, cwd };
    };
    module2.exports = async (options) => {
      options = normalizeOptions(options);
      const paths = await fastGlob("**/.gitignore", {
        ignore: DEFAULT_IGNORE.concat(options.ignore),
        cwd: options.cwd
      });
      const files = await Promise.all(paths.map((file) => getFile(file, options.cwd)));
      const ignores = reduceIgnore(files);
      return getIsIgnoredPredecate(ignores, options.cwd);
    };
    module2.exports.sync = (options) => {
      options = normalizeOptions(options);
      const paths = fastGlob.sync("**/.gitignore", {
        ignore: DEFAULT_IGNORE.concat(options.ignore),
        cwd: options.cwd
      });
      const files = paths.map((file) => getFileSync(file, options.cwd));
      const ignores = reduceIgnore(files);
      return getIsIgnoredPredecate(ignores, options.cwd);
    };
  }
});

// node_modules/globby/stream-utils.js
var require_stream_utils = __commonJS({
  "node_modules/globby/stream-utils.js"(exports2, module2) {
    "use strict";
    var { Transform } = require("stream");
    var ObjectTransform = class extends Transform {
      constructor() {
        super({
          objectMode: true
        });
      }
    };
    var FilterStream = class extends ObjectTransform {
      constructor(filter) {
        super();
        this._filter = filter;
      }
      _transform(data, encoding, callback) {
        if (this._filter(data)) {
          this.push(data);
        }
        callback();
      }
    };
    var UniqueStream = class extends ObjectTransform {
      constructor() {
        super();
        this._pushed = /* @__PURE__ */ new Set();
      }
      _transform(data, encoding, callback) {
        if (!this._pushed.has(data)) {
          this.push(data);
          this._pushed.add(data);
        }
        callback();
      }
    };
    module2.exports = {
      FilterStream,
      UniqueStream
    };
  }
});

// node_modules/globby/index.js
var require_globby = __commonJS({
  "node_modules/globby/index.js"(exports2, module2) {
    "use strict";
    var fs = require("fs");
    var arrayUnion = require_array_union();
    var merge2 = require_merge2();
    var fastGlob = require_out4();
    var dirGlob = require_dir_glob();
    var gitignore = require_gitignore();
    var { FilterStream, UniqueStream } = require_stream_utils();
    var DEFAULT_FILTER = () => false;
    var isNegative = (pattern) => pattern[0] === "!";
    var assertPatternsInput = (patterns) => {
      if (!patterns.every((pattern) => typeof pattern === "string")) {
        throw new TypeError("Patterns must be a string or an array of strings");
      }
    };
    var checkCwdOption = (options = {}) => {
      if (!options.cwd) {
        return;
      }
      let stat;
      try {
        stat = fs.statSync(options.cwd);
      } catch {
        return;
      }
      if (!stat.isDirectory()) {
        throw new Error("The `cwd` option must be a path to a directory");
      }
    };
    var getPathString = (p) => p.stats instanceof fs.Stats ? p.path : p;
    var generateGlobTasks = (patterns, taskOptions) => {
      patterns = arrayUnion([].concat(patterns));
      assertPatternsInput(patterns);
      checkCwdOption(taskOptions);
      const globTasks = [];
      taskOptions = {
        ignore: [],
        expandDirectories: true,
        ...taskOptions
      };
      for (const [index, pattern] of patterns.entries()) {
        if (isNegative(pattern)) {
          continue;
        }
        const ignore = patterns.slice(index).filter((pattern2) => isNegative(pattern2)).map((pattern2) => pattern2.slice(1));
        const options = {
          ...taskOptions,
          ignore: taskOptions.ignore.concat(ignore)
        };
        globTasks.push({ pattern, options });
      }
      return globTasks;
    };
    var globDirs = (task, fn) => {
      let options = {};
      if (task.options.cwd) {
        options.cwd = task.options.cwd;
      }
      if (Array.isArray(task.options.expandDirectories)) {
        options = {
          ...options,
          files: task.options.expandDirectories
        };
      } else if (typeof task.options.expandDirectories === "object") {
        options = {
          ...options,
          ...task.options.expandDirectories
        };
      }
      return fn(task.pattern, options);
    };
    var getPattern = (task, fn) => task.options.expandDirectories ? globDirs(task, fn) : [task.pattern];
    var getFilterSync = (options) => {
      return options && options.gitignore ? gitignore.sync({ cwd: options.cwd, ignore: options.ignore }) : DEFAULT_FILTER;
    };
    var globToTask = (task) => (glob) => {
      const { options } = task;
      if (options.ignore && Array.isArray(options.ignore) && options.expandDirectories) {
        options.ignore = dirGlob.sync(options.ignore);
      }
      return {
        pattern: glob,
        options
      };
    };
    module2.exports = async (patterns, options) => {
      const globTasks = generateGlobTasks(patterns, options);
      const getFilter = async () => {
        return options && options.gitignore ? gitignore({ cwd: options.cwd, ignore: options.ignore }) : DEFAULT_FILTER;
      };
      const getTasks = async () => {
        const tasks2 = await Promise.all(globTasks.map(async (task) => {
          const globs = await getPattern(task, dirGlob);
          return Promise.all(globs.map(globToTask(task)));
        }));
        return arrayUnion(...tasks2);
      };
      const [filter, tasks] = await Promise.all([getFilter(), getTasks()]);
      const paths = await Promise.all(tasks.map((task) => fastGlob(task.pattern, task.options)));
      return arrayUnion(...paths).filter((path_) => !filter(getPathString(path_)));
    };
    module2.exports.sync = (patterns, options) => {
      const globTasks = generateGlobTasks(patterns, options);
      const tasks = [];
      for (const task of globTasks) {
        const newTask = getPattern(task, dirGlob.sync).map(globToTask(task));
        tasks.push(...newTask);
      }
      const filter = getFilterSync(options);
      let matches = [];
      for (const task of tasks) {
        matches = arrayUnion(matches, fastGlob.sync(task.pattern, task.options));
      }
      return matches.filter((path_) => !filter(path_));
    };
    module2.exports.stream = (patterns, options) => {
      const globTasks = generateGlobTasks(patterns, options);
      const tasks = [];
      for (const task of globTasks) {
        const newTask = getPattern(task, dirGlob.sync).map(globToTask(task));
        tasks.push(...newTask);
      }
      const filter = getFilterSync(options);
      const filterStream = new FilterStream((p) => !filter(p));
      const uniqueStream = new UniqueStream();
      return merge2(tasks.map((task) => fastGlob.stream(task.pattern, task.options))).pipe(filterStream).pipe(uniqueStream);
    };
    module2.exports.generateGlobTasks = generateGlobTasks;
    module2.exports.hasMagic = (patterns, options) => [].concat(patterns).some((pattern) => fastGlob.isDynamicPattern(pattern, options));
    module2.exports.gitignore = gitignore;
  }
});

// node_modules/ignore-by-default/index.js
var require_ignore_by_default = __commonJS({
  "node_modules/ignore-by-default/index.js"(exports2) {
    "use strict";
    exports2.directories = () => [
      ".git",
      // Git repository files, see <https://git-scm.com/>
      ".log",
      // Log files emitted by tools such as `tsserver`, see <https://github.com/Microsoft/TypeScript/wiki/Standalone-Server-%28tsserver%29>
      ".nyc_output",
      // Temporary directory where nyc stores coverage data, see <https://github.com/bcoe/nyc>
      ".sass-cache",
      // Cache folder for node-sass, see <https://github.com/sass/node-sass>
      ".yarn",
      // Where node modules are installed when using Yarn, see <https://yarnpkg.com/>
      "bower_components",
      // Where Bower packages are installed, see <http://bower.io/>
      "coverage",
      // Standard output directory for code coverage reports, see <https://github.com/gotwarlost/istanbul>
      "node_modules"
      // Where Node modules are installed, see <https://nodejs.org/>
    ];
  }
});

// node_modules/ava/lib/globs.js
var require_globs = __commonJS({
  "node_modules/ava/lib/globs.js"(exports2) {
    "use strict";
    var path = require("path");
    var globby = require_globby();
    var ignoreByDefault = require_ignore_by_default();
    var picomatch = require_picomatch2();
    var slash = require_slash();
    var providerManager = require_provider_manager();
    var defaultIgnorePatterns = [...ignoreByDefault.directories(), "**/node_modules"];
    var defaultPicomatchIgnorePatterns = [
      ...defaultIgnorePatterns,
      // Unlike globby(), picomatch needs a complete pattern when ignoring directories.
      ...defaultIgnorePatterns.map((pattern) => `${pattern}/**/*`)
    ];
    var defaultMatchNoIgnore = picomatch(defaultPicomatchIgnorePatterns);
    var defaultIgnoredByWatcherPatterns = [
      "**/*.snap.md",
      // No need to rerun tests when the Markdown files change.
      "ava.config.js",
      // Config is not reloaded so avoid rerunning tests when it changes.
      "ava.config.cjs"
      // Config is not reloaded so avoid rerunning tests when it changes.
    ];
    var buildExtensionPattern = (extensions) => extensions.length === 1 ? extensions[0] : `{${extensions.join(",")}}`;
    function normalizePattern(pattern) {
      if (process.platform === "win32") {
        pattern = slash(pattern);
      }
      if (pattern.startsWith("./")) {
        return pattern.slice(2);
      }
      if (pattern.startsWith("!./")) {
        return `!${pattern.slice(3)}`;
      }
      return pattern;
    }
    exports2.normalizePattern = normalizePattern;
    function normalizePatterns(patterns) {
      return patterns.map((pattern) => normalizePattern(pattern));
    }
    exports2.normalizePatterns = normalizePatterns;
    function normalizeGlobs({ extensions, files: filePatterns, ignoredByWatcher: ignoredByWatcherPatterns, providers }) {
      if (filePatterns !== void 0 && (!Array.isArray(filePatterns) || filePatterns.length === 0)) {
        throw new Error("The \u2019files\u2019 configuration must be an array containing glob patterns.");
      }
      if (ignoredByWatcherPatterns !== void 0 && (!Array.isArray(ignoredByWatcherPatterns) || ignoredByWatcherPatterns.length === 0)) {
        throw new Error("The \u2019ignoredByWatcher\u2019 configuration must be an array containing glob patterns.");
      }
      const extensionPattern = buildExtensionPattern(extensions);
      const defaultTestPatterns = [
        `test.${extensionPattern}`,
        `{src,source}/test.${extensionPattern}`,
        `**/__tests__/**/*.${extensionPattern}`,
        `**/*.spec.${extensionPattern}`,
        `**/*.test.${extensionPattern}`,
        `**/test-*.${extensionPattern}`,
        `**/test/**/*.${extensionPattern}`,
        `**/tests/**/*.${extensionPattern}`,
        "!**/__tests__/**/__{helper,fixture}?(s)__/**/*",
        "!**/test?(s)/**/{helper,fixture}?(s)/**/*"
      ];
      if (filePatterns) {
        filePatterns = normalizePatterns(filePatterns);
        if (filePatterns.every((pattern) => pattern.startsWith("!"))) {
          filePatterns = [...defaultTestPatterns, ...filePatterns];
        }
      } else {
        filePatterns = defaultTestPatterns;
      }
      ignoredByWatcherPatterns = ignoredByWatcherPatterns ? [...defaultIgnoredByWatcherPatterns, ...normalizePatterns(ignoredByWatcherPatterns)] : [...defaultIgnoredByWatcherPatterns];
      for (const { level, main } of providers) {
        if (level >= providerManager.levels.pathRewrites) {
          ({ filePatterns, ignoredByWatcherPatterns } = main.updateGlobs({ filePatterns, ignoredByWatcherPatterns }));
        }
      }
      return { extensions, filePatterns, ignoredByWatcherPatterns };
    }
    exports2.normalizeGlobs = normalizeGlobs;
    var hasExtension = (extensions, file) => extensions.includes(path.extname(file).slice(1));
    exports2.hasExtension = hasExtension;
    var globFiles = async (cwd, patterns) => {
      const files = await globby(patterns, {
        // Globs should work relative to the cwd value only (this should be the
        // project directory that AVA is run in).
        absolute: false,
        braceExpansion: true,
        caseSensitiveMatch: false,
        cwd,
        dot: false,
        expandDirectories: false,
        extglob: true,
        followSymbolicLinks: true,
        gitignore: false,
        globstar: true,
        ignore: defaultIgnorePatterns,
        baseNameMatch: false,
        onlyFiles: true,
        stats: false,
        unique: true
      });
      return files.map((file) => path.join(cwd, file));
    };
    async function findFiles({ cwd, extensions, filePatterns }) {
      return (await globFiles(cwd, filePatterns)).filter((file) => hasExtension(extensions, file));
    }
    exports2.findFiles = findFiles;
    async function findTests({ cwd, extensions, filePatterns }) {
      return (await findFiles({ cwd, extensions, filePatterns })).filter((file) => !path.basename(file).startsWith("_"));
    }
    exports2.findTests = findTests;
    function getChokidarIgnorePatterns({ ignoredByWatcherPatterns }) {
      return [
        ...defaultIgnorePatterns.map((pattern) => `${pattern}/**/*`),
        ...ignoredByWatcherPatterns.filter((pattern) => !pattern.startsWith("!"))
      ];
    }
    exports2.getChokidarIgnorePatterns = getChokidarIgnorePatterns;
    var matchingCache = /* @__PURE__ */ new WeakMap();
    var processMatchingPatterns = (input) => {
      let result = matchingCache.get(input);
      if (!result) {
        const ignore = [...defaultPicomatchIgnorePatterns];
        const patterns = input.filter((pattern) => {
          if (pattern.startsWith("!")) {
            ignore.push(pattern.slice(1), `${pattern.slice(1)}/**/*`);
            return false;
          }
          return true;
        });
        result = {
          match: picomatch(patterns, { ignore }),
          matchNoIgnore: picomatch(patterns)
        };
        matchingCache.set(input, result);
      }
      return result;
    };
    function matches(file, patterns) {
      const { match } = processMatchingPatterns(patterns);
      return match(file);
    }
    exports2.matches = matches;
    var matchesIgnorePatterns = (file, patterns) => {
      const { matchNoIgnore } = processMatchingPatterns(patterns);
      return matchNoIgnore(file) || defaultMatchNoIgnore(file);
    };
    function normalizeFileForMatching(cwd, file) {
      if (process.platform === "win32") {
        cwd = slash(cwd);
        file = slash(file);
      }
      if (!cwd) {
        return file;
      }
      if (!file.startsWith(cwd)) {
        return file;
      }
      return file.slice(cwd.length + 1);
    }
    exports2.normalizeFileForMatching = normalizeFileForMatching;
    function isHelperish(file) {
      if (path.basename(file).startsWith("_")) {
        return true;
      }
      if (path.isAbsolute(file)) {
        return false;
      }
      return path.dirname(file).split("/").some((dir) => /^_(?:$|[^_])/.test(dir));
    }
    exports2.isHelperish = isHelperish;
    function classify(file, { cwd, extensions, filePatterns, ignoredByWatcherPatterns }) {
      file = normalizeFileForMatching(cwd, file);
      return {
        isIgnoredByWatcher: matchesIgnorePatterns(file, ignoredByWatcherPatterns),
        isTest: hasExtension(extensions, file) && !isHelperish(file) && filePatterns.length > 0 && matches(file, filePatterns)
      };
    }
    exports2.classify = classify;
    function applyTestFileFilter({ cwd, filter, testFiles }) {
      return testFiles.filter((file) => matches(normalizeFileForMatching(cwd, file), filter));
    }
    exports2.applyTestFileFilter = applyTestFileFilter;
  }
});

// node_modules/ava/lib/provider-manager.js
var require_provider_manager = __commonJS({
  "node_modules/ava/lib/provider-manager.js"(exports2) {
    "use strict";
    var pkg = require_package();
    var globs = require_globs();
    var levels = {
      ava3: 1,
      pathRewrites: 2
    };
    exports2.levels = levels;
    var levelsByProtocol = {
      "ava-3": levels.ava3,
      "ava-3.2": levels.pathRewrites
    };
    function load(providerModule, projectDir) {
      const ava = { version: pkg.version };
      const makeProvider = require(providerModule);
      let fatal;
      let level;
      const provider = makeProvider({
        negotiateProtocol(identifiers, { version }) {
          const identifier = identifiers.find((identifier2) => Reflect.has(levelsByProtocol, identifier2));
          if (identifier === void 0) {
            fatal = new Error(`This version of AVA (${ava.version}) is not compatible with ${providerModule}@${version}`);
            return null;
          }
          level = levelsByProtocol[identifier];
          return {
            ava,
            async findFiles({ extensions, patterns }) {
              return globs.findFiles({ cwd: projectDir, extensions, filePatterns: patterns });
            },
            identifier,
            normalizeGlobPatterns: globs.normalizePatterns,
            projectDir
          };
        }
      });
      if (fatal) {
        throw fatal;
      }
      return { ...provider, level };
    }
    exports2.babel = (projectDir) => load("@ava/babel", projectDir);
    exports2.typescript = (projectDir) => load("@ava/typescript", projectDir);
  }
});

// node_modules/emittery/index.js
var require_emittery = __commonJS({
  "node_modules/emittery/index.js"(exports2, module2) {
    "use strict";
    var anyMap = /* @__PURE__ */ new WeakMap();
    var eventsMap = /* @__PURE__ */ new WeakMap();
    var producersMap = /* @__PURE__ */ new WeakMap();
    var anyProducer = Symbol("anyProducer");
    var resolvedPromise = Promise.resolve();
    var listenerAdded = Symbol("listenerAdded");
    var listenerRemoved = Symbol("listenerRemoved");
    function assertEventName(eventName) {
      if (typeof eventName !== "string" && typeof eventName !== "symbol") {
        throw new TypeError("eventName must be a string or a symbol");
      }
    }
    function assertListener(listener) {
      if (typeof listener !== "function") {
        throw new TypeError("listener must be a function");
      }
    }
    function getListeners(instance, eventName) {
      const events = eventsMap.get(instance);
      if (!events.has(eventName)) {
        events.set(eventName, /* @__PURE__ */ new Set());
      }
      return events.get(eventName);
    }
    function getEventProducers(instance, eventName) {
      const key = typeof eventName === "string" || typeof eventName === "symbol" ? eventName : anyProducer;
      const producers = producersMap.get(instance);
      if (!producers.has(key)) {
        producers.set(key, /* @__PURE__ */ new Set());
      }
      return producers.get(key);
    }
    function enqueueProducers(instance, eventName, eventData) {
      const producers = producersMap.get(instance);
      if (producers.has(eventName)) {
        for (const producer of producers.get(eventName)) {
          producer.enqueue(eventData);
        }
      }
      if (producers.has(anyProducer)) {
        const item = Promise.all([eventName, eventData]);
        for (const producer of producers.get(anyProducer)) {
          producer.enqueue(item);
        }
      }
    }
    function iterator(instance, eventNames) {
      eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];
      let isFinished = false;
      let flush = () => {
      };
      let queue = [];
      const producer = {
        enqueue(item) {
          queue.push(item);
          flush();
        },
        finish() {
          isFinished = true;
          flush();
        }
      };
      for (const eventName of eventNames) {
        getEventProducers(instance, eventName).add(producer);
      }
      return {
        async next() {
          if (!queue) {
            return { done: true };
          }
          if (queue.length === 0) {
            if (isFinished) {
              queue = void 0;
              return this.next();
            }
            await new Promise((resolve) => {
              flush = resolve;
            });
            return this.next();
          }
          return {
            done: false,
            value: await queue.shift()
          };
        },
        async return(value2) {
          queue = void 0;
          for (const eventName of eventNames) {
            getEventProducers(instance, eventName).delete(producer);
          }
          flush();
          return arguments.length > 0 ? { done: true, value: await value2 } : { done: true };
        },
        [Symbol.asyncIterator]() {
          return this;
        }
      };
    }
    function defaultMethodNamesOrAssert(methodNames) {
      if (methodNames === void 0) {
        return allEmitteryMethods;
      }
      if (!Array.isArray(methodNames)) {
        throw new TypeError("`methodNames` must be an array of strings");
      }
      for (const methodName of methodNames) {
        if (!allEmitteryMethods.includes(methodName)) {
          if (typeof methodName !== "string") {
            throw new TypeError("`methodNames` element must be a string");
          }
          throw new Error(`${methodName} is not Emittery method`);
        }
      }
      return methodNames;
    }
    var isListenerSymbol = (symbol) => symbol === listenerAdded || symbol === listenerRemoved;
    var Emittery = class _Emittery {
      static mixin(emitteryPropertyName, methodNames) {
        methodNames = defaultMethodNamesOrAssert(methodNames);
        return (target) => {
          if (typeof target !== "function") {
            throw new TypeError("`target` must be function");
          }
          for (const methodName of methodNames) {
            if (target.prototype[methodName] !== void 0) {
              throw new Error(`The property \`${methodName}\` already exists on \`target\``);
            }
          }
          function getEmitteryProperty() {
            Object.defineProperty(this, emitteryPropertyName, {
              enumerable: false,
              value: new _Emittery()
            });
            return this[emitteryPropertyName];
          }
          Object.defineProperty(target.prototype, emitteryPropertyName, {
            enumerable: false,
            get: getEmitteryProperty
          });
          const emitteryMethodCaller = (methodName) => function(...args) {
            return this[emitteryPropertyName][methodName](...args);
          };
          for (const methodName of methodNames) {
            Object.defineProperty(target.prototype, methodName, {
              enumerable: false,
              value: emitteryMethodCaller(methodName)
            });
          }
          return target;
        };
      }
      constructor() {
        anyMap.set(this, /* @__PURE__ */ new Set());
        eventsMap.set(this, /* @__PURE__ */ new Map());
        producersMap.set(this, /* @__PURE__ */ new Map());
      }
      on(eventNames, listener) {
        assertListener(listener);
        eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];
        for (const eventName of eventNames) {
          assertEventName(eventName);
          getListeners(this, eventName).add(listener);
          if (!isListenerSymbol(eventName)) {
            this.emit(listenerAdded, { eventName, listener });
          }
        }
        return this.off.bind(this, eventNames, listener);
      }
      off(eventNames, listener) {
        assertListener(listener);
        eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];
        for (const eventName of eventNames) {
          assertEventName(eventName);
          getListeners(this, eventName).delete(listener);
          if (!isListenerSymbol(eventName)) {
            this.emit(listenerRemoved, { eventName, listener });
          }
        }
      }
      once(eventNames) {
        return new Promise((resolve) => {
          const off = this.on(eventNames, (data) => {
            off();
            resolve(data);
          });
        });
      }
      events(eventNames) {
        eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];
        for (const eventName of eventNames) {
          assertEventName(eventName);
        }
        return iterator(this, eventNames);
      }
      async emit(eventName, eventData) {
        assertEventName(eventName);
        enqueueProducers(this, eventName, eventData);
        const listeners = getListeners(this, eventName);
        const anyListeners = anyMap.get(this);
        const staticListeners = [...listeners];
        const staticAnyListeners = isListenerSymbol(eventName) ? [] : [...anyListeners];
        await resolvedPromise;
        await Promise.all([
          ...staticListeners.map(async (listener) => {
            if (listeners.has(listener)) {
              return listener(eventData);
            }
          }),
          ...staticAnyListeners.map(async (listener) => {
            if (anyListeners.has(listener)) {
              return listener(eventName, eventData);
            }
          })
        ]);
      }
      async emitSerial(eventName, eventData) {
        assertEventName(eventName);
        const listeners = getListeners(this, eventName);
        const anyListeners = anyMap.get(this);
        const staticListeners = [...listeners];
        const staticAnyListeners = [...anyListeners];
        await resolvedPromise;
        for (const listener of staticListeners) {
          if (listeners.has(listener)) {
            await listener(eventData);
          }
        }
        for (const listener of staticAnyListeners) {
          if (anyListeners.has(listener)) {
            await listener(eventName, eventData);
          }
        }
      }
      onAny(listener) {
        assertListener(listener);
        anyMap.get(this).add(listener);
        this.emit(listenerAdded, { listener });
        return this.offAny.bind(this, listener);
      }
      anyEvent() {
        return iterator(this);
      }
      offAny(listener) {
        assertListener(listener);
        this.emit(listenerRemoved, { listener });
        anyMap.get(this).delete(listener);
      }
      clearListeners(eventNames) {
        eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];
        for (const eventName of eventNames) {
          if (typeof eventName === "string" || typeof eventName === "symbol") {
            getListeners(this, eventName).clear();
            const producers = getEventProducers(this, eventName);
            for (const producer of producers) {
              producer.finish();
            }
            producers.clear();
          } else {
            anyMap.get(this).clear();
            for (const listeners of eventsMap.get(this).values()) {
              listeners.clear();
            }
            for (const producers of producersMap.get(this).values()) {
              for (const producer of producers) {
                producer.finish();
              }
              producers.clear();
            }
          }
        }
      }
      listenerCount(eventNames) {
        eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];
        let count = 0;
        for (const eventName of eventNames) {
          if (typeof eventName === "string") {
            count += anyMap.get(this).size + getListeners(this, eventName).size + getEventProducers(this, eventName).size + getEventProducers(this).size;
            continue;
          }
          if (typeof eventName !== "undefined") {
            assertEventName(eventName);
          }
          count += anyMap.get(this).size;
          for (const value2 of eventsMap.get(this).values()) {
            count += value2.size;
          }
          for (const value2 of producersMap.get(this).values()) {
            count += value2.size;
          }
        }
        return count;
      }
      bindMethods(target, methodNames) {
        if (typeof target !== "object" || target === null) {
          throw new TypeError("`target` must be an object");
        }
        methodNames = defaultMethodNamesOrAssert(methodNames);
        for (const methodName of methodNames) {
          if (target[methodName] !== void 0) {
            throw new Error(`The property \`${methodName}\` already exists on \`target\``);
          }
          Object.defineProperty(target, methodName, {
            enumerable: false,
            value: this[methodName].bind(this)
          });
        }
      }
    };
    var allEmitteryMethods = Object.getOwnPropertyNames(Emittery.prototype).filter((v) => v !== "constructor");
    Object.defineProperty(Emittery, "listenerAdded", {
      value: listenerAdded,
      writable: false,
      enumerable: true,
      configurable: false
    });
    Object.defineProperty(Emittery, "listenerRemoved", {
      value: listenerRemoved,
      writable: false,
      enumerable: true,
      configurable: false
    });
    module2.exports = Emittery;
  }
});

// node_modules/matcher/node_modules/escape-string-regexp/index.js
var require_escape_string_regexp = __commonJS({
  "node_modules/matcher/node_modules/escape-string-regexp/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (string) => {
      if (typeof string !== "string") {
        throw new TypeError("Expected a string");
      }
      return string.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
    };
  }
});

// node_modules/matcher/index.js
var require_matcher2 = __commonJS({
  "node_modules/matcher/index.js"(exports2, module2) {
    "use strict";
    var escapeStringRegexp = require_escape_string_regexp();
    var regexpCache = /* @__PURE__ */ new Map();
    function makeRegexp(pattern, options) {
      options = {
        caseSensitive: false,
        ...options
      };
      const cacheKey = pattern + JSON.stringify(options);
      if (regexpCache.has(cacheKey)) {
        return regexpCache.get(cacheKey);
      }
      const negated = pattern[0] === "!";
      if (negated) {
        pattern = pattern.slice(1);
      }
      pattern = escapeStringRegexp(pattern).replace(/\\\*/g, "[\\s\\S]*");
      const regexp = new RegExp(`^${pattern}$`, options.caseSensitive ? "" : "i");
      regexp.negated = negated;
      regexpCache.set(cacheKey, regexp);
      return regexp;
    }
    module2.exports = (inputs, patterns, options) => {
      if (!(Array.isArray(inputs) && Array.isArray(patterns))) {
        throw new TypeError(`Expected two arrays, got ${typeof inputs} ${typeof patterns}`);
      }
      if (patterns.length === 0) {
        return inputs;
      }
      const isFirstPatternNegated = patterns[0][0] === "!";
      patterns = patterns.map((pattern) => makeRegexp(pattern, options));
      const result = [];
      for (const input of inputs) {
        let matches = isFirstPatternNegated;
        for (const pattern of patterns) {
          if (pattern.test(input)) {
            matches = !pattern.negated;
          }
        }
        if (matches) {
          result.push(input);
        }
      }
      return result;
    };
    module2.exports.isMatch = (input, pattern, options) => {
      const inputArray = Array.isArray(input) ? input : [input];
      const patternArray = Array.isArray(pattern) ? pattern : [pattern];
      return inputArray.some((input2) => {
        return patternArray.every((pattern2) => {
          const regexp = makeRegexp(pattern2, options);
          const matches = regexp.test(input2);
          return regexp.negated ? !matches : matches;
        });
      });
    };
  }
});

// node_modules/ava/lib/context-ref.js
var require_context_ref = __commonJS({
  "node_modules/ava/lib/context-ref.js"(exports2, module2) {
    "use strict";
    var clone = require("lodash/clone");
    var ContextRef = class {
      constructor() {
        this.value = {};
      }
      get() {
        return this.value;
      }
      set(newValue) {
        this.value = newValue;
      }
      copy() {
        return new LateBinding(this);
      }
    };
    module2.exports = ContextRef;
    var LateBinding = class extends ContextRef {
      constructor(ref) {
        super();
        this.ref = ref;
        this.bound = false;
      }
      get() {
        if (!this.bound) {
          this.set(clone(this.ref.get()));
        }
        return super.get();
      }
      set(newValue) {
        this.bound = true;
        super.set(newValue);
      }
    };
  }
});

// node_modules/ava/lib/create-chain.js
var require_create_chain = __commonJS({
  "node_modules/ava/lib/create-chain.js"(exports2, module2) {
    "use strict";
    var chainRegistry = /* @__PURE__ */ new WeakMap();
    function startChain(name, call, defaults) {
      const fn = (...args) => {
        call({ ...defaults }, args);
      };
      Object.defineProperty(fn, "name", { value: name });
      chainRegistry.set(fn, { call, defaults, fullName: name });
      return fn;
    }
    function extendChain(previous, name, flag) {
      if (!flag) {
        flag = name;
      }
      const fn = (...args) => {
        callWithFlag(previous, flag, args);
      };
      const fullName = `${chainRegistry.get(previous).fullName}.${name}`;
      Object.defineProperty(fn, "name", { value: fullName });
      previous[name] = fn;
      chainRegistry.set(fn, { flag, fullName, prev: previous });
      return fn;
    }
    function callWithFlag(previous, flag, args) {
      const combinedFlags = { [flag]: true };
      do {
        const step = chainRegistry.get(previous);
        if (step.call) {
          step.call({ ...step.defaults, ...combinedFlags }, args);
          previous = null;
        } else {
          combinedFlags[step.flag] = true;
          previous = step.prev;
        }
      } while (previous);
    }
    function createHookChain(hook, isAfterHook) {
      extendChain(hook, "cb", "callback");
      extendChain(hook, "skip", "skipped");
      extendChain(hook.cb, "skip", "skipped");
      if (isAfterHook) {
        extendChain(hook, "always");
        extendChain(hook.always, "cb", "callback");
        extendChain(hook.always, "skip", "skipped");
        extendChain(hook.always.cb, "skip", "skipped");
      }
      return hook;
    }
    function createChain(fn, defaults, meta) {
      const root = startChain("test", fn, { ...defaults, type: "test" });
      extendChain(root, "cb", "callback");
      extendChain(root, "failing");
      extendChain(root, "only", "exclusive");
      extendChain(root, "serial");
      extendChain(root, "skip", "skipped");
      extendChain(root.cb, "failing");
      extendChain(root.cb, "only", "exclusive");
      extendChain(root.cb, "skip", "skipped");
      extendChain(root.cb.failing, "only", "exclusive");
      extendChain(root.cb.failing, "skip", "skipped");
      extendChain(root.failing, "only", "exclusive");
      extendChain(root.failing, "skip", "skipped");
      extendChain(root.serial, "cb", "callback");
      extendChain(root.serial, "failing");
      extendChain(root.serial, "only", "exclusive");
      extendChain(root.serial, "skip", "skipped");
      extendChain(root.serial.cb, "failing");
      extendChain(root.serial.cb, "only", "exclusive");
      extendChain(root.serial.cb, "skip", "skipped");
      extendChain(root.serial.cb.failing, "only", "exclusive");
      extendChain(root.serial.cb.failing, "skip", "skipped");
      extendChain(root.serial.failing, "only", "exclusive");
      extendChain(root.serial.failing, "skip", "skipped");
      root.after = createHookChain(startChain("test.after", fn, { ...defaults, type: "after" }), true);
      root.afterEach = createHookChain(startChain("test.afterEach", fn, { ...defaults, type: "afterEach" }), true);
      root.before = createHookChain(startChain("test.before", fn, { ...defaults, type: "before" }), false);
      root.beforeEach = createHookChain(startChain("test.beforeEach", fn, { ...defaults, type: "beforeEach" }), false);
      root.serial.after = createHookChain(startChain("test.after", fn, { ...defaults, serial: true, type: "after" }), true);
      root.serial.afterEach = createHookChain(startChain("test.afterEach", fn, { ...defaults, serial: true, type: "afterEach" }), true);
      root.serial.before = createHookChain(startChain("test.before", fn, { ...defaults, serial: true, type: "before" }), false);
      root.serial.beforeEach = createHookChain(startChain("test.beforeEach", fn, { ...defaults, serial: true, type: "beforeEach" }), false);
      root.todo = startChain("test.todo", fn, { ...defaults, type: "test", todo: true });
      root.serial.todo = startChain("test.serial.todo", fn, { ...defaults, serial: true, type: "test", todo: true });
      root.meta = meta;
      return root;
    }
    module2.exports = createChain;
  }
});

// node_modules/ava/lib/parse-test-args.js
var require_parse_test_args = __commonJS({
  "node_modules/ava/lib/parse-test-args.js"(exports2, module2) {
    "use strict";
    function parseTestArgs(args) {
      const rawTitle = typeof args[0] === "string" ? args.shift() : void 0;
      const receivedImplementationArray = Array.isArray(args[0]);
      const implementations = receivedImplementationArray ? args.shift() : args.splice(0, 1);
      const buildTitle = (implementation) => {
        const title = implementation.title ? implementation.title(rawTitle, ...args) : rawTitle;
        return { title, isSet: typeof title !== "undefined", isValid: typeof title === "string", isEmpty: !title };
      };
      return { args, buildTitle, implementations, rawTitle, receivedImplementationArray };
    }
    module2.exports = parseTestArgs;
  }
});

// node_modules/concordance/lib/Circular.js
var require_Circular = __commonJS({
  "node_modules/concordance/lib/Circular.js"(exports2, module2) {
    "use strict";
    var Circular = class {
      constructor() {
        this.stack = /* @__PURE__ */ new Map();
      }
      add(descriptor) {
        if (this.stack.has(descriptor)) throw new Error("Already in stack");
        if (descriptor.isItem !== true && descriptor.isMapEntry !== true && descriptor.isProperty !== true) {
          this.stack.set(descriptor, this.stack.size + 1);
        }
        return this;
      }
      delete(descriptor) {
        if (this.stack.has(descriptor)) {
          if (this.stack.get(descriptor) !== this.stack.size) throw new Error("Not on top of stack");
          this.stack.delete(descriptor);
        }
        return this;
      }
      has(descriptor) {
        return this.stack.has(descriptor);
      }
      get(descriptor) {
        return this.stack.has(descriptor) ? this.stack.get(descriptor) : 0;
      }
    };
    module2.exports = Circular;
  }
});

// node_modules/concordance/lib/constants.js
var require_constants4 = __commonJS({
  "node_modules/concordance/lib/constants.js"(exports2, module2) {
    "use strict";
    var AMBIGUOUS = Symbol("AMBIGUOUS");
    var DEEP_EQUAL = Symbol("DEEP_EQUAL");
    var SHALLOW_EQUAL = Symbol("SHALLOW_EQUAL");
    var UNEQUAL = Symbol("UNEQUAL");
    module2.exports = {
      AMBIGUOUS,
      DEEP_EQUAL,
      SHALLOW_EQUAL,
      UNEQUAL
    };
  }
});

// node_modules/concordance/lib/Registry.js
var require_Registry = __commonJS({
  "node_modules/concordance/lib/Registry.js"(exports2, module2) {
    "use strict";
    var Registry = class {
      constructor() {
        this.counter = 0;
        this.map = /* @__PURE__ */ new WeakMap();
      }
      has(value2) {
        return this.map.has(value2);
      }
      get(value2) {
        return this.map.get(value2).descriptor;
      }
      alloc(value2) {
        const index = ++this.counter;
        const pointer = { descriptor: null, index };
        this.map.set(value2, pointer);
        return pointer;
      }
    };
    module2.exports = Registry;
  }
});

// node_modules/concordance/lib/lineBuilder.js
var require_lineBuilder = __commonJS({
  "node_modules/concordance/lib/lineBuilder.js"(exports2, module2) {
    "use strict";
    var ACTUAL = Symbol("lineBuilder.gutters.ACTUAL");
    var EXPECTED = Symbol("lineBuilder.gutters.EXPECTED");
    function translateGutter(theme, invert, gutter) {
      if (invert) {
        if (gutter === ACTUAL) return theme.diffGutters.expected;
        if (gutter === EXPECTED) return theme.diffGutters.actual;
      } else {
        if (gutter === ACTUAL) return theme.diffGutters.actual;
        if (gutter === EXPECTED) return theme.diffGutters.expected;
      }
      return theme.diffGutters.padding;
    }
    var Line = class _Line {
      constructor(isFirst, isLast, gutter, stringValue) {
        this.isFirst = isFirst;
        this.isLast = isLast;
        this.gutter = gutter;
        this.stringValue = stringValue;
      }
      *[Symbol.iterator]() {
        yield this;
      }
      get isEmpty() {
        return false;
      }
      get hasGutter() {
        return this.gutter !== null;
      }
      get isSingle() {
        return this.isFirst && this.isLast;
      }
      append(other) {
        return this.concat(other);
      }
      concat(other) {
        return new Collection().append(this).append(other);
      }
      toString(options) {
        if (options.diff === false) return this.stringValue;
        return translateGutter(options.theme, options.invert, this.gutter) + this.stringValue;
      }
      mergeWithInfix(infix, other) {
        if (other.isLine !== true) {
          return new Collection().append(this).mergeWithInfix(infix, other);
        }
        return new _Line(this.isFirst, other.isLast, other.gutter, this.stringValue + infix + other.stringValue);
      }
      withFirstPrefixed(prefix) {
        if (!this.isFirst) return this;
        return new _Line(true, this.isLast, this.gutter, prefix + this.stringValue);
      }
      withLastPostfixed(postfix) {
        if (!this.isLast) return this;
        return new _Line(this.isFirst, true, this.gutter, this.stringValue + postfix);
      }
      stripFlags() {
        return new _Line(false, false, this.gutter, this.stringValue);
      }
      decompose() {
        return new Collection().append(this).decompose();
      }
    };
    Object.defineProperty(Line.prototype, "isLine", { value: true });
    var Collection = class _Collection {
      constructor() {
        this.buffer = [];
      }
      *[Symbol.iterator]() {
        for (const appended of this.buffer) {
          for (const line of appended) yield line;
        }
      }
      get isEmpty() {
        return this.buffer.length === 0;
      }
      get hasGutter() {
        for (const line of this) {
          if (line.hasGutter) return true;
        }
        return false;
      }
      get isSingle() {
        const iterator = this[Symbol.iterator]();
        iterator.next();
        return iterator.next().done === true;
      }
      append(lineOrLines) {
        if (!lineOrLines.isEmpty) this.buffer.push(lineOrLines);
        return this;
      }
      concat(other) {
        return new _Collection().append(this).append(other);
      }
      toString(options) {
        let lines = this;
        if (options.invert) {
          lines = new _Collection();
          let buffer = new _Collection();
          let prev = null;
          for (const line of this) {
            if (line.gutter === ACTUAL) {
              if (prev !== null && prev.gutter !== ACTUAL && !buffer.isEmpty) {
                lines.append(buffer);
                buffer = new _Collection();
              }
              buffer.append(line);
            } else if (line.gutter === EXPECTED) {
              lines.append(line);
            } else {
              if (!buffer.isEmpty) {
                lines.append(buffer);
                buffer = new _Collection();
              }
              lines.append(line);
            }
            prev = line;
          }
          lines.append(buffer);
        }
        return Array.from(lines, (line) => line.toString(options)).join("\n");
      }
      mergeWithInfix(infix, from) {
        if (from.isEmpty) throw new Error("Cannot merge, `from` is empty.");
        const otherLines = Array.from(from);
        if (!otherLines[0].isFirst) throw new Error("Cannot merge, `from` has no first line.");
        const merged = new _Collection();
        let seenLast = false;
        for (const line of this) {
          if (seenLast) throw new Error("Cannot merge line, the last line has already been seen.");
          if (!line.isLast) {
            merged.append(line);
            continue;
          }
          seenLast = true;
          for (const other of otherLines) {
            if (other.isFirst) {
              merged.append(line.mergeWithInfix(infix, other));
            } else {
              merged.append(other);
            }
          }
        }
        return merged;
      }
      withFirstPrefixed(prefix) {
        return new _Collection().append(Array.from(this, (line) => line.withFirstPrefixed(prefix)));
      }
      withLastPostfixed(postfix) {
        return new _Collection().append(Array.from(this, (line) => line.withLastPostfixed(postfix)));
      }
      stripFlags() {
        return new _Collection().append(Array.from(this, (line) => line.stripFlags()));
      }
      decompose() {
        const first = { actual: new _Collection(), expected: new _Collection() };
        const last = { actual: new _Collection(), expected: new _Collection() };
        const remaining = new _Collection();
        for (const line of this) {
          if (line.isFirst && line.gutter === ACTUAL) {
            first.actual.append(line);
          } else if (line.isFirst && line.gutter === EXPECTED) {
            first.expected.append(line);
          } else if (line.isLast && line.gutter === ACTUAL) {
            last.actual.append(line);
          } else if (line.isLast && line.gutter === EXPECTED) {
            last.expected.append(line);
          } else {
            remaining.append(line);
          }
        }
        return { first, last, remaining };
      }
    };
    Object.defineProperty(Collection.prototype, "isCollection", { value: true });
    function setDefaultGutter(iterable, gutter) {
      return new Collection().append(Array.from(iterable, (line) => {
        return line.gutter === null ? new Line(line.isFirst, line.isLast, gutter, line.stringValue) : line;
      }));
    }
    module2.exports = {
      buffer() {
        return new Collection();
      },
      first(stringValue) {
        return new Line(true, false, null, stringValue);
      },
      last(stringValue) {
        return new Line(false, true, null, stringValue);
      },
      line(stringValue) {
        return new Line(false, false, null, stringValue);
      },
      single(stringValue) {
        return new Line(true, true, null, stringValue);
      },
      setDefaultGutter(lineOrCollection) {
        return lineOrCollection;
      },
      actual: {
        first(stringValue) {
          return new Line(true, false, ACTUAL, stringValue);
        },
        last(stringValue) {
          return new Line(false, true, ACTUAL, stringValue);
        },
        line(stringValue) {
          return new Line(false, false, ACTUAL, stringValue);
        },
        single(stringValue) {
          return new Line(true, true, ACTUAL, stringValue);
        },
        setDefaultGutter(lineOrCollection) {
          return setDefaultGutter(lineOrCollection, ACTUAL);
        }
      },
      expected: {
        first(stringValue) {
          return new Line(true, false, EXPECTED, stringValue);
        },
        last(stringValue) {
          return new Line(false, true, EXPECTED, stringValue);
        },
        line(stringValue) {
          return new Line(false, false, EXPECTED, stringValue);
        },
        single(stringValue) {
          return new Line(true, true, EXPECTED, stringValue);
        },
        setDefaultGutter(lineOrCollection) {
          return setDefaultGutter(lineOrCollection, EXPECTED);
        }
      }
    };
  }
});

// node_modules/concordance/lib/formatUtils.js
var require_formatUtils = __commonJS({
  "node_modules/concordance/lib/formatUtils.js"(exports2) {
    "use strict";
    var lineBuilder = require_lineBuilder();
    function wrap(fromTheme, value2) {
      return fromTheme.open + value2 + fromTheme.close;
    }
    exports2.wrap = wrap;
    function formatCtorAndStringTag(theme, object) {
      if (!object.ctor) return wrap(theme.object.stringTag, object.stringTag);
      let retval = wrap(theme.object.ctor, object.ctor);
      if (object.stringTag && object.stringTag !== object.ctor && object.stringTag !== "Object") {
        retval += " " + wrap(theme.object.secondaryStringTag, object.stringTag);
      }
      return retval;
    }
    exports2.formatCtorAndStringTag = formatCtorAndStringTag;
    var ObjectFormatter = class {
      constructor(object, theme, indent) {
        this.object = object;
        this.theme = theme;
        this.indent = indent;
        this.increaseIndent = true;
        this.innerLines = lineBuilder.buffer();
        this.pendingStats = null;
      }
      append(formatted, origin) {
        if (origin.isStats === true) {
          this.pendingStats = formatted;
        } else {
          if (this.pendingStats !== null) {
            if (!this.innerLines.isEmpty) {
              this.innerLines.append(this.pendingStats);
            }
            this.pendingStats = null;
          }
          this.innerLines.append(formatted);
        }
      }
      finalize() {
        const variant = this.object.isList ? this.theme.list : this.theme.object;
        const ctor = this.object.ctor;
        const stringTag = this.object.stringTag;
        const prefix = (ctor === "Array" || ctor === "Object") && ctor === stringTag ? "" : formatCtorAndStringTag(this.theme, this.object) + " ";
        if (this.innerLines.isEmpty) {
          return lineBuilder.single(prefix + variant.openBracket + variant.closeBracket);
        }
        return lineBuilder.first(prefix + variant.openBracket).concat(this.innerLines.withFirstPrefixed(this.indent.increase()).stripFlags()).append(lineBuilder.last(this.indent + variant.closeBracket));
      }
      maxDepth() {
        const variant = this.object.isList ? this.theme.list : this.theme.object;
        return lineBuilder.single(
          formatCtorAndStringTag(this.theme, this.object) + " " + variant.openBracket + " " + this.theme.maxDepth + " " + variant.closeBracket
        );
      }
      shouldFormat() {
        return true;
      }
      customize(methods) {
        if (methods.finalize) {
          this.finalize = () => methods.finalize(this.innerLines);
        }
        if (methods.maxDepth) {
          this.maxDepth = methods.maxDepth;
        }
        if (methods.shouldFormat) {
          this.shouldFormat = methods.shouldFormat;
        }
        return this;
      }
    };
    exports2.ObjectFormatter = ObjectFormatter;
    var SingleValueFormatter = class {
      constructor(theme, finalizeFn, increaseIndent) {
        this.theme = theme;
        this.finalizeFn = finalizeFn;
        this.hasValue = false;
        this.increaseIndent = increaseIndent === true;
        this.value = null;
      }
      append(formatted) {
        if (this.hasValue) throw new Error("Formatter buffer can only take one formatted value.");
        this.hasValue = true;
        this.value = formatted;
      }
      finalize() {
        if (!this.hasValue) throw new Error("Formatter buffer never received a formatted value.");
        return this.finalizeFn(this.value);
      }
      maxDepth() {
        return this.finalizeFn(lineBuilder.single(this.theme.maxDepth));
      }
    };
    exports2.SingleValueFormatter = SingleValueFormatter;
  }
});

// node_modules/concordance/lib/getObjectKeys.js
var require_getObjectKeys = __commonJS({
  "node_modules/concordance/lib/getObjectKeys.js"(exports2, module2) {
    "use strict";
    function getObjectKeys(obj, excludeListItemAccessorsBelowLength) {
      const keys = [];
      let size = 0;
      const nameCandidates = Object.getOwnPropertyNames(obj).sort();
      const symbolCandidates = Object.getOwnPropertySymbols(obj);
      for (const name of nameCandidates) {
        let accept = true;
        if (excludeListItemAccessorsBelowLength > 0) {
          const index = Number(name);
          accept = !Number.isInteger(index) || index < 0 || index >= excludeListItemAccessorsBelowLength;
        }
        if (accept && Object.getOwnPropertyDescriptor(obj, name).enumerable) {
          keys[size++] = name;
        }
      }
      for (const symbol of symbolCandidates) {
        if (Object.getOwnPropertyDescriptor(obj, symbol).enumerable) {
          keys[size++] = symbol;
        }
      }
      return { keys, size };
    }
    module2.exports = getObjectKeys;
  }
});

// node_modules/concordance/lib/hasLength.js
var require_hasLength = __commonJS({
  "node_modules/concordance/lib/hasLength.js"(exports2, module2) {
    "use strict";
    var isLength = require("lodash/isLength");
    var hop = Object.prototype.hasOwnProperty;
    function hasLength(obj) {
      return Array.isArray(obj) || hop.call(obj, "length") && isLength(obj.length) && (obj.length === 0 || "0" in obj);
    }
    module2.exports = hasLength;
  }
});

// node_modules/concordance/lib/recursorUtils.js
var require_recursorUtils = __commonJS({
  "node_modules/concordance/lib/recursorUtils.js"(exports2) {
    "use strict";
    var NOOP_RECURSOR = {
      size: 0,
      next() {
        return null;
      }
    };
    exports2.NOOP_RECURSOR = NOOP_RECURSOR;
    function fork(recursor) {
      const buffer = [];
      return {
        shared() {
          const next = recursor();
          if (next !== null) buffer.push(next);
          return next;
        },
        recursor() {
          if (buffer.length > 0) return buffer.shift();
          return recursor();
        }
      };
    }
    exports2.fork = fork;
    function consumeDeep(recursor) {
      const stack = [recursor];
      while (stack.length > 0) {
        const subject = stack[stack.length - 1]();
        if (subject === null) {
          stack.pop();
          continue;
        }
        if (typeof subject.createRecursor === "function") {
          stack.push(subject.createRecursor());
        }
      }
    }
    exports2.consumeDeep = consumeDeep;
    function map(recursor, mapFn) {
      return () => {
        const next = recursor();
        if (next === null) return null;
        return mapFn(next);
      };
    }
    exports2.map = map;
    function replay(state, create) {
      if (!state) {
        const recursor = create();
        if (recursor === NOOP_RECURSOR) {
          state = recursor;
        } else {
          state = Object.assign({
            buffer: [],
            done: false
          }, recursor);
        }
      }
      if (state === NOOP_RECURSOR) return { state, recursor: state };
      let done = false;
      let index = 0;
      const next = () => {
        if (done) return null;
        let retval = state.buffer[index];
        if (retval === void 0) {
          retval = state.buffer[index] = state.next();
        }
        index++;
        if (retval === null) {
          done = true;
        }
        return retval;
      };
      return { state, recursor: { next, size: state.size } };
    }
    exports2.replay = replay;
    function sequence(first, second) {
      let fromFirst = true;
      return () => {
        if (fromFirst) {
          const next = first();
          if (next !== null) return next;
          fromFirst = false;
        }
        return second();
      };
    }
    exports2.sequence = sequence;
    function singleValue(value2) {
      let done = false;
      return () => {
        if (done) return null;
        done = true;
        return value2;
      };
    }
    exports2.singleValue = singleValue;
    function unshift(recursor, value2) {
      return () => {
        if (value2 !== null) {
          const next = value2;
          value2 = null;
          return next;
        }
        return recursor();
      };
    }
    exports2.unshift = unshift;
  }
});

// node_modules/concordance/lib/metaDescriptors/stats.js
var require_stats = __commonJS({
  "node_modules/concordance/lib/metaDescriptors/stats.js"(exports2) {
    "use strict";
    var constants = require_constants4();
    var lineBuilder = require_lineBuilder();
    var recursorUtils = require_recursorUtils();
    var DEEP_EQUAL = constants.DEEP_EQUAL;
    var UNEQUAL = constants.UNEQUAL;
    function describeIterableRecursor(recursor) {
      return new IterableStats(recursor.size);
    }
    exports2.describeIterableRecursor = describeIterableRecursor;
    function describeListRecursor(recursor) {
      return new ListStats(recursor.size);
    }
    exports2.describeListRecursor = describeListRecursor;
    function describePropertyRecursor(recursor) {
      return new PropertyStats(recursor.size);
    }
    exports2.describePropertyRecursor = describePropertyRecursor;
    function deserializeIterableStats(size) {
      return new IterableStats(size);
    }
    exports2.deserializeIterableStats = deserializeIterableStats;
    function deserializeListStats(size) {
      return new ListStats(size);
    }
    exports2.deserializeListStats = deserializeListStats;
    function deserializePropertyStats(size) {
      return new PropertyStats(size);
    }
    exports2.deserializePropertyStats = deserializePropertyStats;
    var iterableTag = Symbol("IterableStats");
    exports2.iterableTag = iterableTag;
    var listTag = Symbol("ListStats");
    exports2.listTag = listTag;
    var propertyTag = Symbol("PropertyStats");
    exports2.propertyTag = propertyTag;
    var Stats = class {
      constructor(size) {
        this.size = size;
      }
      formatDeep(theme) {
        return lineBuilder.single(theme.stats.separator);
      }
      prepareDiff(expected, lhsRecursor, rhsRecursor, compareComplexShape) {
        if (expected.isStats !== true || expected.tag === this.tag) return null;
        const rhsFork = recursorUtils.fork(rhsRecursor);
        const initialExpected = expected;
        const missing = [];
        while (expected !== null && this.tag !== expected.tag) {
          missing.push(expected);
          expected = rhsFork.shared();
        }
        if (expected !== null && missing.length > 0) {
          return {
            multipleAreMissing: true,
            descriptors: missing,
            lhsRecursor: recursorUtils.unshift(lhsRecursor, this),
            // Use original `rhsRecursor`, not `rhsFork`, since the consumed
            // descriptors are returned with the `missing` array.
            rhsRecursor: recursorUtils.unshift(rhsRecursor, expected)
          };
        }
        const lhsFork = recursorUtils.fork(lhsRecursor);
        let actual = this;
        const extraneous = [];
        while (actual !== null && actual.tag !== initialExpected.tag) {
          extraneous.push(actual);
          actual = lhsFork.shared();
        }
        if (actual !== null && extraneous.length > 0) {
          return {
            multipleAreExtraneous: true,
            descriptors: extraneous,
            // Use original `lhsRecursor`, not `lhsFork`, since the consumed
            // descriptors are returned with the `extraneous` array.
            lhsRecursor: recursorUtils.unshift(lhsRecursor, actual),
            rhsRecursor: recursorUtils.unshift(rhsFork.recursor, initialExpected)
          };
        }
        return null;
      }
      serialize() {
        return this.size;
      }
    };
    Object.defineProperty(Stats.prototype, "isStats", { value: true });
    var IterableStats = class extends Stats {
      compare(expected) {
        return expected.tag === iterableTag && this.size === expected.size ? DEEP_EQUAL : UNEQUAL;
      }
    };
    Object.defineProperty(IterableStats.prototype, "tag", { value: iterableTag });
    var ListStats = class extends Stats {
      compare(expected) {
        return expected.tag === listTag && this.size === expected.size ? DEEP_EQUAL : UNEQUAL;
      }
    };
    Object.defineProperty(ListStats.prototype, "tag", { value: listTag });
    var PropertyStats = class extends Stats {
      compare(expected) {
        return expected.tag === propertyTag && this.size === expected.size ? DEEP_EQUAL : UNEQUAL;
      }
    };
    Object.defineProperty(PropertyStats.prototype, "tag", { value: propertyTag });
  }
});

// node_modules/concordance/lib/complexValues/object.js
var require_object = __commonJS({
  "node_modules/concordance/lib/complexValues/object.js"(exports2) {
    "use strict";
    var constants = require_constants4();
    var ObjectFormatter = require_formatUtils().ObjectFormatter;
    var getObjectKeys = require_getObjectKeys();
    var hasLength = require_hasLength();
    var stats = require_stats();
    var recursorUtils = require_recursorUtils();
    var DEEP_EQUAL = constants.DEEP_EQUAL;
    var SHALLOW_EQUAL = constants.SHALLOW_EQUAL;
    var UNEQUAL = constants.UNEQUAL;
    function describe(props) {
      const isArray = props.stringTag === "Array";
      const object = props.value;
      return new DescribedObjectValue(Object.assign({
        isArray,
        isIterable: object[Symbol.iterator] !== void 0,
        isList: isArray || hasLength(object)
      }, props));
    }
    exports2.describe = describe;
    function deserialize(state, recursor) {
      return new DeserializedObjectValue(state, recursor);
    }
    exports2.deserialize = deserialize;
    var tag = Symbol("ObjectValue");
    exports2.tag = tag;
    var ObjectValue = class {
      constructor(props) {
        this.ctor = props.ctor;
        this.pointer = props.pointer;
        this.stringTag = props.stringTag;
        this.isArray = props.isArray === true;
        this.isIterable = props.isIterable === true;
        this.isList = props.isList === true;
      }
      compare(expected) {
        if (this.tag !== expected.tag) return UNEQUAL;
        if (this.stringTag !== expected.stringTag || !this.hasSameCtor(expected)) return UNEQUAL;
        return SHALLOW_EQUAL;
      }
      hasSameCtor(expected) {
        return this.ctor === expected.ctor;
      }
      formatShallow(theme, indent) {
        return new ObjectFormatter(this, theme, indent);
      }
      serialize() {
        return [
          this.ctor,
          this.pointer,
          this.stringTag,
          this.isArray,
          this.isIterable,
          this.isList
        ];
      }
    };
    Object.defineProperty(ObjectValue.prototype, "isComplex", { value: true });
    Object.defineProperty(ObjectValue.prototype, "tag", { value: tag });
    exports2.ObjectValue = ObjectValue;
    var DescribedObjectValue = DescribedMixin(ObjectValue);
    var DeserializedObjectValue = DeserializedMixin(ObjectValue);
    function DescribedMixin(base) {
      return class extends base {
        constructor(props) {
          super(props);
          this.value = props.value;
          this.describeAny = props.describeAny;
          this.describeItem = props.describeItem;
          this.describeMapEntry = props.describeMapEntry;
          this.describeProperty = props.describeProperty;
          this.iterableState = null;
          this.listState = null;
          this.propertyState = null;
        }
        compare(expected) {
          return this.value === expected.value ? DEEP_EQUAL : super.compare(expected);
        }
        createPropertyRecursor() {
          const objectKeys = getObjectKeys(this.value, this.isList ? this.value.length : 0);
          const size = objectKeys.size;
          if (size === 0) return recursorUtils.NOOP_RECURSOR;
          let index = 0;
          const next = () => {
            if (index === size) return null;
            const key = objectKeys.keys[index++];
            return this.describeProperty(key, this.describeAny(this.value[key]));
          };
          return { size, next };
        }
        createListRecursor() {
          if (!this.isList) return recursorUtils.NOOP_RECURSOR;
          const size = this.value.length;
          if (size === 0) return recursorUtils.NOOP_RECURSOR;
          let index = 0;
          const next = () => {
            if (index === size) return null;
            const current = index;
            index++;
            return this.describeItem(current, this.describeAny(this.value[current]));
          };
          return { size, next };
        }
        createIterableRecursor() {
          if (this.isArray || !this.isIterable) return recursorUtils.NOOP_RECURSOR;
          const iterator = this.value[Symbol.iterator]();
          let first = iterator.next();
          let done = false;
          let size = -1;
          if (first.done) {
            if (first.value === void 0) {
              size = 0;
              done = true;
            } else {
              size = 1;
            }
          }
          let index = 0;
          const next = () => {
            if (done) return null;
            while (!done) {
              const current = first || iterator.next();
              if (current === first) {
                first = null;
              }
              if (current.done) {
                done = true;
              }
              const item = current.value;
              if (done && item === void 0) return null;
              if (this.isList && this.value[index] === item) {
                index++;
              } else {
                return this.describeItem(index++, this.describeAny(item));
              }
            }
          };
          return { size, next };
        }
        createRecursor() {
          let recursedProperty = false;
          let recursedList = false;
          let recursedIterable = false;
          let recursor = null;
          return () => {
            let retval = null;
            do {
              if (recursor !== null) {
                retval = recursor.next();
                if (retval === null) {
                  recursor = null;
                }
              }
              while (recursor === null && (!recursedList || !recursedProperty || !recursedIterable)) {
                if (!recursedList) {
                  const replay = recursorUtils.replay(this.listState, () => this.createListRecursor());
                  this.listState = replay.state;
                  recursor = replay.recursor;
                  recursedList = true;
                  if (recursor !== recursorUtils.NOOP_RECURSOR) {
                    retval = stats.describeListRecursor(recursor);
                  }
                } else if (!recursedProperty) {
                  const replay = recursorUtils.replay(this.propertyState, () => this.createPropertyRecursor());
                  this.propertyState = replay.state;
                  recursor = replay.recursor;
                  recursedProperty = true;
                  if (recursor !== recursorUtils.NOOP_RECURSOR) {
                    retval = stats.describePropertyRecursor(recursor);
                  }
                } else if (!recursedIterable) {
                  const replay = recursorUtils.replay(this.iterableState, () => this.createIterableRecursor());
                  this.iterableState = replay.state;
                  recursor = replay.recursor;
                  recursedIterable = true;
                  if (recursor !== recursorUtils.NOOP_RECURSOR) {
                    retval = stats.describeIterableRecursor(recursor);
                  }
                }
              }
            } while (recursor !== null && retval === null);
            return retval;
          };
        }
      };
    }
    exports2.DescribedMixin = DescribedMixin;
    function DeserializedMixin(base) {
      return class extends base {
        constructor(state, recursor) {
          super({
            ctor: state[0],
            pointer: state[1],
            stringTag: state[2],
            isArray: state[3],
            isIterable: state[4],
            isList: state[5]
          });
          this.deserializedRecursor = recursor;
          this.replayState = null;
        }
        createRecursor() {
          if (!this.deserializedRecursor) return () => null;
          const replay = recursorUtils.replay(this.replayState, () => ({ size: -1, next: this.deserializedRecursor }));
          this.replayState = replay.state;
          return replay.recursor.next;
        }
        hasSameCtor(expected) {
          return this.ctor === expected.ctor;
        }
      };
    }
    exports2.DeserializedMixin = DeserializedMixin;
  }
});

// node_modules/concordance/lib/complexValues/arguments.js
var require_arguments = __commonJS({
  "node_modules/concordance/lib/complexValues/arguments.js"(exports2) {
    "use strict";
    var constants = require_constants4();
    var object = require_object();
    var AMBIGUOUS = constants.AMBIGUOUS;
    var UNEQUAL = constants.UNEQUAL;
    function describe(props) {
      return new DescribedArgumentsValue(Object.assign({
        // Treat as an array, to allow comparisons with arrays
        isArray: true,
        isList: true
      }, props, { ctor: "Arguments" }));
    }
    exports2.describe = describe;
    function deserialize(state, recursor) {
      return new DeserializedArgumentsValue(state, recursor);
    }
    exports2.deserialize = deserialize;
    var tag = Symbol("ArgumentsValue");
    exports2.tag = tag;
    var ArgumentsValue = class extends object.ObjectValue {
      compare(expected) {
        if (expected.isComplex !== true) return UNEQUAL;
        if (expected.stringTag === "Array") return AMBIGUOUS;
        return super.compare(expected);
      }
    };
    Object.defineProperty(ArgumentsValue.prototype, "tag", { value: tag });
    var DescribedArgumentsValue = object.DescribedMixin(ArgumentsValue);
    var DeserializedArgumentsValue = class extends object.DeserializedMixin(ArgumentsValue) {
      compare(expected) {
        return expected.isComplex === true && expected.stringTag === "Array" ? UNEQUAL : super.compare(expected);
      }
    };
  }
});

// node_modules/concordance/lib/complexValues/typedArray.js
var require_typedArray = __commonJS({
  "node_modules/concordance/lib/complexValues/typedArray.js"(exports2) {
    "use strict";
    var constants = require_constants4();
    var formatUtils = require_formatUtils();
    var lineBuilder = require_lineBuilder();
    var propertyStatsTag = require_stats().propertyTag;
    var recursorUtils = require_recursorUtils();
    var object = require_object();
    var DEEP_EQUAL = constants.DEEP_EQUAL;
    var UNEQUAL = constants.UNEQUAL;
    function getBuffer(value2) {
      const buffer = Buffer.from(value2.buffer);
      return value2.byteLength !== value2.buffer.byteLength ? buffer.slice(value2.byteOffset, value2.byteOffset + value2.byteLength) : buffer;
    }
    exports2.getBuffer = getBuffer;
    function describe(props) {
      return new DescribedTypedArrayValue(Object.assign({
        buffer: getBuffer(props.value),
        // Set isArray and isList so the property recursor excludes the byte accessors
        isArray: true,
        isList: true
      }, props));
    }
    exports2.describe = describe;
    function deserialize(state, recursor) {
      return new DeserializedTypedArrayValue(state, recursor);
    }
    exports2.deserialize = deserialize;
    function deserializeBytes(buffer) {
      return new Bytes(buffer);
    }
    exports2.deserializeBytes = deserializeBytes;
    var bytesTag = Symbol("Bytes");
    exports2.bytesTag = bytesTag;
    var tag = Symbol("TypedArrayValue");
    exports2.tag = tag;
    var Bytes = class {
      constructor(buffer) {
        this.buffer = buffer;
      }
      compare(expected) {
        return expected.tag === bytesTag && this.buffer.equals(expected.buffer) ? DEEP_EQUAL : UNEQUAL;
      }
      formatDeep(theme, indent) {
        const indentation = indent;
        const lines = lineBuilder.buffer();
        let string = "";
        let isFirst = true;
        for (let offset = 0; offset < this.buffer.length; offset += 4) {
          if (offset > 0) {
            if (offset % 32 === 0) {
              if (isFirst) {
                lines.append(lineBuilder.first(string));
                isFirst = false;
              } else {
                lines.append(lineBuilder.line(string));
              }
              string = String(indentation);
            } else {
              string += " ";
            }
          }
          string += formatUtils.wrap(theme.typedArray.bytes, this.buffer.toString("hex", offset, offset + 4));
        }
        return isFirst ? lineBuilder.single(string) : lines.append(lineBuilder.last(string));
      }
      serialize() {
        return this.buffer;
      }
    };
    Object.defineProperty(Bytes.prototype, "tag", { value: bytesTag });
    var TypedArrayValue = class extends object.ObjectValue {
      constructor(props) {
        super(props);
        this.buffer = props.buffer;
      }
      formatShallow(theme, indent) {
        return super.formatShallow(theme, indent).customize({
          shouldFormat(subject) {
            if (subject.tag === propertyStatsTag) return subject.size > 1;
            if (subject.isProperty === true) return subject.key.value !== "byteLength";
            if (subject.tag === bytesTag) return subject.buffer.byteLength > 0;
            return true;
          }
        });
      }
    };
    Object.defineProperty(TypedArrayValue.prototype, "tag", { value: tag });
    exports2.TypedArrayValue = TypedArrayValue;
    function DescribedMixin(base) {
      return class extends object.DescribedMixin(base) {
        // The list isn't recursed. Instead a Bytes instance is returned by the main
        // recursor.
        createListRecursor() {
          return recursorUtils.NOOP_RECURSOR;
        }
        createPropertyRecursor() {
          const recursor = super.createPropertyRecursor();
          const size = recursor.size + 1;
          let done = false;
          const next = () => {
            if (done) return null;
            const property = recursor.next();
            if (property) return property;
            done = true;
            return this.describeProperty("byteLength", this.describeAny(this.buffer.byteLength));
          };
          return { size, next };
        }
        createRecursor() {
          return recursorUtils.unshift(super.createRecursor(), new Bytes(this.buffer));
        }
      };
    }
    exports2.DescribedMixin = DescribedMixin;
    var DescribedTypedArrayValue = DescribedMixin(TypedArrayValue);
    function DeserializedMixin(base) {
      return class extends object.DeserializedMixin(base) {
        constructor(state, recursor) {
          super(state, recursor);
          const bytesDescriptor = this.createRecursor()();
          this.buffer = bytesDescriptor.buffer;
        }
      };
    }
    exports2.DeserializedMixin = DeserializedMixin;
    var DeserializedTypedArrayValue = DeserializedMixin(TypedArrayValue);
  }
});

// node_modules/concordance/lib/complexValues/arrayBuffer.js
var require_arrayBuffer = __commonJS({
  "node_modules/concordance/lib/complexValues/arrayBuffer.js"(exports2) {
    "use strict";
    var typedArray = require_typedArray();
    function describe(props) {
      return new DescribedArrayBufferValue(Object.assign({
        buffer: Buffer.from(props.value),
        // Set isArray and isList so the property recursor excludes the byte accessors
        isArray: true,
        isList: true
      }, props));
    }
    exports2.describe = describe;
    function deserialize(state, recursor) {
      return new DeserializedArrayBufferValue(state, recursor);
    }
    exports2.deserialize = deserialize;
    var tag = Symbol("ArrayBufferValue");
    exports2.tag = tag;
    var ArrayBufferValue = class extends typedArray.TypedArrayValue {
    };
    Object.defineProperty(ArrayBufferValue.prototype, "tag", { value: tag });
    var DescribedArrayBufferValue = typedArray.DescribedMixin(ArrayBufferValue);
    var DeserializedArrayBufferValue = typedArray.DeserializedMixin(ArrayBufferValue);
  }
});

// node_modules/esutils/lib/ast.js
var require_ast = __commonJS({
  "node_modules/esutils/lib/ast.js"(exports2, module2) {
    "use strict";
    (function() {
      "use strict";
      function isExpression(node) {
        if (node == null) {
          return false;
        }
        switch (node.type) {
          case "ArrayExpression":
          case "AssignmentExpression":
          case "BinaryExpression":
          case "CallExpression":
          case "ConditionalExpression":
          case "FunctionExpression":
          case "Identifier":
          case "Literal":
          case "LogicalExpression":
          case "MemberExpression":
          case "NewExpression":
          case "ObjectExpression":
          case "SequenceExpression":
          case "ThisExpression":
          case "UnaryExpression":
          case "UpdateExpression":
            return true;
        }
        return false;
      }
      function isIterationStatement(node) {
        if (node == null) {
          return false;
        }
        switch (node.type) {
          case "DoWhileStatement":
          case "ForInStatement":
          case "ForStatement":
          case "WhileStatement":
            return true;
        }
        return false;
      }
      function isStatement(node) {
        if (node == null) {
          return false;
        }
        switch (node.type) {
          case "BlockStatement":
          case "BreakStatement":
          case "ContinueStatement":
          case "DebuggerStatement":
          case "DoWhileStatement":
          case "EmptyStatement":
          case "ExpressionStatement":
          case "ForInStatement":
          case "ForStatement":
          case "IfStatement":
          case "LabeledStatement":
          case "ReturnStatement":
          case "SwitchStatement":
          case "ThrowStatement":
          case "TryStatement":
          case "VariableDeclaration":
          case "WhileStatement":
          case "WithStatement":
            return true;
        }
        return false;
      }
      function isSourceElement(node) {
        return isStatement(node) || node != null && node.type === "FunctionDeclaration";
      }
      function trailingStatement(node) {
        switch (node.type) {
          case "IfStatement":
            if (node.alternate != null) {
              return node.alternate;
            }
            return node.consequent;
          case "LabeledStatement":
          case "ForStatement":
          case "ForInStatement":
          case "WhileStatement":
          case "WithStatement":
            return node.body;
        }
        return null;
      }
      function isProblematicIfStatement(node) {
        var current;
        if (node.type !== "IfStatement") {
          return false;
        }
        if (node.alternate == null) {
          return false;
        }
        current = node.consequent;
        do {
          if (current.type === "IfStatement") {
            if (current.alternate == null) {
              return true;
            }
          }
          current = trailingStatement(current);
        } while (current);
        return false;
      }
      module2.exports = {
        isExpression,
        isStatement,
        isIterationStatement,
        isSourceElement,
        isProblematicIfStatement,
        trailingStatement
      };
    })();
  }
});

// node_modules/esutils/lib/code.js
var require_code = __commonJS({
  "node_modules/esutils/lib/code.js"(exports2, module2) {
    "use strict";
    (function() {
      "use strict";
      var ES6Regex, ES5Regex, NON_ASCII_WHITESPACES, IDENTIFIER_START, IDENTIFIER_PART, ch;
      ES5Regex = {
        // ECMAScript 5.1/Unicode v9.0.0 NonAsciiIdentifierStart:
        NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
        // ECMAScript 5.1/Unicode v9.0.0 NonAsciiIdentifierPart:
        NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/
      };
      ES6Regex = {
        // ECMAScript 6/Unicode v9.0.0 NonAsciiIdentifierStart:
        NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
        // ECMAScript 6/Unicode v9.0.0 NonAsciiIdentifierPart:
        NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
      };
      function isDecimalDigit(ch2) {
        return 48 <= ch2 && ch2 <= 57;
      }
      function isHexDigit(ch2) {
        return 48 <= ch2 && ch2 <= 57 || // 0..9
        97 <= ch2 && ch2 <= 102 || // a..f
        65 <= ch2 && ch2 <= 70;
      }
      function isOctalDigit(ch2) {
        return ch2 >= 48 && ch2 <= 55;
      }
      NON_ASCII_WHITESPACES = [
        5760,
        8192,
        8193,
        8194,
        8195,
        8196,
        8197,
        8198,
        8199,
        8200,
        8201,
        8202,
        8239,
        8287,
        12288,
        65279
      ];
      function isWhiteSpace(ch2) {
        return ch2 === 32 || ch2 === 9 || ch2 === 11 || ch2 === 12 || ch2 === 160 || ch2 >= 5760 && NON_ASCII_WHITESPACES.indexOf(ch2) >= 0;
      }
      function isLineTerminator(ch2) {
        return ch2 === 10 || ch2 === 13 || ch2 === 8232 || ch2 === 8233;
      }
      function fromCodePoint(cp) {
        if (cp <= 65535) {
          return String.fromCharCode(cp);
        }
        var cu1 = String.fromCharCode(Math.floor((cp - 65536) / 1024) + 55296);
        var cu2 = String.fromCharCode((cp - 65536) % 1024 + 56320);
        return cu1 + cu2;
      }
      IDENTIFIER_START = new Array(128);
      for (ch = 0; ch < 128; ++ch) {
        IDENTIFIER_START[ch] = ch >= 97 && ch <= 122 || // a..z
        ch >= 65 && ch <= 90 || // A..Z
        ch === 36 || ch === 95;
      }
      IDENTIFIER_PART = new Array(128);
      for (ch = 0; ch < 128; ++ch) {
        IDENTIFIER_PART[ch] = ch >= 97 && ch <= 122 || // a..z
        ch >= 65 && ch <= 90 || // A..Z
        ch >= 48 && ch <= 57 || // 0..9
        ch === 36 || ch === 95;
      }
      function isIdentifierStartES5(ch2) {
        return ch2 < 128 ? IDENTIFIER_START[ch2] : ES5Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch2));
      }
      function isIdentifierPartES5(ch2) {
        return ch2 < 128 ? IDENTIFIER_PART[ch2] : ES5Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch2));
      }
      function isIdentifierStartES6(ch2) {
        return ch2 < 128 ? IDENTIFIER_START[ch2] : ES6Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch2));
      }
      function isIdentifierPartES6(ch2) {
        return ch2 < 128 ? IDENTIFIER_PART[ch2] : ES6Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch2));
      }
      module2.exports = {
        isDecimalDigit,
        isHexDigit,
        isOctalDigit,
        isWhiteSpace,
        isLineTerminator,
        isIdentifierStartES5,
        isIdentifierPartES5,
        isIdentifierStartES6,
        isIdentifierPartES6
      };
    })();
  }
});

// node_modules/esutils/lib/keyword.js
var require_keyword = __commonJS({
  "node_modules/esutils/lib/keyword.js"(exports2, module2) {
    "use strict";
    (function() {
      "use strict";
      var code = require_code();
      function isStrictModeReservedWordES6(id) {
        switch (id) {
          case "implements":
          case "interface":
          case "package":
          case "private":
          case "protected":
          case "public":
          case "static":
          case "let":
            return true;
          default:
            return false;
        }
      }
      function isKeywordES5(id, strict) {
        if (!strict && id === "yield") {
          return false;
        }
        return isKeywordES6(id, strict);
      }
      function isKeywordES6(id, strict) {
        if (strict && isStrictModeReservedWordES6(id)) {
          return true;
        }
        switch (id.length) {
          case 2:
            return id === "if" || id === "in" || id === "do";
          case 3:
            return id === "var" || id === "for" || id === "new" || id === "try";
          case 4:
            return id === "this" || id === "else" || id === "case" || id === "void" || id === "with" || id === "enum";
          case 5:
            return id === "while" || id === "break" || id === "catch" || id === "throw" || id === "const" || id === "yield" || id === "class" || id === "super";
          case 6:
            return id === "return" || id === "typeof" || id === "delete" || id === "switch" || id === "export" || id === "import";
          case 7:
            return id === "default" || id === "finally" || id === "extends";
          case 8:
            return id === "function" || id === "continue" || id === "debugger";
          case 10:
            return id === "instanceof";
          default:
            return false;
        }
      }
      function isReservedWordES5(id, strict) {
        return id === "null" || id === "true" || id === "false" || isKeywordES5(id, strict);
      }
      function isReservedWordES6(id, strict) {
        return id === "null" || id === "true" || id === "false" || isKeywordES6(id, strict);
      }
      function isRestrictedWord(id) {
        return id === "eval" || id === "arguments";
      }
      function isIdentifierNameES5(id) {
        var i, iz, ch;
        if (id.length === 0) {
          return false;
        }
        ch = id.charCodeAt(0);
        if (!code.isIdentifierStartES5(ch)) {
          return false;
        }
        for (i = 1, iz = id.length; i < iz; ++i) {
          ch = id.charCodeAt(i);
          if (!code.isIdentifierPartES5(ch)) {
            return false;
          }
        }
        return true;
      }
      function decodeUtf16(lead, trail) {
        return (lead - 55296) * 1024 + (trail - 56320) + 65536;
      }
      function isIdentifierNameES6(id) {
        var i, iz, ch, lowCh, check;
        if (id.length === 0) {
          return false;
        }
        check = code.isIdentifierStartES6;
        for (i = 0, iz = id.length; i < iz; ++i) {
          ch = id.charCodeAt(i);
          if (55296 <= ch && ch <= 56319) {
            ++i;
            if (i >= iz) {
              return false;
            }
            lowCh = id.charCodeAt(i);
            if (!(56320 <= lowCh && lowCh <= 57343)) {
              return false;
            }
            ch = decodeUtf16(ch, lowCh);
          }
          if (!check(ch)) {
            return false;
          }
          check = code.isIdentifierPartES6;
        }
        return true;
      }
      function isIdentifierES5(id, strict) {
        return isIdentifierNameES5(id) && !isReservedWordES5(id, strict);
      }
      function isIdentifierES6(id, strict) {
        return isIdentifierNameES6(id) && !isReservedWordES6(id, strict);
      }
      module2.exports = {
        isKeywordES5,
        isKeywordES6,
        isReservedWordES5,
        isReservedWordES6,
        isRestrictedWord,
        isIdentifierNameES5,
        isIdentifierNameES6,
        isIdentifierES5,
        isIdentifierES6
      };
    })();
  }
});

// node_modules/esutils/lib/utils.js
var require_utils5 = __commonJS({
  "node_modules/esutils/lib/utils.js"(exports2) {
    "use strict";
    (function() {
      "use strict";
      exports2.ast = require_ast();
      exports2.code = require_code();
      exports2.keyword = require_keyword();
    })();
  }
});

// node_modules/fast-diff/diff.js
var require_diff = __commonJS({
  "node_modules/fast-diff/diff.js"(exports2, module2) {
    "use strict";
    var DIFF_DELETE = -1;
    var DIFF_INSERT = 1;
    var DIFF_EQUAL = 0;
    function diff_main(text1, text2, cursor_pos, cleanup, _fix_unicode) {
      if (text1 === text2) {
        if (text1) {
          return [[DIFF_EQUAL, text1]];
        }
        return [];
      }
      if (cursor_pos != null) {
        var editdiff = find_cursor_edit_diff(text1, text2, cursor_pos);
        if (editdiff) {
          return editdiff;
        }
      }
      var commonlength = diff_commonPrefix(text1, text2);
      var commonprefix = text1.substring(0, commonlength);
      text1 = text1.substring(commonlength);
      text2 = text2.substring(commonlength);
      commonlength = diff_commonSuffix(text1, text2);
      var commonsuffix = text1.substring(text1.length - commonlength);
      text1 = text1.substring(0, text1.length - commonlength);
      text2 = text2.substring(0, text2.length - commonlength);
      var diffs = diff_compute_(text1, text2);
      if (commonprefix) {
        diffs.unshift([DIFF_EQUAL, commonprefix]);
      }
      if (commonsuffix) {
        diffs.push([DIFF_EQUAL, commonsuffix]);
      }
      diff_cleanupMerge(diffs, _fix_unicode);
      if (cleanup) {
        diff_cleanupSemantic(diffs);
      }
      return diffs;
    }
    function diff_compute_(text1, text2) {
      var diffs;
      if (!text1) {
        return [[DIFF_INSERT, text2]];
      }
      if (!text2) {
        return [[DIFF_DELETE, text1]];
      }
      var longtext = text1.length > text2.length ? text1 : text2;
      var shorttext = text1.length > text2.length ? text2 : text1;
      var i = longtext.indexOf(shorttext);
      if (i !== -1) {
        diffs = [
          [DIFF_INSERT, longtext.substring(0, i)],
          [DIFF_EQUAL, shorttext],
          [DIFF_INSERT, longtext.substring(i + shorttext.length)]
        ];
        if (text1.length > text2.length) {
          diffs[0][0] = diffs[2][0] = DIFF_DELETE;
        }
        return diffs;
      }
      if (shorttext.length === 1) {
        return [
          [DIFF_DELETE, text1],
          [DIFF_INSERT, text2]
        ];
      }
      var hm = diff_halfMatch_(text1, text2);
      if (hm) {
        var text1_a = hm[0];
        var text1_b = hm[1];
        var text2_a = hm[2];
        var text2_b = hm[3];
        var mid_common = hm[4];
        var diffs_a = diff_main(text1_a, text2_a);
        var diffs_b = diff_main(text1_b, text2_b);
        return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);
      }
      return diff_bisect_(text1, text2);
    }
    function diff_bisect_(text1, text2) {
      var text1_length = text1.length;
      var text2_length = text2.length;
      var max_d = Math.ceil((text1_length + text2_length) / 2);
      var v_offset = max_d;
      var v_length = 2 * max_d;
      var v1 = new Array(v_length);
      var v2 = new Array(v_length);
      for (var x = 0; x < v_length; x++) {
        v1[x] = -1;
        v2[x] = -1;
      }
      v1[v_offset + 1] = 0;
      v2[v_offset + 1] = 0;
      var delta = text1_length - text2_length;
      var front = delta % 2 !== 0;
      var k1start = 0;
      var k1end = 0;
      var k2start = 0;
      var k2end = 0;
      for (var d = 0; d < max_d; d++) {
        for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
          var k1_offset = v_offset + k1;
          var x1;
          if (k1 === -d || k1 !== d && v1[k1_offset - 1] < v1[k1_offset + 1]) {
            x1 = v1[k1_offset + 1];
          } else {
            x1 = v1[k1_offset - 1] + 1;
          }
          var y1 = x1 - k1;
          while (x1 < text1_length && y1 < text2_length && text1.charAt(x1) === text2.charAt(y1)) {
            x1++;
            y1++;
          }
          v1[k1_offset] = x1;
          if (x1 > text1_length) {
            k1end += 2;
          } else if (y1 > text2_length) {
            k1start += 2;
          } else if (front) {
            var k2_offset = v_offset + delta - k1;
            if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] !== -1) {
              var x2 = text1_length - v2[k2_offset];
              if (x1 >= x2) {
                return diff_bisectSplit_(text1, text2, x1, y1);
              }
            }
          }
        }
        for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
          var k2_offset = v_offset + k2;
          var x2;
          if (k2 === -d || k2 !== d && v2[k2_offset - 1] < v2[k2_offset + 1]) {
            x2 = v2[k2_offset + 1];
          } else {
            x2 = v2[k2_offset - 1] + 1;
          }
          var y2 = x2 - k2;
          while (x2 < text1_length && y2 < text2_length && text1.charAt(text1_length - x2 - 1) === text2.charAt(text2_length - y2 - 1)) {
            x2++;
            y2++;
          }
          v2[k2_offset] = x2;
          if (x2 > text1_length) {
            k2end += 2;
          } else if (y2 > text2_length) {
            k2start += 2;
          } else if (!front) {
            var k1_offset = v_offset + delta - k2;
            if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] !== -1) {
              var x1 = v1[k1_offset];
              var y1 = v_offset + x1 - k1_offset;
              x2 = text1_length - x2;
              if (x1 >= x2) {
                return diff_bisectSplit_(text1, text2, x1, y1);
              }
            }
          }
        }
      }
      return [
        [DIFF_DELETE, text1],
        [DIFF_INSERT, text2]
      ];
    }
    function diff_bisectSplit_(text1, text2, x, y) {
      var text1a = text1.substring(0, x);
      var text2a = text2.substring(0, y);
      var text1b = text1.substring(x);
      var text2b = text2.substring(y);
      var diffs = diff_main(text1a, text2a);
      var diffsb = diff_main(text1b, text2b);
      return diffs.concat(diffsb);
    }
    function diff_commonPrefix(text1, text2) {
      if (!text1 || !text2 || text1.charAt(0) !== text2.charAt(0)) {
        return 0;
      }
      var pointermin = 0;
      var pointermax = Math.min(text1.length, text2.length);
      var pointermid = pointermax;
      var pointerstart = 0;
      while (pointermin < pointermid) {
        if (text1.substring(pointerstart, pointermid) == text2.substring(pointerstart, pointermid)) {
          pointermin = pointermid;
          pointerstart = pointermin;
        } else {
          pointermax = pointermid;
        }
        pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
      }
      if (is_surrogate_pair_start(text1.charCodeAt(pointermid - 1))) {
        pointermid--;
      }
      return pointermid;
    }
    function diff_commonOverlap_(text1, text2) {
      var text1_length = text1.length;
      var text2_length = text2.length;
      if (text1_length == 0 || text2_length == 0) {
        return 0;
      }
      if (text1_length > text2_length) {
        text1 = text1.substring(text1_length - text2_length);
      } else if (text1_length < text2_length) {
        text2 = text2.substring(0, text1_length);
      }
      var text_length = Math.min(text1_length, text2_length);
      if (text1 == text2) {
        return text_length;
      }
      var best = 0;
      var length = 1;
      while (true) {
        var pattern = text1.substring(text_length - length);
        var found = text2.indexOf(pattern);
        if (found == -1) {
          return best;
        }
        length += found;
        if (found == 0 || text1.substring(text_length - length) == text2.substring(0, length)) {
          best = length;
          length++;
        }
      }
    }
    function diff_commonSuffix(text1, text2) {
      if (!text1 || !text2 || text1.slice(-1) !== text2.slice(-1)) {
        return 0;
      }
      var pointermin = 0;
      var pointermax = Math.min(text1.length, text2.length);
      var pointermid = pointermax;
      var pointerend = 0;
      while (pointermin < pointermid) {
        if (text1.substring(text1.length - pointermid, text1.length - pointerend) == text2.substring(text2.length - pointermid, text2.length - pointerend)) {
          pointermin = pointermid;
          pointerend = pointermin;
        } else {
          pointermax = pointermid;
        }
        pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
      }
      if (is_surrogate_pair_end(text1.charCodeAt(text1.length - pointermid))) {
        pointermid--;
      }
      return pointermid;
    }
    function diff_halfMatch_(text1, text2) {
      var longtext = text1.length > text2.length ? text1 : text2;
      var shorttext = text1.length > text2.length ? text2 : text1;
      if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
        return null;
      }
      function diff_halfMatchI_(longtext2, shorttext2, i) {
        var seed = longtext2.substring(i, i + Math.floor(longtext2.length / 4));
        var j = -1;
        var best_common = "";
        var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
        while ((j = shorttext2.indexOf(seed, j + 1)) !== -1) {
          var prefixLength = diff_commonPrefix(
            longtext2.substring(i),
            shorttext2.substring(j)
          );
          var suffixLength = diff_commonSuffix(
            longtext2.substring(0, i),
            shorttext2.substring(0, j)
          );
          if (best_common.length < suffixLength + prefixLength) {
            best_common = shorttext2.substring(j - suffixLength, j) + shorttext2.substring(j, j + prefixLength);
            best_longtext_a = longtext2.substring(0, i - suffixLength);
            best_longtext_b = longtext2.substring(i + prefixLength);
            best_shorttext_a = shorttext2.substring(0, j - suffixLength);
            best_shorttext_b = shorttext2.substring(j + prefixLength);
          }
        }
        if (best_common.length * 2 >= longtext2.length) {
          return [
            best_longtext_a,
            best_longtext_b,
            best_shorttext_a,
            best_shorttext_b,
            best_common
          ];
        } else {
          return null;
        }
      }
      var hm1 = diff_halfMatchI_(
        longtext,
        shorttext,
        Math.ceil(longtext.length / 4)
      );
      var hm2 = diff_halfMatchI_(
        longtext,
        shorttext,
        Math.ceil(longtext.length / 2)
      );
      var hm;
      if (!hm1 && !hm2) {
        return null;
      } else if (!hm2) {
        hm = hm1;
      } else if (!hm1) {
        hm = hm2;
      } else {
        hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
      }
      var text1_a, text1_b, text2_a, text2_b;
      if (text1.length > text2.length) {
        text1_a = hm[0];
        text1_b = hm[1];
        text2_a = hm[2];
        text2_b = hm[3];
      } else {
        text2_a = hm[0];
        text2_b = hm[1];
        text1_a = hm[2];
        text1_b = hm[3];
      }
      var mid_common = hm[4];
      return [text1_a, text1_b, text2_a, text2_b, mid_common];
    }
    function diff_cleanupSemantic(diffs) {
      var changes = false;
      var equalities = [];
      var equalitiesLength = 0;
      var lastequality = null;
      var pointer = 0;
      var length_insertions1 = 0;
      var length_deletions1 = 0;
      var length_insertions2 = 0;
      var length_deletions2 = 0;
      while (pointer < diffs.length) {
        if (diffs[pointer][0] == DIFF_EQUAL) {
          equalities[equalitiesLength++] = pointer;
          length_insertions1 = length_insertions2;
          length_deletions1 = length_deletions2;
          length_insertions2 = 0;
          length_deletions2 = 0;
          lastequality = diffs[pointer][1];
        } else {
          if (diffs[pointer][0] == DIFF_INSERT) {
            length_insertions2 += diffs[pointer][1].length;
          } else {
            length_deletions2 += diffs[pointer][1].length;
          }
          if (lastequality && lastequality.length <= Math.max(length_insertions1, length_deletions1) && lastequality.length <= Math.max(length_insertions2, length_deletions2)) {
            diffs.splice(equalities[equalitiesLength - 1], 0, [
              DIFF_DELETE,
              lastequality
            ]);
            diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
            equalitiesLength--;
            equalitiesLength--;
            pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
            length_insertions1 = 0;
            length_deletions1 = 0;
            length_insertions2 = 0;
            length_deletions2 = 0;
            lastequality = null;
            changes = true;
          }
        }
        pointer++;
      }
      if (changes) {
        diff_cleanupMerge(diffs);
      }
      diff_cleanupSemanticLossless(diffs);
      pointer = 1;
      while (pointer < diffs.length) {
        if (diffs[pointer - 1][0] == DIFF_DELETE && diffs[pointer][0] == DIFF_INSERT) {
          var deletion = diffs[pointer - 1][1];
          var insertion = diffs[pointer][1];
          var overlap_length1 = diff_commonOverlap_(deletion, insertion);
          var overlap_length2 = diff_commonOverlap_(insertion, deletion);
          if (overlap_length1 >= overlap_length2) {
            if (overlap_length1 >= deletion.length / 2 || overlap_length1 >= insertion.length / 2) {
              diffs.splice(pointer, 0, [
                DIFF_EQUAL,
                insertion.substring(0, overlap_length1)
              ]);
              diffs[pointer - 1][1] = deletion.substring(
                0,
                deletion.length - overlap_length1
              );
              diffs[pointer + 1][1] = insertion.substring(overlap_length1);
              pointer++;
            }
          } else {
            if (overlap_length2 >= deletion.length / 2 || overlap_length2 >= insertion.length / 2) {
              diffs.splice(pointer, 0, [
                DIFF_EQUAL,
                deletion.substring(0, overlap_length2)
              ]);
              diffs[pointer - 1][0] = DIFF_INSERT;
              diffs[pointer - 1][1] = insertion.substring(
                0,
                insertion.length - overlap_length2
              );
              diffs[pointer + 1][0] = DIFF_DELETE;
              diffs[pointer + 1][1] = deletion.substring(overlap_length2);
              pointer++;
            }
          }
          pointer++;
        }
        pointer++;
      }
    }
    var nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;
    var whitespaceRegex_ = /\s/;
    var linebreakRegex_ = /[\r\n]/;
    var blanklineEndRegex_ = /\n\r?\n$/;
    var blanklineStartRegex_ = /^\r?\n\r?\n/;
    function diff_cleanupSemanticLossless(diffs) {
      function diff_cleanupSemanticScore_(one, two) {
        if (!one || !two) {
          return 6;
        }
        var char1 = one.charAt(one.length - 1);
        var char2 = two.charAt(0);
        var nonAlphaNumeric1 = char1.match(nonAlphaNumericRegex_);
        var nonAlphaNumeric2 = char2.match(nonAlphaNumericRegex_);
        var whitespace1 = nonAlphaNumeric1 && char1.match(whitespaceRegex_);
        var whitespace2 = nonAlphaNumeric2 && char2.match(whitespaceRegex_);
        var lineBreak1 = whitespace1 && char1.match(linebreakRegex_);
        var lineBreak2 = whitespace2 && char2.match(linebreakRegex_);
        var blankLine1 = lineBreak1 && one.match(blanklineEndRegex_);
        var blankLine2 = lineBreak2 && two.match(blanklineStartRegex_);
        if (blankLine1 || blankLine2) {
          return 5;
        } else if (lineBreak1 || lineBreak2) {
          return 4;
        } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {
          return 3;
        } else if (whitespace1 || whitespace2) {
          return 2;
        } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {
          return 1;
        }
        return 0;
      }
      var pointer = 1;
      while (pointer < diffs.length - 1) {
        if (diffs[pointer - 1][0] == DIFF_EQUAL && diffs[pointer + 1][0] == DIFF_EQUAL) {
          var equality1 = diffs[pointer - 1][1];
          var edit = diffs[pointer][1];
          var equality2 = diffs[pointer + 1][1];
          var commonOffset = diff_commonSuffix(equality1, edit);
          if (commonOffset) {
            var commonString = edit.substring(edit.length - commonOffset);
            equality1 = equality1.substring(0, equality1.length - commonOffset);
            edit = commonString + edit.substring(0, edit.length - commonOffset);
            equality2 = commonString + equality2;
          }
          var bestEquality1 = equality1;
          var bestEdit = edit;
          var bestEquality2 = equality2;
          var bestScore = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);
          while (edit.charAt(0) === equality2.charAt(0)) {
            equality1 += edit.charAt(0);
            edit = edit.substring(1) + equality2.charAt(0);
            equality2 = equality2.substring(1);
            var score = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);
            if (score >= bestScore) {
              bestScore = score;
              bestEquality1 = equality1;
              bestEdit = edit;
              bestEquality2 = equality2;
            }
          }
          if (diffs[pointer - 1][1] != bestEquality1) {
            if (bestEquality1) {
              diffs[pointer - 1][1] = bestEquality1;
            } else {
              diffs.splice(pointer - 1, 1);
              pointer--;
            }
            diffs[pointer][1] = bestEdit;
            if (bestEquality2) {
              diffs[pointer + 1][1] = bestEquality2;
            } else {
              diffs.splice(pointer + 1, 1);
              pointer--;
            }
          }
        }
        pointer++;
      }
    }
    function diff_cleanupMerge(diffs, fix_unicode) {
      diffs.push([DIFF_EQUAL, ""]);
      var pointer = 0;
      var count_delete = 0;
      var count_insert = 0;
      var text_delete = "";
      var text_insert = "";
      var commonlength;
      while (pointer < diffs.length) {
        if (pointer < diffs.length - 1 && !diffs[pointer][1]) {
          diffs.splice(pointer, 1);
          continue;
        }
        switch (diffs[pointer][0]) {
          case DIFF_INSERT:
            count_insert++;
            text_insert += diffs[pointer][1];
            pointer++;
            break;
          case DIFF_DELETE:
            count_delete++;
            text_delete += diffs[pointer][1];
            pointer++;
            break;
          case DIFF_EQUAL:
            var previous_equality = pointer - count_insert - count_delete - 1;
            if (fix_unicode) {
              if (previous_equality >= 0 && ends_with_pair_start(diffs[previous_equality][1])) {
                var stray = diffs[previous_equality][1].slice(-1);
                diffs[previous_equality][1] = diffs[previous_equality][1].slice(
                  0,
                  -1
                );
                text_delete = stray + text_delete;
                text_insert = stray + text_insert;
                if (!diffs[previous_equality][1]) {
                  diffs.splice(previous_equality, 1);
                  pointer--;
                  var k = previous_equality - 1;
                  if (diffs[k] && diffs[k][0] === DIFF_INSERT) {
                    count_insert++;
                    text_insert = diffs[k][1] + text_insert;
                    k--;
                  }
                  if (diffs[k] && diffs[k][0] === DIFF_DELETE) {
                    count_delete++;
                    text_delete = diffs[k][1] + text_delete;
                    k--;
                  }
                  previous_equality = k;
                }
              }
              if (starts_with_pair_end(diffs[pointer][1])) {
                var stray = diffs[pointer][1].charAt(0);
                diffs[pointer][1] = diffs[pointer][1].slice(1);
                text_delete += stray;
                text_insert += stray;
              }
            }
            if (pointer < diffs.length - 1 && !diffs[pointer][1]) {
              diffs.splice(pointer, 1);
              break;
            }
            if (text_delete.length > 0 || text_insert.length > 0) {
              if (text_delete.length > 0 && text_insert.length > 0) {
                commonlength = diff_commonPrefix(text_insert, text_delete);
                if (commonlength !== 0) {
                  if (previous_equality >= 0) {
                    diffs[previous_equality][1] += text_insert.substring(
                      0,
                      commonlength
                    );
                  } else {
                    diffs.splice(0, 0, [
                      DIFF_EQUAL,
                      text_insert.substring(0, commonlength)
                    ]);
                    pointer++;
                  }
                  text_insert = text_insert.substring(commonlength);
                  text_delete = text_delete.substring(commonlength);
                }
                commonlength = diff_commonSuffix(text_insert, text_delete);
                if (commonlength !== 0) {
                  diffs[pointer][1] = text_insert.substring(text_insert.length - commonlength) + diffs[pointer][1];
                  text_insert = text_insert.substring(
                    0,
                    text_insert.length - commonlength
                  );
                  text_delete = text_delete.substring(
                    0,
                    text_delete.length - commonlength
                  );
                }
              }
              var n = count_insert + count_delete;
              if (text_delete.length === 0 && text_insert.length === 0) {
                diffs.splice(pointer - n, n);
                pointer = pointer - n;
              } else if (text_delete.length === 0) {
                diffs.splice(pointer - n, n, [DIFF_INSERT, text_insert]);
                pointer = pointer - n + 1;
              } else if (text_insert.length === 0) {
                diffs.splice(pointer - n, n, [DIFF_DELETE, text_delete]);
                pointer = pointer - n + 1;
              } else {
                diffs.splice(
                  pointer - n,
                  n,
                  [DIFF_DELETE, text_delete],
                  [DIFF_INSERT, text_insert]
                );
                pointer = pointer - n + 2;
              }
            }
            if (pointer !== 0 && diffs[pointer - 1][0] === DIFF_EQUAL) {
              diffs[pointer - 1][1] += diffs[pointer][1];
              diffs.splice(pointer, 1);
            } else {
              pointer++;
            }
            count_insert = 0;
            count_delete = 0;
            text_delete = "";
            text_insert = "";
            break;
        }
      }
      if (diffs[diffs.length - 1][1] === "") {
        diffs.pop();
      }
      var changes = false;
      pointer = 1;
      while (pointer < diffs.length - 1) {
        if (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {
          if (diffs[pointer][1].substring(
            diffs[pointer][1].length - diffs[pointer - 1][1].length
          ) === diffs[pointer - 1][1]) {
            diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(
              0,
              diffs[pointer][1].length - diffs[pointer - 1][1].length
            );
            diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
            diffs.splice(pointer - 1, 1);
            changes = true;
          } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) == diffs[pointer + 1][1]) {
            diffs[pointer - 1][1] += diffs[pointer + 1][1];
            diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];
            diffs.splice(pointer + 1, 1);
            changes = true;
          }
        }
        pointer++;
      }
      if (changes) {
        diff_cleanupMerge(diffs, fix_unicode);
      }
    }
    function is_surrogate_pair_start(charCode) {
      return charCode >= 55296 && charCode <= 56319;
    }
    function is_surrogate_pair_end(charCode) {
      return charCode >= 56320 && charCode <= 57343;
    }
    function starts_with_pair_end(str) {
      return is_surrogate_pair_end(str.charCodeAt(0));
    }
    function ends_with_pair_start(str) {
      return is_surrogate_pair_start(str.charCodeAt(str.length - 1));
    }
    function remove_empty_tuples(tuples) {
      var ret = [];
      for (var i = 0; i < tuples.length; i++) {
        if (tuples[i][1].length > 0) {
          ret.push(tuples[i]);
        }
      }
      return ret;
    }
    function make_edit_splice(before, oldMiddle, newMiddle, after) {
      if (ends_with_pair_start(before) || starts_with_pair_end(after)) {
        return null;
      }
      return remove_empty_tuples([
        [DIFF_EQUAL, before],
        [DIFF_DELETE, oldMiddle],
        [DIFF_INSERT, newMiddle],
        [DIFF_EQUAL, after]
      ]);
    }
    function find_cursor_edit_diff(oldText, newText, cursor_pos) {
      var oldRange = typeof cursor_pos === "number" ? { index: cursor_pos, length: 0 } : cursor_pos.oldRange;
      var newRange = typeof cursor_pos === "number" ? null : cursor_pos.newRange;
      var oldLength = oldText.length;
      var newLength = newText.length;
      if (oldRange.length === 0 && (newRange === null || newRange.length === 0)) {
        var oldCursor = oldRange.index;
        var oldBefore = oldText.slice(0, oldCursor);
        var oldAfter = oldText.slice(oldCursor);
        var maybeNewCursor = newRange ? newRange.index : null;
        editBefore: {
          var newCursor = oldCursor + newLength - oldLength;
          if (maybeNewCursor !== null && maybeNewCursor !== newCursor) {
            break editBefore;
          }
          if (newCursor < 0 || newCursor > newLength) {
            break editBefore;
          }
          var newBefore = newText.slice(0, newCursor);
          var newAfter = newText.slice(newCursor);
          if (newAfter !== oldAfter) {
            break editBefore;
          }
          var prefixLength = Math.min(oldCursor, newCursor);
          var oldPrefix = oldBefore.slice(0, prefixLength);
          var newPrefix = newBefore.slice(0, prefixLength);
          if (oldPrefix !== newPrefix) {
            break editBefore;
          }
          var oldMiddle = oldBefore.slice(prefixLength);
          var newMiddle = newBefore.slice(prefixLength);
          return make_edit_splice(oldPrefix, oldMiddle, newMiddle, oldAfter);
        }
        editAfter: {
          if (maybeNewCursor !== null && maybeNewCursor !== oldCursor) {
            break editAfter;
          }
          var cursor = oldCursor;
          var newBefore = newText.slice(0, cursor);
          var newAfter = newText.slice(cursor);
          if (newBefore !== oldBefore) {
            break editAfter;
          }
          var suffixLength = Math.min(oldLength - cursor, newLength - cursor);
          var oldSuffix = oldAfter.slice(oldAfter.length - suffixLength);
          var newSuffix = newAfter.slice(newAfter.length - suffixLength);
          if (oldSuffix !== newSuffix) {
            break editAfter;
          }
          var oldMiddle = oldAfter.slice(0, oldAfter.length - suffixLength);
          var newMiddle = newAfter.slice(0, newAfter.length - suffixLength);
          return make_edit_splice(oldBefore, oldMiddle, newMiddle, oldSuffix);
        }
      }
      if (oldRange.length > 0 && newRange && newRange.length === 0) {
        replaceRange: {
          var oldPrefix = oldText.slice(0, oldRange.index);
          var oldSuffix = oldText.slice(oldRange.index + oldRange.length);
          var prefixLength = oldPrefix.length;
          var suffixLength = oldSuffix.length;
          if (newLength < prefixLength + suffixLength) {
            break replaceRange;
          }
          var newPrefix = newText.slice(0, prefixLength);
          var newSuffix = newText.slice(newLength - suffixLength);
          if (oldPrefix !== newPrefix || oldSuffix !== newSuffix) {
            break replaceRange;
          }
          var oldMiddle = oldText.slice(prefixLength, oldLength - suffixLength);
          var newMiddle = newText.slice(prefixLength, newLength - suffixLength);
          return make_edit_splice(oldPrefix, oldMiddle, newMiddle, oldSuffix);
        }
      }
      return null;
    }
    function diff(text1, text2, cursor_pos, cleanup) {
      return diff_main(text1, text2, cursor_pos, cleanup, true);
    }
    diff.INSERT = DIFF_INSERT;
    diff.DELETE = DIFF_DELETE;
    diff.EQUAL = DIFF_EQUAL;
    module2.exports = diff;
  }
});

// node_modules/concordance/lib/primitiveValues/string.js
var require_string2 = __commonJS({
  "node_modules/concordance/lib/primitiveValues/string.js"(exports2) {
    "use strict";
    var keyword = require_utils5().keyword;
    var fastDiff = require_diff();
    var constants = require_constants4();
    var formatUtils = require_formatUtils();
    var lineBuilder = require_lineBuilder();
    var DEEP_EQUAL = constants.DEEP_EQUAL;
    var UNEQUAL = constants.UNEQUAL;
    function describe(value2) {
      return new StringValue(value2);
    }
    exports2.describe = describe;
    exports2.deserialize = describe;
    var tag = Symbol("StringValue");
    exports2.tag = tag;
    function basicEscape(string) {
      return string.replace(/\\/g, "\\\\");
    }
    var CRLF_CONTROL_PICTURE = "\u240D\u240A";
    var LF_CONTROL_PICTURE = "\u240A";
    var CR_CONTROL_PICTURE = "\u240D";
    var MATCH_CONTROL_PICTURES = new RegExp(`${CR_CONTROL_PICTURE}|${LF_CONTROL_PICTURE}|${CR_CONTROL_PICTURE}`, "g");
    function escapeLinebreak(string) {
      if (string === "\r\n") return CRLF_CONTROL_PICTURE;
      if (string === "\n") return LF_CONTROL_PICTURE;
      if (string === "\r") return CR_CONTROL_PICTURE;
      return string;
    }
    function themeControlPictures(theme, resetWrap, str) {
      return str.replace(MATCH_CONTROL_PICTURES, (picture) => {
        return resetWrap.close + formatUtils.wrap(theme.string.controlPicture, picture) + resetWrap.open;
      });
    }
    var MATCH_SINGLE_QUOTE = /'/g;
    var MATCH_DOUBLE_QUOTE = /"/g;
    var MATCH_BACKTICKS = /`/g;
    function escapeQuotes(line, string) {
      const quote = line.escapeQuote;
      if (quote === "'") return string.replace(MATCH_SINGLE_QUOTE, "\\'");
      if (quote === '"') return string.replace(MATCH_DOUBLE_QUOTE, '\\"');
      if (quote === "`") return string.replace(MATCH_BACKTICKS, "\\`");
      return string;
    }
    function includesLinebreaks(string) {
      return string.includes("\r") || string.includes("\n");
    }
    function diffLine(theme, actual, expected, invert) {
      const outcome = fastDiff(actual, expected);
      const isPartiallyEqual = !(outcome.length === 2 && outcome[0][1] === actual && outcome[1][1] === expected || // Discount line ending control pictures, which will be equal even when the
      // rest of the line isn't.
      outcome.length === 3 && outcome[2][0] === fastDiff.EQUAL && MATCH_CONTROL_PICTURES.test(outcome[2][1]) && outcome[0][1] + outcome[2][1] === actual && outcome[1][1] + outcome[2][1] === expected);
      let stringActual = "";
      let stringExpected = "";
      const noopWrap = { open: "", close: "" };
      let deleteWrap = isPartiallyEqual ? theme.string.diff.delete : noopWrap;
      let insertWrap = isPartiallyEqual ? theme.string.diff.insert : noopWrap;
      const equalWrap = isPartiallyEqual ? theme.string.diff.equal : noopWrap;
      if (invert) {
        [deleteWrap, insertWrap] = [insertWrap, deleteWrap];
      }
      for (const diff of outcome) {
        if (diff[0] === fastDiff.DELETE) {
          stringActual += formatUtils.wrap(deleteWrap, diff[1]);
        } else if (diff[0] === fastDiff.INSERT) {
          stringExpected += formatUtils.wrap(insertWrap, diff[1]);
        } else {
          const string = formatUtils.wrap(equalWrap, themeControlPictures(theme, equalWrap, diff[1]));
          stringActual += string;
          stringExpected += string;
        }
      }
      if (!isPartiallyEqual) {
        const deleteLineWrap = invert ? theme.string.diff.insertLine : theme.string.diff.deleteLine;
        const insertLineWrap = invert ? theme.string.diff.deleteLine : theme.string.diff.insertLine;
        stringActual = formatUtils.wrap(deleteLineWrap, stringActual);
        stringExpected = formatUtils.wrap(insertLineWrap, stringExpected);
      }
      return [stringActual, stringExpected];
    }
    var LINEBREAKS = /\r\n|\r|\n/g;
    function gatherLines(string) {
      const lines = [];
      let prevIndex = 0;
      for (let match; match = LINEBREAKS.exec(string); prevIndex = match.index + match[0].length) {
        lines.push(string.slice(prevIndex, match.index) + escapeLinebreak(match[0]));
      }
      lines.push(string.slice(prevIndex));
      return lines;
    }
    var StringValue = class {
      constructor(value2) {
        this.value = value2;
      }
      compare(expected) {
        return expected.tag === tag && this.value === expected.value ? DEEP_EQUAL : UNEQUAL;
      }
      get includesLinebreaks() {
        return includesLinebreaks(this.value);
      }
      formatDeep(theme, indent) {
        let escaped = basicEscape(this.value);
        if (!this.includesLinebreaks) {
          escaped = escapeQuotes(theme.string.line, escaped);
          return lineBuilder.single(formatUtils.wrap(theme.string.line, formatUtils.wrap(theme.string, escaped)));
        }
        escaped = escapeQuotes(theme.string.multiline, escaped);
        const lineStrings = gatherLines(escaped).map((string) => {
          return formatUtils.wrap(theme.string, themeControlPictures(theme, theme.string, string));
        });
        const lastIndex = lineStrings.length - 1;
        const indentation = indent;
        return lineBuilder.buffer().append(
          lineStrings.map((string, index) => {
            if (index === 0) return lineBuilder.first(theme.string.multiline.start + string);
            if (index === lastIndex) return lineBuilder.last(indentation + string + theme.string.multiline.end);
            return lineBuilder.line(indentation + string);
          })
        );
      }
      formatAsKey(theme) {
        const key = this.value;
        if (keyword.isIdentifierNameES6(key, true) || String(parseInt(key, 10)) === key) {
          return key;
        }
        const escaped = basicEscape(key).replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/'/g, "\\'");
        return formatUtils.wrap(theme.string.line, formatUtils.wrap(theme.string, escaped));
      }
      diffDeep(expected, theme, indent, invert) {
        if (expected.tag !== tag) return null;
        const escapedActual = basicEscape(this.value);
        const escapedExpected = basicEscape(expected.value);
        if (!includesLinebreaks(escapedActual) && !includesLinebreaks(escapedExpected)) {
          const result = diffLine(
            theme,
            escapeQuotes(theme.string.line, escapedActual),
            escapeQuotes(theme.string.line, escapedExpected),
            invert
          );
          return lineBuilder.actual.single(formatUtils.wrap(theme.string.line, result[0])).concat(lineBuilder.expected.single(formatUtils.wrap(theme.string.line, result[1])));
        }
        const actualLines = gatherLines(escapeQuotes(theme.string.multiline, escapedActual));
        const expectedLines = gatherLines(escapeQuotes(theme.string.multiline, escapedExpected));
        const indentation = indent;
        const lines = lineBuilder.buffer();
        const lastActualIndex = actualLines.length - 1;
        const lastExpectedIndex = expectedLines.length - 1;
        let actualBuffer = [];
        let expectedBuffer = [];
        let mustOpenNextExpected = false;
        for (let actualIndex = 0, expectedIndex = 0, extraneousOffset = 0; actualIndex < actualLines.length; ) {
          if (actualLines[actualIndex] === expectedLines[expectedIndex]) {
            lines.append(actualBuffer);
            lines.append(expectedBuffer);
            actualBuffer = [];
            expectedBuffer = [];
            let string = actualLines[actualIndex];
            string = themeControlPictures(theme, theme.string.diff.equal, string);
            string = formatUtils.wrap(theme.string.diff.equal, string);
            if (actualIndex === 0) {
              lines.append(lineBuilder.first(theme.string.multiline.start + string));
            } else if (actualIndex === lastActualIndex && expectedIndex === lastExpectedIndex) {
              lines.append(lineBuilder.last(indentation + string + theme.string.multiline.end));
            } else {
              lines.append(lineBuilder.line(indentation + string));
            }
            actualIndex++;
            expectedIndex++;
            continue;
          }
          let expectedIsMissing = false;
          {
            const compare = actualLines[actualIndex];
            for (let index = expectedIndex; !expectedIsMissing && index < expectedLines.length; index++) {
              expectedIsMissing = compare === expectedLines[index];
            }
          }
          let actualIsExtraneous = actualIndex - extraneousOffset > lastExpectedIndex || expectedIndex > lastExpectedIndex;
          if (!actualIsExtraneous) {
            const compare = expectedLines[expectedIndex];
            for (let index = actualIndex; !actualIsExtraneous && index < actualLines.length; index++) {
              actualIsExtraneous = compare === actualLines[index];
            }
            if (!actualIsExtraneous && actualIndex - extraneousOffset === lastExpectedIndex && actualIndex < lastActualIndex) {
              actualIsExtraneous = true;
            }
          }
          if (actualIsExtraneous && !expectedIsMissing) {
            const wrap = invert ? theme.string.diff.insertLine : theme.string.diff.deleteLine;
            const string = formatUtils.wrap(wrap, actualLines[actualIndex]);
            if (actualIndex === 0) {
              actualBuffer.push(lineBuilder.actual.first(theme.string.multiline.start + string));
              mustOpenNextExpected = true;
            } else if (actualIndex === lastActualIndex) {
              actualBuffer.push(lineBuilder.actual.last(indentation + string + theme.string.multiline.end));
            } else {
              actualBuffer.push(lineBuilder.actual.line(indentation + string));
            }
            actualIndex++;
            extraneousOffset++;
          } else if (expectedIsMissing && !actualIsExtraneous) {
            const wrap = invert ? theme.string.diff.deleteLine : theme.string.diff.insertLine;
            const string = formatUtils.wrap(wrap, expectedLines[expectedIndex]);
            if (mustOpenNextExpected) {
              expectedBuffer.push(lineBuilder.expected.first(theme.string.multiline.start + string));
              mustOpenNextExpected = false;
            } else if (expectedIndex === lastExpectedIndex) {
              expectedBuffer.push(lineBuilder.expected.last(indentation + string + theme.string.multiline.end));
            } else {
              expectedBuffer.push(lineBuilder.expected.line(indentation + string));
            }
            expectedIndex++;
          } else {
            const result = diffLine(theme, actualLines[actualIndex], expectedLines[expectedIndex], invert);
            if (actualIndex === 0) {
              actualBuffer.push(lineBuilder.actual.first(theme.string.multiline.start + result[0]));
              mustOpenNextExpected = true;
            } else if (actualIndex === lastActualIndex) {
              actualBuffer.push(lineBuilder.actual.last(indentation + result[0] + theme.string.multiline.end));
            } else {
              actualBuffer.push(lineBuilder.actual.line(indentation + result[0]));
            }
            if (mustOpenNextExpected) {
              expectedBuffer.push(lineBuilder.expected.first(theme.string.multiline.start + result[1]));
              mustOpenNextExpected = false;
            } else if (expectedIndex === lastExpectedIndex) {
              expectedBuffer.push(lineBuilder.expected.last(indentation + result[1] + theme.string.multiline.end));
            } else {
              expectedBuffer.push(lineBuilder.expected.line(indentation + result[1]));
            }
            actualIndex++;
            expectedIndex++;
          }
        }
        lines.append(actualBuffer);
        lines.append(expectedBuffer);
        return lines;
      }
      serialize() {
        return this.value;
      }
    };
    Object.defineProperty(StringValue.prototype, "isPrimitive", { value: true });
    Object.defineProperty(StringValue.prototype, "tag", { value: tag });
  }
});

// node_modules/concordance/lib/complexValues/boxed.js
var require_boxed = __commonJS({
  "node_modules/concordance/lib/complexValues/boxed.js"(exports2) {
    "use strict";
    var stringPrimitive = require_string2().tag;
    var recursorUtils = require_recursorUtils();
    var object = require_object();
    function describe(props) {
      return new DescribedBoxedValue(props);
    }
    exports2.describe = describe;
    function deserialize(state, recursor) {
      return new DeserializedBoxedValue(state, recursor);
    }
    exports2.deserialize = deserialize;
    var tag = Symbol("BoxedValue");
    exports2.tag = tag;
    var BoxedValue = class extends object.ObjectValue {
    };
    Object.defineProperty(BoxedValue.prototype, "tag", { value: tag });
    var DescribedBoxedValue = class extends object.DescribedMixin(BoxedValue) {
      constructor(props) {
        super(props);
        this.unboxed = props.unboxed;
      }
      createListRecursor() {
        return recursorUtils.NOOP_RECURSOR;
      }
      createPropertyRecursor() {
        if (this.unboxed.tag !== stringPrimitive) return super.createPropertyRecursor();
        try {
          this.isList = true;
          return super.createPropertyRecursor();
        } finally {
          this.isList = false;
        }
      }
      createRecursor() {
        return recursorUtils.unshift(super.createRecursor(), this.unboxed);
      }
    };
    var DeserializedBoxedValue = object.DeserializedMixin(BoxedValue);
  }
});

// node_modules/concordance/lib/complexValues/dataView.js
var require_dataView = __commonJS({
  "node_modules/concordance/lib/complexValues/dataView.js"(exports2) {
    "use strict";
    var typedArray = require_typedArray();
    function describe(props) {
      return new DescribedDataViewValue(Object.assign({
        buffer: typedArray.getBuffer(props.value),
        // Set isArray and isList so the property recursor excludes the byte accessors
        isArray: true,
        isList: true
      }, props));
    }
    exports2.describe = describe;
    function deserialize(state, recursor) {
      return new DeserializedDataViewValue(state, recursor);
    }
    exports2.deserialize = deserialize;
    var tag = Symbol("DataViewValue");
    exports2.tag = tag;
    var DataViewValue = class extends typedArray.TypedArrayValue {
    };
    Object.defineProperty(DataViewValue.prototype, "tag", { value: tag });
    var DescribedDataViewValue = typedArray.DescribedMixin(DataViewValue);
    var DeserializedDataViewValue = typedArray.DeserializedMixin(DataViewValue);
  }
});

// node_modules/time-zone/index.js
var require_time_zone = __commonJS({
  "node_modules/time-zone/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (date) => {
      const offset = (date || /* @__PURE__ */ new Date()).getTimezoneOffset();
      const absOffset = Math.abs(offset);
      const hours = Math.floor(absOffset / 60);
      const minutes = absOffset % 60;
      const minutesOut = minutes > 0 ? ":" + ("0" + minutes).slice(-2) : "";
      return (offset < 0 ? "+" : "-") + hours + minutesOut;
    };
  }
});

// node_modules/date-time/index.js
var require_date_time = __commonJS({
  "node_modules/date-time/index.js"(exports2, module2) {
    "use strict";
    var timeZone = require_time_zone();
    var dateTime = (options) => {
      options = Object.assign({
        date: /* @__PURE__ */ new Date(),
        local: true,
        showTimeZone: false,
        showMilliseconds: false
      }, options);
      let { date } = options;
      if (options.local) {
        date = new Date(date.getTime() - date.getTimezoneOffset() * 6e4);
      }
      let end = "";
      if (options.showTimeZone) {
        end = " UTC" + (options.local ? timeZone(date) : "");
      }
      if (options.showMilliseconds && date.getUTCMilliseconds() > 0) {
        end = ` ${date.getUTCMilliseconds()}ms${end}`;
      }
      return date.toISOString().replace(/T/, " ").replace(/\..+/, end);
    };
    module2.exports = dateTime;
    module2.exports.default = dateTime;
  }
});

// node_modules/concordance/lib/complexValues/date.js
var require_date = __commonJS({
  "node_modules/concordance/lib/complexValues/date.js"(exports2) {
    "use strict";
    var dateTime = require_date_time();
    var constants = require_constants4();
    var formatUtils = require_formatUtils();
    var lineBuilder = require_lineBuilder();
    var object = require_object();
    var SHALLOW_EQUAL = constants.SHALLOW_EQUAL;
    var UNEQUAL = constants.UNEQUAL;
    function describe(props) {
      const date = props.value;
      const invalid = isNaN(date.valueOf());
      return new DescribedDateValue(Object.assign({}, props, { invalid }));
    }
    exports2.describe = describe;
    function deserialize(state, recursor) {
      return new DeserializedDateValue(state, recursor);
    }
    exports2.deserialize = deserialize;
    var tag = Symbol("DateValue");
    exports2.tag = tag;
    function formatDate(date) {
      return dateTime({
        date,
        local: false,
        showTimeZone: true,
        showMilliseconds: true
      });
    }
    var DateValue = class extends object.ObjectValue {
      constructor(props) {
        super(props);
        this.invalid = props.invalid;
      }
      compare(expected) {
        const result = super.compare(expected);
        if (result !== SHALLOW_EQUAL) return result;
        return this.invalid && expected.invalid || Object.is(this.value.getTime(), expected.value.getTime()) ? SHALLOW_EQUAL : UNEQUAL;
      }
      formatShallow(theme, indent) {
        const string = formatUtils.formatCtorAndStringTag(theme, this) + " " + (this.invalid ? theme.date.invalid : formatUtils.wrap(theme.date.value, formatDate(this.value))) + " " + theme.object.openBracket;
        return super.formatShallow(theme, indent).customize({
          finalize(innerLines) {
            return innerLines.isEmpty ? lineBuilder.single(string + theme.object.closeBracket) : lineBuilder.first(string).concat(innerLines.withFirstPrefixed(indent.increase()).stripFlags()).append(lineBuilder.last(indent + theme.object.closeBracket));
          },
          maxDepth() {
            return lineBuilder.single(string + " " + theme.maxDepth + " " + theme.object.closeBracket);
          }
        });
      }
      serialize() {
        const iso = this.invalid ? null : this.value.toISOString();
        return [this.invalid, iso, super.serialize()];
      }
    };
    Object.defineProperty(DateValue.prototype, "tag", { value: tag });
    var DescribedDateValue = object.DescribedMixin(DateValue);
    var DeserializedDateValue = class extends object.DeserializedMixin(DateValue) {
      constructor(state, recursor) {
        super(state[2], recursor);
        this.invalid = state[0];
        this.value = new Date(this.invalid ? NaN : state[1]);
      }
    };
  }
});

// node_modules/concordance/lib/isEnumerable.js
var require_isEnumerable = __commonJS({
  "node_modules/concordance/lib/isEnumerable.js"(exports2, module2) {
    "use strict";
    function isEnumerable(obj, key) {
      const desc = Object.getOwnPropertyDescriptor(obj, key);
      return desc && desc.enumerable;
    }
    module2.exports = isEnumerable;
  }
});

// node_modules/concordance/lib/complexValues/error.js
var require_error2 = __commonJS({
  "node_modules/concordance/lib/complexValues/error.js"(exports2) {
    "use strict";
    var constants = require_constants4();
    var formatUtils = require_formatUtils();
    var isEnumerable = require_isEnumerable();
    var lineBuilder = require_lineBuilder();
    var NOOP_RECURSOR = require_recursorUtils().NOOP_RECURSOR;
    var object = require_object();
    var UNEQUAL = constants.UNEQUAL;
    function describe(props) {
      const error = props.value;
      return new DescribedErrorValue(Object.assign({
        nameIsEnumerable: isEnumerable(error, "name"),
        name: error.name,
        messageIsEnumerable: isEnumerable(error, "message"),
        message: error.message
      }, props));
    }
    exports2.describe = describe;
    function deserialize(state, recursor) {
      return new DeserializedErrorValue(state, recursor);
    }
    exports2.deserialize = deserialize;
    var tag = Symbol("ErrorValue");
    exports2.tag = tag;
    var ErrorValue = class extends object.ObjectValue {
      constructor(props) {
        super(props);
        this.name = props.name;
      }
      compare(expected) {
        return this.tag === expected.tag && this.name === expected.name ? super.compare(expected) : UNEQUAL;
      }
      formatShallow(theme, indent) {
        const name = this.name || this.ctor;
        let string = name ? formatUtils.wrap(theme.error.name, name) : formatUtils.wrap(theme.object.stringTag, this.stringTag);
        if (this.ctor && this.ctor !== name) {
          string += " " + formatUtils.wrap(theme.error.ctor, this.ctor);
        }
        if (this.stringTag && this.stringTag !== this.ctor && this.name && !this.name.includes(this.stringTag)) {
          string += " " + formatUtils.wrap(theme.object.secondaryStringTag, this.stringTag);
        }
        string += " " + theme.object.openBracket;
        return super.formatShallow(theme, indent).customize({
          finalize(innerLines) {
            return innerLines.isEmpty ? lineBuilder.single(string + theme.object.closeBracket) : lineBuilder.first(string).concat(innerLines.withFirstPrefixed(indent.increase()).stripFlags()).append(lineBuilder.last(indent + theme.object.closeBracket));
          },
          maxDepth() {
            return lineBuilder.single(string + " " + theme.maxDepth + " " + theme.object.closeBracket);
          }
        });
      }
      serialize() {
        return [this.name, super.serialize()];
      }
    };
    Object.defineProperty(ErrorValue.prototype, "tag", { value: tag });
    var DescribedErrorValue = class extends object.DescribedMixin(ErrorValue) {
      constructor(props) {
        super(props);
        this.nameIsEnumerable = props.nameIsEnumerable;
        this.messageIsEnumerable = props.messageIsEnumerable;
        this.message = props.message;
      }
      createPropertyRecursor() {
        const recursor = super.createPropertyRecursor();
        let skipName = this.nameIsEnumerable;
        let emitMessage = !this.messageIsEnumerable;
        let size = recursor.size;
        if (skipName && size > 0) {
          size -= 1;
        }
        if (emitMessage) {
          size += 1;
        }
        if (size === 0) return NOOP_RECURSOR;
        let done = false;
        const next = () => {
          if (done) return null;
          const property = recursor.next();
          if (property) {
            if (skipName && property.key.value === "name") {
              skipName = false;
              return next();
            }
            return property;
          }
          if (emitMessage) {
            emitMessage = false;
            return this.describeProperty("message", this.describeAny(this.message));
          }
          done = true;
          return null;
        };
        return { size, next };
      }
    };
    var DeserializedErrorValue = class extends object.DeserializedMixin(ErrorValue) {
      constructor(state, recursor) {
        super(state[1], recursor);
        this.name = state[0];
      }
    };
  }
});

// node_modules/concordance/lib/complexValues/function.js
var require_function = __commonJS({
  "node_modules/concordance/lib/complexValues/function.js"(exports2) {
    "use strict";
    var constants = require_constants4();
    var formatUtils = require_formatUtils();
    var isEnumerable = require_isEnumerable();
    var lineBuilder = require_lineBuilder();
    var NOOP_RECURSOR = require_recursorUtils().NOOP_RECURSOR;
    var object = require_object();
    var UNEQUAL = constants.UNEQUAL;
    var SHALLOW_EQUAL = constants.SHALLOW_EQUAL;
    function describe(props) {
      const fn = props.value;
      return new DescribedFunctionValue(Object.assign({
        nameIsEnumerable: isEnumerable(fn, "name"),
        name: typeof fn.name === "string" ? fn.name : null
      }, props));
    }
    exports2.describe = describe;
    function deserialize(state, recursor) {
      return new DeserializedFunctionValue(state, recursor);
    }
    exports2.deserialize = deserialize;
    var tag = Symbol("FunctionValue");
    exports2.tag = tag;
    var FunctionValue = class extends object.ObjectValue {
      constructor(props) {
        super(props);
        this.name = props.name;
      }
      formatShallow(theme, indent) {
        const string = formatUtils.wrap(theme.function.stringTag, this.stringTag) + (this.name ? " " + formatUtils.wrap(theme.function.name, this.name) : "") + " " + theme.object.openBracket;
        return super.formatShallow(theme, indent).customize({
          finalize(innerLines) {
            return innerLines.isEmpty ? lineBuilder.single(string + theme.object.closeBracket) : lineBuilder.first(string).concat(innerLines.withFirstPrefixed(indent.increase()).stripFlags()).append(lineBuilder.last(indent + theme.object.closeBracket));
          },
          maxDepth() {
            return lineBuilder.single(string + " " + theme.maxDepth + " " + theme.object.closeBracket);
          }
        });
      }
    };
    Object.defineProperty(FunctionValue.prototype, "tag", { value: tag });
    var DescribedFunctionValue = class extends object.DescribedMixin(FunctionValue) {
      constructor(props) {
        super(props);
        this.nameIsEnumerable = props.nameIsEnumerable;
      }
      compare(expected) {
        if (this.tag !== expected.tag) return UNEQUAL;
        if (this.name !== expected.name) return UNEQUAL;
        if (this.value && expected.value && this.value !== expected.value) return UNEQUAL;
        return super.compare(expected);
      }
      createPropertyRecursor() {
        const recursor = super.createPropertyRecursor();
        const skipName = this.nameIsEnumerable;
        if (!skipName) return recursor;
        let size = recursor.size;
        if (skipName) {
          size -= 1;
        }
        if (size === 0) return NOOP_RECURSOR;
        const next = () => {
          const property = recursor.next();
          if (property) {
            if (skipName && property.key.value === "name") {
              return next();
            }
            return property;
          }
          return null;
        };
        return { size, next };
      }
      serialize() {
        return [this.name, super.serialize()];
      }
    };
    var DeserializedFunctionValue = class extends object.DeserializedMixin(FunctionValue) {
      constructor(state, recursor) {
        super(state[1], recursor);
        this.name = state[0];
      }
      compare(expected) {
        if (this.tag !== expected.tag) return UNEQUAL;
        if (this.name !== expected.name) return UNEQUAL;
        if (this.stringTag !== expected.stringTag) return UNEQUAL;
        return SHALLOW_EQUAL;
      }
      serialize() {
        return [this.name, super.serialize()];
      }
    };
  }
});

// node_modules/concordance/lib/complexValues/global.js
var require_global = __commonJS({
  "node_modules/concordance/lib/complexValues/global.js"(exports2) {
    "use strict";
    var constants = require_constants4();
    var formatUtils = require_formatUtils();
    var lineBuilder = require_lineBuilder();
    var DEEP_EQUAL = constants.DEEP_EQUAL;
    var UNEQUAL = constants.UNEQUAL;
    function describe() {
      return new GlobalValue();
    }
    exports2.describe = describe;
    exports2.deserialize = describe;
    var tag = Symbol("GlobalValue");
    exports2.tag = tag;
    var GlobalValue = class {
      compare(expected) {
        return this.tag === expected.tag ? DEEP_EQUAL : UNEQUAL;
      }
      formatDeep(theme) {
        return lineBuilder.single(
          formatUtils.wrap(theme.global, "Global") + " " + theme.object.openBracket + theme.object.closeBracket
        );
      }
    };
    Object.defineProperty(GlobalValue.prototype, "isComplex", { value: true });
    Object.defineProperty(GlobalValue.prototype, "tag", { value: tag });
  }
});

// node_modules/concordance/lib/complexValues/map.js
var require_map = __commonJS({
  "node_modules/concordance/lib/complexValues/map.js"(exports2) {
    "use strict";
    var constants = require_constants4();
    var recursorUtils = require_recursorUtils();
    var object = require_object();
    var SHALLOW_EQUAL = constants.SHALLOW_EQUAL;
    var UNEQUAL = constants.UNEQUAL;
    function describe(props) {
      return new DescribedMapValue(Object.assign({
        size: props.value.size
      }, props));
    }
    exports2.describe = describe;
    function deserialize(state, recursor) {
      return new DeserializedMapValue(state, recursor);
    }
    exports2.deserialize = deserialize;
    var tag = Symbol("MapValue");
    exports2.tag = tag;
    var MapValue = class extends object.ObjectValue {
      constructor(props) {
        super(props);
        this.size = props.size;
      }
      compare(expected) {
        const result = super.compare(expected);
        if (result !== SHALLOW_EQUAL) return result;
        return this.size === expected.size ? SHALLOW_EQUAL : UNEQUAL;
      }
      prepareDiff(expected) {
        return { compareResult: super.compare(expected) };
      }
      serialize() {
        return [this.size, super.serialize()];
      }
    };
    Object.defineProperty(MapValue.prototype, "tag", { value: tag });
    var DescribedMapValue = class extends object.DescribedMixin(MapValue) {
      createIterableRecursor() {
        const size = this.size;
        if (size === 0) return recursorUtils.NOOP_RECURSOR;
        let index = 0;
        let entries;
        const next = () => {
          if (index === size) return null;
          if (!entries) {
            entries = Array.from(this.value);
          }
          const entry = entries[index++];
          return this.describeMapEntry(this.describeAny(entry[0]), this.describeAny(entry[1]));
        };
        return { size, next };
      }
    };
    var DeserializedMapValue = class extends object.DeserializedMixin(MapValue) {
      constructor(state, recursor) {
        super(state[1], recursor);
        this.size = state[0];
      }
    };
  }
});

// node_modules/concordance/lib/complexValues/promise.js
var require_promise = __commonJS({
  "node_modules/concordance/lib/complexValues/promise.js"(exports2) {
    "use strict";
    var constants = require_constants4();
    var object = require_object();
    var DEEP_EQUAL = constants.DEEP_EQUAL;
    var UNEQUAL = constants.UNEQUAL;
    function describe(props) {
      return new DescribedPromiseValue(props);
    }
    exports2.describe = describe;
    function deserialize(props) {
      return new DeserializedPromiseValue(props);
    }
    exports2.deserialize = deserialize;
    var tag = Symbol("PromiseValue");
    exports2.tag = tag;
    var PromiseValue = class extends object.ObjectValue {
    };
    Object.defineProperty(PromiseValue.prototype, "tag", { value: tag });
    var DescribedPromiseValue = class extends object.DescribedMixin(PromiseValue) {
      compare(expected) {
        return super.compare(expected) === DEEP_EQUAL ? DEEP_EQUAL : UNEQUAL;
      }
    };
    var DeserializedPromiseValue = class extends object.DeserializedMixin(PromiseValue) {
      compare(expected) {
        return super.compare(expected);
      }
    };
  }
});

// node_modules/concordance/lib/complexValues/regexp.js
var require_regexp = __commonJS({
  "node_modules/concordance/lib/complexValues/regexp.js"(exports2) {
    "use strict";
    var constants = require_constants4();
    var formatUtils = require_formatUtils();
    var lineBuilder = require_lineBuilder();
    var object = require_object();
    var UNEQUAL = constants.UNEQUAL;
    function describe(props) {
      const regexp = props.value;
      return new DescribedRegexpValue(Object.assign({
        flags: getSortedFlags(regexp),
        source: regexp.source
      }, props));
    }
    exports2.describe = describe;
    function deserialize(state, recursor) {
      return new DeserializedRegexpValue(state, recursor);
    }
    exports2.deserialize = deserialize;
    var tag = Symbol("RegexpValue");
    exports2.tag = tag;
    function getSortedFlags(regexp) {
      const flags = regexp.flags || String(regexp).slice(regexp.source.length + 2);
      return flags.split("").sort().join("");
    }
    var RegexpValue = class extends object.ObjectValue {
      constructor(props) {
        super(props);
        this.flags = props.flags;
        this.source = props.source;
      }
      compare(expected) {
        return this.tag === expected.tag && this.flags === expected.flags && this.source === expected.source ? super.compare(expected) : UNEQUAL;
      }
      formatShallow(theme, indent) {
        const ctor = this.ctor || this.stringTag;
        const regexp = formatUtils.wrap(theme.regexp.source, this.source) + formatUtils.wrap(theme.regexp.flags, this.flags);
        return super.formatShallow(theme, indent).customize({
          finalize: (innerLines) => {
            if (ctor === "RegExp" && innerLines.isEmpty) return lineBuilder.single(regexp);
            const innerIndentation = indent.increase();
            const header = lineBuilder.first(formatUtils.formatCtorAndStringTag(theme, this) + " " + theme.object.openBracket).concat(lineBuilder.line(innerIndentation + regexp));
            if (!innerLines.isEmpty) {
              header.append(lineBuilder.line(innerIndentation + theme.regexp.separator));
              header.append(innerLines.withFirstPrefixed(innerIndentation).stripFlags());
            }
            return header.append(lineBuilder.last(indent + theme.object.closeBracket));
          },
          maxDepth: () => {
            return lineBuilder.single(
              formatUtils.formatCtorAndStringTag(theme, this) + " " + theme.object.openBracket + " " + regexp + " " + theme.maxDepth + " " + theme.object.closeBracket
            );
          }
        });
      }
      serialize() {
        return [this.flags, this.source, super.serialize()];
      }
    };
    Object.defineProperty(RegexpValue.prototype, "tag", { value: tag });
    var DescribedRegexpValue = object.DescribedMixin(RegexpValue);
    var DeserializedRegexpValue = class extends object.DeserializedMixin(RegexpValue) {
      constructor(state, recursor) {
        super(state[2], recursor);
        this.flags = state[0];
        this.source = state[1];
      }
    };
  }
});

// node_modules/concordance/lib/complexValues/set.js
var require_set = __commonJS({
  "node_modules/concordance/lib/complexValues/set.js"(exports2) {
    "use strict";
    var constants = require_constants4();
    var recursorUtils = require_recursorUtils();
    var object = require_object();
    var SHALLOW_EQUAL = constants.SHALLOW_EQUAL;
    var UNEQUAL = constants.UNEQUAL;
    function describe(props) {
      return new DescribedSetValue(Object.assign({
        size: props.value.size
      }, props));
    }
    exports2.describe = describe;
    function deserialize(state, recursor) {
      return new DeserializedSetValue(state, recursor);
    }
    exports2.deserialize = deserialize;
    var tag = Symbol("SetValue");
    exports2.tag = tag;
    var SetValue = class extends object.ObjectValue {
      constructor(props) {
        super(props);
        this.size = props.size;
      }
      compare(expected) {
        const result = super.compare(expected);
        if (result !== SHALLOW_EQUAL) return result;
        return this.size === expected.size ? SHALLOW_EQUAL : UNEQUAL;
      }
      prepareDiff(expected) {
        return { compareResult: super.compare(expected) };
      }
      serialize() {
        return [this.size, super.serialize()];
      }
    };
    Object.defineProperty(SetValue.prototype, "tag", { value: tag });
    var DescribedSetValue = class extends object.DescribedMixin(SetValue) {
      createIterableRecursor() {
        const size = this.size;
        if (size === 0) return recursorUtils.NOOP_RECURSOR;
        let index = 0;
        let members;
        const next = () => {
          if (index === size) return null;
          if (!members) {
            members = Array.from(this.value);
          }
          const value2 = members[index];
          return this.describeItem(index++, this.describeAny(value2));
        };
        return { size, next };
      }
    };
    var DeserializedSetValue = class extends object.DeserializedMixin(SetValue) {
      constructor(state, recursor) {
        super(state[1], recursor);
        this.size = state[0];
      }
    };
  }
});

// node_modules/concordance/lib/getCtor.js
var require_getCtor = __commonJS({
  "node_modules/concordance/lib/getCtor.js"(exports2, module2) {
    "use strict";
    var hop = Object.prototype.hasOwnProperty;
    function getCtor(stringTag, value2) {
      if (value2.constructor) {
        const name = value2.constructor.name;
        return typeof name === "string" && name !== "" ? name : null;
      }
      if (value2.constructor === void 0) {
        if (stringTag !== "Object" || value2 instanceof Object) return null;
        for (var p in value2) {
          if (!hop.call(value2, p)) return null;
        }
        return stringTag;
      }
      return null;
    }
    module2.exports = getCtor;
  }
});

// node_modules/concordance/lib/getStringTag.js
var require_getStringTag = __commonJS({
  "node_modules/concordance/lib/getStringTag.js"(exports2, module2) {
    "use strict";
    var ts = Object.prototype.toString;
    function getStringTag(value2) {
      return ts.call(value2).slice(8, -1);
    }
    var fts = Function.prototype.toString;
    var promiseCtorString = fts.call(Promise);
    var isPromise = (value2) => {
      if (!value2.constructor) return false;
      try {
        return fts.call(value2.constructor) === promiseCtorString;
      } catch {
        return false;
      }
    };
    if (getStringTag(Promise.resolve()) === "Promise") {
      module2.exports = getStringTag;
    } else {
      const getStringTagWithPromiseWorkaround = (value2) => {
        const stringTag = getStringTag(value2);
        return stringTag === "Object" && isPromise(value2) ? "Promise" : stringTag;
      };
      module2.exports = getStringTagWithPromiseWorkaround;
    }
  }
});

// node_modules/concordance/lib/metaDescriptors/item.js
var require_item = __commonJS({
  "node_modules/concordance/lib/metaDescriptors/item.js"(exports2) {
    "use strict";
    var constants = require_constants4();
    var formatUtils = require_formatUtils();
    var recursorUtils = require_recursorUtils();
    var DEEP_EQUAL = constants.DEEP_EQUAL;
    var UNEQUAL = constants.UNEQUAL;
    function describeComplex(index, value2) {
      return new ComplexItem(index, value2);
    }
    exports2.describeComplex = describeComplex;
    function deserializeComplex(index, recursor) {
      const value2 = recursor();
      return new ComplexItem(index, value2);
    }
    exports2.deserializeComplex = deserializeComplex;
    function describePrimitive(index, value2) {
      return new PrimitiveItem(index, value2);
    }
    exports2.describePrimitive = describePrimitive;
    function deserializePrimitive(state) {
      const index = state[0];
      const value2 = state[1];
      return new PrimitiveItem(index, value2);
    }
    exports2.deserializePrimitive = deserializePrimitive;
    var complexTag = Symbol("ComplexItem");
    exports2.complexTag = complexTag;
    var primitiveTag = Symbol("PrimitiveItem");
    exports2.primitiveTag = primitiveTag;
    var ComplexItem = class {
      constructor(index, value2) {
        this.index = index;
        this.value = value2;
      }
      createRecursor() {
        return recursorUtils.singleValue(this.value);
      }
      compare(expected) {
        return expected.tag === complexTag && this.index === expected.index ? this.value.compare(expected.value) : UNEQUAL;
      }
      formatShallow(theme, indent) {
        const increaseValueIndent = theme.item.increaseValueIndent === true;
        return new formatUtils.SingleValueFormatter(theme, (value2) => {
          if (typeof theme.item.customFormat === "function") {
            return theme.item.customFormat(theme, indent, value2);
          }
          return value2.withLastPostfixed(theme.item.after);
        }, increaseValueIndent);
      }
      prepareDiff(expected, lhsRecursor, rhsRecursor, compareComplexShape, isCircular) {
        if (isCircular(this.value) || isCircular(expected.value)) return { compareResult: UNEQUAL };
        const lhsFork = recursorUtils.fork(lhsRecursor);
        const rhsFork = recursorUtils.fork(rhsRecursor);
        const initialExpected = expected;
        let expectedIsMissing = false;
        while (!expectedIsMissing && expected !== null && expected.isItem === true) {
          if (expected.tag === complexTag) {
            expectedIsMissing = compareComplexShape(this.value, expected.value) !== UNEQUAL;
          }
          expected = rhsFork.shared();
        }
        let actualIsExtraneous = false;
        if (initialExpected.tag === complexTag) {
          let actual = this;
          while (!actualIsExtraneous && actual !== null && actual.isItem === true) {
            if (actual.tag === complexTag) {
              actualIsExtraneous = compareComplexShape(actual.value, initialExpected.value) !== UNEQUAL;
            }
            actual = lhsFork.shared();
          }
        } else if (initialExpected.tag === primitiveTag) {
          let actual = this;
          while (!actualIsExtraneous && actual !== null && actual.isItem === true) {
            if (actual.tag === primitiveTag) {
              actualIsExtraneous = initialExpected.value.compare(actual.value) === DEEP_EQUAL;
            }
            actual = lhsFork.shared();
          }
        }
        if (actualIsExtraneous && !expectedIsMissing) {
          return {
            actualIsExtraneous: true,
            lhsRecursor: lhsFork.recursor,
            rhsRecursor: recursorUtils.map(
              recursorUtils.unshift(rhsFork.recursor, initialExpected),
              (next) => {
                if (next.isItem !== true) return next;
                next.index++;
                return next;
              }
            )
          };
        }
        if (expectedIsMissing && !actualIsExtraneous) {
          return {
            expectedIsMissing: true,
            lhsRecursor: recursorUtils.map(
              recursorUtils.unshift(lhsFork.recursor, this),
              (next) => {
                if (next.isItem !== true) return next;
                next.index++;
                return next;
              }
            ),
            rhsRecursor: rhsFork.recursor
          };
        }
        const mustRecurse = this.tag === complexTag && initialExpected.tag === complexTag && this.value.compare(initialExpected.value) !== UNEQUAL;
        return {
          mustRecurse,
          isUnequal: !mustRecurse,
          lhsRecursor: lhsFork.recursor,
          rhsRecursor: rhsFork.recursor
        };
      }
      serialize() {
        return this.index;
      }
    };
    Object.defineProperty(ComplexItem.prototype, "isItem", { value: true });
    Object.defineProperty(ComplexItem.prototype, "tag", { value: complexTag });
    var PrimitiveItem = class {
      constructor(index, value2) {
        this.index = index;
        this.value = value2;
      }
      compare(expected) {
        return expected.tag === primitiveTag && this.index === expected.index ? this.value.compare(expected.value) : UNEQUAL;
      }
      formatDeep(theme, indent) {
        const increaseValueIndent = theme.item.increaseValueIndent === true;
        const valueIndent = increaseValueIndent ? indent.increase() : indent;
        const formatted = this.value.formatDeep(theme, valueIndent);
        if (typeof theme.item.customFormat === "function") {
          return theme.item.customFormat(theme, indent, formatted);
        }
        return formatted.withLastPostfixed(theme.item.after);
      }
      prepareDiff(expected, lhsRecursor, rhsRecursor, compareComplexShape, isCircular) {
        const compareResult = this.compare(expected);
        if (compareResult === DEEP_EQUAL) return { compareResult };
        if (expected.tag === primitiveTag && this.value.tag === expected.value.tag && typeof this.value.diffDeep === "function") {
          return { compareResult };
        }
        const rhsFork = recursorUtils.fork(rhsRecursor);
        const initialExpected = expected;
        do {
          if (expected === null || expected.isItem !== true) {
            return {
              actualIsExtraneous: true,
              rhsRecursor: recursorUtils.map(
                recursorUtils.unshift(rhsFork.recursor, initialExpected),
                (next) => {
                  if (next.isItem !== true) return next;
                  next.index++;
                  return next;
                }
              )
            };
          }
          if (this.value.compare(expected.value) === DEEP_EQUAL) {
            return {
              expectedIsMissing: true,
              lhsRecursor: recursorUtils.map(
                recursorUtils.unshift(lhsRecursor, this),
                (next) => {
                  if (next.isItem !== true) return next;
                  next.index++;
                  return next;
                }
              ),
              rhsRecursor: rhsFork.recursor
            };
          }
          expected = rhsFork.shared();
        } while (true);
      }
      diffDeep(expected, theme, indent, invert) {
        if (this.tag !== expected.tag || typeof this.value.diffDeep !== "function") return null;
        const increaseValueIndent = theme.property.increaseValueIndent === true;
        const valueIndent = increaseValueIndent ? indent.increase() : indent;
        const diff = this.value.diffDeep(expected.value, theme, valueIndent, invert);
        if (diff === null) return null;
        if (typeof theme.item.customFormat === "function") {
          return theme.item.customFormat(theme, indent, diff);
        }
        return diff.withLastPostfixed(theme.item.after);
      }
      serialize() {
        return [this.index, this.value];
      }
    };
    Object.defineProperty(PrimitiveItem.prototype, "isItem", { value: true });
    Object.defineProperty(PrimitiveItem.prototype, "tag", { value: primitiveTag });
  }
});

// node_modules/concordance/node_modules/semver/internal/constants.js
var require_constants5 = __commonJS({
  "node_modules/concordance/node_modules/semver/internal/constants.js"(exports2, module2) {
    "use strict";
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var RELEASE_TYPES = [
      "major",
      "premajor",
      "minor",
      "preminor",
      "patch",
      "prepatch",
      "prerelease"
    ];
    module2.exports = {
      MAX_LENGTH,
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_SAFE_INTEGER,
      RELEASE_TYPES,
      SEMVER_SPEC_VERSION,
      FLAG_INCLUDE_PRERELEASE: 1,
      FLAG_LOOSE: 2
    };
  }
});

// node_modules/concordance/node_modules/semver/internal/debug.js
var require_debug = __commonJS({
  "node_modules/concordance/node_modules/semver/internal/debug.js"(exports2, module2) {
    "use strict";
    var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module2.exports = debug;
  }
});

// node_modules/concordance/node_modules/semver/internal/re.js
var require_re = __commonJS({
  "node_modules/concordance/node_modules/semver/internal/re.js"(exports2, module2) {
    "use strict";
    var {
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_LENGTH
    } = require_constants5();
    var debug = require_debug();
    exports2 = module2.exports = {};
    var re = exports2.re = [];
    var safeRe = exports2.safeRe = [];
    var src = exports2.src = [];
    var t = exports2.t = {};
    var R = 0;
    var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    var safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    var makeSafeRegex = (value2) => {
      for (const [token, max] of safeRegexReplacements) {
        value2 = value2.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
      }
      return value2;
    };
    var createToken = (name, value2, isGlobal) => {
      const safe = makeSafeRegex(value2);
      const index = R++;
      debug(name, index, value2);
      t[name] = index;
      src[index] = value2;
      re[index] = new RegExp(value2, isGlobal ? "g" : void 0);
      safeRe[index] = new RegExp(safe, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
    createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
    createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
    createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
    createToken("FULL", `^${src[t.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
    createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COERCE", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t.COERCE], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
    exports2.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
    exports2.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
    exports2.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  }
});

// node_modules/concordance/node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS({
  "node_modules/concordance/node_modules/semver/internal/parse-options.js"(exports2, module2) {
    "use strict";
    var looseOption = Object.freeze({ loose: true });
    var emptyOpts = Object.freeze({});
    var parseOptions = (options) => {
      if (!options) {
        return emptyOpts;
      }
      if (typeof options !== "object") {
        return looseOption;
      }
      return options;
    };
    module2.exports = parseOptions;
  }
});

// node_modules/concordance/node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS({
  "node_modules/concordance/node_modules/semver/internal/identifiers.js"(exports2, module2) {
    "use strict";
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = (a, b) => {
      const anum = numeric.test(a);
      const bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    };
    var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
    module2.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
});

// node_modules/concordance/node_modules/semver/classes/semver.js
var require_semver = __commonJS({
  "node_modules/concordance/node_modules/semver/classes/semver.js"(exports2, module2) {
    "use strict";
    var debug = require_debug();
    var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants5();
    var { safeRe: re, t } = require_re();
    var parseOptions = require_parse_options();
    var { compareIdentifiers } = require_identifiers();
    var SemVer = class _SemVer {
      constructor(version, options) {
        options = parseOptions(options);
        if (version instanceof _SemVer) {
          if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
            return version;
          } else {
            version = version.version;
          }
        } else if (typeof version !== "string") {
          throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`);
        }
        if (version.length > MAX_LENGTH) {
          throw new TypeError(
            `version is longer than ${MAX_LENGTH} characters`
          );
        }
        debug("SemVer", version, options);
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
        if (!m) {
          throw new TypeError(`Invalid Version: ${version}`);
        }
        this.raw = version;
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m[4].split(".").map((id) => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }
            return id;
          });
        }
        this.build = m[5] ? m[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof _SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new _SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
      }
      comparePre(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i = 0;
        do {
          const a = this.prerelease[i];
          const b = other.prerelease[i];
          debug("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      compareBuild(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        let i = 0;
        do {
          const a = this.build[i];
          const b = other.build[i];
          debug("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      // preminor will bump the version up to the next minor release, and immediately
      // down to pre-release. premajor and prepatch work the same way.
      inc(release, identifier, identifierBase) {
        switch (release) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier, identifierBase);
            this.inc("pre", identifier, identifierBase);
            break;
          // If the input is a non-prerelease version, this acts the same as
          // prepatch.
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier, identifierBase);
            }
            this.inc("pre", identifier, identifierBase);
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          // This probably shouldn't be used publicly.
          // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
          case "pre": {
            const base = Number(identifierBase) ? 1 : 0;
            if (!identifier && identifierBase === false) {
              throw new Error("invalid increment argument: identifier is empty");
            }
            if (this.prerelease.length === 0) {
              this.prerelease = [base];
            } else {
              let i = this.prerelease.length;
              while (--i >= 0) {
                if (typeof this.prerelease[i] === "number") {
                  this.prerelease[i]++;
                  i = -2;
                }
              }
              if (i === -1) {
                if (identifier === this.prerelease.join(".") && identifierBase === false) {
                  throw new Error("invalid increment argument: identifier already exists");
                }
                this.prerelease.push(base);
              }
            }
            if (identifier) {
              let prerelease = [identifier, base];
              if (identifierBase === false) {
                prerelease = [identifier];
              }
              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = prerelease;
                }
              } else {
                this.prerelease = prerelease;
              }
            }
            break;
          }
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        this.raw = this.format();
        if (this.build.length) {
          this.raw += `+${this.build.join(".")}`;
        }
        return this;
      }
    };
    module2.exports = SemVer;
  }
});

// node_modules/concordance/node_modules/semver/functions/parse.js
var require_parse3 = __commonJS({
  "node_modules/concordance/node_modules/semver/functions/parse.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var parse = (version, options, throwErrors = false) => {
      if (version instanceof SemVer) {
        return version;
      }
      try {
        return new SemVer(version, options);
      } catch (er) {
        if (!throwErrors) {
          return null;
        }
        throw er;
      }
    };
    module2.exports = parse;
  }
});

// node_modules/concordance/node_modules/semver/functions/valid.js
var require_valid = __commonJS({
  "node_modules/concordance/node_modules/semver/functions/valid.js"(exports2, module2) {
    "use strict";
    var parse = require_parse3();
    var valid = (version, options) => {
      const v = parse(version, options);
      return v ? v.version : null;
    };
    module2.exports = valid;
  }
});

// node_modules/concordance/node_modules/semver/functions/clean.js
var require_clean = __commonJS({
  "node_modules/concordance/node_modules/semver/functions/clean.js"(exports2, module2) {
    "use strict";
    var parse = require_parse3();
    var clean = (version, options) => {
      const s = parse(version.trim().replace(/^[=v]+/, ""), options);
      return s ? s.version : null;
    };
    module2.exports = clean;
  }
});

// node_modules/concordance/node_modules/semver/functions/inc.js
var require_inc = __commonJS({
  "node_modules/concordance/node_modules/semver/functions/inc.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var inc = (version, release, options, identifier, identifierBase) => {
      if (typeof options === "string") {
        identifierBase = identifier;
        identifier = options;
        options = void 0;
      }
      try {
        return new SemVer(
          version instanceof SemVer ? version.version : version,
          options
        ).inc(release, identifier, identifierBase).version;
      } catch (er) {
        return null;
      }
    };
    module2.exports = inc;
  }
});

// node_modules/concordance/node_modules/semver/functions/diff.js
var require_diff2 = __commonJS({
  "node_modules/concordance/node_modules/semver/functions/diff.js"(exports2, module2) {
    "use strict";
    var parse = require_parse3();
    var diff = (version1, version2) => {
      const v1 = parse(version1, null, true);
      const v2 = parse(version2, null, true);
      const comparison = v1.compare(v2);
      if (comparison === 0) {
        return null;
      }
      const v1Higher = comparison > 0;
      const highVersion = v1Higher ? v1 : v2;
      const lowVersion = v1Higher ? v2 : v1;
      const highHasPre = !!highVersion.prerelease.length;
      const lowHasPre = !!lowVersion.prerelease.length;
      if (lowHasPre && !highHasPre) {
        if (!lowVersion.patch && !lowVersion.minor) {
          return "major";
        }
        if (highVersion.patch) {
          return "patch";
        }
        if (highVersion.minor) {
          return "minor";
        }
        return "major";
      }
      const prefix = highHasPre ? "pre" : "";
      if (v1.major !== v2.major) {
        return prefix + "major";
      }
      if (v1.minor !== v2.minor) {
        return prefix + "minor";
      }
      if (v1.patch !== v2.patch) {
        return prefix + "patch";
      }
      return "prerelease";
    };
    module2.exports = diff;
  }
});

// node_modules/concordance/node_modules/semver/functions/major.js
var require_major = __commonJS({
  "node_modules/concordance/node_modules/semver/functions/major.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var major = (a, loose) => new SemVer(a, loose).major;
    module2.exports = major;
  }
});

// node_modules/concordance/node_modules/semver/functions/minor.js
var require_minor = __commonJS({
  "node_modules/concordance/node_modules/semver/functions/minor.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var minor = (a, loose) => new SemVer(a, loose).minor;
    module2.exports = minor;
  }
});

// node_modules/concordance/node_modules/semver/functions/patch.js
var require_patch = __commonJS({
  "node_modules/concordance/node_modules/semver/functions/patch.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var patch = (a, loose) => new SemVer(a, loose).patch;
    module2.exports = patch;
  }
});

// node_modules/concordance/node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS({
  "node_modules/concordance/node_modules/semver/functions/prerelease.js"(exports2, module2) {
    "use strict";
    var parse = require_parse3();
    var prerelease = (version, options) => {
      const parsed = parse(version, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    };
    module2.exports = prerelease;
  }
});

// node_modules/concordance/node_modules/semver/functions/compare.js
var require_compare = __commonJS({
  "node_modules/concordance/node_modules/semver/functions/compare.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
    module2.exports = compare;
  }
});

// node_modules/concordance/node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS({
  "node_modules/concordance/node_modules/semver/functions/rcompare.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var rcompare = (a, b, loose) => compare(b, a, loose);
    module2.exports = rcompare;
  }
});

// node_modules/concordance/node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS({
  "node_modules/concordance/node_modules/semver/functions/compare-loose.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var compareLoose = (a, b) => compare(a, b, true);
    module2.exports = compareLoose;
  }
});

// node_modules/concordance/node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS({
  "node_modules/concordance/node_modules/semver/functions/compare-build.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var compareBuild = (a, b, loose) => {
      const versionA = new SemVer(a, loose);
      const versionB = new SemVer(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    };
    module2.exports = compareBuild;
  }
});

// node_modules/concordance/node_modules/semver/functions/sort.js
var require_sort = __commonJS({
  "node_modules/concordance/node_modules/semver/functions/sort.js"(exports2, module2) {
    "use strict";
    var compareBuild = require_compare_build();
    var sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));
    module2.exports = sort;
  }
});

// node_modules/concordance/node_modules/semver/functions/rsort.js
var require_rsort = __commonJS({
  "node_modules/concordance/node_modules/semver/functions/rsort.js"(exports2, module2) {
    "use strict";
    var compareBuild = require_compare_build();
    var rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
    module2.exports = rsort;
  }
});

// node_modules/concordance/node_modules/semver/functions/gt.js
var require_gt = __commonJS({
  "node_modules/concordance/node_modules/semver/functions/gt.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var gt = (a, b, loose) => compare(a, b, loose) > 0;
    module2.exports = gt;
  }
});

// node_modules/concordance/node_modules/semver/functions/lt.js
var require_lt = __commonJS({
  "node_modules/concordance/node_modules/semver/functions/lt.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var lt = (a, b, loose) => compare(a, b, loose) < 0;
    module2.exports = lt;
  }
});

// node_modules/concordance/node_modules/semver/functions/eq.js
var require_eq = __commonJS({
  "node_modules/concordance/node_modules/semver/functions/eq.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var eq = (a, b, loose) => compare(a, b, loose) === 0;
    module2.exports = eq;
  }
});

// node_modules/concordance/node_modules/semver/functions/neq.js
var require_neq = __commonJS({
  "node_modules/concordance/node_modules/semver/functions/neq.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var neq = (a, b, loose) => compare(a, b, loose) !== 0;
    module2.exports = neq;
  }
});

// node_modules/concordance/node_modules/semver/functions/gte.js
var require_gte = __commonJS({
  "node_modules/concordance/node_modules/semver/functions/gte.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var gte = (a, b, loose) => compare(a, b, loose) >= 0;
    module2.exports = gte;
  }
});

// node_modules/concordance/node_modules/semver/functions/lte.js
var require_lte = __commonJS({
  "node_modules/concordance/node_modules/semver/functions/lte.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var lte = (a, b, loose) => compare(a, b, loose) <= 0;
    module2.exports = lte;
  }
});

// node_modules/concordance/node_modules/semver/functions/cmp.js
var require_cmp = __commonJS({
  "node_modules/concordance/node_modules/semver/functions/cmp.js"(exports2, module2) {
    "use strict";
    var eq = require_eq();
    var neq = require_neq();
    var gt = require_gt();
    var gte = require_gte();
    var lt = require_lt();
    var lte = require_lte();
    var cmp = (a, op, b, loose) => {
      switch (op) {
        case "===":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a === b;
        case "!==":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    };
    module2.exports = cmp;
  }
});

// node_modules/concordance/node_modules/semver/functions/coerce.js
var require_coerce = __commonJS({
  "node_modules/concordance/node_modules/semver/functions/coerce.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var parse = require_parse3();
    var { safeRe: re, t } = require_re();
    var coerce = (version, options) => {
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version === "number") {
        version = String(version);
      }
      if (typeof version !== "string") {
        return null;
      }
      options = options || {};
      let match = null;
      if (!options.rtl) {
        match = version.match(re[t.COERCE]);
      } else {
        let next;
        while ((next = re[t.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
        }
        re[t.COERCERTL].lastIndex = -1;
      }
      if (match === null) {
        return null;
      }
      return parse(`${match[2]}.${match[3] || "0"}.${match[4] || "0"}`, options);
    };
    module2.exports = coerce;
  }
});

// node_modules/yallist/iterator.js
var require_iterator = __commonJS({
  "node_modules/yallist/iterator.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Yallist) {
      Yallist.prototype[Symbol.iterator] = function* () {
        for (let walker = this.head; walker; walker = walker.next) {
          yield walker.value;
        }
      };
    };
  }
});

// node_modules/yallist/yallist.js
var require_yallist = __commonJS({
  "node_modules/yallist/yallist.js"(exports2, module2) {
    "use strict";
    module2.exports = Yallist;
    Yallist.Node = Node;
    Yallist.create = Yallist;
    function Yallist(list) {
      var self2 = this;
      if (!(self2 instanceof Yallist)) {
        self2 = new Yallist();
      }
      self2.tail = null;
      self2.head = null;
      self2.length = 0;
      if (list && typeof list.forEach === "function") {
        list.forEach(function(item) {
          self2.push(item);
        });
      } else if (arguments.length > 0) {
        for (var i = 0, l = arguments.length; i < l; i++) {
          self2.push(arguments[i]);
        }
      }
      return self2;
    }
    Yallist.prototype.removeNode = function(node) {
      if (node.list !== this) {
        throw new Error("removing node which does not belong to this list");
      }
      var next = node.next;
      var prev = node.prev;
      if (next) {
        next.prev = prev;
      }
      if (prev) {
        prev.next = next;
      }
      if (node === this.head) {
        this.head = next;
      }
      if (node === this.tail) {
        this.tail = prev;
      }
      node.list.length--;
      node.next = null;
      node.prev = null;
      node.list = null;
      return next;
    };
    Yallist.prototype.unshiftNode = function(node) {
      if (node === this.head) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var head = this.head;
      node.list = this;
      node.next = head;
      if (head) {
        head.prev = node;
      }
      this.head = node;
      if (!this.tail) {
        this.tail = node;
      }
      this.length++;
    };
    Yallist.prototype.pushNode = function(node) {
      if (node === this.tail) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var tail = this.tail;
      node.list = this;
      node.prev = tail;
      if (tail) {
        tail.next = node;
      }
      this.tail = node;
      if (!this.head) {
        this.head = node;
      }
      this.length++;
    };
    Yallist.prototype.push = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        push(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.unshift = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        unshift(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.pop = function() {
      if (!this.tail) {
        return void 0;
      }
      var res = this.tail.value;
      this.tail = this.tail.prev;
      if (this.tail) {
        this.tail.next = null;
      } else {
        this.head = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.shift = function() {
      if (!this.head) {
        return void 0;
      }
      var res = this.head.value;
      this.head = this.head.next;
      if (this.head) {
        this.head.prev = null;
      } else {
        this.tail = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.forEach = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.head, i = 0; walker !== null; i++) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.next;
      }
    };
    Yallist.prototype.forEachReverse = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.prev;
      }
    };
    Yallist.prototype.get = function(n) {
      for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
        walker = walker.next;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.getReverse = function(n) {
      for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
        walker = walker.prev;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.map = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.head; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.next;
      }
      return res;
    };
    Yallist.prototype.mapReverse = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.tail; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.prev;
      }
      return res;
    };
    Yallist.prototype.reduce = function(fn, initial) {
      var acc;
      var walker = this.head;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.head) {
        walker = this.head.next;
        acc = this.head.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = 0; walker !== null; i++) {
        acc = fn(acc, walker.value, i);
        walker = walker.next;
      }
      return acc;
    };
    Yallist.prototype.reduceReverse = function(fn, initial) {
      var acc;
      var walker = this.tail;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.tail) {
        walker = this.tail.prev;
        acc = this.tail.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = this.length - 1; walker !== null; i--) {
        acc = fn(acc, walker.value, i);
        walker = walker.prev;
      }
      return acc;
    };
    Yallist.prototype.toArray = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.head; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.next;
      }
      return arr;
    };
    Yallist.prototype.toArrayReverse = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.tail; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.prev;
      }
      return arr;
    };
    Yallist.prototype.slice = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
        walker = walker.next;
      }
      for (; walker !== null && i < to; i++, walker = walker.next) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.sliceReverse = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
        walker = walker.prev;
      }
      for (; walker !== null && i > from; i--, walker = walker.prev) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
      if (start > this.length) {
        start = this.length - 1;
      }
      if (start < 0) {
        start = this.length + start;
      }
      for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
        walker = walker.next;
      }
      var ret = [];
      for (var i = 0; walker && i < deleteCount; i++) {
        ret.push(walker.value);
        walker = this.removeNode(walker);
      }
      if (walker === null) {
        walker = this.tail;
      }
      if (walker !== this.head && walker !== this.tail) {
        walker = walker.prev;
      }
      for (var i = 0; i < nodes.length; i++) {
        walker = insert(this, walker, nodes[i]);
      }
      return ret;
    };
    Yallist.prototype.reverse = function() {
      var head = this.head;
      var tail = this.tail;
      for (var walker = head; walker !== null; walker = walker.prev) {
        var p = walker.prev;
        walker.prev = walker.next;
        walker.next = p;
      }
      this.head = tail;
      this.tail = head;
      return this;
    };
    function insert(self2, node, value2) {
      var inserted = node === self2.head ? new Node(value2, null, node, self2) : new Node(value2, node, node.next, self2);
      if (inserted.next === null) {
        self2.tail = inserted;
      }
      if (inserted.prev === null) {
        self2.head = inserted;
      }
      self2.length++;
      return inserted;
    }
    function push(self2, item) {
      self2.tail = new Node(item, self2.tail, null, self2);
      if (!self2.head) {
        self2.head = self2.tail;
      }
      self2.length++;
    }
    function unshift(self2, item) {
      self2.head = new Node(item, null, self2.head, self2);
      if (!self2.tail) {
        self2.tail = self2.head;
      }
      self2.length++;
    }
    function Node(value2, prev, next, list) {
      if (!(this instanceof Node)) {
        return new Node(value2, prev, next, list);
      }
      this.list = list;
      this.value = value2;
      if (prev) {
        prev.next = this;
        this.prev = prev;
      } else {
        this.prev = null;
      }
      if (next) {
        next.prev = this;
        this.next = next;
      } else {
        this.next = null;
      }
    }
    try {
      require_iterator()(Yallist);
    } catch (er) {
    }
  }
});

// node_modules/lru-cache/index.js
var require_lru_cache = __commonJS({
  "node_modules/lru-cache/index.js"(exports2, module2) {
    "use strict";
    var Yallist = require_yallist();
    var MAX = Symbol("max");
    var LENGTH = Symbol("length");
    var LENGTH_CALCULATOR = Symbol("lengthCalculator");
    var ALLOW_STALE = Symbol("allowStale");
    var MAX_AGE = Symbol("maxAge");
    var DISPOSE = Symbol("dispose");
    var NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
    var LRU_LIST = Symbol("lruList");
    var CACHE = Symbol("cache");
    var UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
    var naiveLength = () => 1;
    var LRUCache = class {
      constructor(options) {
        if (typeof options === "number")
          options = { max: options };
        if (!options)
          options = {};
        if (options.max && (typeof options.max !== "number" || options.max < 0))
          throw new TypeError("max must be a non-negative number");
        const max = this[MAX] = options.max || Infinity;
        const lc = options.length || naiveLength;
        this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
        this[ALLOW_STALE] = options.stale || false;
        if (options.maxAge && typeof options.maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        this[MAX_AGE] = options.maxAge || 0;
        this[DISPOSE] = options.dispose;
        this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
        this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
        this.reset();
      }
      // resize the cache when the max changes.
      set max(mL) {
        if (typeof mL !== "number" || mL < 0)
          throw new TypeError("max must be a non-negative number");
        this[MAX] = mL || Infinity;
        trim(this);
      }
      get max() {
        return this[MAX];
      }
      set allowStale(allowStale) {
        this[ALLOW_STALE] = !!allowStale;
      }
      get allowStale() {
        return this[ALLOW_STALE];
      }
      set maxAge(mA) {
        if (typeof mA !== "number")
          throw new TypeError("maxAge must be a non-negative number");
        this[MAX_AGE] = mA;
        trim(this);
      }
      get maxAge() {
        return this[MAX_AGE];
      }
      // resize the cache when the lengthCalculator changes.
      set lengthCalculator(lC) {
        if (typeof lC !== "function")
          lC = naiveLength;
        if (lC !== this[LENGTH_CALCULATOR]) {
          this[LENGTH_CALCULATOR] = lC;
          this[LENGTH] = 0;
          this[LRU_LIST].forEach((hit) => {
            hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
            this[LENGTH] += hit.length;
          });
        }
        trim(this);
      }
      get lengthCalculator() {
        return this[LENGTH_CALCULATOR];
      }
      get length() {
        return this[LENGTH];
      }
      get itemCount() {
        return this[LRU_LIST].length;
      }
      rforEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].tail; walker !== null; ) {
          const prev = walker.prev;
          forEachStep(this, fn, walker, thisp);
          walker = prev;
        }
      }
      forEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].head; walker !== null; ) {
          const next = walker.next;
          forEachStep(this, fn, walker, thisp);
          walker = next;
        }
      }
      keys() {
        return this[LRU_LIST].toArray().map((k) => k.key);
      }
      values() {
        return this[LRU_LIST].toArray().map((k) => k.value);
      }
      reset() {
        if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
          this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
        }
        this[CACHE] = /* @__PURE__ */ new Map();
        this[LRU_LIST] = new Yallist();
        this[LENGTH] = 0;
      }
      dump() {
        return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
          k: hit.key,
          v: hit.value,
          e: hit.now + (hit.maxAge || 0)
        }).toArray().filter((h) => h);
      }
      dumpLru() {
        return this[LRU_LIST];
      }
      set(key, value2, maxAge) {
        maxAge = maxAge || this[MAX_AGE];
        if (maxAge && typeof maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        const now = maxAge ? Date.now() : 0;
        const len = this[LENGTH_CALCULATOR](value2, key);
        if (this[CACHE].has(key)) {
          if (len > this[MAX]) {
            del(this, this[CACHE].get(key));
            return false;
          }
          const node = this[CACHE].get(key);
          const item = node.value;
          if (this[DISPOSE]) {
            if (!this[NO_DISPOSE_ON_SET])
              this[DISPOSE](key, item.value);
          }
          item.now = now;
          item.maxAge = maxAge;
          item.value = value2;
          this[LENGTH] += len - item.length;
          item.length = len;
          this.get(key);
          trim(this);
          return true;
        }
        const hit = new Entry(key, value2, len, now, maxAge);
        if (hit.length > this[MAX]) {
          if (this[DISPOSE])
            this[DISPOSE](key, value2);
          return false;
        }
        this[LENGTH] += hit.length;
        this[LRU_LIST].unshift(hit);
        this[CACHE].set(key, this[LRU_LIST].head);
        trim(this);
        return true;
      }
      has(key) {
        if (!this[CACHE].has(key)) return false;
        const hit = this[CACHE].get(key).value;
        return !isStale(this, hit);
      }
      get(key) {
        return get(this, key, true);
      }
      peek(key) {
        return get(this, key, false);
      }
      pop() {
        const node = this[LRU_LIST].tail;
        if (!node)
          return null;
        del(this, node);
        return node.value;
      }
      del(key) {
        del(this, this[CACHE].get(key));
      }
      load(arr) {
        this.reset();
        const now = Date.now();
        for (let l = arr.length - 1; l >= 0; l--) {
          const hit = arr[l];
          const expiresAt = hit.e || 0;
          if (expiresAt === 0)
            this.set(hit.k, hit.v);
          else {
            const maxAge = expiresAt - now;
            if (maxAge > 0) {
              this.set(hit.k, hit.v, maxAge);
            }
          }
        }
      }
      prune() {
        this[CACHE].forEach((value2, key) => get(this, key, false));
      }
    };
    var get = (self2, key, doUse) => {
      const node = self2[CACHE].get(key);
      if (node) {
        const hit = node.value;
        if (isStale(self2, hit)) {
          del(self2, node);
          if (!self2[ALLOW_STALE])
            return void 0;
        } else {
          if (doUse) {
            if (self2[UPDATE_AGE_ON_GET])
              node.value.now = Date.now();
            self2[LRU_LIST].unshiftNode(node);
          }
        }
        return hit.value;
      }
    };
    var isStale = (self2, hit) => {
      if (!hit || !hit.maxAge && !self2[MAX_AGE])
        return false;
      const diff = Date.now() - hit.now;
      return hit.maxAge ? diff > hit.maxAge : self2[MAX_AGE] && diff > self2[MAX_AGE];
    };
    var trim = (self2) => {
      if (self2[LENGTH] > self2[MAX]) {
        for (let walker = self2[LRU_LIST].tail; self2[LENGTH] > self2[MAX] && walker !== null; ) {
          const prev = walker.prev;
          del(self2, walker);
          walker = prev;
        }
      }
    };
    var del = (self2, node) => {
      if (node) {
        const hit = node.value;
        if (self2[DISPOSE])
          self2[DISPOSE](hit.key, hit.value);
        self2[LENGTH] -= hit.length;
        self2[CACHE].delete(hit.key);
        self2[LRU_LIST].removeNode(node);
      }
    };
    var Entry = class {
      constructor(key, value2, length, now, maxAge) {
        this.key = key;
        this.value = value2;
        this.length = length;
        this.now = now;
        this.maxAge = maxAge || 0;
      }
    };
    var forEachStep = (self2, fn, node, thisp) => {
      let hit = node.value;
      if (isStale(self2, hit)) {
        del(self2, node);
        if (!self2[ALLOW_STALE])
          hit = void 0;
      }
      if (hit)
        fn.call(thisp, hit.value, hit.key, self2);
    };
    module2.exports = LRUCache;
  }
});

// node_modules/concordance/node_modules/semver/classes/range.js
var require_range = __commonJS({
  "node_modules/concordance/node_modules/semver/classes/range.js"(exports2, module2) {
    "use strict";
    var Range = class _Range {
      constructor(range, options) {
        options = parseOptions(options);
        if (range instanceof _Range) {
          if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
            return range;
          } else {
            return new _Range(range.raw, options);
          }
        }
        if (range instanceof Comparator) {
          this.raw = range.value;
          this.set = [[range]];
          this.format();
          return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        this.raw = range.trim().split(/\s+/).join(" ");
        this.set = this.raw.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
        }
        if (this.set.length > 1) {
          const first = this.set[0];
          this.set = this.set.filter((c) => !isNullSet(c[0]));
          if (this.set.length === 0) {
            this.set = [first];
          } else if (this.set.length > 1) {
            for (const c of this.set) {
              if (c.length === 1 && isAny(c[0])) {
                this.set = [c];
                break;
              }
            }
          }
        }
        this.format();
      }
      format() {
        this.range = this.set.map((comps) => comps.join(" ").trim()).join("||").trim();
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range) {
        const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
        const memoKey = memoOpts + ":" + range;
        const cached = cache.get(memoKey);
        if (cached) {
          return cached;
        }
        const loose = this.options.loose;
        const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug("hyphen replace", range);
        range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
        debug("comparator trim", range);
        range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
        debug("tilde trim", range);
        range = range.replace(re[t.CARETTRIM], caretTrimReplace);
        debug("caret trim", range);
        let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
        if (loose) {
          rangeList = rangeList.filter((comp) => {
            debug("loose invalid filter", comp, this.options);
            return !!comp.match(re[t.COMPARATORLOOSE]);
          });
        }
        debug("range list", rangeList);
        const rangeMap = /* @__PURE__ */ new Map();
        const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
        for (const comp of comparators) {
          if (isNullSet(comp)) {
            return [comp];
          }
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has("")) {
          rangeMap.delete("");
        }
        const result = [...rangeMap.values()];
        cache.set(memoKey, result);
        return result;
      }
      intersects(range, options) {
        if (!(range instanceof _Range)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options);
              });
            });
          });
        });
      }
      // if ANY of the sets match ALL of its comparators, then pass
      test(version) {
        if (!version) {
          return false;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer(version, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i = 0; i < this.set.length; i++) {
          if (testSet(this.set[i], version, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module2.exports = Range;
    var LRU = require_lru_cache();
    var cache = new LRU({ max: 1e3 });
    var parseOptions = require_parse_options();
    var Comparator = require_comparator();
    var debug = require_debug();
    var SemVer = require_semver();
    var {
      safeRe: re,
      t,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = require_re();
    var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants5();
    var isNullSet = (c) => c.value === "<0.0.0-0";
    var isAny = (c) => c.value === "";
    var isSatisfiable = (comparators, options) => {
      let result = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    };
    var parseComparator = (comp, options) => {
      debug("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug("caret", comp);
      comp = replaceTildes(comp, options);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug("xrange", comp);
      comp = replaceStars(comp, options);
      debug("stars", comp);
      return comp;
    };
    var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
    var replaceTildes = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceTilde(c, options)).join(" ");
    };
    var replaceTilde = (comp, options) => {
      const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
      return comp.replace(r, (_2, M, m, p, pr) => {
        debug("tilde", comp, _2, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
        }
        debug("tilde return", ret);
        return ret;
      });
    };
    var replaceCarets = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceCaret(c, options)).join(" ");
    };
    var replaceCaret = (comp, options) => {
      debug("caret", comp, options);
      const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
      const z = options.includePrerelease ? "-0" : "";
      return comp.replace(r, (_2, M, m, p, pr) => {
        debug("caret", comp, _2, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          if (M === "0") {
            ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
          } else {
            ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
          }
        } else {
          debug("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
          }
        }
        debug("caret return", ret);
        return ret;
      });
    };
    var replaceXRanges = (comp, options) => {
      debug("replaceXRanges", comp, options);
      return comp.split(/\s+/).map((c) => replaceXRange(c, options)).join(" ");
    };
    var replaceXRange = (comp, options) => {
      comp = comp.trim();
      const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
      return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
        debug("xRange", comp, ret, gtlt, M, m, p, pr);
        const xM = isX(M);
        const xm = xM || isX(m);
        const xp = xm || isX(p);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          if (gtlt === "<") {
            pr = "-0";
          }
          ret = `${gtlt + M}.${m}.${p}${pr}`;
        } else if (xm) {
          ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
        }
        debug("xRange return", ret);
        return ret;
      });
    };
    var replaceStars = (comp, options) => {
      debug("replaceStars", comp, options);
      return comp.trim().replace(re[t.STAR], "");
    };
    var replaceGTE0 = (comp, options) => {
      debug("replaceGTE0", comp, options);
      return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
    };
    var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) => {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from} ${to}`.trim();
    };
    var testSet = (set, version, options) => {
      for (let i = 0; i < set.length; i++) {
        if (!set[i].test(version)) {
          return false;
        }
      }
      if (version.prerelease.length && !options.includePrerelease) {
        for (let i = 0; i < set.length; i++) {
          debug(set[i].semver);
          if (set[i].semver === Comparator.ANY) {
            continue;
          }
          if (set[i].semver.prerelease.length > 0) {
            const allowed = set[i].semver;
            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
  }
});

// node_modules/concordance/node_modules/semver/classes/comparator.js
var require_comparator = __commonJS({
  "node_modules/concordance/node_modules/semver/classes/comparator.js"(exports2, module2) {
    "use strict";
    var ANY = Symbol("SemVer ANY");
    var Comparator = class _Comparator {
      static get ANY() {
        return ANY;
      }
      constructor(comp, options) {
        options = parseOptions(options);
        if (comp instanceof _Comparator) {
          if (comp.loose === !!options.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        comp = comp.trim().split(/\s+/).join(" ");
        debug("comparator", comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug("comp", this);
      }
      parse(comp) {
        const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
        const m = comp.match(r);
        if (!m) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m[1] !== void 0 ? m[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version) {
        debug("Comparator.test", version, this.options.loose);
        if (this.semver === ANY || version === ANY) {
          return true;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer(version, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp(version, this.operator, this.semver, this.options);
      }
      intersects(comp, options) {
        if (!(comp instanceof _Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range(comp.value, options).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range(this.value, options).test(comp.semver);
        }
        options = parseOptions(options);
        if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
          return false;
        }
        if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
          return false;
        }
        if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
          return true;
        }
        if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
          return true;
        }
        if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
          return true;
        }
        if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
          return true;
        }
        if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
          return true;
        }
        return false;
      }
    };
    module2.exports = Comparator;
    var parseOptions = require_parse_options();
    var { safeRe: re, t } = require_re();
    var cmp = require_cmp();
    var debug = require_debug();
    var SemVer = require_semver();
    var Range = require_range();
  }
});

// node_modules/concordance/node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS({
  "node_modules/concordance/node_modules/semver/functions/satisfies.js"(exports2, module2) {
    "use strict";
    var Range = require_range();
    var satisfies = (version, range, options) => {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version);
    };
    module2.exports = satisfies;
  }
});

// node_modules/concordance/node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS({
  "node_modules/concordance/node_modules/semver/ranges/to-comparators.js"(exports2, module2) {
    "use strict";
    var Range = require_range();
    var toComparators = (range, options) => new Range(range, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
    module2.exports = toComparators;
  }
});

// node_modules/concordance/node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS({
  "node_modules/concordance/node_modules/semver/ranges/max-satisfying.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var Range = require_range();
    var maxSatisfying = (versions, range, options) => {
      let max = null;
      let maxSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    };
    module2.exports = maxSatisfying;
  }
});

// node_modules/concordance/node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS({
  "node_modules/concordance/node_modules/semver/ranges/min-satisfying.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var Range = require_range();
    var minSatisfying = (versions, range, options) => {
      let min = null;
      let minSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    };
    module2.exports = minSatisfying;
  }
});

// node_modules/concordance/node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS({
  "node_modules/concordance/node_modules/semver/ranges/min-version.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var Range = require_range();
    var gt = require_gt();
    var minVersion = (range, loose) => {
      range = new Range(range, loose);
      let minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let setMin = null;
        comparators.forEach((comparator) => {
          const compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            /* fallthrough */
            case "":
            case ">=":
              if (!setMin || gt(compver, setMin)) {
                setMin = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            /* istanbul ignore next */
            default:
              throw new Error(`Unexpected operation: ${comparator.operator}`);
          }
        });
        if (setMin && (!minver || gt(minver, setMin))) {
          minver = setMin;
        }
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    };
    module2.exports = minVersion;
  }
});

// node_modules/concordance/node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS({
  "node_modules/concordance/node_modules/semver/ranges/valid.js"(exports2, module2) {
    "use strict";
    var Range = require_range();
    var validRange = (range, options) => {
      try {
        return new Range(range, options).range || "*";
      } catch (er) {
        return null;
      }
    };
    module2.exports = validRange;
  }
});

// node_modules/concordance/node_modules/semver/ranges/outside.js
var require_outside = __commonJS({
  "node_modules/concordance/node_modules/semver/ranges/outside.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var Range = require_range();
    var satisfies = require_satisfies();
    var gt = require_gt();
    var lt = require_lt();
    var lte = require_lte();
    var gte = require_gte();
    var outside = (version, range, hilo, options) => {
      version = new SemVer(version, options);
      range = new Range(range, options);
      let gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version, range, options)) {
        return false;
      }
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let high = null;
        let low = null;
        comparators.forEach((comparator) => {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
          return false;
        }
      }
      return true;
    };
    module2.exports = outside;
  }
});

// node_modules/concordance/node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS({
  "node_modules/concordance/node_modules/semver/ranges/gtr.js"(exports2, module2) {
    "use strict";
    var outside = require_outside();
    var gtr = (version, range, options) => outside(version, range, ">", options);
    module2.exports = gtr;
  }
});

// node_modules/concordance/node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS({
  "node_modules/concordance/node_modules/semver/ranges/ltr.js"(exports2, module2) {
    "use strict";
    var outside = require_outside();
    var ltr = (version, range, options) => outside(version, range, "<", options);
    module2.exports = ltr;
  }
});

// node_modules/concordance/node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS({
  "node_modules/concordance/node_modules/semver/ranges/intersects.js"(exports2, module2) {
    "use strict";
    var Range = require_range();
    var intersects = (r1, r2, options) => {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2, options);
    };
    module2.exports = intersects;
  }
});

// node_modules/concordance/node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS({
  "node_modules/concordance/node_modules/semver/ranges/simplify.js"(exports2, module2) {
    "use strict";
    var satisfies = require_satisfies();
    var compare = require_compare();
    module2.exports = (versions, range, options) => {
      const set = [];
      let first = null;
      let prev = null;
      const v = versions.sort((a, b) => compare(a, b, options));
      for (const version of v) {
        const included = satisfies(version, range, options);
        if (included) {
          prev = version;
          if (!first) {
            first = version;
          }
        } else {
          if (prev) {
            set.push([first, prev]);
          }
          prev = null;
          first = null;
        }
      }
      if (first) {
        set.push([first, null]);
      }
      const ranges = [];
      for (const [min, max] of set) {
        if (min === max) {
          ranges.push(min);
        } else if (!max && min === v[0]) {
          ranges.push("*");
        } else if (!max) {
          ranges.push(`>=${min}`);
        } else if (min === v[0]) {
          ranges.push(`<=${max}`);
        } else {
          ranges.push(`${min} - ${max}`);
        }
      }
      const simplified = ranges.join(" || ");
      const original = typeof range.raw === "string" ? range.raw : String(range);
      return simplified.length < original.length ? simplified : range;
    };
  }
});

// node_modules/concordance/node_modules/semver/ranges/subset.js
var require_subset = __commonJS({
  "node_modules/concordance/node_modules/semver/ranges/subset.js"(exports2, module2) {
    "use strict";
    var Range = require_range();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var satisfies = require_satisfies();
    var compare = require_compare();
    var subset = (sub, dom, options = {}) => {
      if (sub === dom) {
        return true;
      }
      sub = new Range(sub, options);
      dom = new Range(dom, options);
      let sawNonNull = false;
      OUTER: for (const simpleSub of sub.set) {
        for (const simpleDom of dom.set) {
          const isSub = simpleSubset(simpleSub, simpleDom, options);
          sawNonNull = sawNonNull || isSub !== null;
          if (isSub) {
            continue OUTER;
          }
        }
        if (sawNonNull) {
          return false;
        }
      }
      return true;
    };
    var minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
    var minimumVersion = [new Comparator(">=0.0.0")];
    var simpleSubset = (sub, dom, options) => {
      if (sub === dom) {
        return true;
      }
      if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY) {
          return true;
        } else if (options.includePrerelease) {
          sub = minimumVersionWithPreRelease;
        } else {
          sub = minimumVersion;
        }
      }
      if (dom.length === 1 && dom[0].semver === ANY) {
        if (options.includePrerelease) {
          return true;
        } else {
          dom = minimumVersion;
        }
      }
      const eqSet = /* @__PURE__ */ new Set();
      let gt, lt;
      for (const c of sub) {
        if (c.operator === ">" || c.operator === ">=") {
          gt = higherGT(gt, c, options);
        } else if (c.operator === "<" || c.operator === "<=") {
          lt = lowerLT(lt, c, options);
        } else {
          eqSet.add(c.semver);
        }
      }
      if (eqSet.size > 1) {
        return null;
      }
      let gtltComp;
      if (gt && lt) {
        gtltComp = compare(gt.semver, lt.semver, options);
        if (gtltComp > 0) {
          return null;
        } else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) {
          return null;
        }
      }
      for (const eq of eqSet) {
        if (gt && !satisfies(eq, String(gt), options)) {
          return null;
        }
        if (lt && !satisfies(eq, String(lt), options)) {
          return null;
        }
        for (const c of dom) {
          if (!satisfies(eq, String(c), options)) {
            return false;
          }
        }
        return true;
      }
      let higher, lower;
      let hasDomLT, hasDomGT;
      let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
      let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
      if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
        needDomLTPre = false;
      }
      for (const c of dom) {
        hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
        hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
        if (gt) {
          if (needDomGTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
              needDomGTPre = false;
            }
          }
          if (c.operator === ">" || c.operator === ">=") {
            higher = higherGT(gt, c, options);
            if (higher === c && higher !== gt) {
              return false;
            }
          } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c), options)) {
            return false;
          }
        }
        if (lt) {
          if (needDomLTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
              needDomLTPre = false;
            }
          }
          if (c.operator === "<" || c.operator === "<=") {
            lower = lowerLT(lt, c, options);
            if (lower === c && lower !== lt) {
              return false;
            }
          } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c), options)) {
            return false;
          }
        }
        if (!c.operator && (lt || gt) && gtltComp !== 0) {
          return false;
        }
      }
      if (gt && hasDomLT && !lt && gtltComp !== 0) {
        return false;
      }
      if (lt && hasDomGT && !gt && gtltComp !== 0) {
        return false;
      }
      if (needDomGTPre || needDomLTPre) {
        return false;
      }
      return true;
    };
    var higherGT = (a, b, options) => {
      if (!a) {
        return b;
      }
      const comp = compare(a.semver, b.semver, options);
      return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
    };
    var lowerLT = (a, b, options) => {
      if (!a) {
        return b;
      }
      const comp = compare(a.semver, b.semver, options);
      return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
    };
    module2.exports = subset;
  }
});

// node_modules/concordance/node_modules/semver/index.js
var require_semver2 = __commonJS({
  "node_modules/concordance/node_modules/semver/index.js"(exports2, module2) {
    "use strict";
    var internalRe = require_re();
    var constants = require_constants5();
    var SemVer = require_semver();
    var identifiers = require_identifiers();
    var parse = require_parse3();
    var valid = require_valid();
    var clean = require_clean();
    var inc = require_inc();
    var diff = require_diff2();
    var major = require_major();
    var minor = require_minor();
    var patch = require_patch();
    var prerelease = require_prerelease();
    var compare = require_compare();
    var rcompare = require_rcompare();
    var compareLoose = require_compare_loose();
    var compareBuild = require_compare_build();
    var sort = require_sort();
    var rsort = require_rsort();
    var gt = require_gt();
    var lt = require_lt();
    var eq = require_eq();
    var neq = require_neq();
    var gte = require_gte();
    var lte = require_lte();
    var cmp = require_cmp();
    var coerce = require_coerce();
    var Comparator = require_comparator();
    var Range = require_range();
    var satisfies = require_satisfies();
    var toComparators = require_to_comparators();
    var maxSatisfying = require_max_satisfying();
    var minSatisfying = require_min_satisfying();
    var minVersion = require_min_version();
    var validRange = require_valid2();
    var outside = require_outside();
    var gtr = require_gtr();
    var ltr = require_ltr();
    var intersects = require_intersects();
    var simplifyRange = require_simplify();
    var subset = require_subset();
    module2.exports = {
      parse,
      valid,
      clean,
      inc,
      diff,
      major,
      minor,
      patch,
      prerelease,
      compare,
      rcompare,
      compareLoose,
      compareBuild,
      sort,
      rsort,
      gt,
      lt,
      eq,
      neq,
      gte,
      lte,
      cmp,
      coerce,
      Comparator,
      Range,
      satisfies,
      toComparators,
      maxSatisfying,
      minSatisfying,
      minVersion,
      validRange,
      outside,
      gtr,
      ltr,
      intersects,
      simplifyRange,
      subset,
      SemVer,
      re: internalRe.re,
      src: internalRe.src,
      tokens: internalRe.t,
      SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
      RELEASE_TYPES: constants.RELEASE_TYPES,
      compareIdentifiers: identifiers.compareIdentifiers,
      rcompareIdentifiers: identifiers.rcompareIdentifiers
    };
  }
});

// node_modules/concordance/package.json
var require_package2 = __commonJS({
  "node_modules/concordance/package.json"(exports2, module2) {
    module2.exports = {
      name: "concordance",
      version: "5.0.4",
      description: "Compare, format, diff and serialize any JavaScript value",
      main: "index.js",
      files: [
        "lib",
        "index.js"
      ],
      engines: {
        node: ">=10.18.0 <11 || >=12.14.0 <13 || >=14"
      },
      scripts: {
        test: "as-i-preach && c8 ava"
      },
      repository: {
        type: "git",
        url: "git+https://github.com/concordancejs/concordance.git"
      },
      author: "Mark Wubben (https://novemberborn.net/)",
      license: "ISC",
      bugs: {
        url: "https://github.com/concordancejs/concordance/issues"
      },
      homepage: "https://github.com/concordancejs/concordance#readme",
      dependencies: {
        "date-time": "^3.1.0",
        esutils: "^2.0.3",
        "fast-diff": "^1.2.0",
        "js-string-escape": "^1.0.1",
        lodash: "^4.17.15",
        "md5-hex": "^3.0.1",
        semver: "^7.3.2",
        "well-known-symbols": "^2.0.0"
      },
      devDependencies: {
        "@novemberborn/eslint-plugin-as-i-preach": "^12.0.0",
        ava: "^3.15.0",
        c8: "^7.1.2",
        eslint: "^6.8.0",
        "eslint-plugin-ava": "^10.3.0",
        "eslint-plugin-import": "^2.20.2",
        "eslint-plugin-node": "^11.1.0",
        "eslint-plugin-promise": "^4.2.1",
        "eslint-plugin-security": "^1.4.0",
        "eslint-plugin-standard": "^4.0.1",
        "eslint-plugin-unicorn": "^17.2.0",
        proxyquire: "^2.1.3"
      }
    };
  }
});

// node_modules/js-string-escape/index.js
var require_js_string_escape = __commonJS({
  "node_modules/js-string-escape/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function(string) {
      return ("" + string).replace(/["'\\\n\r\u2028\u2029]/g, function(character) {
        switch (character) {
          case '"':
          case "'":
          case "\\":
            return "\\" + character;
          // Four possible LineTerminator characters need to be escaped:
          case "\n":
            return "\\n";
          case "\r":
            return "\\r";
          case "\u2028":
            return "\\u2028";
          case "\u2029":
            return "\\u2029";
        }
      });
    };
  }
});

// node_modules/well-known-symbols/index.js
var require_well_known_symbols = __commonJS({
  "node_modules/well-known-symbols/index.js"(exports2) {
    "use strict";
    var WELL_KNOWN = new Map([
      [Symbol.iterator, "Symbol.iterator"],
      [Symbol.asyncIterator, "Symbol.asyncIterator"],
      [Symbol.match, "Symbol.match"],
      [Symbol.replace, "Symbol.replace"],
      [Symbol.search, "Symbol.search"],
      [Symbol.split, "Symbol.split"],
      [Symbol.hasInstance, "Symbol.hasInstance"],
      [Symbol.isConcatSpreadable, "Symbol.isConcatSpreadable"],
      [Symbol.unscopables, "Symbol.unscopables"],
      [Symbol.species, "Symbol.species"],
      [Symbol.toPrimitive, "Symbol.toPrimitive"],
      [Symbol.toStringTag, "Symbol.toStringTag"]
    ].filter((entry) => entry[0]));
    exports2.isWellKnown = (symbol) => WELL_KNOWN.has(symbol);
    exports2.getLabel = (symbol) => WELL_KNOWN.get(symbol);
  }
});

// node_modules/concordance/lib/primitiveValues/symbol.js
var require_symbol = __commonJS({
  "node_modules/concordance/lib/primitiveValues/symbol.js"(exports2) {
    "use strict";
    var stringEscape = require_js_string_escape();
    var wellKnownSymbols = require_well_known_symbols();
    var constants = require_constants4();
    var formatUtils = require_formatUtils();
    var lineBuilder = require_lineBuilder();
    var DEEP_EQUAL = constants.DEEP_EQUAL;
    var UNEQUAL = constants.UNEQUAL;
    function describe(value2) {
      let stringCompare = null;
      const key = Symbol.keyFor(value2);
      if (key !== void 0) {
        stringCompare = `Symbol.for(${stringEscape(key)})`;
      } else if (wellKnownSymbols.isWellKnown(value2)) {
        stringCompare = wellKnownSymbols.getLabel(value2);
      }
      return new SymbolValue({
        stringCompare,
        value: value2
      });
    }
    exports2.describe = describe;
    function deserialize(state) {
      const stringCompare = state[0];
      const string = state[1] || state[0];
      return new DeserializedSymbolValue({
        string,
        stringCompare,
        value: null
      });
    }
    exports2.deserialize = deserialize;
    var tag = Symbol("SymbolValue");
    exports2.tag = tag;
    var SymbolValue = class {
      constructor(props) {
        this.stringCompare = props.stringCompare;
        this.value = props.value;
      }
      compare(expected) {
        if (expected.tag !== tag) return UNEQUAL;
        if (this.stringCompare !== null) {
          return this.stringCompare === expected.stringCompare ? DEEP_EQUAL : UNEQUAL;
        }
        return this.value === expected.value ? DEEP_EQUAL : UNEQUAL;
      }
      formatString() {
        if (this.stringCompare !== null) return this.stringCompare;
        return stringEscape(this.value.toString());
      }
      formatDeep(theme) {
        return lineBuilder.single(formatUtils.wrap(theme.symbol, this.formatString()));
      }
      formatAsKey(theme) {
        return formatUtils.wrap(theme.property.keyBracket, formatUtils.wrap(theme.symbol, this.formatString()));
      }
      serialize() {
        const string = this.formatString();
        return this.stringCompare === string ? [this.stringCompare] : [this.stringCompare, string];
      }
    };
    Object.defineProperty(SymbolValue.prototype, "isPrimitive", { value: true });
    Object.defineProperty(SymbolValue.prototype, "tag", { value: tag });
    var DeserializedSymbolValue = class extends SymbolValue {
      constructor(props) {
        super(props);
        this.string = props.string;
      }
      compare(expected) {
        if (expected.tag !== tag) return UNEQUAL;
        if (this.stringCompare !== null) {
          return this.stringCompare === expected.stringCompare ? DEEP_EQUAL : UNEQUAL;
        }
        return this.string === expected.formatString() ? DEEP_EQUAL : UNEQUAL;
      }
      formatString() {
        return this.string;
      }
    };
  }
});

// node_modules/concordance/lib/metaDescriptors/property.js
var require_property = __commonJS({
  "node_modules/concordance/lib/metaDescriptors/property.js"(exports2) {
    "use strict";
    var constants = require_constants4();
    var formatUtils = require_formatUtils();
    var symbolPrimitive = require_symbol().tag;
    var recursorUtils = require_recursorUtils();
    var AMBIGUOUS = constants.AMBIGUOUS;
    var DEEP_EQUAL = constants.DEEP_EQUAL;
    var UNEQUAL = constants.UNEQUAL;
    function describeComplex(key, value2) {
      return new ComplexProperty(key, value2);
    }
    exports2.describeComplex = describeComplex;
    function deserializeComplex(key, recursor) {
      const value2 = recursor();
      return new ComplexProperty(key, value2);
    }
    exports2.deserializeComplex = deserializeComplex;
    function describePrimitive(key, value2) {
      return new PrimitiveProperty(key, value2);
    }
    exports2.describePrimitive = describePrimitive;
    function deserializePrimitive(state) {
      const key = state[0];
      const value2 = state[1];
      return new PrimitiveProperty(key, value2);
    }
    exports2.deserializePrimitive = deserializePrimitive;
    var complexTag = Symbol("ComplexProperty");
    exports2.complexTag = complexTag;
    var primitiveTag = Symbol("PrimitiveProperty");
    exports2.primitiveTag = primitiveTag;
    var Property = class {
      constructor(key) {
        this.key = key;
      }
      compareKeys(expected) {
        const result = this.key.compare(expected.key);
        return result === UNEQUAL && this.key.tag === symbolPrimitive && expected.key.tag === symbolPrimitive ? AMBIGUOUS : result;
      }
      prepareDiff(expected, lhsRecursor, rhsRecursor, compareComplexShape, isCircular) {
        if (isCircular(this.value) || isCircular(expected.value)) return { compareResult: UNEQUAL };
        const rhsFork = recursorUtils.fork(rhsRecursor);
        const initialExpected = expected;
        do {
          if (expected === null || expected.isProperty !== true) {
            return {
              actualIsExtraneous: true,
              rhsRecursor: recursorUtils.unshift(rhsFork.recursor, initialExpected)
            };
          } else if (this.key.compare(expected.key) === DEEP_EQUAL) {
            if (expected === initialExpected) {
              return null;
            } else {
              return {
                expectedIsMissing: true,
                lhsRecursor: recursorUtils.unshift(lhsRecursor, this),
                rhsRecursor: rhsFork.recursor
              };
            }
          }
          expected = rhsFork.shared();
        } while (true);
      }
    };
    Object.defineProperty(Property.prototype, "isProperty", { value: true });
    var ComplexProperty = class extends Property {
      constructor(key, value2) {
        super(key);
        this.value = value2;
      }
      createRecursor() {
        return recursorUtils.singleValue(this.value);
      }
      compare(expected) {
        if (expected.isProperty !== true) return UNEQUAL;
        const keyResult = this.compareKeys(expected);
        if (keyResult !== DEEP_EQUAL) return keyResult;
        return this.tag === expected.tag ? this.value.compare(expected.value) : UNEQUAL;
      }
      formatShallow(theme, indent) {
        const increaseValueIndent = theme.property.increaseValueIndent === true;
        return new formatUtils.SingleValueFormatter(theme, (value2) => {
          if (typeof theme.property.customFormat === "function") {
            return theme.property.customFormat(theme, indent, this.key, value2);
          }
          return value2.withFirstPrefixed(this.key.formatAsKey(theme) + theme.property.separator).withLastPostfixed(theme.property.after);
        }, increaseValueIndent);
      }
      serialize() {
        return this.key;
      }
    };
    Object.defineProperty(ComplexProperty.prototype, "tag", { value: complexTag });
    var PrimitiveProperty = class extends Property {
      constructor(key, value2) {
        super(key);
        this.value = value2;
      }
      compare(expected) {
        if (expected.isProperty !== true) return UNEQUAL;
        const keyResult = this.compareKeys(expected);
        if (keyResult !== DEEP_EQUAL) return keyResult;
        return this.tag !== expected.tag ? UNEQUAL : this.value.compare(expected.value);
      }
      formatDeep(theme, indent) {
        const increaseValueIndent = theme.property.increaseValueIndent === true;
        const valueIndent = increaseValueIndent ? indent.increase() : indent;
        const formatted = this.value.formatDeep(theme, valueIndent);
        if (typeof theme.property.customFormat === "function") {
          return theme.property.customFormat(theme, indent, this.key, formatted);
        }
        return formatted.withFirstPrefixed(this.key.formatAsKey(theme) + theme.property.separator).withLastPostfixed(theme.property.after);
      }
      diffDeep(expected, theme, indent, invert) {
        if (this.tag !== expected.tag || typeof this.value.diffDeep !== "function") return null;
        if (this.key.compare(expected.key) !== DEEP_EQUAL) return null;
        const increaseValueIndent = theme.property.increaseValueIndent === true;
        const valueIndent = increaseValueIndent ? indent.increase() : indent;
        const diff = this.value.diffDeep(expected.value, theme, valueIndent, invert);
        if (diff === null) return null;
        if (typeof theme.property.customFormat === "function") {
          return theme.property.customFormat(theme, indent, this.key, diff);
        }
        return diff.withFirstPrefixed(this.key.formatAsKey(theme) + theme.property.separator).withLastPostfixed(theme.property.after);
      }
      serialize() {
        return [this.key, this.value];
      }
    };
    Object.defineProperty(PrimitiveProperty.prototype, "tag", { value: primitiveTag });
  }
});

// node_modules/concordance/lib/pluginRegistry.js
var require_pluginRegistry = __commonJS({
  "node_modules/concordance/lib/pluginRegistry.js"(exports2) {
    "use strict";
    var semver = require_semver2();
    var pkg = require_package2();
    var object = require_object();
    var constants = require_constants4();
    var formatUtils = require_formatUtils();
    var lineBuilder = require_lineBuilder();
    var itemDescriptor = require_item();
    var propertyDescriptor = require_property();
    var stringDescriptor = require_string2();
    var recursorUtils = require_recursorUtils();
    var themeUtils = require_themeUtils();
    var API_VERSION = 1;
    var CONCORDANCE_VERSION = pkg.version;
    var descriptorRegistry = /* @__PURE__ */ new Map();
    var registry = /* @__PURE__ */ new Map();
    var PluginError = class extends Error {
      constructor(message, plugin) {
        super(message);
        this.name = "PluginError";
        this.plugin = plugin;
      }
    };
    var PluginTypeError = class extends TypeError {
      constructor(message, plugin) {
        super(message);
        this.name = "PluginTypeError";
        this.plugin = plugin;
      }
    };
    var UnsupportedApiError = class extends PluginError {
      constructor(plugin) {
        super("Plugin requires an unsupported API version", plugin);
        this.name = "UnsupportedApiError";
      }
    };
    var UnsupportedError = class extends PluginError {
      constructor(plugin) {
        super("Plugin does not support this version of Concordance", plugin);
        this.name = "UnsupportedError";
      }
    };
    var DuplicateDescriptorTagError = class extends PluginError {
      constructor(tag, plugin) {
        super(`Could not add descriptor: tag ${String(tag)} has already been registered`, plugin);
        this.name = "DuplicateDescriptorTagError";
        this.tag = tag;
      }
    };
    var DuplicateDescriptorIdError = class extends PluginError {
      constructor(id, plugin) {
        const printed = typeof id === "number" ? `0x${id.toString(16).toUpperCase()}` : String(id);
        super(`Could not add descriptor: id ${printed} has already been registered`, plugin);
        this.name = "DuplicateDescriptorIdError";
        this.id = id;
      }
    };
    function verify(plugin) {
      if (typeof plugin.name !== "string" || !plugin.name) {
        throw new PluginTypeError("Plugin must have a `name`", plugin);
      }
      if (plugin.apiVersion !== API_VERSION) {
        throw new UnsupportedApiError(plugin);
      }
      if ("minimalConcordanceVersion" in plugin) {
        if (!semver.valid(plugin.minimalConcordanceVersion)) {
          throw new PluginTypeError("If specified, `minimalConcordanceVersion` must be a valid SemVer version", plugin);
        }
        const range = `>=${plugin.minimalConcordanceVersion}`;
        if (!semver.satisfies(CONCORDANCE_VERSION, range)) {
          throw new UnsupportedError(plugin);
        }
      }
    }
    var publicDescriptorTags = Object.freeze({
      complexItem: itemDescriptor.complexTag,
      primitiveItem: itemDescriptor.primitiveTag,
      primitiveProperty: propertyDescriptor.primitiveTag,
      string: stringDescriptor.tag
    });
    var publicLineBuilder = Object.freeze({
      buffer: lineBuilder.buffer,
      first: lineBuilder.first,
      last: lineBuilder.last,
      line: lineBuilder.line,
      single: lineBuilder.single,
      actual: Object.freeze({
        buffer: lineBuilder.actual.buffer,
        first: lineBuilder.actual.first,
        last: lineBuilder.actual.last,
        line: lineBuilder.actual.line,
        single: lineBuilder.actual.single
      }),
      expected: Object.freeze({
        buffer: lineBuilder.expected.buffer,
        first: lineBuilder.expected.first,
        last: lineBuilder.expected.last,
        line: lineBuilder.expected.line,
        single: lineBuilder.expected.single
      })
    });
    function modifyTheme(descriptor, modifier) {
      themeUtils.addModifier(descriptor, modifier);
      return descriptor;
    }
    function add(plugin) {
      verify(plugin);
      const name = plugin.name;
      if (registry.has(name)) return registry.get(name);
      const id2deserialize = /* @__PURE__ */ new Map();
      const tag2id = /* @__PURE__ */ new Map();
      const addDescriptor = (id, tag, deserialize) => {
        if (id2deserialize.has(id)) throw new DuplicateDescriptorIdError(id, plugin);
        if (descriptorRegistry.has(tag) || tag2id.has(tag)) throw new DuplicateDescriptorTagError(tag, plugin);
        id2deserialize.set(id, deserialize);
        tag2id.set(tag, id);
      };
      const tryDescribeValue = plugin.register({
        // Concordance makes assumptions about when AMBIGUOUS occurs. Do not expose
        // it to plugins.
        UNEQUAL: constants.UNEQUAL,
        SHALLOW_EQUAL: constants.SHALLOW_EQUAL,
        DEEP_EQUAL: constants.DEEP_EQUAL,
        ObjectValue: object.ObjectValue,
        DescribedMixin: object.DescribedMixin,
        DeserializedMixin: object.DeserializedMixin,
        addDescriptor,
        applyThemeModifiers: themeUtils.applyModifiers,
        descriptorTags: publicDescriptorTags,
        lineBuilder: publicLineBuilder,
        mapRecursor: recursorUtils.map,
        modifyTheme,
        wrapFromTheme: formatUtils.wrap
      });
      const registered = {
        id2deserialize,
        serializerVersion: plugin.serializerVersion,
        name,
        tag2id,
        theme: plugin.theme || {},
        tryDescribeValue
      };
      registry.set(name, registered);
      for (const tag of tag2id.keys()) {
        descriptorRegistry.set(tag, registered);
      }
      return registered;
    }
    exports2.add = add;
    function getDeserializers(plugins) {
      return plugins.map((plugin) => {
        const registered = add(plugin);
        return {
          id2deserialize: registered.id2deserialize,
          name: registered.name,
          serializerVersion: registered.serializerVersion
        };
      });
    }
    exports2.getDeserializers = getDeserializers;
    function getThemes(plugins) {
      return plugins.map((plugin) => {
        const registered = add(plugin);
        return {
          name: registered.name,
          theme: registered.theme
        };
      });
    }
    exports2.getThemes = getThemes;
    function getTryDescribeValues(plugins) {
      return plugins.map((plugin) => add(plugin).tryDescribeValue);
    }
    exports2.getTryDescribeValues = getTryDescribeValues;
    function resolveDescriptorRef(tag) {
      if (!descriptorRegistry.has(tag)) return null;
      const registered = descriptorRegistry.get(tag);
      return {
        id: registered.tag2id.get(tag),
        name: registered.name,
        serialization: {
          serializerVersion: registered.serializerVersion
        }
      };
    }
    exports2.resolveDescriptorRef = resolveDescriptorRef;
  }
});

// node_modules/concordance/lib/themeUtils.js
var require_themeUtils = __commonJS({
  "node_modules/concordance/lib/themeUtils.js"(exports2) {
    "use strict";
    var cloneDeep = require("lodash/cloneDeep");
    var merge = require("lodash/merge");
    var pluginRegistry = require_pluginRegistry();
    function freezeTheme(theme) {
      const queue = [theme];
      while (queue.length > 0) {
        const object = queue.shift();
        Object.freeze(object);
        for (const key of Object.keys(object)) {
          const value2 = object[key];
          if (value2 !== null && typeof value2 === "object") {
            queue.push(value2);
          }
        }
      }
      return theme;
    }
    var defaultTheme = freezeTheme({
      bigInt: { open: "", close: "" },
      boolean: { open: "", close: "" },
      circular: "[Circular]",
      date: {
        invalid: "invalid",
        value: { open: "", close: "" }
      },
      diffGutters: {
        actual: "- ",
        expected: "+ ",
        padding: "  "
      },
      error: {
        ctor: { open: "(", close: ")" },
        name: { open: "", close: "" }
      },
      function: {
        name: { open: "", close: "" },
        stringTag: { open: "", close: "" }
      },
      global: { open: "", close: "" },
      item: {
        after: ",",
        customFormat: null,
        increaseValueIndent: false
      },
      list: { openBracket: "[", closeBracket: "]" },
      mapEntry: {
        after: ",",
        separator: " => "
      },
      maxDepth: "\u2026",
      null: { open: "", close: "" },
      number: { open: "", close: "" },
      object: {
        openBracket: "{",
        closeBracket: "}",
        ctor: { open: "", close: "" },
        stringTag: { open: "@", close: "" },
        secondaryStringTag: { open: "@", close: "" }
      },
      property: {
        after: ",",
        customFormat: null,
        keyBracket: { open: "[", close: "]" },
        separator: ": ",
        increaseValueIndent: false
      },
      regexp: {
        source: { open: "/", close: "/" },
        flags: { open: "", close: "" },
        separator: "---"
      },
      stats: { separator: "---" },
      string: {
        open: "",
        close: "",
        line: { open: "'", close: "'", escapeQuote: "'" },
        multiline: { start: "`", end: "`", escapeQuote: "`" },
        controlPicture: { open: "", close: "" },
        diff: {
          insert: { open: "", close: "" },
          delete: { open: "", close: "" },
          equal: { open: "", close: "" },
          insertLine: { open: "", close: "" },
          deleteLine: { open: "", close: "" }
        }
      },
      symbol: { open: "", close: "" },
      typedArray: {
        bytes: { open: "", close: "" }
      },
      undefined: { open: "", close: "" }
    });
    var pluginRefs = /* @__PURE__ */ new Map();
    pluginRefs.count = 0;
    var normalizedPluginThemes = /* @__PURE__ */ new Map();
    function normalizePlugins(plugins) {
      if (!Array.isArray(plugins) || plugins.length === 0) return null;
      const refs = [];
      const themes = [];
      for (const fromPlugin of pluginRegistry.getThemes(plugins)) {
        if (!pluginRefs.has(fromPlugin.name)) {
          pluginRefs.set(fromPlugin.name, pluginRefs.count++);
        }
        refs.push(pluginRefs.get(fromPlugin.name));
        themes.push(fromPlugin.theme);
      }
      const ref = refs.join(".");
      if (normalizedPluginThemes.has(ref)) {
        return {
          ref,
          theme: normalizedPluginThemes.get(ref)
        };
      }
      const theme = freezeTheme(themes.reduce((acc, pluginTheme) => {
        return merge(acc, pluginTheme);
      }, cloneDeep(defaultTheme)));
      normalizedPluginThemes.set(ref, theme);
      return { ref, theme };
    }
    var normalizedCache = /* @__PURE__ */ new WeakMap();
    function normalize(options) {
      options = Object.assign({ plugins: [], theme: null }, options);
      const normalizedPlugins = normalizePlugins(options.plugins);
      if (!options.theme) {
        return normalizedPlugins ? normalizedPlugins.theme : defaultTheme;
      }
      const entry = normalizedCache.get(options.theme) || { theme: null, withPlugins: /* @__PURE__ */ new Map() };
      if (!normalizedCache.has(options.theme)) normalizedCache.set(options.theme, entry);
      if (normalizedPlugins) {
        if (entry.withPlugins.has(normalizedPlugins.ref)) {
          return entry.withPlugins.get(normalizedPlugins.ref);
        }
        const theme = freezeTheme(merge(cloneDeep(normalizedPlugins.theme), options.theme));
        entry.withPlugins.set(normalizedPlugins.ref, theme);
        return theme;
      }
      if (!entry.theme) {
        entry.theme = freezeTheme(merge(cloneDeep(defaultTheme), options.theme));
      }
      return entry.theme;
    }
    exports2.normalize = normalize;
    var modifiers = /* @__PURE__ */ new WeakMap();
    function addModifier(descriptor, modifier) {
      if (modifiers.has(descriptor)) {
        modifiers.get(descriptor).add(modifier);
      } else {
        modifiers.set(descriptor, /* @__PURE__ */ new Set([modifier]));
      }
    }
    exports2.addModifier = addModifier;
    var modifierCache = /* @__PURE__ */ new WeakMap();
    var originalCache = /* @__PURE__ */ new WeakMap();
    function applyModifiers(descriptor, theme) {
      if (!modifiers.has(descriptor)) return theme;
      return Array.from(modifiers.get(descriptor)).reduce((prev, modifier) => {
        const cache = modifierCache.get(modifier) || /* @__PURE__ */ new WeakMap();
        if (!modifierCache.has(modifier)) modifierCache.set(modifier, cache);
        if (cache.has(prev)) return cache.get(prev);
        const modifiedTheme = cloneDeep(prev);
        modifier(modifiedTheme);
        freezeTheme(modifiedTheme);
        cache.set(prev, modifiedTheme);
        originalCache.set(modifiedTheme, theme);
        return modifiedTheme;
      }, theme);
    }
    exports2.applyModifiers = applyModifiers;
    function applyModifiersToOriginal(descriptor, theme) {
      return applyModifiers(descriptor, originalCache.get(theme) || theme);
    }
    exports2.applyModifiersToOriginal = applyModifiersToOriginal;
  }
});

// node_modules/concordance/lib/metaDescriptors/mapEntry.js
var require_mapEntry = __commonJS({
  "node_modules/concordance/lib/metaDescriptors/mapEntry.js"(exports2) {
    "use strict";
    var constants = require_constants4();
    var lineBuilder = require_lineBuilder();
    var recursorUtils = require_recursorUtils();
    var themeUtils = require_themeUtils();
    var DEEP_EQUAL = constants.DEEP_EQUAL;
    var UNEQUAL = constants.UNEQUAL;
    var SHALLOW_EQUAL = constants.SHALLOW_EQUAL;
    function describe(keyDescriptor, valueDescriptor) {
      const keyIsPrimitive = keyDescriptor.isPrimitive === true;
      const valueIsPrimitive = valueDescriptor.isPrimitive === true;
      return new MapEntry(keyDescriptor, valueDescriptor, keyIsPrimitive, valueIsPrimitive);
    }
    exports2.describe = describe;
    function deserialize(state, recursor) {
      const keyIsPrimitive = state[0];
      const valueIsPrimitive = state[1];
      const keyDescriptor = recursor();
      const valueDescriptor = recursor();
      return new MapEntry(keyDescriptor, valueDescriptor, keyIsPrimitive, valueIsPrimitive);
    }
    exports2.deserialize = deserialize;
    var tag = Symbol("MapEntry");
    exports2.tag = tag;
    function mergeWithKey(theme, key, values) {
      const lines = lineBuilder.buffer();
      const keyRemainder = lineBuilder.buffer();
      for (const line of key) {
        if (!line.isLast && !line.hasGutter) {
          lines.append(line);
        } else {
          keyRemainder.append(line);
        }
      }
      for (const value2 of values) {
        lines.append(keyRemainder.mergeWithInfix(theme.mapEntry.separator, value2).withLastPostfixed(theme.mapEntry.after));
      }
      return lines;
    }
    var MapEntry = class {
      constructor(key, value2, keyIsPrimitive, valueIsPrimitive) {
        this.key = key;
        this.value = value2;
        this.keyIsPrimitive = keyIsPrimitive;
        this.valueIsPrimitive = valueIsPrimitive;
      }
      createRecursor() {
        let emitKey = true;
        let emitValue = true;
        return () => {
          if (emitKey) {
            emitKey = false;
            return this.key;
          }
          if (emitValue) {
            emitValue = false;
            return this.value;
          }
          return null;
        };
      }
      compare(expected) {
        if (this.tag !== expected.tag) return UNEQUAL;
        if (this.keyIsPrimitive !== expected.keyIsPrimitive) return UNEQUAL;
        if (this.valueIsPrimitive !== expected.valueIsPrimitive) return UNEQUAL;
        if (!this.keyIsPrimitive) return SHALLOW_EQUAL;
        const keyResult = this.key.compare(expected.key);
        if (keyResult !== DEEP_EQUAL) return keyResult;
        if (!this.valueIsPrimitive) return SHALLOW_EQUAL;
        return this.value.compare(expected.value);
      }
      formatDeep(theme, indent) {
        if (!this.keyIsPrimitive || typeof this.value.formatDeep !== "function") return null;
        const value2 = this.value.formatDeep(themeUtils.applyModifiersToOriginal(this.value, theme), indent);
        if (value2 === null) return null;
        const key = this.key.formatDeep(themeUtils.applyModifiersToOriginal(this.key, theme), indent);
        return mergeWithKey(theme, key, [value2]);
      }
      formatShallow(theme, indent) {
        let key = null;
        const values = [];
        return {
          append: (formatted, origin) => {
            if (this.key === origin) {
              key = formatted;
            } else {
              values.push(formatted);
            }
          },
          finalize() {
            return mergeWithKey(theme, key, values);
          }
        };
      }
      diffDeep(expected, theme, indent, invert) {
        if (this.tag !== expected.tag || typeof this.value.diffDeep !== "function") return null;
        if (!this.keyIsPrimitive || !expected.keyIsPrimitive || this.key.compare(expected.key) !== DEEP_EQUAL) {
          return null;
        }
        const diff = this.value.diffDeep(expected.value, themeUtils.applyModifiersToOriginal(this.value, theme), indent, invert);
        if (diff === null) return null;
        const key = this.key.formatDeep(themeUtils.applyModifiersToOriginal(this.key, theme), indent, "");
        return mergeWithKey(theme, key, [diff]);
      }
      prepareDiff(expected, lhsRecursor, rhsRecursor, compareComplexShape, isCircular) {
        if (isCircular(this.value) || isCircular(expected.value)) return { compareResult: UNEQUAL };
        const compareResult = this.compare(expected);
        const keysAreEqual = this.tag === expected.tag && this.key.compare(expected.key) === DEEP_EQUAL;
        if (compareResult === DEEP_EQUAL || keysAreEqual) return { compareResult };
        const lhsFork = recursorUtils.fork(lhsRecursor);
        const rhsFork = recursorUtils.fork(rhsRecursor);
        const initialExpected = expected;
        let expectedIsMissing = false;
        while (!expectedIsMissing && expected !== null && this.tag === expected.tag) {
          if (expected.keyIsPrimitive) {
            expectedIsMissing = this.key.compare(expected.key) !== UNEQUAL;
          } else {
            expectedIsMissing = compareComplexShape(this.key, expected.key) !== UNEQUAL;
          }
          expected = rhsFork.shared();
        }
        let actualIsExtraneous = false;
        if (this.tag === initialExpected.tag) {
          if (initialExpected.keyIsPrimitive) {
            let actual = this;
            while (!actualIsExtraneous && actual !== null && this.tag === actual.tag) {
              if (actual.keyIsPrimitive) {
                actualIsExtraneous = initialExpected.key.compare(actual.key) === DEEP_EQUAL;
              }
              actual = lhsFork.shared();
            }
          } else {
            let actual = this;
            while (!actualIsExtraneous && actual !== null && this.tag === actual.tag) {
              if (!actual.keyIsPrimitive) {
                actualIsExtraneous = compareComplexShape(actual.key, initialExpected.key) !== UNEQUAL;
              }
              actual = lhsFork.shared();
            }
          }
        }
        if (actualIsExtraneous && !expectedIsMissing) {
          return {
            actualIsExtraneous: true,
            lhsRecursor: lhsFork.recursor,
            rhsRecursor: recursorUtils.unshift(rhsFork.recursor, initialExpected)
          };
        }
        if (expectedIsMissing && !actualIsExtraneous) {
          return {
            expectedIsMissing: true,
            lhsRecursor: recursorUtils.unshift(lhsFork.recursor, this),
            rhsRecursor: rhsFork.recursor
          };
        }
        let mustRecurse = false;
        if (!this.keyIsPrimitive && !initialExpected.keyIsPrimitive) {
          if (this.valueIsPrimitive || initialExpected.valueIsPrimitive) {
            mustRecurse = this.value.compare(initialExpected.value) !== UNEQUAL;
          } else {
            mustRecurse = compareComplexShape(this.value, initialExpected.value) !== UNEQUAL;
          }
        }
        return {
          mustRecurse,
          isUnequal: !mustRecurse,
          lhsRecursor: lhsFork.recursor,
          rhsRecursor: rhsFork.recursor
        };
      }
      serialize() {
        return [this.keyIsPrimitive, this.valueIsPrimitive];
      }
    };
    Object.defineProperty(MapEntry.prototype, "isMapEntry", { value: true });
    Object.defineProperty(MapEntry.prototype, "tag", { value: tag });
  }
});

// node_modules/concordance/lib/primitiveValues/bigInt.js
var require_bigInt = __commonJS({
  "node_modules/concordance/lib/primitiveValues/bigInt.js"(exports2) {
    "use strict";
    var constants = require_constants4();
    var formatUtils = require_formatUtils();
    var lineBuilder = require_lineBuilder();
    var DEEP_EQUAL = constants.DEEP_EQUAL;
    var UNEQUAL = constants.UNEQUAL;
    function describe(value2) {
      return new BigIntValue(value2);
    }
    exports2.describe = describe;
    exports2.deserialize = describe;
    var tag = Symbol("BigIntValue");
    exports2.tag = tag;
    var BigIntValue = class {
      constructor(value2) {
        this.value = value2;
      }
      compare(expected) {
        return expected.tag === tag && Object.is(this.value, expected.value) ? DEEP_EQUAL : UNEQUAL;
      }
      formatDeep(theme) {
        return lineBuilder.single(formatUtils.wrap(theme.bigInt, `${this.value}n`));
      }
      serialize() {
        return this.value;
      }
    };
    Object.defineProperty(BigIntValue.prototype, "isPrimitive", { value: true });
    Object.defineProperty(BigIntValue.prototype, "tag", { value: tag });
  }
});

// node_modules/concordance/lib/primitiveValues/boolean.js
var require_boolean = __commonJS({
  "node_modules/concordance/lib/primitiveValues/boolean.js"(exports2) {
    "use strict";
    var constants = require_constants4();
    var formatUtils = require_formatUtils();
    var lineBuilder = require_lineBuilder();
    var DEEP_EQUAL = constants.DEEP_EQUAL;
    var UNEQUAL = constants.UNEQUAL;
    function describe(value2) {
      return new BooleanValue(value2);
    }
    exports2.describe = describe;
    exports2.deserialize = describe;
    var tag = Symbol("BooleanValue");
    exports2.tag = tag;
    var BooleanValue = class {
      constructor(value2) {
        this.value = value2;
      }
      compare(expected) {
        return this.tag === expected.tag && this.value === expected.value ? DEEP_EQUAL : UNEQUAL;
      }
      formatDeep(theme) {
        return lineBuilder.single(formatUtils.wrap(theme.boolean, this.value === true ? "true" : "false"));
      }
      serialize() {
        return this.value;
      }
    };
    Object.defineProperty(BooleanValue.prototype, "isPrimitive", { value: true });
    Object.defineProperty(BooleanValue.prototype, "tag", { value: tag });
  }
});

// node_modules/concordance/lib/primitiveValues/null.js
var require_null = __commonJS({
  "node_modules/concordance/lib/primitiveValues/null.js"(exports2) {
    "use strict";
    var constants = require_constants4();
    var formatUtils = require_formatUtils();
    var lineBuilder = require_lineBuilder();
    var DEEP_EQUAL = constants.DEEP_EQUAL;
    var UNEQUAL = constants.UNEQUAL;
    function describe() {
      return new NullValue();
    }
    exports2.describe = describe;
    exports2.deserialize = describe;
    var tag = Symbol("NullValue");
    exports2.tag = tag;
    var NullValue = class {
      compare(expected) {
        return expected.tag === tag ? DEEP_EQUAL : UNEQUAL;
      }
      formatDeep(theme) {
        return lineBuilder.single(formatUtils.wrap(theme.null, "null"));
      }
    };
    Object.defineProperty(NullValue.prototype, "isPrimitive", { value: true });
    Object.defineProperty(NullValue.prototype, "tag", { value: tag });
  }
});

// node_modules/concordance/lib/primitiveValues/number.js
var require_number = __commonJS({
  "node_modules/concordance/lib/primitiveValues/number.js"(exports2) {
    "use strict";
    var constants = require_constants4();
    var formatUtils = require_formatUtils();
    var lineBuilder = require_lineBuilder();
    var DEEP_EQUAL = constants.DEEP_EQUAL;
    var UNEQUAL = constants.UNEQUAL;
    function describe(value2) {
      return new NumberValue(value2);
    }
    exports2.describe = describe;
    exports2.deserialize = describe;
    var tag = Symbol("NumberValue");
    exports2.tag = tag;
    var NumberValue = class {
      constructor(value2) {
        this.value = value2;
      }
      compare(expected) {
        return expected.tag === tag && Object.is(this.value, expected.value) ? DEEP_EQUAL : UNEQUAL;
      }
      formatDeep(theme) {
        const string = Object.is(this.value, -0) ? "-0" : String(this.value);
        return lineBuilder.single(formatUtils.wrap(theme.number, string));
      }
      serialize() {
        return this.value;
      }
    };
    Object.defineProperty(NumberValue.prototype, "isPrimitive", { value: true });
    Object.defineProperty(NumberValue.prototype, "tag", { value: tag });
  }
});

// node_modules/concordance/lib/primitiveValues/undefined.js
var require_undefined = __commonJS({
  "node_modules/concordance/lib/primitiveValues/undefined.js"(exports2) {
    "use strict";
    var constants = require_constants4();
    var formatUtils = require_formatUtils();
    var lineBuilder = require_lineBuilder();
    var DEEP_EQUAL = constants.DEEP_EQUAL;
    var UNEQUAL = constants.UNEQUAL;
    function describe() {
      return new UndefinedValue();
    }
    exports2.describe = describe;
    exports2.deserialize = describe;
    var tag = Symbol("UndefinedValue");
    exports2.tag = tag;
    var UndefinedValue = class {
      compare(expected) {
        return expected.tag === tag ? DEEP_EQUAL : UNEQUAL;
      }
      formatDeep(theme) {
        return lineBuilder.single(formatUtils.wrap(theme.undefined, "undefined"));
      }
    };
    Object.defineProperty(UndefinedValue.prototype, "isPrimitive", { value: true });
    Object.defineProperty(UndefinedValue.prototype, "tag", { value: tag });
  }
});

// node_modules/concordance/lib/describe.js
var require_describe = __commonJS({
  "node_modules/concordance/lib/describe.js"(exports2, module2) {
    "use strict";
    var Registry = require_Registry();
    var argumentsValue = require_arguments();
    var arrayBufferValue = require_arrayBuffer();
    var boxedValue = require_boxed();
    var dataViewValue = require_dataView();
    var dateValue = require_date();
    var errorValue = require_error2();
    var functionValue = require_function();
    var globalValue = require_global();
    var mapValue = require_map();
    var objectValue = require_object();
    var promiseValue = require_promise();
    var regexpValue = require_regexp();
    var setValue = require_set();
    var typedArrayValue = require_typedArray();
    var getCtor = require_getCtor();
    var getStringTag = require_getStringTag();
    var itemDescriptor = require_item();
    var mapEntryDescriptor = require_mapEntry();
    var propertyDescriptor = require_property();
    var pluginRegistry = require_pluginRegistry();
    var bigIntValue = require_bigInt();
    var booleanValue = require_boolean();
    var nullValue = require_null();
    var numberValue = require_number();
    var stringValue = require_string2();
    var symbolValue = require_symbol();
    var undefinedValue = require_undefined();
    var SpecializedComplexes = /* @__PURE__ */ new Map([
      ["Arguments", argumentsValue.describe],
      ["ArrayBuffer", arrayBufferValue.describe],
      ["DataView", dataViewValue.describe],
      ["Date", dateValue.describe],
      ["Error", errorValue.describe],
      ["Float32Array", typedArrayValue.describe],
      ["Float64Array", typedArrayValue.describe],
      ["Function", functionValue.describe],
      ["GeneratorFunction", functionValue.describe],
      ["global", globalValue.describe],
      ["Int16Array", typedArrayValue.describe],
      ["Int32Array", typedArrayValue.describe],
      ["Int8Array", typedArrayValue.describe],
      ["Map", mapValue.describe],
      ["Promise", promiseValue.describe],
      ["RegExp", regexpValue.describe],
      ["Set", setValue.describe],
      ["Uint16Array", typedArrayValue.describe],
      ["Uint32Array", typedArrayValue.describe],
      ["Uint8Array", typedArrayValue.describe],
      ["Uint8ClampedArray", typedArrayValue.describe]
    ]);
    function describePrimitive(value2) {
      if (value2 === null) return nullValue.describe();
      if (value2 === void 0) return undefinedValue.describe();
      if (value2 === true || value2 === false) return booleanValue.describe(value2);
      const type = typeof value2;
      if (type === "bigint") return bigIntValue.describe(value2);
      if (type === "number") return numberValue.describe(value2);
      if (type === "string") return stringValue.describe(value2);
      if (type === "symbol") return symbolValue.describe(value2);
      return null;
    }
    function unboxComplex(tag, complex) {
      if (typeof complex.valueOf === "function") {
        const value2 = complex.valueOf();
        if (value2 !== complex) return describePrimitive(value2);
      }
      return null;
    }
    function registerPlugins(plugins) {
      if (!Array.isArray(plugins) || plugins.length === 0) return () => null;
      const tryFns = pluginRegistry.getTryDescribeValues(plugins);
      return (value2, stringTag, ctor) => {
        for (const tryDescribeValue of tryFns) {
          const describeValue = tryDescribeValue(value2, stringTag, ctor);
          if (describeValue) return describeValue;
        }
        return null;
      };
    }
    function describeComplex(value2, registry, tryPlugins, describeAny, describeItem2, describeMapEntry2, describeProperty) {
      if (registry.has(value2)) return registry.get(value2);
      const stringTag = getStringTag(value2);
      const ctor = getCtor(stringTag, value2);
      const pointer = registry.alloc(value2);
      let unboxed;
      let describeValue = tryPlugins(value2, stringTag, ctor);
      if (describeValue === null) {
        if (SpecializedComplexes.has(stringTag)) {
          describeValue = SpecializedComplexes.get(stringTag);
        } else {
          unboxed = unboxComplex(stringTag, value2);
          if (unboxed !== null) {
            describeValue = boxedValue.describe;
          } else {
            describeValue = objectValue.describe;
          }
        }
      }
      const descriptor = describeValue({
        ctor,
        describeAny,
        describeItem: describeItem2,
        describeMapEntry: describeMapEntry2,
        describeProperty,
        pointer: pointer.index,
        stringTag,
        unboxed,
        value: value2
      });
      pointer.descriptor = descriptor;
      return descriptor;
    }
    var describeItem = (index, valueDescriptor) => {
      return valueDescriptor.isPrimitive === true ? itemDescriptor.describePrimitive(index, valueDescriptor) : itemDescriptor.describeComplex(index, valueDescriptor);
    };
    var describeMapEntry = (keyDescriptor, valueDescriptor) => {
      return mapEntryDescriptor.describe(keyDescriptor, valueDescriptor);
    };
    function describe(value2, options) {
      const primitive = describePrimitive(value2);
      if (primitive !== null) return primitive;
      const registry = new Registry();
      const tryPlugins = registerPlugins(options && options.plugins);
      const curriedComplex = (c) => {
        return describeComplex(c, registry, tryPlugins, describeAny, describeItem, describeMapEntry, describeProperty);
      };
      const describeAny = (any) => {
        const descriptor = describePrimitive(any);
        return descriptor !== null ? descriptor : curriedComplex(any);
      };
      const describeProperty = (key, valueDescriptor) => {
        const keyDescriptor = describePrimitive(key);
        return valueDescriptor.isPrimitive === true ? propertyDescriptor.describePrimitive(keyDescriptor, valueDescriptor) : propertyDescriptor.describeComplex(keyDescriptor, valueDescriptor);
      };
      return curriedComplex(value2);
    }
    module2.exports = describe;
  }
});

// node_modules/concordance/lib/shouldCompareDeep.js
var require_shouldCompareDeep = __commonJS({
  "node_modules/concordance/lib/shouldCompareDeep.js"(exports2, module2) {
    "use strict";
    var argumentsObject = require_arguments().tag;
    var constants = require_constants4();
    var AMBIGUOUS = constants.AMBIGUOUS;
    var SHALLOW_EQUAL = constants.SHALLOW_EQUAL;
    function shouldCompareDeep(result, lhs, rhs) {
      if (result === SHALLOW_EQUAL) return true;
      if (result !== AMBIGUOUS) return false;
      return lhs.tag === argumentsObject || lhs.isProperty === true;
    }
    module2.exports = shouldCompareDeep;
  }
});

// node_modules/concordance/lib/symbolProperties.js
var require_symbolProperties = __commonJS({
  "node_modules/concordance/lib/symbolProperties.js"(exports2) {
    "use strict";
    var constants = require_constants4();
    var recursorUtils = require_recursorUtils();
    var DEEP_EQUAL = constants.DEEP_EQUAL;
    var SHALLOW_EQUAL = constants.SHALLOW_EQUAL;
    var UNEQUAL = constants.UNEQUAL;
    var Comparable = class {
      constructor(properties) {
        this.properties = properties;
        this.ordered = properties.slice();
      }
      createRecursor() {
        const length = this.ordered.length;
        let index = 0;
        return () => {
          if (index === length) return null;
          return this.ordered[index++];
        };
      }
      compare(expected) {
        if (this.properties.length !== expected.properties.length) return UNEQUAL;
        const ordered = [];
        const processed = /* @__PURE__ */ new Set();
        for (const property of this.properties) {
          let extraneous = true;
          for (const other of expected.properties) {
            if (processed.has(other.key)) continue;
            if (property.key.compare(other.key) === DEEP_EQUAL) {
              extraneous = false;
              processed.add(other.key);
              ordered.push(other);
              break;
            }
          }
          if (extraneous) return UNEQUAL;
        }
        expected.ordered = ordered;
        return SHALLOW_EQUAL;
      }
      prepareDiff(expected) {
        const missingProperties = [];
        const ordered = [];
        const processed = /* @__PURE__ */ new Set();
        for (const other of expected.properties) {
          let missing = true;
          for (const property of this.properties) {
            if (processed.has(property.key)) continue;
            if (property.key.compare(other.key) === DEEP_EQUAL) {
              missing = false;
              processed.add(property.key);
              ordered.push(other);
              break;
            }
          }
          if (missing) {
            missingProperties.push(other);
          }
        }
        expected.ordered = ordered.concat(missingProperties);
        return { mustRecurse: true };
      }
    };
    Object.defineProperty(Comparable.prototype, "isSymbolPropertiesComparable", { value: true });
    exports2.Comparable = Comparable;
    var Collector = class {
      constructor(firstProperty, recursor) {
        this.properties = [firstProperty];
        this.recursor = recursor;
        this.remainder = null;
      }
      collectAll() {
        do {
          const next = this.recursor();
          if (next && next.isProperty === true) {
            this.properties.push(next);
          } else {
            return next;
          }
        } while (true);
      }
      createRecursor() {
        return recursorUtils.singleValue(new Comparable(this.properties));
      }
    };
    Object.defineProperty(Collector.prototype, "isSymbolPropertiesCollector", { value: true });
    exports2.Collector = Collector;
  }
});

// node_modules/concordance/lib/compare.js
var require_compare2 = __commonJS({
  "node_modules/concordance/lib/compare.js"(exports2) {
    "use strict";
    var Circular = require_Circular();
    var constants = require_constants4();
    var describe = require_describe();
    var recursorUtils = require_recursorUtils();
    var shouldCompareDeep = require_shouldCompareDeep();
    var symbolProperties = require_symbolProperties();
    var AMBIGUOUS = constants.AMBIGUOUS;
    var DEEP_EQUAL = constants.DEEP_EQUAL;
    var UNEQUAL = constants.UNEQUAL;
    function shortcircuitPrimitive(value2) {
      if (value2 === null || value2 === void 0 || value2 === true || value2 === false) return true;
      const type = typeof value2;
      if (type === "string" || type === "symbol") return true;
      if (type === "number") return !isNaN(value2);
      return false;
    }
    function compareDescriptors(lhs, rhs) {
      const lhsCircular = new Circular();
      const rhsCircular = new Circular();
      const lhsStack = [];
      const rhsStack = [];
      let topIndex = -1;
      do {
        let result;
        if (lhsCircular.has(lhs)) {
          result = lhsCircular.get(lhs) === rhsCircular.get(rhs) ? DEEP_EQUAL : UNEQUAL;
        } else if (rhsCircular.has(rhs)) {
          result = UNEQUAL;
        } else {
          result = lhs.compare(rhs);
        }
        if (result === UNEQUAL) return false;
        if (result !== DEEP_EQUAL) {
          if (!shouldCompareDeep(result, lhs, rhs)) return false;
          if (result === AMBIGUOUS && lhs.isProperty === true) {
            lhs = new symbolProperties.Collector(lhs, lhsStack[topIndex].recursor);
            rhs = new symbolProperties.Collector(rhs, rhsStack[topIndex].recursor);
            lhsStack[topIndex].recursor = recursorUtils.unshift(lhsStack[topIndex].recursor, lhs.collectAll());
            rhsStack[topIndex].recursor = recursorUtils.unshift(rhsStack[topIndex].recursor, rhs.collectAll());
          }
          lhsCircular.add(lhs);
          rhsCircular.add(rhs);
          lhsStack.push({ subject: lhs, recursor: lhs.createRecursor() });
          rhsStack.push({ subject: rhs, recursor: rhs.createRecursor() });
          topIndex++;
        }
        while (topIndex >= 0) {
          lhs = lhsStack[topIndex].recursor();
          rhs = rhsStack[topIndex].recursor();
          if (lhs !== null && rhs !== null) {
            break;
          }
          if (lhs === null && rhs === null) {
            const lhsRecord = lhsStack.pop();
            const rhsRecord = rhsStack.pop();
            lhsCircular.delete(lhsRecord.subject);
            rhsCircular.delete(rhsRecord.subject);
            topIndex--;
          } else {
            return false;
          }
        }
      } while (topIndex >= 0);
      return true;
    }
    exports2.compareDescriptors = compareDescriptors;
    function compare(actual, expected, options) {
      if (Object.is(actual, expected)) return { pass: true };
      if (shortcircuitPrimitive(actual) || shortcircuitPrimitive(expected)) return { pass: false };
      actual = describe(actual, options);
      expected = describe(expected, options);
      const pass = compareDescriptors(actual, expected);
      return { actual, expected, pass };
    }
    exports2.compare = compare;
  }
});

// node_modules/concordance/lib/Indenter.js
var require_Indenter = __commonJS({
  "node_modules/concordance/lib/Indenter.js"(exports2, module2) {
    "use strict";
    var Indenter = class _Indenter {
      constructor(level, step) {
        this.level = level;
        this.step = step;
        this.value = step.repeat(level);
      }
      increase() {
        return new _Indenter(this.level + 1, this.step);
      }
      decrease() {
        return new _Indenter(this.level - 1, this.step);
      }
      toString() {
        return this.value;
      }
    };
    module2.exports = Indenter;
  }
});

// node_modules/concordance/lib/diff.js
var require_diff3 = __commonJS({
  "node_modules/concordance/lib/diff.js"(exports2) {
    "use strict";
    var Circular = require_Circular();
    var Indenter = require_Indenter();
    var constants = require_constants4();
    var describe = require_describe();
    var lineBuilder = require_lineBuilder();
    var recursorUtils = require_recursorUtils();
    var shouldCompareDeep = require_shouldCompareDeep();
    var symbolProperties = require_symbolProperties();
    var themeUtils = require_themeUtils();
    var AMBIGUOUS = constants.AMBIGUOUS;
    var DEEP_EQUAL = constants.DEEP_EQUAL;
    var UNEQUAL = constants.UNEQUAL;
    var SHALLOW_EQUAL = constants.SHALLOW_EQUAL;
    var NOOP = Symbol("NOOP");
    var alwaysFormat = () => true;
    function compareComplexShape(lhs, rhs) {
      let result = lhs.compare(rhs);
      if (result === DEEP_EQUAL) return DEEP_EQUAL;
      if (result === UNEQUAL || !shouldCompareDeep(result, lhs, rhs)) return UNEQUAL;
      let collectedSymbolProperties = false;
      let lhsRecursor = lhs.createRecursor();
      let rhsRecursor = rhs.createRecursor();
      do {
        lhs = lhsRecursor();
        rhs = rhsRecursor();
        if (lhs === null && rhs === null) return SHALLOW_EQUAL;
        if (lhs === null || rhs === null) return UNEQUAL;
        result = lhs.compare(rhs);
        if (result === UNEQUAL) return UNEQUAL;
        if (result === AMBIGUOUS && lhs.isProperty === true && !collectedSymbolProperties && shouldCompareDeep(result, lhs, rhs)) {
          collectedSymbolProperties = true;
          const lhsCollector = new symbolProperties.Collector(lhs, lhsRecursor);
          const rhsCollector = new symbolProperties.Collector(rhs, rhsRecursor);
          lhsRecursor = recursorUtils.sequence(
            lhsCollector.createRecursor(),
            recursorUtils.unshift(lhsRecursor, lhsCollector.collectAll())
          );
          rhsRecursor = recursorUtils.sequence(
            rhsCollector.createRecursor(),
            recursorUtils.unshift(rhsRecursor, rhsCollector.collectAll())
          );
        }
      } while (true);
    }
    function diffDescriptors(lhs, rhs, options) {
      const theme = themeUtils.normalize(options);
      const invert = options ? options.invert === true : false;
      const lhsCircular = new Circular();
      const rhsCircular = new Circular();
      const maxDepth = options && options.maxDepth || 0;
      let indent = new Indenter(0, "  ");
      const lhsStack = [];
      const rhsStack = [];
      let topIndex = -1;
      const buffer = lineBuilder.buffer();
      const diffStack = [];
      let diffIndex = -1;
      const isCircular = (descriptor) => lhsCircular.has(descriptor) || rhsCircular.has(descriptor);
      const format = (builder, subject, circular, depthOffset = 0) => {
        if (diffIndex >= 0 && !diffStack[diffIndex].shouldFormat(subject)) return;
        if (circular.has(subject)) {
          diffStack[diffIndex].formatter.append(builder.single(theme.circular));
          return;
        }
        const formatStack = [];
        let formatIndex = -1;
        do {
          if (circular.has(subject)) {
            formatStack[formatIndex].formatter.append(builder.single(theme.circular), subject);
          } else {
            let didFormat = false;
            if (typeof subject.formatDeep === "function") {
              let formatted = subject.formatDeep(themeUtils.applyModifiers(subject, theme), indent);
              if (formatted !== null) {
                didFormat = true;
                if (formatIndex === -1) {
                  formatted = builder.setDefaultGutter(formatted);
                  if (diffIndex === -1) {
                    buffer.append(formatted);
                  } else {
                    diffStack[diffIndex].formatter.append(formatted, subject);
                  }
                } else {
                  formatStack[formatIndex].formatter.append(formatted, subject);
                }
              }
            }
            if (!didFormat && typeof subject.formatShallow === "function") {
              const formatter = subject.formatShallow(themeUtils.applyModifiers(subject, theme), indent);
              const recursor = subject.createRecursor();
              if (formatter.increaseIndent && maxDepth > 0 && indent.level === maxDepth + depthOffset) {
                const isEmpty = recursor() === null;
                let formatted = !isEmpty && typeof formatter.maxDepth === "function" ? formatter.maxDepth() : formatter.finalize();
                if (formatIndex === -1) {
                  formatted = builder.setDefaultGutter(formatted);
                  diffStack[diffIndex].formatter.append(formatted, subject);
                } else {
                  formatStack[formatIndex].formatter.append(formatted, subject);
                }
              } else {
                formatStack.push({
                  formatter,
                  recursor,
                  decreaseIndent: formatter.increaseIndent,
                  shouldFormat: formatter.shouldFormat || alwaysFormat,
                  subject
                });
                formatIndex++;
                if (formatter.increaseIndent) indent = indent.increase();
                circular.add(subject);
              }
            }
          }
          while (formatIndex >= 0) {
            do {
              subject = formatStack[formatIndex].recursor();
            } while (subject && !formatStack[formatIndex].shouldFormat(subject));
            if (subject) {
              break;
            }
            const record = formatStack.pop();
            formatIndex--;
            if (record.decreaseIndent) indent = indent.decrease();
            circular.delete(record.subject);
            let formatted = record.formatter.finalize();
            if (formatIndex === -1) {
              formatted = builder.setDefaultGutter(formatted);
              if (diffIndex === -1) {
                buffer.append(formatted);
              } else {
                diffStack[diffIndex].formatter.append(formatted, record.subject);
              }
            } else {
              formatStack[formatIndex].formatter.append(formatted, record.subject);
            }
          }
        } while (formatIndex >= 0);
      };
      do {
        let compareResult = NOOP;
        if (lhsCircular.has(lhs)) {
          compareResult = lhsCircular.get(lhs) === rhsCircular.get(rhs) ? DEEP_EQUAL : UNEQUAL;
        } else if (rhsCircular.has(rhs)) {
          compareResult = UNEQUAL;
        }
        let firstPassSymbolProperty = false;
        if (lhs.isProperty === true) {
          compareResult = lhs.compare(rhs);
          if (compareResult === AMBIGUOUS) {
            const parent = lhsStack[topIndex].subject;
            firstPassSymbolProperty = parent.isSymbolPropertiesCollector !== true && parent.isSymbolPropertiesComparable !== true;
          }
        }
        let didFormat = false;
        let mustRecurse = false;
        if (compareResult !== DEEP_EQUAL && !firstPassSymbolProperty && typeof lhs.prepareDiff === "function") {
          const lhsRecursor = topIndex === -1 ? null : lhsStack[topIndex].recursor;
          const rhsRecursor = topIndex === -1 ? null : rhsStack[topIndex].recursor;
          const instructions = lhs.prepareDiff(
            rhs,
            lhsRecursor,
            rhsRecursor,
            compareComplexShape,
            isCircular
          );
          if (instructions !== null) {
            if (topIndex >= 0) {
              if (typeof instructions.lhsRecursor === "function") {
                lhsStack[topIndex].recursor = instructions.lhsRecursor;
              }
              if (typeof instructions.rhsRecursor === "function") {
                rhsStack[topIndex].recursor = instructions.rhsRecursor;
              }
            }
            if (instructions.compareResult) {
              compareResult = instructions.compareResult;
            }
            if (instructions.mustRecurse === true) {
              mustRecurse = true;
            } else {
              if (instructions.actualIsExtraneous === true) {
                format(lineBuilder.actual, lhs, lhsCircular);
                didFormat = true;
              } else if (instructions.multipleAreExtraneous === true) {
                for (const extraneous of instructions.descriptors) {
                  format(lineBuilder.actual, extraneous, lhsCircular);
                }
                didFormat = true;
              } else if (instructions.expectedIsMissing === true) {
                format(lineBuilder.expected, rhs, rhsCircular);
                didFormat = true;
              } else if (instructions.multipleAreMissing === true) {
                for (const missing of instructions.descriptors) {
                  format(lineBuilder.expected, missing, rhsCircular);
                }
                didFormat = true;
              } else if (instructions.isUnequal === true) {
                format(lineBuilder.actual, lhs, lhsCircular);
                format(lineBuilder.expected, rhs, rhsCircular);
                didFormat = true;
              } else if (!instructions.compareResult) {
                throw new Error("Illegal result of prepareDiff()");
              }
            }
          }
        }
        if (!didFormat) {
          if (compareResult === NOOP) {
            compareResult = lhs.compare(rhs);
          }
          if (!mustRecurse) {
            mustRecurse = shouldCompareDeep(compareResult, lhs, rhs);
          }
          if (compareResult === DEEP_EQUAL) {
            format(lineBuilder, lhs, lhsCircular);
          } else if (mustRecurse) {
            if (compareResult === AMBIGUOUS && lhs.isProperty === true) {
              lhs = new symbolProperties.Collector(lhs, lhsStack[topIndex].recursor);
              rhs = new symbolProperties.Collector(rhs, rhsStack[topIndex].recursor);
              lhsStack[topIndex].recursor = recursorUtils.unshift(lhsStack[topIndex].recursor, lhs.collectAll());
              rhsStack[topIndex].recursor = recursorUtils.unshift(rhsStack[topIndex].recursor, rhs.collectAll());
            }
            if (typeof lhs.diffShallow === "function") {
              const formatter = lhs.diffShallow(rhs, themeUtils.applyModifiers(lhs, theme), indent);
              diffStack.push({
                formatter,
                origin: lhs,
                decreaseIndent: formatter.increaseIndent,
                exceedsMaxDepth: formatter.increaseIndent && maxDepth > 0 && indent.level >= maxDepth,
                shouldFormat: formatter.shouldFormat || alwaysFormat
              });
              diffIndex++;
              if (formatter.increaseIndent) indent = indent.increase();
            } else if (typeof lhs.formatShallow === "function") {
              const formatter = lhs.formatShallow(themeUtils.applyModifiers(lhs, theme), indent);
              diffStack.push({
                formatter,
                decreaseIndent: formatter.increaseIndent,
                exceedsMaxDepth: formatter.increaseIndent && maxDepth > 0 && indent.level >= maxDepth,
                shouldFormat: formatter.shouldFormat || alwaysFormat,
                subject: lhs
              });
              diffIndex++;
              if (formatter.increaseIndent) indent = indent.increase();
            }
            lhsCircular.add(lhs);
            rhsCircular.add(rhs);
            lhsStack.push({ diffIndex, subject: lhs, recursor: lhs.createRecursor() });
            rhsStack.push({ diffIndex, subject: rhs, recursor: rhs.createRecursor() });
            topIndex++;
          } else {
            const diffed = typeof lhs.diffDeep === "function" ? lhs.diffDeep(rhs, themeUtils.applyModifiers(lhs, theme), indent, invert) : null;
            if (diffed === null) {
              format(lineBuilder.actual, lhs, lhsCircular);
              format(lineBuilder.expected, rhs, rhsCircular);
            } else {
              if (diffIndex === -1) {
                buffer.append(diffed);
              } else {
                diffStack[diffIndex].formatter.append(diffed, lhs);
              }
            }
          }
        }
        while (topIndex >= 0) {
          lhs = lhsStack[topIndex].recursor();
          rhs = rhsStack[topIndex].recursor();
          if (lhs !== null && rhs !== null) {
            break;
          }
          if (lhs === null && rhs === null) {
            const lhsRecord = lhsStack.pop();
            const rhsRecord = rhsStack.pop();
            lhsCircular.delete(lhsRecord.subject);
            rhsCircular.delete(rhsRecord.subject);
            topIndex--;
            if (lhsRecord.diffIndex === diffIndex) {
              const record = diffStack.pop();
              diffIndex--;
              if (record.decreaseIndent) indent = indent.decrease();
              let formatted = record.formatter.finalize();
              if (record.exceedsMaxDepth && !formatted.hasGutter) {
                const subject = lhsRecord.subject;
                const formatter = subject.formatShallow(themeUtils.applyModifiers(subject, theme), indent);
                const isEmpty = subject.createRecursor()() === null;
                formatted = !isEmpty && typeof formatter.maxDepth === "function" ? formatter.maxDepth() : formatter.finalize();
              }
              if (diffIndex === -1) {
                buffer.append(formatted);
              } else {
                diffStack[diffIndex].formatter.append(formatted, record.subject);
              }
            }
          } else {
            let builder, circular, stack, subject;
            if (lhs === null) {
              builder = lineBuilder.expected;
              circular = rhsCircular;
              stack = rhsStack;
              subject = rhs;
            } else {
              builder = lineBuilder.actual;
              circular = lhsCircular;
              stack = lhsStack;
              subject = lhs;
            }
            do {
              format(builder, subject, circular, indent.level);
              subject = stack[topIndex].recursor();
            } while (subject !== null);
          }
        }
      } while (topIndex >= 0);
      return buffer.toString({ diff: true, invert, theme });
    }
    exports2.diffDescriptors = diffDescriptors;
    function diff(actual, expected, options) {
      return diffDescriptors(describe(actual, options), describe(expected, options), options);
    }
    exports2.diff = diff;
  }
});

// node_modules/concordance/lib/format.js
var require_format = __commonJS({
  "node_modules/concordance/lib/format.js"(exports2) {
    "use strict";
    var Circular = require_Circular();
    var Indenter = require_Indenter();
    var describe = require_describe();
    var lineBuilder = require_lineBuilder();
    var themeUtils = require_themeUtils();
    var alwaysFormat = () => true;
    var fixedIndent = new Indenter(0, "  ");
    function formatDescriptor(subject, options) {
      const theme = themeUtils.normalize(options);
      if (subject.isPrimitive === true) {
        const formatted = subject.formatDeep(themeUtils.applyModifiers(subject, theme), fixedIndent);
        return formatted.toString({ diff: false });
      }
      const circular = new Circular();
      const maxDepth = options && options.maxDepth || 0;
      let indent = fixedIndent;
      const buffer = lineBuilder.buffer();
      const stack = [];
      let topIndex = -1;
      do {
        if (circular.has(subject)) {
          stack[topIndex].formatter.append(lineBuilder.single(theme.circular), subject);
        } else {
          let didFormat = false;
          if (typeof subject.formatDeep === "function") {
            const formatted = subject.formatDeep(themeUtils.applyModifiers(subject, theme), indent);
            if (formatted !== null) {
              didFormat = true;
              if (topIndex === -1) {
                buffer.append(formatted);
              } else {
                stack[topIndex].formatter.append(formatted, subject);
              }
            }
          }
          if (!didFormat && typeof subject.formatShallow === "function") {
            const formatter = subject.formatShallow(themeUtils.applyModifiers(subject, theme), indent);
            const recursor = subject.createRecursor();
            if (formatter.increaseIndent && maxDepth > 0 && indent.level === maxDepth) {
              const isEmpty = recursor() === null;
              const formatted = !isEmpty && typeof formatter.maxDepth === "function" ? formatter.maxDepth() : formatter.finalize();
              stack[topIndex].formatter.append(formatted, subject);
            } else {
              stack.push({
                formatter,
                recursor,
                decreaseIndent: formatter.increaseIndent,
                shouldFormat: formatter.shouldFormat || alwaysFormat,
                subject
              });
              topIndex++;
              if (formatter.increaseIndent) indent = indent.increase();
              circular.add(subject);
            }
          }
        }
        while (topIndex >= 0) {
          do {
            subject = stack[topIndex].recursor();
          } while (subject && !stack[topIndex].shouldFormat(subject));
          if (subject) {
            break;
          }
          const record = stack.pop();
          topIndex--;
          if (record.decreaseIndent) indent = indent.decrease();
          circular.delete(record.subject);
          const formatted = record.formatter.finalize();
          if (topIndex === -1) {
            buffer.append(formatted);
          } else {
            stack[topIndex].formatter.append(formatted, record.subject);
          }
        }
      } while (topIndex >= 0);
      return buffer.toString({ diff: false });
    }
    exports2.formatDescriptor = formatDescriptor;
    function format(value2, options) {
      return formatDescriptor(describe(value2, options), options);
    }
    exports2.format = format;
  }
});

// node_modules/md5-hex/index.js
var require_md5_hex = __commonJS({
  "node_modules/md5-hex/index.js"(exports2, module2) {
    "use strict";
    var crypto = require("crypto");
    module2.exports = (data) => {
      const hash = crypto.createHash("md5");
      const update = (buffer) => {
        const inputEncoding = typeof buffer === "string" ? "utf8" : void 0;
        hash.update(buffer, inputEncoding);
      };
      if (Array.isArray(data)) {
        for (const element of data) {
          update(element);
        }
      } else {
        update(data);
      }
      return hash.digest("hex");
    };
  }
});

// node_modules/concordance/lib/encoder.js
var require_encoder = __commonJS({
  "node_modules/concordance/lib/encoder.js"(exports2) {
    "use strict";
    var flattenDeep = require("lodash/flattenDeep");
    var valueTypes = {
      zero: 0,
      int8: 1,
      // Note that the hex value equals the number of bytes required
      int16: 2,
      // to store the integer.
      int24: 3,
      int32: 4,
      int40: 5,
      int48: 6,
      numberString: 7,
      negativeZero: 8,
      notANumber: 9,
      infinity: 10,
      negativeInfinity: 11,
      bigInt: 12,
      undefined: 13,
      null: 14,
      true: 15,
      false: 16,
      utf8: 17,
      bytes: 18,
      list: 19,
      descriptor: 20
    };
    var descriptorSymbol = Symbol("descriptor");
    exports2.descriptorSymbol = descriptorSymbol;
    function encodeInteger(type, value2) {
      const encoded = Buffer.alloc(type);
      encoded.writeIntLE(value2, 0, type);
      return [type, encoded];
    }
    function encodeValue(value2) {
      if (Object.is(value2, 0)) return valueTypes.zero;
      if (Object.is(value2, -0)) return valueTypes.negativeZero;
      if (Object.is(value2, NaN)) return valueTypes.notANumber;
      if (value2 === Infinity) return valueTypes.infinity;
      if (value2 === -Infinity) return valueTypes.negativeInfinity;
      if (value2 === void 0) return valueTypes.undefined;
      if (value2 === null) return valueTypes.null;
      if (value2 === true) return valueTypes.true;
      if (value2 === false) return valueTypes.false;
      const type = typeof value2;
      if (type === "number") {
        if (Number.isInteger(value2)) {
          if (value2 >= -128 && value2 < 128) return encodeInteger(valueTypes.int8, value2);
          if (value2 >= -32768 && value2 < 32768) return encodeInteger(valueTypes.int16, value2);
          if (value2 >= -8388608 && value2 < 8388608) return encodeInteger(valueTypes.int24, value2);
          if (value2 >= -2147483648 && value2 < 2147483648) return encodeInteger(valueTypes.int32, value2);
          if (value2 >= -549755813888 && value2 < 549755813888) return encodeInteger(valueTypes.int40, value2);
          if (value2 >= -140737488355328 && value2 < 140737488355328) return encodeInteger(valueTypes.int48, value2);
        }
        const encoded = Buffer.from(String(value2), "utf8");
        return [valueTypes.numberString, encodeValue(encoded.length), encoded];
      }
      if (type === "string") {
        const encoded = Buffer.from(value2, "utf8");
        return [valueTypes.utf8, encodeValue(encoded.length), encoded];
      }
      if (type === "bigint") {
        const encoded = Buffer.from(String(value2), "utf8");
        return [valueTypes.bigInt, encodeValue(encoded.length), encoded];
      }
      if (Buffer.isBuffer(value2)) {
        return [valueTypes.bytes, encodeValue(value2.byteLength), value2];
      }
      if (Array.isArray(value2)) {
        return [
          value2[descriptorSymbol] === true ? valueTypes.descriptor : valueTypes.list,
          encodeValue(value2.length),
          value2.map((x) => encodeValue(x))
        ];
      }
      const hex = `0x${type.toString(16).toUpperCase()}`;
      throw new TypeError(`Unexpected value with type ${hex}`);
    }
    function decodeValue(buffer, byteOffset) {
      const type = buffer.readUInt8(byteOffset);
      byteOffset += 1;
      if (type === valueTypes.zero) return { byteOffset, value: 0 };
      if (type === valueTypes.negativeZero) return { byteOffset, value: -0 };
      if (type === valueTypes.notANumber) return { byteOffset, value: NaN };
      if (type === valueTypes.infinity) return { byteOffset, value: Infinity };
      if (type === valueTypes.negativeInfinity) return { byteOffset, value: -Infinity };
      if (type === valueTypes.undefined) return { byteOffset, value: void 0 };
      if (type === valueTypes.null) return { byteOffset, value: null };
      if (type === valueTypes.true) return { byteOffset, value: true };
      if (type === valueTypes.false) return { byteOffset, value: false };
      if (type === valueTypes.int8 || type === valueTypes.int16 || type === valueTypes.int24 || type === valueTypes.int32 || type === valueTypes.int40 || type === valueTypes.int48) {
        const value2 = buffer.readIntLE(byteOffset, type);
        byteOffset += type;
        return { byteOffset, value: value2 };
      }
      if (type === valueTypes.numberString || type === valueTypes.utf8 || type === valueTypes.bytes || type === valueTypes.bigInt) {
        const length = decodeValue(buffer, byteOffset);
        const start = length.byteOffset;
        const end = start + length.value;
        if (type === valueTypes.numberString) {
          const value3 = Number(buffer.toString("utf8", start, end));
          return { byteOffset: end, value: value3 };
        }
        if (type === valueTypes.utf8) {
          const value3 = buffer.toString("utf8", start, end);
          return { byteOffset: end, value: value3 };
        }
        if (type === valueTypes.bigInt) {
          const value3 = BigInt(buffer.toString("utf8", start, end));
          return { byteOffset: end, value: value3 };
        }
        const value2 = buffer.slice(start, end);
        return { byteOffset: end, value: value2 };
      }
      if (type === valueTypes.list || type === valueTypes.descriptor) {
        const length = decodeValue(buffer, byteOffset);
        byteOffset = length.byteOffset;
        const value2 = new Array(length.value);
        if (type === valueTypes.descriptor) {
          value2[descriptorSymbol] = true;
        }
        for (let index = 0; index < length.value; index++) {
          const item = decodeValue(buffer, byteOffset);
          byteOffset = item.byteOffset;
          value2[index] = item.value;
        }
        return { byteOffset, value: value2 };
      }
      const hex = `0x${type.toString(16).toUpperCase()}`;
      throw new TypeError(`Could not decode type ${hex}`);
    }
    function buildBuffer(numberOrArray) {
      if (typeof numberOrArray === "number") {
        const byte = Buffer.alloc(1);
        byte.writeUInt8(numberOrArray);
        return byte;
      }
      const array = flattenDeep(numberOrArray);
      const buffers = new Array(array.length);
      let byteLength = 0;
      for (const [index, element] of array.entries()) {
        if (typeof element === "number") {
          byteLength += 1;
          const byte = Buffer.alloc(1);
          byte.writeUInt8(element);
          buffers[index] = byte;
        } else {
          byteLength += element.byteLength;
          buffers[index] = element;
        }
      }
      return Buffer.concat(buffers, byteLength);
    }
    function encode(serializerVersion, rootRecord, usedPlugins) {
      const buffers = [];
      let byteOffset = 0;
      const versionHeader = Buffer.alloc(2);
      versionHeader.writeUInt16LE(serializerVersion);
      buffers.push(versionHeader);
      byteOffset += versionHeader.byteLength;
      const rootOffset = Buffer.alloc(4);
      buffers.push(rootOffset);
      byteOffset += rootOffset.byteLength;
      const numPlugins = buildBuffer(encodeValue(usedPlugins.size));
      buffers.push(numPlugins);
      byteOffset += numPlugins.byteLength;
      for (const name of usedPlugins.keys()) {
        const plugin = usedPlugins.get(name);
        const record = buildBuffer([
          encodeValue(name),
          encodeValue(plugin.serializerVersion)
        ]);
        buffers.push(record);
        byteOffset += record.byteLength;
      }
      const queue = [rootRecord];
      const pointers = [rootOffset];
      while (queue.length > 0) {
        pointers.shift().writeUInt32LE(byteOffset, 0);
        const record = queue.shift();
        const recordHeader = buildBuffer([
          encodeValue(record.pluginIndex),
          encodeValue(record.id),
          encodeValue(record.children.length)
        ]);
        buffers.push(recordHeader);
        byteOffset += recordHeader.byteLength;
        for (const child of record.children) {
          queue.push(child);
          const pointer = Buffer.alloc(4);
          pointers.push(pointer);
          buffers.push(pointer);
          byteOffset += 4;
        }
        const state = buildBuffer(encodeValue(record.state));
        buffers.push(state);
        byteOffset += state.byteLength;
      }
      return Buffer.concat(buffers, byteOffset);
    }
    exports2.encode = encode;
    function decodePlugins(buffer) {
      const $numPlugins = decodeValue(buffer, 0);
      let byteOffset = $numPlugins.byteOffset;
      const usedPlugins = /* @__PURE__ */ new Map();
      const lastIndex = $numPlugins.value;
      for (let index = 1; index <= lastIndex; index++) {
        const $name = decodeValue(buffer, byteOffset);
        const name = $name.value;
        byteOffset = $name.byteOffset;
        const serializerVersion = decodeValue(buffer, byteOffset).value;
        usedPlugins.set(index, { name, serializerVersion });
      }
      return usedPlugins;
    }
    exports2.decodePlugins = decodePlugins;
    function decodeRecord(buffer, byteOffset) {
      const $pluginIndex = decodeValue(buffer, byteOffset);
      const pluginIndex = $pluginIndex.value;
      byteOffset = $pluginIndex.byteOffset;
      const $id = decodeValue(buffer, byteOffset);
      const id = $id.value;
      byteOffset = $id.byteOffset;
      const $numPointers = decodeValue(buffer, byteOffset);
      const numPointers = $numPointers.value;
      byteOffset = $numPointers.byteOffset;
      const pointerAddresses = new Array(numPointers);
      for (let index = 0; index < numPointers; index++) {
        pointerAddresses[index] = buffer.readUInt32LE(byteOffset);
        byteOffset += 4;
      }
      const state = decodeValue(buffer, byteOffset).value;
      return { id, pluginIndex, state, pointerAddresses };
    }
    exports2.decodeRecord = decodeRecord;
    function extractVersion(buffer) {
      return buffer.readUInt16LE(0);
    }
    exports2.extractVersion = extractVersion;
    function decode(buffer) {
      const rootOffset = buffer.readUInt32LE(2);
      const pluginBuffer = buffer.slice(6, rootOffset);
      const rootRecord = decodeRecord(buffer, rootOffset);
      return { pluginBuffer, rootRecord };
    }
    exports2.decode = decode;
  }
});

// node_modules/concordance/lib/metaDescriptors/pointer.js
var require_pointer = __commonJS({
  "node_modules/concordance/lib/metaDescriptors/pointer.js"(exports2) {
    "use strict";
    var UNEQUAL = require_constants4().UNEQUAL;
    function describe(index) {
      return new Pointer(index);
    }
    exports2.describe = describe;
    exports2.deserialize = describe;
    var tag = Symbol("Pointer");
    exports2.tag = tag;
    var Pointer = class {
      constructor(index) {
        this.index = index;
      }
      // Pointers cannot be compared, and are not expected to be part of the
      // comparisons.
      compare(expected) {
        return UNEQUAL;
      }
      serialize() {
        return this.index;
      }
    };
    Object.defineProperty(Pointer.prototype, "isPointer", { value: true });
    Object.defineProperty(Pointer.prototype, "tag", { value: tag });
  }
});

// node_modules/concordance/lib/serialize.js
var require_serialize = __commonJS({
  "node_modules/concordance/lib/serialize.js"(exports2) {
    "use strict";
    var md5hex = require_md5_hex();
    var argumentsValue = require_arguments();
    var arrayBufferValue = require_arrayBuffer();
    var boxedValue = require_boxed();
    var dataViewValue = require_dataView();
    var dateValue = require_date();
    var errorValue = require_error2();
    var functionValue = require_function();
    var globalValue = require_global();
    var mapValue = require_map();
    var objectValue = require_object();
    var promiseValue = require_promise();
    var regexpValue = require_regexp();
    var setValue = require_set();
    var typedArrayValue = require_typedArray();
    var encoder = require_encoder();
    var itemDescriptor = require_item();
    var mapEntryDescriptor = require_mapEntry();
    var pointerDescriptor = require_pointer();
    var propertyDescriptor = require_property();
    var statsDescriptors = require_stats();
    var pluginRegistry = require_pluginRegistry();
    var bigIntValue = require_bigInt();
    var booleanValue = require_boolean();
    var nullValue = require_null();
    var numberValue = require_number();
    var stringValue = require_string2();
    var symbolValue = require_symbol();
    var undefinedValue = require_undefined();
    var recursorUtils = require_recursorUtils();
    var VERSION = 3;
    var mappings = [
      [1, bigIntValue.tag, bigIntValue.deserialize],
      [2, booleanValue.tag, booleanValue.deserialize],
      [3, nullValue.tag, nullValue.deserialize],
      [4, numberValue.tag, numberValue.deserialize],
      [5, stringValue.tag, stringValue.deserialize],
      [6, symbolValue.tag, symbolValue.deserialize],
      [7, undefinedValue.tag, undefinedValue.deserialize],
      [8, objectValue.tag, objectValue.deserialize],
      [9, statsDescriptors.iterableTag, statsDescriptors.deserializeIterableStats],
      [10, statsDescriptors.listTag, statsDescriptors.deserializeListStats],
      [11, itemDescriptor.complexTag, itemDescriptor.deserializeComplex],
      [12, itemDescriptor.primitiveTag, itemDescriptor.deserializePrimitive],
      [13, statsDescriptors.propertyTag, statsDescriptors.deserializePropertyStats],
      [14, propertyDescriptor.complexTag, propertyDescriptor.deserializeComplex],
      [15, propertyDescriptor.primitiveTag, propertyDescriptor.deserializePrimitive],
      [16, pointerDescriptor.tag, pointerDescriptor.deserialize],
      [17, mapValue.tag, mapValue.deserialize],
      [18, mapEntryDescriptor.tag, mapEntryDescriptor.deserialize],
      [19, argumentsValue.tag, argumentsValue.deserialize],
      [20, arrayBufferValue.tag, arrayBufferValue.deserialize],
      [21, boxedValue.tag, boxedValue.deserialize],
      [22, dataViewValue.tag, dataViewValue.deserialize],
      [23, dateValue.tag, dateValue.deserialize],
      [24, errorValue.tag, errorValue.deserialize],
      [25, functionValue.tag, functionValue.deserialize],
      [26, globalValue.tag, globalValue.deserialize],
      [27, promiseValue.tag, promiseValue.deserialize],
      [28, regexpValue.tag, regexpValue.deserialize],
      [29, setValue.tag, setValue.deserialize],
      [30, typedArrayValue.tag, typedArrayValue.deserialize],
      [31, typedArrayValue.bytesTag, typedArrayValue.deserializeBytes]
    ];
    var tag2id = new Map(mappings.map((mapping) => [mapping[1], mapping[0]]));
    var id2deserialize = new Map(mappings.map((mapping) => [mapping[0], mapping[2]]));
    var DescriptorSerializationError = class extends Error {
      constructor(descriptor) {
        super("Could not serialize descriptor");
        this.name = "DescriptorSerializationError";
        this.descriptor = descriptor;
      }
    };
    var MissingPluginError = class extends Error {
      constructor(pluginName) {
        super(`Could not deserialize buffer: missing plugin ${JSON.stringify(pluginName)}`);
        this.name = "MissingPluginError";
        this.pluginName = pluginName;
      }
    };
    var PointerLookupError = class extends Error {
      constructor(index) {
        super(`Could not deserialize buffer: pointer ${index} could not be resolved`);
        this.name = "PointerLookupError";
        this.index = index;
      }
    };
    var UnsupportedPluginError = class extends Error {
      constructor(pluginName, serializerVersion) {
        super(`Could not deserialize buffer: plugin ${JSON.stringify(pluginName)} expects a different serialization`);
        this.name = "UnsupportedPluginError";
        this.pluginName = pluginName;
        this.serializerVersion = serializerVersion;
      }
    };
    var UnsupportedVersion = class extends Error {
      // eslint-disable-line unicorn/custom-error-definition
      constructor(serializerVersion) {
        super("Could not deserialize buffer: a different serialization was expected");
        this.name = "UnsupportedVersion";
        this.serializerVersion = serializerVersion;
      }
    };
    function shallowSerializeDescriptor(descriptor, resolvePluginRef) {
      if (!descriptor.serialize) return void 0;
      return serializeState(descriptor.serialize(), resolvePluginRef);
    }
    function serializeState(state, resolvePluginRef) {
      if (Array.isArray(state)) return state.map((x) => serializeState(x));
      if (state && state.tag) {
        let id, pluginIndex;
        if (tag2id.has(state.tag)) {
          id = tag2id.get(state.tag);
          pluginIndex = 0;
        } else {
          const ref = resolvePluginRef(state.tag);
          if (ref) {
            id = ref.id;
            pluginIndex = ref.pluginIndex;
          }
        }
        if (id !== void 0) {
          const serialized = [pluginIndex, id, shallowSerializeDescriptor(state, resolvePluginRef)];
          serialized[encoder.descriptorSymbol] = true;
          return serialized;
        }
      }
      return state;
    }
    function serialize(descriptor) {
      const usedPlugins = /* @__PURE__ */ new Map();
      const resolvePluginRef = (tag) => {
        const ref = pluginRegistry.resolveDescriptorRef(tag);
        if (!ref) return null;
        if (!usedPlugins.has(ref.name)) {
          const index = usedPlugins.size + 1;
          usedPlugins.set(ref.name, Object.assign({ index }, ref.serialization));
        }
        return {
          id: ref.id,
          pluginIndex: usedPlugins.get(ref.name).index
        };
      };
      const seen = /* @__PURE__ */ new Set();
      const stack = [];
      let topIndex = -1;
      let rootRecord;
      do {
        if (descriptor.isComplex === true) {
          if (seen.has(descriptor.pointer)) {
            descriptor = pointerDescriptor.describe(descriptor.pointer);
          } else {
            seen.add(descriptor.pointer);
          }
        }
        let id;
        let pluginIndex = 0;
        if (tag2id.has(descriptor.tag)) {
          id = tag2id.get(descriptor.tag);
        } else {
          const ref = resolvePluginRef(descriptor.tag);
          if (!ref) throw new DescriptorSerializationError(descriptor);
          id = ref.id;
          pluginIndex = ref.pluginIndex;
        }
        const record = {
          id,
          pluginIndex,
          children: [],
          state: shallowSerializeDescriptor(descriptor, resolvePluginRef)
        };
        if (!rootRecord) {
          rootRecord = record;
        } else {
          stack[topIndex].children.push(record);
        }
        if (descriptor.createRecursor) {
          stack.push({ recursor: descriptor.createRecursor(), children: record.children });
          topIndex++;
        }
        while (topIndex >= 0) {
          descriptor = stack[topIndex].recursor();
          if (descriptor === null) {
            stack.pop();
            topIndex--;
          } else {
            break;
          }
        }
      } while (topIndex >= 0);
      return encoder.encode(VERSION, rootRecord, usedPlugins);
    }
    exports2.serialize = serialize;
    function deserializeState(state, getDescriptorDeserializer) {
      if (state && state[encoder.descriptorSymbol] === true) {
        return shallowDeserializeDescriptor(state, getDescriptorDeserializer);
      }
      return Array.isArray(state) ? state.map((item) => deserializeState(item, getDescriptorDeserializer)) : state;
    }
    function shallowDeserializeDescriptor(entry, getDescriptorDeserializer) {
      const deserializeDescriptor = getDescriptorDeserializer(entry[0], entry[1]);
      return deserializeDescriptor(entry[2]);
    }
    function deserializeRecord(record, getDescriptorDeserializer, buffer) {
      const deserializeDescriptor = getDescriptorDeserializer(record.pluginIndex, record.id);
      const state = deserializeState(record.state, getDescriptorDeserializer);
      if (record.pointerAddresses.length === 0) {
        return deserializeDescriptor(state);
      }
      const endIndex = record.pointerAddresses.length;
      let index = 0;
      const recursor = () => {
        if (index === endIndex) return null;
        const recursorRecord = encoder.decodeRecord(buffer, record.pointerAddresses[index++]);
        return deserializeRecord(recursorRecord, getDescriptorDeserializer, buffer);
      };
      return deserializeDescriptor(state, recursor);
    }
    function buildPluginMap(buffer, options) {
      const cache = options && options.deserializedPluginsCache;
      const cacheKey = md5hex(buffer);
      if (cache && cache.has(cacheKey)) return cache.get(cacheKey);
      const decodedPlugins = encoder.decodePlugins(buffer);
      if (decodedPlugins.size === 0) {
        const pluginMap2 = /* @__PURE__ */ new Map();
        if (cache) cache.set(cacheKey, pluginMap2);
        return pluginMap2;
      }
      const deserializerLookup = /* @__PURE__ */ new Map();
      if (Array.isArray(options && options.plugins)) {
        for (const deserializer of pluginRegistry.getDeserializers(options.plugins)) {
          deserializerLookup.set(deserializer.name, deserializer);
        }
      }
      const pluginMap = /* @__PURE__ */ new Map();
      for (const index of decodedPlugins.keys()) {
        const used = decodedPlugins.get(index);
        const pluginName = used.name;
        const serializerVersion = used.serializerVersion;
        if (!deserializerLookup.has(pluginName)) {
          throw new MissingPluginError(pluginName);
        }
        if (serializerVersion !== deserializerLookup.get(pluginName).serializerVersion) {
          throw new UnsupportedPluginError(pluginName, serializerVersion);
        }
        pluginMap.set(index, deserializerLookup.get(pluginName).id2deserialize);
      }
      if (cache) cache.set(cacheKey, pluginMap);
      return pluginMap;
    }
    function deserialize(buffer, options) {
      const version = encoder.extractVersion(buffer);
      if (version !== VERSION) throw new UnsupportedVersion(version);
      const decoded = encoder.decode(buffer);
      const pluginMap = buildPluginMap(decoded.pluginBuffer, options);
      const descriptorsByPointerIndex = /* @__PURE__ */ new Map();
      const mapPointerDescriptor = (descriptor) => {
        if (descriptor.isPointer === true) {
          if (descriptorsByPointerIndex.has(descriptor.index)) {
            return descriptorsByPointerIndex.get(descriptor.index);
          }
          if (typeof rootDescriptor.createRecursor === "function") {
            recursorUtils.consumeDeep(rootDescriptor.createRecursor());
            if (descriptorsByPointerIndex.has(descriptor.index)) {
              return descriptorsByPointerIndex.get(descriptor.index);
            }
          }
          throw new PointerLookupError(descriptor.index);
        }
        if (descriptor.isComplex === true) {
          descriptorsByPointerIndex.set(descriptor.pointer, descriptor);
        }
        return descriptor;
      };
      const getDescriptorDeserializer = (pluginIndex, id) => {
        return (state, recursor) => {
          const deserializeDescriptor = pluginIndex === 0 ? id2deserialize.get(id) : pluginMap.get(pluginIndex).get(id);
          return mapPointerDescriptor(deserializeDescriptor(state, recursor));
        };
      };
      const rootDescriptor = deserializeRecord(decoded.rootRecord, getDescriptorDeserializer, buffer);
      return rootDescriptor;
    }
    exports2.deserialize = deserialize;
  }
});

// node_modules/concordance/index.js
var require_concordance = __commonJS({
  "node_modules/concordance/index.js"(exports2) {
    "use strict";
    var compare = require_compare2();
    var describe = require_describe();
    var diff = require_diff3();
    var format = require_format();
    var serialize = require_serialize();
    exports2.compare = compare.compare;
    exports2.compareDescriptors = compare.compareDescriptors;
    exports2.describe = describe;
    exports2.diff = diff.diff;
    exports2.diffDescriptors = diff.diffDescriptors;
    exports2.format = format.format;
    exports2.formatDescriptor = format.formatDescriptor;
    exports2.serialize = serialize.serialize;
    exports2.deserialize = serialize.deserialize;
  }
});

// node_modules/indent-string/index.js
var require_indent_string = __commonJS({
  "node_modules/indent-string/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (string, count = 1, options) => {
      options = {
        indent: " ",
        includeEmptyLines: false,
        ...options
      };
      if (typeof string !== "string") {
        throw new TypeError(
          `Expected \`input\` to be a \`string\`, got \`${typeof string}\``
        );
      }
      if (typeof count !== "number") {
        throw new TypeError(
          `Expected \`count\` to be a \`number\`, got \`${typeof count}\``
        );
      }
      if (typeof options.indent !== "string") {
        throw new TypeError(
          `Expected \`options.indent\` to be a \`string\`, got \`${typeof options.indent}\``
        );
      }
      if (count === 0) {
        return string;
      }
      const regex = options.includeEmptyLines ? /^/gm : /^(?!\s*$)/gm;
      return string.replace(regex, options.indent.repeat(count));
    };
  }
});

// node_modules/convert-source-map/index.js
var require_convert_source_map = __commonJS({
  "node_modules/convert-source-map/index.js"(exports2) {
    "use strict";
    var fs = require("fs");
    var path = require("path");
    Object.defineProperty(exports2, "commentRegex", {
      get: function getCommentRegex() {
        return /^\s*\/(?:\/|\*)[@#]\s+sourceMappingURL=data:(?:application|text)\/json;(?:charset[:=]\S+?;)?base64,(?:.*)$/mg;
      }
    });
    Object.defineProperty(exports2, "mapFileCommentRegex", {
      get: function getMapFileCommentRegex() {
        return /(?:\/\/[@#][ \t]+sourceMappingURL=([^\s'"`]+?)[ \t]*$)|(?:\/\*[@#][ \t]+sourceMappingURL=([^\*]+?)[ \t]*(?:\*\/){1}[ \t]*$)/mg;
      }
    });
    var decodeBase64;
    if (typeof Buffer !== "undefined") {
      if (typeof Buffer.from === "function") {
        decodeBase64 = decodeBase64WithBufferFrom;
      } else {
        decodeBase64 = decodeBase64WithNewBuffer;
      }
    } else {
      decodeBase64 = decodeBase64WithAtob;
    }
    function decodeBase64WithBufferFrom(base64) {
      return Buffer.from(base64, "base64").toString();
    }
    function decodeBase64WithNewBuffer(base64) {
      if (typeof value === "number") {
        throw new TypeError("The value to decode must not be of type number.");
      }
      return new Buffer(base64, "base64").toString();
    }
    function decodeBase64WithAtob(base64) {
      return decodeURIComponent(escape(atob(base64)));
    }
    function stripComment(sm) {
      return sm.split(",").pop();
    }
    function readFromFileMap(sm, dir) {
      var r = exports2.mapFileCommentRegex.exec(sm);
      var filename = r[1] || r[2];
      var filepath = path.resolve(dir, filename);
      try {
        return fs.readFileSync(filepath, "utf8");
      } catch (e) {
        throw new Error("An error occurred while trying to read the map file at " + filepath + "\n" + e);
      }
    }
    function Converter(sm, opts) {
      opts = opts || {};
      if (opts.isFileComment) sm = readFromFileMap(sm, opts.commentFileDir);
      if (opts.hasComment) sm = stripComment(sm);
      if (opts.isEncoded) sm = decodeBase64(sm);
      if (opts.isJSON || opts.isEncoded) sm = JSON.parse(sm);
      this.sourcemap = sm;
    }
    Converter.prototype.toJSON = function(space) {
      return JSON.stringify(this.sourcemap, null, space);
    };
    if (typeof Buffer !== "undefined") {
      if (typeof Buffer.from === "function") {
        Converter.prototype.toBase64 = encodeBase64WithBufferFrom;
      } else {
        Converter.prototype.toBase64 = encodeBase64WithNewBuffer;
      }
    } else {
      Converter.prototype.toBase64 = encodeBase64WithBtoa;
    }
    function encodeBase64WithBufferFrom() {
      var json = this.toJSON();
      return Buffer.from(json, "utf8").toString("base64");
    }
    function encodeBase64WithNewBuffer() {
      var json = this.toJSON();
      if (typeof json === "number") {
        throw new TypeError("The json to encode must not be of type number.");
      }
      return new Buffer(json, "utf8").toString("base64");
    }
    function encodeBase64WithBtoa() {
      var json = this.toJSON();
      return btoa(unescape(encodeURIComponent(json)));
    }
    Converter.prototype.toComment = function(options) {
      var base64 = this.toBase64();
      var data = "sourceMappingURL=data:application/json;charset=utf-8;base64," + base64;
      return options && options.multiline ? "/*# " + data + " */" : "//# " + data;
    };
    Converter.prototype.toObject = function() {
      return JSON.parse(this.toJSON());
    };
    Converter.prototype.addProperty = function(key, value2) {
      if (this.sourcemap.hasOwnProperty(key)) throw new Error('property "' + key + '" already exists on the sourcemap, use set property instead');
      return this.setProperty(key, value2);
    };
    Converter.prototype.setProperty = function(key, value2) {
      this.sourcemap[key] = value2;
      return this;
    };
    Converter.prototype.getProperty = function(key) {
      return this.sourcemap[key];
    };
    exports2.fromObject = function(obj) {
      return new Converter(obj);
    };
    exports2.fromJSON = function(json) {
      return new Converter(json, { isJSON: true });
    };
    exports2.fromBase64 = function(base64) {
      return new Converter(base64, { isEncoded: true });
    };
    exports2.fromComment = function(comment) {
      comment = comment.replace(/^\/\*/g, "//").replace(/\*\/$/g, "");
      return new Converter(comment, { isEncoded: true, hasComment: true });
    };
    exports2.fromMapFileComment = function(comment, dir) {
      return new Converter(comment, { commentFileDir: dir, isFileComment: true, isJSON: true });
    };
    exports2.fromSource = function(content) {
      var m = content.match(exports2.commentRegex);
      return m ? exports2.fromComment(m.pop()) : null;
    };
    exports2.fromMapFileSource = function(content, dir) {
      var m = content.match(exports2.mapFileCommentRegex);
      return m ? exports2.fromMapFileComment(m.pop(), dir) : null;
    };
    exports2.removeComments = function(src) {
      return src.replace(exports2.commentRegex, "");
    };
    exports2.removeMapFileComments = function(src) {
      return src.replace(exports2.mapFileCommentRegex, "");
    };
    exports2.generateMapFileComment = function(file, options) {
      var data = "sourceMappingURL=" + file;
      return options && options.multiline ? "/*# " + data + " */" : "//# " + data;
    };
  }
});

// node_modules/imurmurhash/imurmurhash.js
var require_imurmurhash = __commonJS({
  "node_modules/imurmurhash/imurmurhash.js"(exports2, module2) {
    "use strict";
    (function() {
      var cache;
      function MurmurHash3(key, seed) {
        var m = this instanceof MurmurHash3 ? this : cache;
        m.reset(seed);
        if (typeof key === "string" && key.length > 0) {
          m.hash(key);
        }
        if (m !== this) {
          return m;
        }
      }
      ;
      MurmurHash3.prototype.hash = function(key) {
        var h1, k1, i, top, len;
        len = key.length;
        this.len += len;
        k1 = this.k1;
        i = 0;
        switch (this.rem) {
          case 0:
            k1 ^= len > i ? key.charCodeAt(i++) & 65535 : 0;
          case 1:
            k1 ^= len > i ? (key.charCodeAt(i++) & 65535) << 8 : 0;
          case 2:
            k1 ^= len > i ? (key.charCodeAt(i++) & 65535) << 16 : 0;
          case 3:
            k1 ^= len > i ? (key.charCodeAt(i) & 255) << 24 : 0;
            k1 ^= len > i ? (key.charCodeAt(i++) & 65280) >> 8 : 0;
        }
        this.rem = len + this.rem & 3;
        len -= this.rem;
        if (len > 0) {
          h1 = this.h1;
          while (1) {
            k1 = k1 * 11601 + (k1 & 65535) * 3432906752 & 4294967295;
            k1 = k1 << 15 | k1 >>> 17;
            k1 = k1 * 13715 + (k1 & 65535) * 461832192 & 4294967295;
            h1 ^= k1;
            h1 = h1 << 13 | h1 >>> 19;
            h1 = h1 * 5 + 3864292196 & 4294967295;
            if (i >= len) {
              break;
            }
            k1 = key.charCodeAt(i++) & 65535 ^ (key.charCodeAt(i++) & 65535) << 8 ^ (key.charCodeAt(i++) & 65535) << 16;
            top = key.charCodeAt(i++);
            k1 ^= (top & 255) << 24 ^ (top & 65280) >> 8;
          }
          k1 = 0;
          switch (this.rem) {
            case 3:
              k1 ^= (key.charCodeAt(i + 2) & 65535) << 16;
            case 2:
              k1 ^= (key.charCodeAt(i + 1) & 65535) << 8;
            case 1:
              k1 ^= key.charCodeAt(i) & 65535;
          }
          this.h1 = h1;
        }
        this.k1 = k1;
        return this;
      };
      MurmurHash3.prototype.result = function() {
        var k1, h1;
        k1 = this.k1;
        h1 = this.h1;
        if (k1 > 0) {
          k1 = k1 * 11601 + (k1 & 65535) * 3432906752 & 4294967295;
          k1 = k1 << 15 | k1 >>> 17;
          k1 = k1 * 13715 + (k1 & 65535) * 461832192 & 4294967295;
          h1 ^= k1;
        }
        h1 ^= this.len;
        h1 ^= h1 >>> 16;
        h1 = h1 * 51819 + (h1 & 65535) * 2246770688 & 4294967295;
        h1 ^= h1 >>> 13;
        h1 = h1 * 44597 + (h1 & 65535) * 3266445312 & 4294967295;
        h1 ^= h1 >>> 16;
        return h1 >>> 0;
      };
      MurmurHash3.prototype.reset = function(seed) {
        this.h1 = typeof seed === "number" ? seed : 0;
        this.rem = this.k1 = this.len = 0;
        return this;
      };
      cache = new MurmurHash3();
      if (typeof module2 != "undefined") {
        module2.exports = MurmurHash3;
      } else {
        this.MurmurHash3 = MurmurHash3;
      }
    })();
  }
});

// node_modules/signal-exit/signals.js
var require_signals = __commonJS({
  "node_modules/signal-exit/signals.js"(exports2, module2) {
    "use strict";
    module2.exports = [
      "SIGABRT",
      "SIGALRM",
      "SIGHUP",
      "SIGINT",
      "SIGTERM"
    ];
    if (process.platform !== "win32") {
      module2.exports.push(
        "SIGVTALRM",
        "SIGXCPU",
        "SIGXFSZ",
        "SIGUSR2",
        "SIGTRAP",
        "SIGSYS",
        "SIGQUIT",
        "SIGIOT"
        // should detect profiler and enable/disable accordingly.
        // see #21
        // 'SIGPROF'
      );
    }
    if (process.platform === "linux") {
      module2.exports.push(
        "SIGIO",
        "SIGPOLL",
        "SIGPWR",
        "SIGSTKFLT",
        "SIGUNUSED"
      );
    }
  }
});

// node_modules/signal-exit/index.js
var require_signal_exit = __commonJS({
  "node_modules/signal-exit/index.js"(exports2, module2) {
    "use strict";
    var process2 = global.process;
    var processOk = function(process3) {
      return process3 && typeof process3 === "object" && typeof process3.removeListener === "function" && typeof process3.emit === "function" && typeof process3.reallyExit === "function" && typeof process3.listeners === "function" && typeof process3.kill === "function" && typeof process3.pid === "number" && typeof process3.on === "function";
    };
    if (!processOk(process2)) {
      module2.exports = function() {
        return function() {
        };
      };
    } else {
      assert = require("assert");
      signals = require_signals();
      isWin = /^win/i.test(process2.platform);
      EE = require("events");
      if (typeof EE !== "function") {
        EE = EE.EventEmitter;
      }
      if (process2.__signal_exit_emitter__) {
        emitter = process2.__signal_exit_emitter__;
      } else {
        emitter = process2.__signal_exit_emitter__ = new EE();
        emitter.count = 0;
        emitter.emitted = {};
      }
      if (!emitter.infinite) {
        emitter.setMaxListeners(Infinity);
        emitter.infinite = true;
      }
      module2.exports = function(cb, opts) {
        if (!processOk(global.process)) {
          return function() {
          };
        }
        assert.equal(typeof cb, "function", "a callback must be provided for exit handler");
        if (loaded === false) {
          load();
        }
        var ev = "exit";
        if (opts && opts.alwaysLast) {
          ev = "afterexit";
        }
        var remove = function() {
          emitter.removeListener(ev, cb);
          if (emitter.listeners("exit").length === 0 && emitter.listeners("afterexit").length === 0) {
            unload();
          }
        };
        emitter.on(ev, cb);
        return remove;
      };
      unload = function unload2() {
        if (!loaded || !processOk(global.process)) {
          return;
        }
        loaded = false;
        signals.forEach(function(sig) {
          try {
            process2.removeListener(sig, sigListeners[sig]);
          } catch (er) {
          }
        });
        process2.emit = originalProcessEmit;
        process2.reallyExit = originalProcessReallyExit;
        emitter.count -= 1;
      };
      module2.exports.unload = unload;
      emit = function emit2(event, code, signal) {
        if (emitter.emitted[event]) {
          return;
        }
        emitter.emitted[event] = true;
        emitter.emit(event, code, signal);
      };
      sigListeners = {};
      signals.forEach(function(sig) {
        sigListeners[sig] = function listener() {
          if (!processOk(global.process)) {
            return;
          }
          var listeners = process2.listeners(sig);
          if (listeners.length === emitter.count) {
            unload();
            emit("exit", null, sig);
            emit("afterexit", null, sig);
            if (isWin && sig === "SIGHUP") {
              sig = "SIGINT";
            }
            process2.kill(process2.pid, sig);
          }
        };
      });
      module2.exports.signals = function() {
        return signals;
      };
      loaded = false;
      load = function load2() {
        if (loaded || !processOk(global.process)) {
          return;
        }
        loaded = true;
        emitter.count += 1;
        signals = signals.filter(function(sig) {
          try {
            process2.on(sig, sigListeners[sig]);
            return true;
          } catch (er) {
            return false;
          }
        });
        process2.emit = processEmit;
        process2.reallyExit = processReallyExit;
      };
      module2.exports.load = load;
      originalProcessReallyExit = process2.reallyExit;
      processReallyExit = function processReallyExit2(code) {
        if (!processOk(global.process)) {
          return;
        }
        process2.exitCode = code || /* istanbul ignore next */
        0;
        emit("exit", process2.exitCode, null);
        emit("afterexit", process2.exitCode, null);
        originalProcessReallyExit.call(process2, process2.exitCode);
      };
      originalProcessEmit = process2.emit;
      processEmit = function processEmit2(ev, arg) {
        if (ev === "exit" && processOk(global.process)) {
          if (arg !== void 0) {
            process2.exitCode = arg;
          }
          var ret = originalProcessEmit.apply(this, arguments);
          emit("exit", process2.exitCode, null);
          emit("afterexit", process2.exitCode, null);
          return ret;
        } else {
          return originalProcessEmit.apply(this, arguments);
        }
      };
    }
    var assert;
    var signals;
    var isWin;
    var EE;
    var emitter;
    var unload;
    var emit;
    var sigListeners;
    var loaded;
    var load;
    var originalProcessReallyExit;
    var processReallyExit;
    var originalProcessEmit;
    var processEmit;
  }
});

// node_modules/is-typedarray/index.js
var require_is_typedarray = __commonJS({
  "node_modules/is-typedarray/index.js"(exports2, module2) {
    "use strict";
    module2.exports = isTypedArray;
    isTypedArray.strict = isStrictTypedArray;
    isTypedArray.loose = isLooseTypedArray;
    var toString = Object.prototype.toString;
    var names = {
      "[object Int8Array]": true,
      "[object Int16Array]": true,
      "[object Int32Array]": true,
      "[object Uint8Array]": true,
      "[object Uint8ClampedArray]": true,
      "[object Uint16Array]": true,
      "[object Uint32Array]": true,
      "[object Float32Array]": true,
      "[object Float64Array]": true
    };
    function isTypedArray(arr) {
      return isStrictTypedArray(arr) || isLooseTypedArray(arr);
    }
    function isStrictTypedArray(arr) {
      return arr instanceof Int8Array || arr instanceof Int16Array || arr instanceof Int32Array || arr instanceof Uint8Array || arr instanceof Uint8ClampedArray || arr instanceof Uint16Array || arr instanceof Uint32Array || arr instanceof Float32Array || arr instanceof Float64Array;
    }
    function isLooseTypedArray(arr) {
      return names[toString.call(arr)];
    }
  }
});

// node_modules/typedarray-to-buffer/index.js
var require_typedarray_to_buffer = __commonJS({
  "node_modules/typedarray-to-buffer/index.js"(exports2, module2) {
    "use strict";
    var isTypedArray = require_is_typedarray().strict;
    module2.exports = function typedarrayToBuffer(arr) {
      if (isTypedArray(arr)) {
        var buf = Buffer.from(arr.buffer);
        if (arr.byteLength !== arr.buffer.byteLength) {
          buf = buf.slice(arr.byteOffset, arr.byteOffset + arr.byteLength);
        }
        return buf;
      } else {
        return Buffer.from(arr);
      }
    };
  }
});

// node_modules/write-file-atomic/index.js
var require_write_file_atomic = __commonJS({
  "node_modules/write-file-atomic/index.js"(exports2, module2) {
    "use strict";
    module2.exports = writeFile;
    module2.exports.sync = writeFileSync;
    module2.exports._getTmpname = getTmpname;
    module2.exports._cleanupOnExit = cleanupOnExit;
    var fs = require("fs");
    var MurmurHash3 = require_imurmurhash();
    var onExit = require_signal_exit();
    var path = require("path");
    var isTypedArray = require_is_typedarray();
    var typedArrayToBuffer = require_typedarray_to_buffer();
    var { promisify } = require("util");
    var activeFiles = {};
    var threadId = function getId() {
      try {
        const workerThreads = require("worker_threads");
        return workerThreads.threadId;
      } catch (e) {
        return 0;
      }
    }();
    var invocations = 0;
    function getTmpname(filename) {
      return filename + "." + MurmurHash3(__filename).hash(String(process.pid)).hash(String(threadId)).hash(String(++invocations)).result();
    }
    function cleanupOnExit(tmpfile) {
      return () => {
        try {
          fs.unlinkSync(typeof tmpfile === "function" ? tmpfile() : tmpfile);
        } catch (_2) {
        }
      };
    }
    function serializeActiveFile(absoluteName) {
      return new Promise((resolve) => {
        if (!activeFiles[absoluteName]) activeFiles[absoluteName] = [];
        activeFiles[absoluteName].push(resolve);
        if (activeFiles[absoluteName].length === 1) resolve();
      });
    }
    function isChownErrOk(err) {
      if (err.code === "ENOSYS") {
        return true;
      }
      const nonroot = !process.getuid || process.getuid() !== 0;
      if (nonroot) {
        if (err.code === "EINVAL" || err.code === "EPERM") {
          return true;
        }
      }
      return false;
    }
    async function writeFileAsync(filename, data, options = {}) {
      if (typeof options === "string") {
        options = { encoding: options };
      }
      let fd;
      let tmpfile;
      const removeOnExitHandler = onExit(cleanupOnExit(() => tmpfile));
      const absoluteName = path.resolve(filename);
      try {
        await serializeActiveFile(absoluteName);
        const truename = await promisify(fs.realpath)(filename).catch(() => filename);
        tmpfile = getTmpname(truename);
        if (!options.mode || !options.chown) {
          const stats = await promisify(fs.stat)(truename).catch(() => {
          });
          if (stats) {
            if (options.mode == null) {
              options.mode = stats.mode;
            }
            if (options.chown == null && process.getuid) {
              options.chown = { uid: stats.uid, gid: stats.gid };
            }
          }
        }
        fd = await promisify(fs.open)(tmpfile, "w", options.mode);
        if (options.tmpfileCreated) {
          await options.tmpfileCreated(tmpfile);
        }
        if (isTypedArray(data)) {
          data = typedArrayToBuffer(data);
        }
        if (Buffer.isBuffer(data)) {
          await promisify(fs.write)(fd, data, 0, data.length, 0);
        } else if (data != null) {
          await promisify(fs.write)(fd, String(data), 0, String(options.encoding || "utf8"));
        }
        if (options.fsync !== false) {
          await promisify(fs.fsync)(fd);
        }
        await promisify(fs.close)(fd);
        fd = null;
        if (options.chown) {
          await promisify(fs.chown)(tmpfile, options.chown.uid, options.chown.gid).catch((err) => {
            if (!isChownErrOk(err)) {
              throw err;
            }
          });
        }
        if (options.mode) {
          await promisify(fs.chmod)(tmpfile, options.mode).catch((err) => {
            if (!isChownErrOk(err)) {
              throw err;
            }
          });
        }
        await promisify(fs.rename)(tmpfile, truename);
      } finally {
        if (fd) {
          await promisify(fs.close)(fd).catch(
            /* istanbul ignore next */
            () => {
            }
          );
        }
        removeOnExitHandler();
        await promisify(fs.unlink)(tmpfile).catch(() => {
        });
        activeFiles[absoluteName].shift();
        if (activeFiles[absoluteName].length > 0) {
          activeFiles[absoluteName][0]();
        } else delete activeFiles[absoluteName];
      }
    }
    function writeFile(filename, data, options, callback) {
      if (options instanceof Function) {
        callback = options;
        options = {};
      }
      const promise = writeFileAsync(filename, data, options);
      if (callback) {
        promise.then(callback, callback);
      }
      return promise;
    }
    function writeFileSync(filename, data, options) {
      if (typeof options === "string") options = { encoding: options };
      else if (!options) options = {};
      try {
        filename = fs.realpathSync(filename);
      } catch (ex) {
      }
      const tmpfile = getTmpname(filename);
      if (!options.mode || !options.chown) {
        try {
          const stats = fs.statSync(filename);
          options = Object.assign({}, options);
          if (!options.mode) {
            options.mode = stats.mode;
          }
          if (!options.chown && process.getuid) {
            options.chown = { uid: stats.uid, gid: stats.gid };
          }
        } catch (ex) {
        }
      }
      let fd;
      const cleanup = cleanupOnExit(tmpfile);
      const removeOnExitHandler = onExit(cleanup);
      let threw = true;
      try {
        fd = fs.openSync(tmpfile, "w", options.mode || 438);
        if (options.tmpfileCreated) {
          options.tmpfileCreated(tmpfile);
        }
        if (isTypedArray(data)) {
          data = typedArrayToBuffer(data);
        }
        if (Buffer.isBuffer(data)) {
          fs.writeSync(fd, data, 0, data.length, 0);
        } else if (data != null) {
          fs.writeSync(fd, String(data), 0, String(options.encoding || "utf8"));
        }
        if (options.fsync !== false) {
          fs.fsyncSync(fd);
        }
        fs.closeSync(fd);
        fd = null;
        if (options.chown) {
          try {
            fs.chownSync(tmpfile, options.chown.uid, options.chown.gid);
          } catch (err) {
            if (!isChownErrOk(err)) {
              throw err;
            }
          }
        }
        if (options.mode) {
          try {
            fs.chmodSync(tmpfile, options.mode);
          } catch (err) {
            if (!isChownErrOk(err)) {
              throw err;
            }
          }
        }
        fs.renameSync(tmpfile, filename);
        threw = false;
      } finally {
        if (fd) {
          try {
            fs.closeSync(fd);
          } catch (ex) {
          }
        }
        removeOnExitHandler();
        if (threw) {
          cleanup();
        }
      }
    }
  }
});

// node_modules/mimic-fn/index.js
var require_mimic_fn = __commonJS({
  "node_modules/mimic-fn/index.js"(exports2, module2) {
    "use strict";
    var copyProperty = (to, from, property, ignoreNonConfigurable) => {
      if (property === "length" || property === "prototype") {
        return;
      }
      if (property === "arguments" || property === "caller") {
        return;
      }
      const toDescriptor = Object.getOwnPropertyDescriptor(to, property);
      const fromDescriptor = Object.getOwnPropertyDescriptor(from, property);
      if (!canCopyProperty(toDescriptor, fromDescriptor) && ignoreNonConfigurable) {
        return;
      }
      Object.defineProperty(to, property, fromDescriptor);
    };
    var canCopyProperty = function(toDescriptor, fromDescriptor) {
      return toDescriptor === void 0 || toDescriptor.configurable || toDescriptor.writable === fromDescriptor.writable && toDescriptor.enumerable === fromDescriptor.enumerable && toDescriptor.configurable === fromDescriptor.configurable && (toDescriptor.writable || toDescriptor.value === fromDescriptor.value);
    };
    var changePrototype = (to, from) => {
      const fromPrototype = Object.getPrototypeOf(from);
      if (fromPrototype === Object.getPrototypeOf(to)) {
        return;
      }
      Object.setPrototypeOf(to, fromPrototype);
    };
    var wrappedToString = (withName, fromBody) => `/* Wrapped ${withName}*/
${fromBody}`;
    var toStringDescriptor = Object.getOwnPropertyDescriptor(Function.prototype, "toString");
    var toStringName = Object.getOwnPropertyDescriptor(Function.prototype.toString, "name");
    var changeToString = (to, from, name) => {
      const withName = name === "" ? "" : `with ${name.trim()}() `;
      const newToString = wrappedToString.bind(null, withName, from.toString());
      Object.defineProperty(newToString, "name", toStringName);
      Object.defineProperty(to, "toString", { ...toStringDescriptor, value: newToString });
    };
    var mimicFn = (to, from, { ignoreNonConfigurable = false } = {}) => {
      const { name } = to;
      for (const property of Reflect.ownKeys(from)) {
        copyProperty(to, from, property, ignoreNonConfigurable);
      }
      changePrototype(to, from);
      changeToString(to, from, name);
      return to;
    };
    module2.exports = mimicFn;
  }
});

// node_modules/p-defer/index.js
var require_p_defer = __commonJS({
  "node_modules/p-defer/index.js"(exports2, module2) {
    "use strict";
    module2.exports = () => {
      const ret = {};
      ret.promise = new Promise((resolve, reject) => {
        ret.resolve = resolve;
        ret.reject = reject;
      });
      return ret;
    };
  }
});

// node_modules/map-age-cleaner/dist/index.js
var require_dist = __commonJS({
  "node_modules/map-age-cleaner/dist/index.js"(exports2, module2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value2) {
          try {
            step(generator.next(value2));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value2) {
          try {
            step(generator["throw"](value2));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : new P(function(resolve2) {
            resolve2(result.value);
          }).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var p_defer_1 = __importDefault(require_p_defer());
    function mapAgeCleaner(map, property = "maxAge") {
      let processingKey;
      let processingTimer;
      let processingDeferred;
      const cleanup = () => __awaiter(this, void 0, void 0, function* () {
        if (processingKey !== void 0) {
          return;
        }
        const setupTimer = (item) => __awaiter(this, void 0, void 0, function* () {
          processingDeferred = p_defer_1.default();
          const delay = item[1][property] - Date.now();
          if (delay <= 0) {
            map.delete(item[0]);
            processingDeferred.resolve();
            return;
          }
          processingKey = item[0];
          processingTimer = setTimeout(() => {
            map.delete(item[0]);
            if (processingDeferred) {
              processingDeferred.resolve();
            }
          }, delay);
          if (typeof processingTimer.unref === "function") {
            processingTimer.unref();
          }
          return processingDeferred.promise;
        });
        try {
          for (const entry of map) {
            yield setupTimer(entry);
          }
        } catch (_a) {
        }
        processingKey = void 0;
      });
      const reset = () => {
        processingKey = void 0;
        if (processingTimer !== void 0) {
          clearTimeout(processingTimer);
          processingTimer = void 0;
        }
        if (processingDeferred !== void 0) {
          processingDeferred.reject(void 0);
          processingDeferred = void 0;
        }
      };
      const originalSet = map.set.bind(map);
      map.set = (key, value2) => {
        if (map.has(key)) {
          map.delete(key);
        }
        const result = originalSet(key, value2);
        if (processingKey && processingKey === key) {
          reset();
        }
        cleanup();
        return result;
      };
      cleanup();
      return map;
    }
    exports2.default = mapAgeCleaner;
    module2.exports = mapAgeCleaner;
    module2.exports.default = mapAgeCleaner;
  }
});

// node_modules/mem/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/mem/dist/index.js"(exports2, module2) {
    "use strict";
    var mimicFn = require_mimic_fn();
    var mapAgeCleaner = require_dist();
    var decoratorInstanceMap = /* @__PURE__ */ new WeakMap();
    var cacheStore = /* @__PURE__ */ new WeakMap();
    var mem = (fn, { cacheKey, cache = /* @__PURE__ */ new Map(), maxAge } = {}) => {
      if (typeof maxAge === "number") {
        mapAgeCleaner(cache);
      }
      const memoized = function(...arguments_) {
        const key = cacheKey ? cacheKey(arguments_) : arguments_[0];
        const cacheItem = cache.get(key);
        if (cacheItem) {
          return cacheItem.data;
        }
        const result = fn.apply(this, arguments_);
        cache.set(key, {
          data: result,
          maxAge: maxAge ? Date.now() + maxAge : Number.POSITIVE_INFINITY
        });
        return result;
      };
      mimicFn(memoized, fn, {
        ignoreNonConfigurable: true
      });
      cacheStore.set(memoized, cache);
      return memoized;
    };
    mem.decorator = (options = {}) => (target, propertyKey, descriptor) => {
      const input = target[propertyKey];
      if (typeof input !== "function") {
        throw new TypeError("The decorated value must be a function");
      }
      delete descriptor.value;
      delete descriptor.writable;
      descriptor.get = function() {
        if (!decoratorInstanceMap.has(this)) {
          const value2 = mem(input, options);
          decoratorInstanceMap.set(this, value2);
          return value2;
        }
        return decoratorInstanceMap.get(this);
      };
    };
    mem.clear = (fn) => {
      const cache = cacheStore.get(fn);
      if (!cache) {
        throw new TypeError("Can't clear a function that was not memoized!");
      }
      if (typeof cache.clear !== "function") {
        throw new TypeError("The cache Map can't be cleared!");
      }
      cache.clear();
    };
    module2.exports = mem;
  }
});

// node_modules/ava/node_modules/ansi-styles/index.js
var require_ansi_styles2 = __commonJS({
  "node_modules/ava/node_modules/ansi-styles/index.js"(exports2, module2) {
    "use strict";
    var ANSI_BACKGROUND_OFFSET = 10;
    var wrapAnsi256 = (offset = 0) => (code) => `\x1B[${38 + offset};5;${code}m`;
    var wrapAnsi16m = (offset = 0) => (red, green, blue) => `\x1B[${38 + offset};2;${red};${green};${blue}m`;
    function assembleStyles() {
      const codes = /* @__PURE__ */ new Map();
      const styles = {
        modifier: {
          reset: [0, 0],
          // 21 isn't widely supported and 22 does the same thing
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          overline: [53, 55],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          // Bright color
          blackBright: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          // Bright color
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      styles.color.gray = styles.color.blackBright;
      styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
      styles.color.grey = styles.color.blackBright;
      styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
      for (const [groupName, group] of Object.entries(styles)) {
        for (const [styleName, style] of Object.entries(group)) {
          styles[styleName] = {
            open: `\x1B[${style[0]}m`,
            close: `\x1B[${style[1]}m`
          };
          group[styleName] = styles[styleName];
          codes.set(style[0], style[1]);
        }
        Object.defineProperty(styles, groupName, {
          value: group,
          enumerable: false
        });
      }
      Object.defineProperty(styles, "codes", {
        value: codes,
        enumerable: false
      });
      styles.color.close = "\x1B[39m";
      styles.bgColor.close = "\x1B[49m";
      styles.color.ansi256 = wrapAnsi256();
      styles.color.ansi16m = wrapAnsi16m();
      styles.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
      styles.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);
      Object.defineProperties(styles, {
        rgbToAnsi256: {
          value: (red, green, blue) => {
            if (red === green && green === blue) {
              if (red < 8) {
                return 16;
              }
              if (red > 248) {
                return 231;
              }
              return Math.round((red - 8) / 247 * 24) + 232;
            }
            return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
          },
          enumerable: false
        },
        hexToRgb: {
          value: (hex) => {
            const matches = /(?<colorString>[a-f\d]{6}|[a-f\d]{3})/i.exec(hex.toString(16));
            if (!matches) {
              return [0, 0, 0];
            }
            let { colorString } = matches.groups;
            if (colorString.length === 3) {
              colorString = colorString.split("").map((character) => character + character).join("");
            }
            const integer = Number.parseInt(colorString, 16);
            return [
              integer >> 16 & 255,
              integer >> 8 & 255,
              integer & 255
            ];
          },
          enumerable: false
        },
        hexToAnsi256: {
          value: (hex) => styles.rgbToAnsi256(...styles.hexToRgb(hex)),
          enumerable: false
        }
      });
      return styles;
    }
    Object.defineProperty(module2, "exports", {
      enumerable: true,
      get: assembleStyles
    });
  }
});

// node_modules/ansi-regex/index.js
var require_ansi_regex = __commonJS({
  "node_modules/ansi-regex/index.js"(exports2, module2) {
    "use strict";
    module2.exports = ({ onlyFirst = false } = {}) => {
      const pattern = [
        "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
        "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
      ].join("|");
      return new RegExp(pattern, onlyFirst ? void 0 : "g");
    };
  }
});

// node_modules/strip-ansi/index.js
var require_strip_ansi = __commonJS({
  "node_modules/strip-ansi/index.js"(exports2, module2) {
    "use strict";
    var ansiRegex = require_ansi_regex();
    module2.exports = (string) => typeof string === "string" ? string.replace(ansiRegex(), "") : string;
  }
});

// node_modules/@concordance/react/package.json
var require_package3 = __commonJS({
  "node_modules/@concordance/react/package.json"(exports2, module2) {
    module2.exports = {
      name: "@concordance/react",
      version: "2.0.0",
      description: "Compare, format, diff and serialize React trees with Concordance",
      main: "index.js",
      files: [
        "lib",
        "index.js"
      ],
      engines: {
        node: ">=6.12.3 <7 || >=8.9.4 <9 || >=10.0.0"
      },
      scripts: {
        "build:fixtures": "babel --presets=module:@babel/preset-react,module:ava/stage-4 --out-dir=test/fixtures/react --extensions=.jsx test/fixtures/react",
        lint: "as-i-preach",
        pretest: "npm run -s build:fixtures",
        test: "npm run -s lint && nyc ava"
      },
      repository: {
        type: "git",
        url: "git+https://github.com/concordancejs/react.git"
      },
      author: "Mark Wubben (https://novemberborn.net/)",
      license: "ISC",
      bugs: {
        url: "https://github.com/concordancejs/react/issues"
      },
      homepage: "https://github.com/concordancejs/react#readme",
      keywords: [
        "concordance-plugin",
        "concordance",
        "react"
      ],
      dependencies: {
        arrify: "^1.0.1"
      },
      devDependencies: {
        "@babel/cli": "^7.1.0",
        "@babel/core": "^7.1.0",
        "@babel/preset-react": "^7.0.0",
        "@novemberborn/as-i-preach": "^10.1.0",
        ava: "1.0.0-beta.8",
        codecov: "^3.1.0",
        concordance: "^4.0.0",
        nyc: "^13.0.1",
        react: "^16.5.2",
        "react-test-renderer": "^16.5.2"
      },
      "as-i-preach": {
        allowDevDependencies: [
          "test/**/*.js",
          "test/**/*.jsx"
        ],
        ignore: [
          "test/fixtures/react/*.js"
        ]
      },
      ava: {
        babel: {
          testOptions: {
            presets: [
              "module:@babel/preset-react"
            ]
          }
        }
      },
      nyc: {
        reporter: [
          "html",
          "lcov",
          "text"
        ]
      },
      "standard-engine": "@novemberborn/as-i-preach"
    };
  }
});

// node_modules/arrify/index.js
var require_arrify = __commonJS({
  "node_modules/arrify/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function(val) {
      if (val === null || val === void 0) {
        return [];
      }
      return Array.isArray(val) ? val : [val];
    };
  }
});

// node_modules/@concordance/react/lib/diffShallow.js
var require_diffShallow = __commonJS({
  "node_modules/@concordance/react/lib/diffShallow.js"(exports2, module2) {
    "use strict";
    function diffShallow(api, actual, expected, theme, indent) {
      const childBuffer = api.lineBuilder.buffer();
      const propertyBuffer = api.lineBuilder.buffer();
      return {
        append(formatted, origin) {
          if (origin.isItem === true) {
            childBuffer.append(formatted);
          } else {
            propertyBuffer.append(formatted);
          }
        },
        finalize: () => {
          const namesAreEqual = actual.compareNames(expected);
          const actualName = actual.formatName(theme);
          const expectedName = expected.formatName(theme);
          const openTag = theme.react.openTag;
          const innerIndentation = indent.increase();
          const allChildren = childBuffer.withFirstPrefixed(innerIndentation);
          const children = allChildren.decompose();
          const allProperties = propertyBuffer.withFirstPrefixed(innerIndentation);
          const properties = allProperties.decompose();
          if (properties.remaining.isEmpty && (!actual.hasChildren || !expected.hasChildren)) {
            properties.last = properties.first;
            properties.first = { actual: api.lineBuilder.buffer(), expected: api.lineBuilder.buffer() };
          }
          const result = api.lineBuilder.buffer();
          if (actual.hasProperties && expected.hasProperties) {
            if (namesAreEqual) {
              result.append(api.lineBuilder.first(openTag.start + actualName)).append(properties.first.actual.stripFlags()).append(properties.first.expected.stripFlags());
            } else {
              result.append(api.lineBuilder.actual.first(openTag.start + actualName)).append(properties.first.actual.stripFlags()).append(api.lineBuilder.expected.first(openTag.start + expectedName)).append(properties.first.expected.stripFlags());
            }
            result.append(properties.remaining.stripFlags());
            if (actual.hasChildren && expected.hasChildren) {
              result.append(properties.last.actual.stripFlags()).append(properties.last.expected.stripFlags()).append(api.lineBuilder.line(indent + openTag.end));
              if (namesAreEqual) {
                result.append(allChildren.stripFlags()).append(api.lineBuilder.last(indent + api.wrapFromTheme(theme.react.closeTag, actualName)));
              } else {
                result.append(children.first.actual.stripFlags()).append(children.first.expected.stripFlags()).append(children.remaining.stripFlags()).append(children.last.actual.stripFlags()).append(api.lineBuilder.actual.last(indent + api.wrapFromTheme(theme.react.closeTag, actualName))).append(children.last.expected.stripFlags()).append(api.lineBuilder.expected.last(indent + api.wrapFromTheme(theme.react.closeTag, expectedName)));
              }
            } else if (actual.hasChildren) {
              result.append(properties.last.actual.stripFlags()).append(api.lineBuilder.actual.line(indent + openTag.end)).append(allChildren.stripFlags()).append(api.lineBuilder.actual.last(indent + api.wrapFromTheme(theme.react.closeTag, actualName))).append(properties.last.expected.stripFlags()).append(api.lineBuilder.expected.last(indent + openTag.selfClose + openTag.end));
            } else if (expected.hasChildren) {
              result.append(properties.last.actual.stripFlags()).append(api.lineBuilder.actual.last(indent + openTag.selfClose + openTag.end)).append(properties.last.expected.stripFlags()).append(api.lineBuilder.expected.line(indent + openTag.end)).append(allChildren.stripFlags()).append(api.lineBuilder.expected.last(indent + api.wrapFromTheme(theme.react.closeTag, expectedName)));
            } else {
              result.append(properties.last.actual.stripFlags()).append(properties.last.expected.stripFlags()).append(api.lineBuilder.last(indent + openTag.selfClose + openTag.end));
            }
          } else if (actual.hasProperties) {
            result.append(api.lineBuilder.actual.first(openTag.start + actualName)).append(allProperties.stripFlags());
            if (actual.hasChildren && expected.hasChildren) {
              result.append(api.lineBuilder.actual.line(indent + openTag.end)).append(children.first.actual.stripFlags()).append(api.lineBuilder.expected.first(openTag.start + expectedName + openTag.end)).append(children.first.expected.stripFlags()).append(children.remaining.stripFlags());
              if (namesAreEqual) {
                result.append(children.last.actual.stripFlags()).append(children.last.expected.stripFlags()).append(api.lineBuilder.last(indent + api.wrapFromTheme(theme.react.closeTag, actualName)));
              } else {
                result.append(children.last.actual.stripFlags()).append(api.lineBuilder.actual.last(indent + api.wrapFromTheme(theme.react.closeTag, actualName))).append(children.last.expected.stripFlags()).append(api.lineBuilder.expected.last(indent + api.wrapFromTheme(theme.react.closeTag, expectedName)));
              }
            } else if (actual.hasChildren) {
              result.append(api.lineBuilder.actual.last(indent + openTag.selfClose + openTag.end)).append(allChildren.stripFlags()).append(api.lineBuilder.actual.last(indent + api.wrapFromTheme(theme.react.closeTag, actualName))).append(api.lineBuilder.expected.single(openTag.start + expectedName + openTag.selfCloseVoid + openTag.end));
            } else if (expected.hasChildren) {
              result.append(api.lineBuilder.actual.last(indent + openTag.selfClose + openTag.end)).append(api.lineBuilder.expected.first(openTag.start + expectedName + openTag.end)).append(allChildren.stripFlags()).append(api.lineBuilder.expected.last(indent + api.wrapFromTheme(theme.react.closeTag, expectedName)));
            } else {
              result.append(api.lineBuilder.actual.last(indent + openTag.selfClose + openTag.end)).append(api.lineBuilder.expected.single(openTag.start + expectedName + openTag.selfCloseVoid + openTag.end));
            }
          } else if (expected.hasProperties) {
            if (actual.hasChildren && expected.hasChildren) {
              result.append(api.lineBuilder.actual.first(openTag.start + actualName + openTag.end)).append(children.first.actual.stripFlags()).append(api.lineBuilder.expected.first(openTag.start + expectedName)).append(allProperties.stripFlags()).append(api.lineBuilder.expected.line(indent + openTag.end)).append(children.first.expected.stripFlags()).append(children.remaining.stripFlags());
              if (namesAreEqual) {
                result.append(children.last.actual.stripFlags()).append(children.last.expected.stripFlags()).append(api.lineBuilder.last(indent + api.wrapFromTheme(theme.react.closeTag, actualName)));
              } else {
                result.append(children.last.actual.stripFlags()).append(api.lineBuilder.actual.last(indent + api.wrapFromTheme(theme.react.closeTag, actualName))).append(children.last.expected.stripFlags()).append(api.lineBuilder.expected.last(indent + api.wrapFromTheme(theme.react.closeTag, expectedName)));
              }
            } else if (actual.hasChildren) {
              result.append(api.lineBuilder.actual.first(openTag.start + actualName + openTag.end)).append(allChildren.stripFlags()).append(api.lineBuilder.actual.last(indent + api.wrapFromTheme(theme.react.closeTag, actualName))).append(api.lineBuilder.expected.first(openTag.start + expectedName)).append(allProperties.stripFlags()).append(api.lineBuilder.expected.last(indent + openTag.selfClose + openTag.end));
            } else if (expected.hasChildren) {
              result.append(api.lineBuilder.actual.single(openTag.start + actualName + openTag.selfCloseVoid + openTag.end)).append(api.lineBuilder.expected.first(openTag.start + expectedName)).append(allProperties.stripFlags()).append(api.lineBuilder.expected.line(indent + openTag.end)).append(allChildren.stripFlags()).append(api.lineBuilder.expected.last(indent + api.wrapFromTheme(theme.react.closeTag, expectedName)));
            } else {
              result.append(api.lineBuilder.actual.single(openTag.start + actualName + openTag.selfCloseVoid + openTag.end)).append(api.lineBuilder.expected.first(openTag.start + expectedName)).append(allProperties.stripFlags()).append(api.lineBuilder.expected.last(indent + openTag.selfCloseVoid + openTag.end));
            }
          } else {
            if (actual.hasChildren && expected.hasChildren) {
              if (namesAreEqual) {
                result.append(api.lineBuilder.first(openTag.start + actualName + openTag.end)).append(allChildren.stripFlags()).append(api.lineBuilder.last(indent + api.wrapFromTheme(theme.react.closeTag, actualName)));
              } else {
                result.append(api.lineBuilder.actual.first(openTag.start + actualName + openTag.end)).append(children.first.actual.stripFlags()).append(api.lineBuilder.expected.first(openTag.start + expectedName + openTag.end)).append(children.first.expected.stripFlags()).append(children.remaining.stripFlags()).append(children.last.actual.stripFlags()).append(api.lineBuilder.actual.last(indent + api.wrapFromTheme(theme.react.closeTag, actualName))).append(children.last.expected.stripFlags()).append(api.lineBuilder.expected.last(indent + api.wrapFromTheme(theme.react.closeTag, expectedName)));
              }
            } else if (actual.hasChildren) {
              result.append(api.lineBuilder.actual.first(openTag.start + actualName + openTag.end)).append(allChildren.stripFlags()).append(api.lineBuilder.actual.last(indent + api.wrapFromTheme(theme.react.closeTag, actualName))).append(api.lineBuilder.expected.single(openTag.start + expectedName + openTag.selfCloseVoid + openTag.end));
            } else if (expected.hasChildren) {
              result.append(api.lineBuilder.actual.single(openTag.start + actualName + openTag.selfCloseVoid + openTag.end)).append(api.lineBuilder.expected.first(openTag.start + expectedName + openTag.end)).append(allChildren.stripFlags()).append(api.lineBuilder.expected.last(indent + api.wrapFromTheme(theme.react.closeTag, actualName)));
            } else {
              if (namesAreEqual) {
                result.append(api.lineBuilder.single(openTag.start + actualName + openTag.selfCloseVoid + openTag.end));
              } else {
                result.append(api.lineBuilder.actual.single(openTag.start + actualName + openTag.selfCloseVoid + openTag.end)).append(api.lineBuilder.expected.single(openTag.start + expectedName + openTag.selfCloseVoid + openTag.end));
              }
            }
          }
          return result;
        },
        shouldFormat(subject) {
          return subject.isItem === true || subject.isProperty === true;
        },
        increaseIndent: true
      };
    }
    module2.exports = diffShallow;
  }
});

// node_modules/@concordance/react/lib/escapeText.js
var require_escapeText = __commonJS({
  "node_modules/@concordance/react/lib/escapeText.js"(exports2, module2) {
    "use strict";
    function escapeText(text) {
      return text.replace(/</g, "&lt;").replace(/>/g, "&gt;");
    }
    module2.exports = escapeText;
  }
});

// node_modules/@concordance/react/lib/elementFactory.js
var require_elementFactory = __commonJS({
  "node_modules/@concordance/react/lib/elementFactory.js"(exports2, module2) {
    "use strict";
    var arrify = require_arrify();
    var diffShallow = require_diffShallow();
    var escapeText = require_escapeText();
    var FRAGMENT_NAME = Symbol.for("react.fragment");
    function factory(api, reactTags) {
      const tag = Symbol("@concordance/react.ElementValue");
      function customPropertyFormatter(theme, indent, key, value2) {
        const separator = theme.react.attribute.separator + theme.react.attribute.value.openBracket;
        if (value2.isSingle) {
          return value2.withFirstPrefixed(key.formatAsKey(theme) + separator).withLastPostfixed(theme.react.attribute.value.closeBracket);
        }
        return api.lineBuilder.first(key.formatAsKey(theme) + separator).concat(value2.withFirstPrefixed(indent.increase()).stripFlags()).append(api.lineBuilder.last(indent + theme.react.attribute.value.closeBracket));
      }
      function themeProperty(theme) {
        theme.property.increaseValueIndent = true;
        theme.property.customFormat = customPropertyFormatter;
      }
      function themeStringProperty(theme) {
        theme.property.separator = theme.react.attribute.separator;
        theme.property.after = "";
        Object.assign(theme.string.line, theme.react.attribute.value.string.line);
      }
      function customItemFormatter(theme, indent, value2) {
        if (value2.isSingle) {
          return value2.withFirstPrefixed(theme.react.child.openBracket).withLastPostfixed(theme.react.child.closeBracket);
        }
        return api.lineBuilder.first(theme.react.child.openBracket).concat(value2.withFirstPrefixed(indent.increase()).stripFlags()).append(api.lineBuilder.last(indent + theme.react.child.closeBracket));
      }
      function themeChild(theme) {
        theme.item.increaseValueIndent = true;
        theme.item.customFormat = customItemFormatter;
      }
      function themeReactChild(theme) {
        theme.item.after = "";
      }
      function themeStringChild(theme) {
        theme.item.after = "";
        Object.assign(theme.string, theme.react.child.string);
      }
      function describe(props) {
        const element = props.value;
        const type = element.type;
        const hasTypeFn = typeof type === "function";
        const typeFn = hasTypeFn ? type : null;
        const name = hasTypeFn ? type.displayName || type.name : type;
        const children = arrify(element.props.children);
        const properties = Object.assign({}, element.props);
        delete properties.children;
        if (element.key !== null) {
          properties.key = element.key;
        }
        const hasProperties = Object.keys(properties).length > 0;
        return new DescribedElementValue(Object.assign({
          children,
          hasProperties,
          hasTypeFn,
          name,
          properties,
          typeFn,
          isList: children.length > 0
        }, props));
      }
      function deserialize(state, recursor) {
        return new DeserializedElementValue(state, recursor);
      }
      class ElementValue extends api.ObjectValue {
        constructor(props) {
          super(props);
          this.isFragment = props.name === FRAGMENT_NAME;
          this.name = props.name;
          this.hasProperties = props.hasProperties;
          this.hasTypeFn = props.hasTypeFn;
          this.hasChildren = this.isList;
        }
        compare(expected) {
          return this.tag === expected.tag && this.name === expected.name ? api.SHALLOW_EQUAL : api.UNEQUAL;
        }
        formatName(theme) {
          const formatted = api.wrapFromTheme(theme.react.tagName, this.isFragment ? "React.Fragment" : this.name);
          return this.hasTypeFn ? formatted + theme.react.functionType : formatted;
        }
        compareNames(expected) {
          return this.name === expected.name && this.hasTypeFn === expected.hasTypeFn;
        }
        formatShallow(theme, indent) {
          const childBuffer = api.lineBuilder.buffer();
          const propertyBuffer = api.lineBuilder.buffer();
          return {
            append(formatted, origin) {
              if (origin.isItem === true) {
                childBuffer.append(formatted);
              } else {
                propertyBuffer.append(formatted);
              }
            },
            finalize: () => {
              const name = this.formatName(theme);
              const openTag = theme.react.openTag;
              if (!this.hasChildren && !this.hasProperties) {
                return api.lineBuilder.single(openTag.start + name + openTag.selfCloseVoid + openTag.end);
              }
              const innerIndentation = indent.increase();
              const children = childBuffer.withFirstPrefixed(innerIndentation).stripFlags();
              const properties = propertyBuffer.withFirstPrefixed(innerIndentation).stripFlags();
              const result = api.lineBuilder.buffer();
              if (this.hasProperties) {
                result.append(api.lineBuilder.first(openTag.start + name)).append(properties);
                if (this.hasChildren) {
                  result.append(api.lineBuilder.line(indent + openTag.end));
                } else {
                  result.append(api.lineBuilder.last(indent + openTag.selfClose + openTag.end));
                }
              } else {
                result.append(api.lineBuilder.first(openTag.start + name + openTag.end));
              }
              if (this.hasChildren) {
                result.append(children).append(api.lineBuilder.last(indent + api.wrapFromTheme(theme.react.closeTag, name)));
              }
              return result;
            },
            maxDepth: () => {
              const name = this.formatName(theme);
              const openTag = theme.react.openTag;
              if (!this.hasChildren && !this.hasProperties) {
                return api.lineBuilder.single(openTag.start + name + openTag.selfCloseVoid + openTag.end);
              }
              let str = openTag.start + name;
              if (this.hasProperties) {
                str += theme.maxDepth;
                if (this.hasChildren) {
                  str += openTag.end;
                } else {
                  str += " " + openTag.selfClose + openTag.end;
                }
              } else {
                str += openTag.end;
              }
              if (this.hasChildren) {
                str += theme.maxDepth + api.wrapFromTheme(theme.react.closeTag, name);
              }
              return api.lineBuilder.single(str);
            },
            shouldFormat(subject) {
              return subject.isItem === true || subject.isProperty === true;
            },
            increaseIndent: true
          };
        }
        prepareDiff(expected) {
          return {
            compareResult: this.tag === expected.tag ? api.SHALLOW_EQUAL : api.UNEQUAL
          };
        }
        diffShallow(expected, theme, indent) {
          return diffShallow(api, this, expected, theme, indent);
        }
        serialize() {
          return [this.isFragment, this.isFragment ? null : this.name, this.hasProperties, this.hasTypeFn, super.serialize()];
        }
      }
      Object.defineProperty(ElementValue.prototype, "tag", { value: tag });
      function modifyThemes(recursor) {
        return api.mapRecursor(recursor, (next) => {
          let modifier;
          if (next.isItem === true) {
            if (next.tag === api.descriptorTags.primitiveItem && next.value.tag === api.descriptorTags.string) {
              modifier = themeStringChild;
            } else if (next.tag === api.descriptorTags.complexItem && reactTags.has(next.value.tag)) {
              modifier = themeReactChild;
            } else {
              modifier = themeChild;
            }
          } else if (next.isProperty === true) {
            if (next.tag === api.descriptorTags.primitiveProperty && next.value.tag === api.descriptorTags.string && !next.value.includesLinebreaks) {
              modifier = themeStringProperty;
            } else {
              modifier = themeProperty;
            }
          }
          return modifier ? api.modifyTheme(next, modifier) : next;
        });
      }
      function DescribedMixin(base) {
        return class extends api.DescribedMixin(base) {
          constructor(props) {
            super(props);
            this.children = props.children;
            this.properties = props.properties;
            this.typeFn = props.typeFn;
          }
          compare(expected) {
            const result = super.compare(expected);
            return result === api.SHALLOW_EQUAL && this.typeFn !== expected.typeFn ? api.UNEQUAL : result;
          }
          compareNames(expected) {
            return super.compareNames(expected) && this.typeFn === expected.typeFn;
          }
          createPropertyRecursor() {
            const keys = Object.keys(this.properties).sort();
            const size = keys.length;
            let index = 0;
            const next = () => {
              if (index === size) return null;
              const key = keys[index++];
              return this.describeProperty(key, this.describeAny(this.properties[key]));
            };
            return { size, next };
          }
          createListRecursor() {
            if (!this.isList) return super.createListRecursor();
            const size = this.children.length;
            let index = 0;
            const next = () => {
              if (index === size) return null;
              const current = index++;
              const child = this.children[current];
              const type = typeof child;
              let descriptor;
              if (type === "string") {
                descriptor = this.describeAny(escapeText(child));
              } else {
                descriptor = this.describeAny(child);
              }
              return this.describeItem(current, descriptor);
            };
            return { size, next };
          }
          createRecursor() {
            return modifyThemes(super.createRecursor());
          }
        };
      }
      function DeserializedMixin(base) {
        return class extends api.DeserializedMixin(base) {
          constructor(state, recursor) {
            super(state[4], recursor);
            this.isFragment = state[0];
            this.name = this.isFragment ? FRAGMENT_NAME : state[1];
            this.hasProperties = state[2];
            this.hasTypeFn = state[3];
          }
          createRecursor() {
            return modifyThemes(super.createRecursor());
          }
        };
      }
      const DescribedElementValue = DescribedMixin(ElementValue);
      const DeserializedElementValue = DeserializedMixin(ElementValue);
      return {
        DescribedMixin,
        DeserializedMixin,
        ElementValue,
        describe,
        deserialize,
        tag
      };
    }
    module2.exports = factory;
  }
});

// node_modules/@concordance/react/lib/testJsonFactory.js
var require_testJsonFactory = __commonJS({
  "node_modules/@concordance/react/lib/testJsonFactory.js"(exports2, module2) {
    "use strict";
    var arrify = require_arrify();
    function factory(api, element) {
      const tag = Symbol("@concordance/react.TestJsonValue");
      function describe(props) {
        const obj = props.value;
        const name = obj.type;
        const children = arrify(obj.children);
        const properties = Object.assign({}, obj.props);
        const hasProperties = Object.keys(properties).length > 0;
        return new DescribedTestJsonValue(Object.assign({
          children,
          hasProperties,
          hasTypeFn: false,
          name,
          properties,
          typeFn: null,
          isList: children.length > 0
        }, props));
      }
      function deserialize(state, recursor) {
        return new DeserializedTestJsonValue(state, recursor);
      }
      class TestJsonValue extends element.ElementValue {
        compare(expected) {
          return (this.tag === expected.tag || expected.tag === element.tag) && this.name === expected.name ? api.SHALLOW_EQUAL : api.UNEQUAL;
        }
        prepareDiff(expected) {
          return {
            // Allow expected value to be a React element.
            compareResult: this.tag === expected.tag || expected.tag === element.tag ? api.SHALLOW_EQUAL : api.UNEQUAL
          };
        }
      }
      Object.defineProperty(TestJsonValue.prototype, "tag", { value: tag });
      const DescribedTestJsonValue = element.DescribedMixin(TestJsonValue);
      const DeserializedTestJsonValue = element.DeserializedMixin(TestJsonValue);
      return {
        describe,
        deserialize,
        tag
      };
    }
    module2.exports = factory;
  }
});

// node_modules/@concordance/react/index.js
var require_react = __commonJS({
  "node_modules/@concordance/react/index.js"(exports2) {
    "use strict";
    var pkg = require_package3();
    var elementFactory = require_elementFactory();
    var testJsonFactory = require_testJsonFactory();
    exports2.name = pkg.name;
    exports2.apiVersion = 1;
    exports2.minimalConcordanceVersion = "1.0.0";
    exports2.serializerVersion = 2;
    exports2.theme = {
      react: {
        functionType: "\u235F",
        openTag: {
          start: "<",
          end: ">",
          selfClose: "/",
          selfCloseVoid: " /"
        },
        closeTag: {
          open: "</",
          close: ">"
        },
        tagName: { open: "", close: "" },
        attribute: {
          separator: "=",
          value: {
            openBracket: "{",
            closeBracket: "}",
            string: {
              line: { open: '"', close: '"', escapeQuote: '"' }
            }
          }
        },
        child: {
          openBracket: "{",
          closeBracket: "}",
          string: {
            line: { open: "", close: "", escapeQuote: "" },
            multiline: { start: "", end: "", escapeQuote: "" }
          }
        }
      }
    };
    var ELEMENT = Symbol.for("react.element");
    var TEST_JSON = Symbol.for("react.test.json");
    function register(api) {
      const reactTags = /* @__PURE__ */ new Set();
      const element = elementFactory(api, reactTags);
      const testJson = testJsonFactory(api, element);
      api.addDescriptor(1, element.tag, element.deserialize);
      api.addDescriptor(2, testJson.tag, testJson.deserialize);
      reactTags.add(element.tag).add(testJson.tag);
      return (value2) => {
        if (value2.$$typeof === ELEMENT) return element.describe;
        if (value2.$$typeof === TEST_JSON) return testJson.describe;
        return null;
      };
    }
    exports2.register = register;
  }
});

// node_modules/ava/lib/concordance-options.js
var require_concordance_options = __commonJS({
  "node_modules/ava/lib/concordance-options.js"(exports2) {
    "use strict";
    var util = require("util");
    var ansiStyles = require_ansi_styles2();
    var stripAnsi = require_strip_ansi();
    var cloneDeepWith = require("lodash/cloneDeepWith");
    var reactPlugin = require_react();
    var chalk = require_chalk().get();
    var avaReactPlugin = { ...reactPlugin, name: "ava-plugin-react" };
    var plugins = [avaReactPlugin];
    var forceColor = new chalk.Instance({ level: Math.max(chalk.level, 1) });
    var colorTheme = {
      boolean: ansiStyles.yellow,
      circular: forceColor.grey("[Circular]"),
      date: {
        invalid: forceColor.red("invalid"),
        value: ansiStyles.blue
      },
      diffGutters: {
        actual: forceColor.red("-") + " ",
        expected: forceColor.green("+") + " ",
        padding: "  "
      },
      error: {
        ctor: { open: ansiStyles.grey.open + "(", close: ")" + ansiStyles.grey.close },
        name: ansiStyles.magenta
      },
      function: {
        name: ansiStyles.blue,
        stringTag: ansiStyles.magenta
      },
      global: ansiStyles.magenta,
      item: { after: forceColor.grey(",") },
      list: { openBracket: forceColor.grey("["), closeBracket: forceColor.grey("]") },
      mapEntry: { after: forceColor.grey(",") },
      maxDepth: forceColor.grey("\u2026"),
      null: ansiStyles.yellow,
      number: ansiStyles.yellow,
      object: {
        openBracket: forceColor.grey("{"),
        closeBracket: forceColor.grey("}"),
        ctor: ansiStyles.magenta,
        stringTag: { open: ansiStyles.magenta.open + "@", close: ansiStyles.magenta.close },
        secondaryStringTag: { open: ansiStyles.grey.open + "@", close: ansiStyles.grey.close }
      },
      property: {
        after: forceColor.grey(","),
        keyBracket: { open: forceColor.grey("["), close: forceColor.grey("]") },
        valueFallback: forceColor.grey("\u2026")
      },
      react: {
        functionType: forceColor.grey("\u235F"),
        openTag: {
          start: forceColor.grey("<"),
          end: forceColor.grey(">"),
          selfClose: forceColor.grey("/"),
          selfCloseVoid: " " + forceColor.grey("/")
        },
        closeTag: {
          open: forceColor.grey("</"),
          close: forceColor.grey(">")
        },
        tagName: ansiStyles.magenta,
        attribute: {
          separator: "=",
          value: {
            openBracket: forceColor.grey("{"),
            closeBracket: forceColor.grey("}"),
            string: {
              line: { open: forceColor.blue('"'), close: forceColor.blue('"'), escapeQuote: '"' }
            }
          }
        },
        child: {
          openBracket: forceColor.grey("{"),
          closeBracket: forceColor.grey("}")
        }
      },
      regexp: {
        source: { open: ansiStyles.blue.open + "/", close: "/" + ansiStyles.blue.close },
        flags: ansiStyles.yellow
      },
      stats: { separator: forceColor.grey("---") },
      string: {
        open: ansiStyles.blue.open,
        close: ansiStyles.blue.close,
        line: { open: forceColor.blue("'"), close: forceColor.blue("'") },
        multiline: { start: forceColor.blue("`"), end: forceColor.blue("`") },
        controlPicture: ansiStyles.grey,
        diff: {
          insert: {
            open: ansiStyles.bgGreen.open + ansiStyles.black.open,
            close: ansiStyles.black.close + ansiStyles.bgGreen.close
          },
          delete: {
            open: ansiStyles.bgRed.open + ansiStyles.black.open,
            close: ansiStyles.black.close + ansiStyles.bgRed.close
          },
          equal: ansiStyles.blue,
          insertLine: {
            open: ansiStyles.green.open,
            close: ansiStyles.green.close
          },
          deleteLine: {
            open: ansiStyles.red.open,
            close: ansiStyles.red.close
          }
        }
      },
      symbol: ansiStyles.yellow,
      typedArray: {
        bytes: ansiStyles.yellow
      },
      undefined: ansiStyles.yellow
    };
    var plainTheme = cloneDeepWith(colorTheme, (value2) => {
      if (typeof value2 === "string") {
        return stripAnsi(value2);
      }
    });
    var theme = chalk.level > 0 ? colorTheme : plainTheme;
    exports2.default = {
      // Use Node's object inspection depth, clamped to a minimum of 3
      get maxDepth() {
        return Math.max(3, util.inspect.defaultOptions.depth);
      },
      plugins,
      theme
    };
    exports2.snapshotManager = { plugins, theme: plainTheme };
  }
});

// node_modules/ava/lib/snapshot-manager.js
var require_snapshot_manager = __commonJS({
  "node_modules/ava/lib/snapshot-manager.js"(exports2) {
    "use strict";
    var crypto = require("crypto");
    var fs = require("fs");
    var path = require("path");
    var zlib = require("zlib");
    var concordance = require_concordance();
    var indentString = require_indent_string();
    var md5Hex = require_md5_hex();
    var convertSourceMap = require_convert_source_map();
    var slash = require_slash();
    var writeFileAtomic = require_write_file_atomic();
    var mem = require_dist2();
    var concordanceOptions = require_concordance_options().snapshotManager;
    var VERSION = 2;
    var VERSION_HEADER = Buffer.alloc(2);
    VERSION_HEADER.writeUInt16LE(VERSION);
    var READABLE_PREFIX = Buffer.from(`AVA Snapshot v${VERSION}
`, "ascii");
    var REPORT_SEPARATOR = Buffer.from("\n\n", "ascii");
    var REPORT_TRAILING_NEWLINE = Buffer.from("\n", "ascii");
    var MD5_HASH_LENGTH = 16;
    var SnapshotError = class extends Error {
      constructor(message, snapPath) {
        super(message);
        this.name = "SnapshotError";
        this.snapPath = snapPath;
      }
    };
    exports2.SnapshotError = SnapshotError;
    var ChecksumError = class extends SnapshotError {
      constructor(snapPath) {
        super("Checksum mismatch", snapPath);
        this.name = "ChecksumError";
      }
    };
    exports2.ChecksumError = ChecksumError;
    var VersionMismatchError = class extends SnapshotError {
      constructor(snapPath, version) {
        super("Unexpected snapshot version", snapPath);
        this.name = "VersionMismatchError";
        this.snapVersion = version;
        this.expectedVersion = VERSION;
      }
    };
    exports2.VersionMismatchError = VersionMismatchError;
    var LEGACY_SNAPSHOT_HEADER = Buffer.from("// Jest Snapshot v1");
    function isLegacySnapshot(buffer) {
      return LEGACY_SNAPSHOT_HEADER.equals(buffer.slice(0, LEGACY_SNAPSHOT_HEADER.byteLength));
    }
    var LegacyError = class extends SnapshotError {
      constructor(snapPath) {
        super("Legacy snapshot file", snapPath);
        this.name = "LegacyError";
      }
    };
    exports2.LegacyError = LegacyError;
    function tryRead(file) {
      try {
        return fs.readFileSync(file);
      } catch (error) {
        if (error.code === "ENOENT") {
          return null;
        }
        throw error;
      }
    }
    function withoutLineEndings(buffer) {
      let checkPosition = buffer.byteLength - 1;
      while (buffer[checkPosition] === 10 || buffer[checkPosition] === 13) {
        checkPosition--;
      }
      return buffer.slice(0, checkPosition + 1);
    }
    function formatEntry(label, descriptor) {
      if (label) {
        label = `> ${label}

`;
      }
      const codeBlock = indentString(concordance.formatDescriptor(descriptor, concordanceOptions), 4);
      return Buffer.from(label + codeBlock, "utf8");
    }
    function combineEntries(entries) {
      const buffers = [];
      let byteLength = 0;
      const sortedKeys = [...entries.keys()].sort((keyA, keyB) => {
        const [a, b] = [entries.get(keyA), entries.get(keyB)];
        const taskDifference = a.taskIndex - b.taskIndex;
        if (taskDifference !== 0) {
          return taskDifference;
        }
        const [assocA, assocB] = [a.associatedTaskIndex, b.associatedTaskIndex];
        if (assocA !== void 0 && assocB !== void 0) {
          const assocDifference = assocA - assocB;
          if (assocDifference !== 0) {
            return assocDifference;
          }
        }
        return a.snapIndex - b.snapIndex;
      });
      for (const key of sortedKeys) {
        const keyBuffer = Buffer.from(`

## ${key}

`, "utf8");
        buffers.push(keyBuffer);
        byteLength += keyBuffer.byteLength;
        const formattedEntries = entries.get(key).buffers;
        const last = formattedEntries[formattedEntries.length - 1];
        for (const entry of formattedEntries) {
          buffers.push(entry);
          byteLength += entry.byteLength;
          if (entry !== last) {
            buffers.push(REPORT_SEPARATOR);
            byteLength += REPORT_SEPARATOR.byteLength;
          }
        }
      }
      return { buffers, byteLength };
    }
    function generateReport(relFile, snapFile, entries) {
      const combined = combineEntries(entries);
      const { buffers } = combined;
      let { byteLength } = combined;
      const header = Buffer.from(`# Snapshot report for \`${slash(relFile)}\`

The actual snapshot is saved in \`${snapFile}\`.

Generated by [AVA](https://avajs.dev).`, "utf8");
      buffers.unshift(header);
      byteLength += header.byteLength;
      buffers.push(REPORT_TRAILING_NEWLINE);
      byteLength += REPORT_TRAILING_NEWLINE.byteLength;
      return Buffer.concat(buffers, byteLength);
    }
    function appendReportEntries(existingReport, entries) {
      const combined = combineEntries(entries);
      const { buffers } = combined;
      let { byteLength } = combined;
      const prepend = withoutLineEndings(existingReport);
      buffers.unshift(prepend);
      byteLength += prepend.byteLength;
      buffers.push(REPORT_TRAILING_NEWLINE);
      byteLength += REPORT_TRAILING_NEWLINE.byteLength;
      return Buffer.concat(buffers, byteLength);
    }
    function encodeSnapshots(buffersByHash) {
      const buffers = [];
      let byteOffset = 0;
      const headerLength = Buffer.alloc(4);
      buffers.push(headerLength);
      byteOffset += 4;
      const numberHashes = Buffer.alloc(2);
      numberHashes.writeUInt16LE(buffersByHash.size);
      buffers.push(numberHashes);
      byteOffset += 2;
      const entries = [];
      const sortedHashes = [...buffersByHash.keys()].sort();
      const sortedBuffersByHash = [...sortedHashes.map((hash) => [hash, buffersByHash.get(hash)])];
      for (const [hash, snapshotBuffers] of sortedBuffersByHash) {
        buffers.push(Buffer.from(hash, "hex"));
        byteOffset += MD5_HASH_LENGTH;
        const numberSnapshots = Buffer.alloc(2);
        numberSnapshots.writeUInt16LE(snapshotBuffers.length, 0);
        buffers.push(numberSnapshots);
        byteOffset += 2;
        for (const value2 of snapshotBuffers) {
          const start = Buffer.alloc(4);
          const end = Buffer.alloc(4);
          entries.push({ start, end, value: value2 });
          buffers.push(start, end);
          byteOffset += 8;
        }
      }
      headerLength.writeUInt32LE(byteOffset, 0);
      let bodyOffset = 0;
      for (const entry of entries) {
        const start = bodyOffset;
        const end = bodyOffset + entry.value.byteLength;
        entry.start.writeUInt32LE(start, 0);
        entry.end.writeUInt32LE(end, 0);
        buffers.push(entry.value);
        bodyOffset = end;
      }
      byteOffset += bodyOffset;
      const compressed = zlib.gzipSync(Buffer.concat(buffers, byteOffset));
      compressed[9] = 3;
      const md5sum = crypto.createHash("md5").update(compressed).digest();
      return Buffer.concat([
        READABLE_PREFIX,
        VERSION_HEADER,
        md5sum,
        compressed
      ], READABLE_PREFIX.byteLength + VERSION_HEADER.byteLength + MD5_HASH_LENGTH + compressed.byteLength);
    }
    function decodeSnapshots(buffer, snapPath) {
      if (isLegacySnapshot(buffer)) {
        throw new LegacyError(snapPath);
      }
      const versionOffset = buffer.indexOf(10) + 1;
      const version = buffer.readUInt16LE(versionOffset);
      if (version !== VERSION) {
        throw new VersionMismatchError(snapPath, version);
      }
      const md5sumOffset = versionOffset + 2;
      const compressedOffset = md5sumOffset + MD5_HASH_LENGTH;
      const compressed = buffer.slice(compressedOffset);
      const md5sum = crypto.createHash("md5").update(compressed).digest();
      const expectedSum = buffer.slice(md5sumOffset, compressedOffset);
      if (!md5sum.equals(expectedSum)) {
        throw new ChecksumError(snapPath);
      }
      const decompressed = zlib.gunzipSync(compressed);
      let byteOffset = 0;
      const headerLength = decompressed.readUInt32LE(byteOffset);
      byteOffset += 4;
      const snapshotsByHash = /* @__PURE__ */ new Map();
      const numberHashes = decompressed.readUInt16LE(byteOffset);
      byteOffset += 2;
      for (let count = 0; count < numberHashes; count++) {
        const hash = decompressed.toString("hex", byteOffset, byteOffset + MD5_HASH_LENGTH);
        byteOffset += MD5_HASH_LENGTH;
        const numberSnapshots = decompressed.readUInt16LE(byteOffset);
        byteOffset += 2;
        const snapshotsBuffers = new Array(numberSnapshots);
        for (let index = 0; index < numberSnapshots; index++) {
          const start = decompressed.readUInt32LE(byteOffset) + headerLength;
          byteOffset += 4;
          const end = decompressed.readUInt32LE(byteOffset) + headerLength;
          byteOffset += 4;
          snapshotsBuffers[index] = decompressed.slice(start, end);
        }
        if (snapshotsByHash.has(hash)) {
          snapshotsByHash.set(hash, snapshotsByHash.get(hash).concat(snapshotsBuffers));
        } else {
          snapshotsByHash.set(hash, snapshotsBuffers);
        }
      }
      return snapshotsByHash;
    }
    var Manager = class {
      constructor(options) {
        this.appendOnly = options.appendOnly;
        this.dir = options.dir;
        this.recordNewSnapshots = options.recordNewSnapshots;
        this.relFile = options.relFile;
        this.reportFile = options.reportFile;
        this.snapFile = options.snapFile;
        this.snapPath = options.snapPath;
        this.snapshotsByHash = options.snapshotsByHash;
        this.hasChanges = false;
        this.reportEntries = /* @__PURE__ */ new Map();
      }
      compare(options) {
        const hash = md5Hex(options.belongsTo);
        const entries = this.snapshotsByHash.get(hash) || [];
        const snapshotBuffer = entries[options.index];
        if (!snapshotBuffer) {
          if (!this.recordNewSnapshots) {
            return { pass: false };
          }
          if (options.deferRecording) {
            const record = this.deferRecord(hash, options);
            return { pass: true, record };
          }
          this.record(hash, options);
          return { pass: true };
        }
        const actual = concordance.deserialize(snapshotBuffer, concordanceOptions);
        const expected = concordance.describe(options.expected, concordanceOptions);
        const pass = concordance.compareDescriptors(actual, expected);
        return { actual, expected, pass };
      }
      deferRecord(hash, options) {
        const descriptor = concordance.describe(options.expected, concordanceOptions);
        const snapshot = concordance.serialize(descriptor);
        const entry = formatEntry(options.label, descriptor);
        const { taskIndex, snapIndex, associatedTaskIndex } = options;
        return () => {
          this.hasChanges = true;
          let snapshots = this.snapshotsByHash.get(hash);
          if (!snapshots) {
            snapshots = [];
            this.snapshotsByHash.set(hash, snapshots);
          }
          if (options.index > snapshots.length) {
            throw new RangeError(`Cannot record snapshot ${options.index} for ${JSON.stringify(options.belongsTo)}, exceeds expected index of ${snapshots.length}`);
          }
          if (options.index < snapshots.length) {
            throw new RangeError(`Cannot record snapshot ${options.index} for ${JSON.stringify(options.belongsTo)}, already exists`);
          }
          snapshots.push(snapshot);
          if (this.reportEntries.has(options.belongsTo)) {
            this.reportEntries.get(options.belongsTo).buffers.push(entry);
          } else {
            this.reportEntries.set(options.belongsTo, { buffers: [entry], taskIndex, snapIndex, associatedTaskIndex });
          }
        };
      }
      record(hash, options) {
        const record = this.deferRecord(hash, options);
        record();
      }
      save() {
        if (!this.hasChanges) {
          return null;
        }
        const { snapPath } = this;
        const buffer = encodeSnapshots(this.snapshotsByHash);
        const reportPath = path.join(this.dir, this.reportFile);
        const existingReport = this.appendOnly ? tryRead(reportPath) : null;
        const reportBuffer = existingReport ? appendReportEntries(existingReport, this.reportEntries) : generateReport(this.relFile, this.snapFile, this.reportEntries);
        fs.mkdirSync(this.dir, { recursive: true });
        const paths = [snapPath, reportPath];
        const tmpfileCreated = (tmpfile) => paths.push(tmpfile);
        writeFileAtomic.sync(snapPath, buffer, { tmpfileCreated });
        writeFileAtomic.sync(reportPath, reportBuffer, { tmpfileCreated });
        return paths;
      }
    };
    var resolveSourceFile = mem((file) => {
      const testDir = path.dirname(file);
      const buffer = tryRead(file);
      if (!buffer) {
        return file;
      }
      const source = buffer.toString();
      const converter = convertSourceMap.fromSource(source) || convertSourceMap.fromMapFileSource(source, testDir);
      if (converter) {
        const map = converter.toObject();
        const firstSource = `${map.sourceRoot || ""}${map.sources[0]}`;
        return path.resolve(testDir, firstSource);
      }
      return file;
    });
    var determineSnapshotDir = mem(({ file, fixedLocation, projectDir }) => {
      const testDir = path.dirname(resolveSourceFile(file));
      if (fixedLocation) {
        const relativeTestLocation = path.relative(projectDir, testDir);
        return path.join(fixedLocation, relativeTestLocation);
      }
      const parts = new Set(path.relative(projectDir, testDir).split(path.sep));
      if (parts.has("__tests__")) {
        return path.join(testDir, "__snapshots__");
      }
      if (parts.has("test") || parts.has("tests")) {
        return path.join(testDir, "snapshots");
      }
      return testDir;
    }, { cacheKey: ([{ file }]) => file });
    exports2.determineSnapshotDir = determineSnapshotDir;
    function determineSnapshotPaths({ file, fixedLocation, projectDir }) {
      const dir = determineSnapshotDir({ file, fixedLocation, projectDir });
      const relFile = path.relative(projectDir, resolveSourceFile(file));
      const name = path.basename(relFile);
      const reportFile = `${name}.md`;
      const snapFile = `${name}.snap`;
      return {
        dir,
        relFile,
        snapFile,
        reportFile
      };
    }
    function cleanFile(file) {
      try {
        fs.unlinkSync(file);
        return [file];
      } catch (error) {
        if (error.code === "ENOENT") {
          return [];
        }
        throw error;
      }
    }
    function cleanSnapshots({ file, fixedLocation, projectDir }) {
      const { dir, snapFile, reportFile } = determineSnapshotPaths({ file, fixedLocation, projectDir });
      return [
        ...cleanFile(path.join(dir, snapFile)),
        ...cleanFile(path.join(dir, reportFile))
      ];
    }
    exports2.cleanSnapshots = cleanSnapshots;
    function load({ file, fixedLocation, projectDir, recordNewSnapshots, updating }) {
      const { dir, relFile, snapFile, reportFile } = determineSnapshotPaths({ file, fixedLocation, projectDir });
      const snapPath = path.join(dir, snapFile);
      let appendOnly = !updating;
      let snapshotsByHash;
      if (!updating) {
        const buffer = tryRead(snapPath);
        if (buffer) {
          snapshotsByHash = decodeSnapshots(buffer, snapPath);
        } else {
          appendOnly = false;
        }
      }
      return new Manager({
        appendOnly,
        dir,
        recordNewSnapshots,
        relFile,
        reportFile,
        snapFile,
        snapPath,
        snapshotsByHash: snapshotsByHash || /* @__PURE__ */ new Map()
      });
    }
    exports2.load = load;
  }
});

// node_modules/clean-yaml-object/index.js
var require_clean_yaml_object = __commonJS({
  "node_modules/clean-yaml-object/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function(object, filterFn) {
      return cleanYamlObj(object, filterFn || defaultFilter, true, []);
    };
    function cleanYamlObj(object, filter, isRoot, seen) {
      if (object === void 0) {
        return null;
      }
      if (typeof object === "function") {
        return object.toString();
      }
      if (Buffer.isBuffer(object)) {
        return "Buffer\n" + object.toString("hex").split("").reduce(function(set2, c) {
          if (set2.length && set2[set2.length - 1].length === 1) {
            set2[set2.length - 1] += c;
            if (set2.length && set2.length % 20 === 0) {
              set2[set2.length - 1] += "\n";
            } else {
              set2[set2.length - 1] += " ";
            }
          } else {
            set2.push(c);
          }
          return set2;
        }, []).join("").trim();
      }
      if (object && typeof object === "object") {
        if (object instanceof RegExp) {
          return object.toString();
        }
        seen = seen.concat([object]);
        var isArray = Array.isArray(object);
        if (isArray) {
          object = Array.apply(null, object);
        }
        var isError = object && typeof object === "object" && object instanceof Error;
        var set = isArray ? [] : {};
        if (isError && object.name && !object.hasOwnProperty("name") && filter("name", isRoot, object, set)) {
          setProp("name", object, set, seen, filter);
        }
        var keys = Object.getOwnPropertyNames(object);
        return keys.reduce(function(set2, k) {
          if (isArray && k === "length") {
            return set2;
          }
          if (isError && /^domain/.test(k)) {
            return set2;
          }
          if (!filter(k, isRoot, object, set2)) {
            return set2;
          }
          setProp(k, object, set2, seen, filter);
          return set2;
        }, set);
      }
      return object;
    }
    function setProp(propName, source, target, seen, filter) {
      if (seen.indexOf(source[propName]) === -1) {
        target[propName] = cleanYamlObj(source[propName], filter, false, seen);
      } else {
        target[propName] = "[Circular]";
      }
    }
    function defaultFilter() {
      return true;
    }
  }
});

// node_modules/is-error/index.js
var require_is_error = __commonJS({
  "node_modules/is-error/index.js"(exports2, module2) {
    "use strict";
    var objectToString = Object.prototype.toString;
    var getPrototypeOf = Object.getPrototypeOf;
    var ERROR_TYPE = "[object Error]";
    module2.exports = function isError(err) {
      if (typeof err !== "object") {
        return false;
      }
      if (err instanceof Error) {
        return true;
      }
      while (err) {
        if (objectToString.call(err) === ERROR_TYPE) {
          return true;
        }
        err = getPrototypeOf(err);
      }
      return false;
    };
  }
});

// node_modules/stack-utils/node_modules/escape-string-regexp/index.js
var require_escape_string_regexp2 = __commonJS({
  "node_modules/stack-utils/node_modules/escape-string-regexp/index.js"(exports2, module2) {
    "use strict";
    var matchOperatorsRegex = /[|\\{}()[\]^$+*?.-]/g;
    module2.exports = (string) => {
      if (typeof string !== "string") {
        throw new TypeError("Expected a string");
      }
      return string.replace(matchOperatorsRegex, "\\$&");
    };
  }
});

// node_modules/stack-utils/index.js
var require_stack_utils = __commonJS({
  "node_modules/stack-utils/index.js"(exports2, module2) {
    "use strict";
    var escapeStringRegexp = require_escape_string_regexp2();
    var cwd = typeof process === "object" && process && typeof process.cwd === "function" ? process.cwd() : ".";
    var natives = [].concat(
      require("module").builtinModules,
      "bootstrap_node",
      "node"
    ).map((n) => new RegExp(`(?:\\((?:node:)?${n}(?:\\.js)?:\\d+:\\d+\\)$|^\\s*at (?:node:)?${n}(?:\\.js)?:\\d+:\\d+$)`));
    natives.push(
      /\((?:node:)?internal\/[^:]+:\d+:\d+\)$/,
      /\s*at (?:node:)?internal\/[^:]+:\d+:\d+$/,
      /\/\.node-spawn-wrap-\w+-\w+\/node:\d+:\d+\)?$/
    );
    var StackUtils = class _StackUtils {
      constructor(opts) {
        opts = {
          ignoredPackages: [],
          ...opts
        };
        if ("internals" in opts === false) {
          opts.internals = _StackUtils.nodeInternals();
        }
        if ("cwd" in opts === false) {
          opts.cwd = cwd;
        }
        this._cwd = opts.cwd.replace(/\\/g, "/");
        this._internals = [].concat(
          opts.internals,
          ignoredPackagesRegExp(opts.ignoredPackages)
        );
        this._wrapCallSite = opts.wrapCallSite || false;
      }
      static nodeInternals() {
        return [...natives];
      }
      clean(stack, indent = 0) {
        indent = " ".repeat(indent);
        if (!Array.isArray(stack)) {
          stack = stack.split("\n");
        }
        if (!/^\s*at /.test(stack[0]) && /^\s*at /.test(stack[1])) {
          stack = stack.slice(1);
        }
        let outdent = false;
        let lastNonAtLine = null;
        const result = [];
        stack.forEach((st) => {
          st = st.replace(/\\/g, "/");
          if (this._internals.some((internal) => internal.test(st))) {
            return;
          }
          const isAtLine = /^\s*at /.test(st);
          if (outdent) {
            st = st.trimEnd().replace(/^(\s+)at /, "$1");
          } else {
            st = st.trim();
            if (isAtLine) {
              st = st.slice(3);
            }
          }
          st = st.replace(`${this._cwd}/`, "");
          if (st) {
            if (isAtLine) {
              if (lastNonAtLine) {
                result.push(lastNonAtLine);
                lastNonAtLine = null;
              }
              result.push(st);
            } else {
              outdent = true;
              lastNonAtLine = st;
            }
          }
        });
        return result.map((line) => `${indent}${line}
`).join("");
      }
      captureString(limit, fn = this.captureString) {
        if (typeof limit === "function") {
          fn = limit;
          limit = Infinity;
        }
        const { stackTraceLimit } = Error;
        if (limit) {
          Error.stackTraceLimit = limit;
        }
        const obj = {};
        Error.captureStackTrace(obj, fn);
        const { stack } = obj;
        Error.stackTraceLimit = stackTraceLimit;
        return this.clean(stack);
      }
      capture(limit, fn = this.capture) {
        if (typeof limit === "function") {
          fn = limit;
          limit = Infinity;
        }
        const { prepareStackTrace, stackTraceLimit } = Error;
        Error.prepareStackTrace = (obj2, site) => {
          if (this._wrapCallSite) {
            return site.map(this._wrapCallSite);
          }
          return site;
        };
        if (limit) {
          Error.stackTraceLimit = limit;
        }
        const obj = {};
        Error.captureStackTrace(obj, fn);
        const { stack } = obj;
        Object.assign(Error, { prepareStackTrace, stackTraceLimit });
        return stack;
      }
      at(fn = this.at) {
        const [site] = this.capture(1, fn);
        if (!site) {
          return {};
        }
        const res = {
          line: site.getLineNumber(),
          column: site.getColumnNumber()
        };
        setFile(res, site.getFileName(), this._cwd);
        if (site.isConstructor()) {
          Object.defineProperty(res, "constructor", {
            value: true,
            configurable: true
          });
        }
        if (site.isEval()) {
          res.evalOrigin = site.getEvalOrigin();
        }
        if (site.isNative()) {
          res.native = true;
        }
        let typename;
        try {
          typename = site.getTypeName();
        } catch (_2) {
        }
        if (typename && typename !== "Object" && typename !== "[object Object]") {
          res.type = typename;
        }
        const fname = site.getFunctionName();
        if (fname) {
          res.function = fname;
        }
        const meth = site.getMethodName();
        if (meth && fname !== meth) {
          res.method = meth;
        }
        return res;
      }
      parseLine(line) {
        const match = line && line.match(re);
        if (!match) {
          return null;
        }
        const ctor = match[1] === "new";
        let fname = match[2];
        const evalOrigin = match[3];
        const evalFile = match[4];
        const evalLine = Number(match[5]);
        const evalCol = Number(match[6]);
        let file = match[7];
        const lnum = match[8];
        const col = match[9];
        const native = match[10] === "native";
        const closeParen = match[11] === ")";
        let method;
        const res = {};
        if (lnum) {
          res.line = Number(lnum);
        }
        if (col) {
          res.column = Number(col);
        }
        if (closeParen && file) {
          let closes = 0;
          for (let i = file.length - 1; i > 0; i--) {
            if (file.charAt(i) === ")") {
              closes++;
            } else if (file.charAt(i) === "(" && file.charAt(i - 1) === " ") {
              closes--;
              if (closes === -1 && file.charAt(i - 1) === " ") {
                const before = file.slice(0, i - 1);
                const after = file.slice(i + 1);
                file = after;
                fname += ` (${before}`;
                break;
              }
            }
          }
        }
        if (fname) {
          const methodMatch = fname.match(methodRe);
          if (methodMatch) {
            fname = methodMatch[1];
            method = methodMatch[2];
          }
        }
        setFile(res, file, this._cwd);
        if (ctor) {
          Object.defineProperty(res, "constructor", {
            value: true,
            configurable: true
          });
        }
        if (evalOrigin) {
          res.evalOrigin = evalOrigin;
          res.evalLine = evalLine;
          res.evalColumn = evalCol;
          res.evalFile = evalFile && evalFile.replace(/\\/g, "/");
        }
        if (native) {
          res.native = true;
        }
        if (fname) {
          res.function = fname;
        }
        if (method && fname !== method) {
          res.method = method;
        }
        return res;
      }
    };
    function setFile(result, filename, cwd2) {
      if (filename) {
        filename = filename.replace(/\\/g, "/");
        if (filename.startsWith(`${cwd2}/`)) {
          filename = filename.slice(cwd2.length + 1);
        }
        result.file = filename;
      }
    }
    function ignoredPackagesRegExp(ignoredPackages) {
      if (ignoredPackages.length === 0) {
        return [];
      }
      const packages = ignoredPackages.map((mod) => escapeStringRegexp(mod));
      return new RegExp(`[/\\\\]node_modules[/\\\\](?:${packages.join("|")})[/\\\\][^:]+:\\d+:\\d+`);
    }
    var re = new RegExp(
      "^(?:\\s*at )?(?:(new) )?(?:(.*?) \\()?(?:eval at ([^ ]+) \\((.+?):(\\d+):(\\d+)\\), )?(?:(.+?):(\\d+):(\\d+)|(native))(\\)?)$"
    );
    var methodRe = /^(.*?) \[as (.*?)\]$/;
    module2.exports = StackUtils;
  }
});

// node_modules/is-promise/index.js
var require_is_promise = __commonJS({
  "node_modules/is-promise/index.js"(exports2, module2) {
    "use strict";
    module2.exports = isPromise;
    module2.exports.default = isPromise;
    function isPromise(obj) {
      return !!obj && (typeof obj === "object" || typeof obj === "function") && typeof obj.then === "function";
    }
  }
});

// node_modules/ava/lib/like-selector.js
var require_like_selector = __commonJS({
  "node_modules/ava/lib/like-selector.js"(exports2) {
    "use strict";
    function isLikeSelector(selector) {
      return selector !== null && typeof selector === "object" && Reflect.getPrototypeOf(selector) === Object.prototype && Reflect.ownKeys(selector).length > 0;
    }
    exports2.isLikeSelector = isLikeSelector;
    var CIRCULAR_SELECTOR = new Error("Encountered a circular selector");
    exports2.CIRCULAR_SELECTOR = CIRCULAR_SELECTOR;
    function selectComparable(lhs, selector, circular = /* @__PURE__ */ new Set()) {
      if (circular.has(selector)) {
        throw CIRCULAR_SELECTOR;
      }
      circular.add(selector);
      if (lhs === null || typeof lhs !== "object") {
        return lhs;
      }
      const comparable = {};
      for (const [key, rhs] of Object.entries(selector)) {
        if (isLikeSelector(rhs)) {
          comparable[key] = selectComparable(Reflect.get(lhs, key), rhs, circular);
        } else {
          comparable[key] = Reflect.get(lhs, key);
        }
      }
      return comparable;
    }
    exports2.selectComparable = selectComparable;
  }
});

// node_modules/ava/lib/assert.js
var require_assert = __commonJS({
  "node_modules/ava/lib/assert.js"(exports2) {
    "use strict";
    var concordance = require_concordance();
    var isError = require_is_error();
    var isPromise = require_is_promise();
    var concordanceOptions = require_concordance_options().default;
    var { CIRCULAR_SELECTOR, isLikeSelector, selectComparable } = require_like_selector();
    var snapshotManager = require_snapshot_manager();
    function formatDescriptorDiff(actualDescriptor, expectedDescriptor, options) {
      options = { ...options, ...concordanceOptions };
      return {
        label: "Difference:",
        formatted: concordance.diffDescriptors(actualDescriptor, expectedDescriptor, options)
      };
    }
    function formatDescriptorWithLabel(label, descriptor) {
      return {
        label,
        formatted: concordance.formatDescriptor(descriptor, concordanceOptions)
      };
    }
    function formatWithLabel(label, value2) {
      return formatDescriptorWithLabel(label, concordance.describe(value2, concordanceOptions));
    }
    function formatPowerAssertValue(value2) {
      return concordance.format(value2, concordanceOptions);
    }
    var hasOwnProperty = (object, prop) => Object.prototype.hasOwnProperty.call(object, prop);
    var noop = () => {
    };
    var notImplemented = () => {
      throw new Error("not implemented");
    };
    var AssertionError = class extends Error {
      constructor(options) {
        super(options.message || "");
        this.name = "AssertionError";
        this.assertion = options.assertion;
        this.fixedSource = options.fixedSource;
        this.improperUsage = options.improperUsage || false;
        this.actualStack = options.actualStack;
        this.operator = options.operator;
        this.values = options.values || [];
        this.raw = options.raw;
        this.statements = [];
        if (options.savedError) {
          this.savedError = options.savedError;
        } else {
          this.savedError = getErrorWithLongStackTrace();
        }
      }
    };
    exports2.AssertionError = AssertionError;
    function checkAssertionMessage(assertion, message) {
      if (typeof message === "undefined" || typeof message === "string") {
        return true;
      }
      return new AssertionError({
        assertion,
        improperUsage: true,
        message: "The assertion message must be a string",
        values: [formatWithLabel("Called with:", message)]
      });
    }
    exports2.checkAssertionMessage = checkAssertionMessage;
    function getErrorWithLongStackTrace() {
      const limitBefore = Error.stackTraceLimit;
      Error.stackTraceLimit = Infinity;
      const err = new Error();
      Error.stackTraceLimit = limitBefore;
      return err;
    }
    function validateExpectations(assertion, expectations, numberArgs, experiments) {
      if (numberArgs === 1 || expectations === null || expectations === void 0) {
        if (experiments.disableNullExpectations && expectations === null) {
          throw new AssertionError({
            assertion,
            message: `The second argument to \`t.${assertion}()\` must be an expectation object or \`undefined\``,
            values: [formatWithLabel("Called with:", expectations)]
          });
        }
        expectations = {};
      } else if (typeof expectations === "function" || typeof expectations === "string" || expectations instanceof RegExp || typeof expectations !== "object" || Array.isArray(expectations) || Object.keys(expectations).length === 0) {
        throw new AssertionError({
          assertion,
          message: `The second argument to \`t.${assertion}()\` must be an expectation object, \`null\` or \`undefined\``,
          values: [formatWithLabel("Called with:", expectations)]
        });
      } else {
        if (hasOwnProperty(expectations, "instanceOf") && typeof expectations.instanceOf !== "function") {
          throw new AssertionError({
            assertion,
            message: `The \`instanceOf\` property of the second argument to \`t.${assertion}()\` must be a function`,
            values: [formatWithLabel("Called with:", expectations)]
          });
        }
        if (hasOwnProperty(expectations, "message") && typeof expectations.message !== "string" && !(expectations.message instanceof RegExp)) {
          throw new AssertionError({
            assertion,
            message: `The \`message\` property of the second argument to \`t.${assertion}()\` must be a string or regular expression`,
            values: [formatWithLabel("Called with:", expectations)]
          });
        }
        if (hasOwnProperty(expectations, "name") && typeof expectations.name !== "string") {
          throw new AssertionError({
            assertion,
            message: `The \`name\` property of the second argument to \`t.${assertion}()\` must be a string`,
            values: [formatWithLabel("Called with:", expectations)]
          });
        }
        if (hasOwnProperty(expectations, "code") && typeof expectations.code !== "string" && typeof expectations.code !== "number") {
          throw new AssertionError({
            assertion,
            message: `The \`code\` property of the second argument to \`t.${assertion}()\` must be a string or number`,
            values: [formatWithLabel("Called with:", expectations)]
          });
        }
        for (const key of Object.keys(expectations)) {
          switch (key) {
            case "instanceOf":
            case "is":
            case "message":
            case "name":
            case "code":
              continue;
            default:
              throw new AssertionError({
                assertion,
                message: `The second argument to \`t.${assertion}()\` contains unexpected properties`,
                values: [formatWithLabel("Called with:", expectations)]
              });
          }
        }
      }
      return expectations;
    }
    function assertExpectations({ assertion, actual, expectations, message, prefix, savedError }) {
      if (!isError(actual)) {
        throw new AssertionError({
          assertion,
          message,
          savedError,
          values: [formatWithLabel(`${prefix} exception that is not an error:`, actual)]
        });
      }
      const actualStack = actual.stack;
      if (hasOwnProperty(expectations, "is") && actual !== expectations.is) {
        throw new AssertionError({
          assertion,
          message,
          savedError,
          actualStack,
          values: [
            formatWithLabel(`${prefix} unexpected exception:`, actual),
            formatWithLabel("Expected to be strictly equal to:", expectations.is)
          ]
        });
      }
      if (expectations.instanceOf && !(actual instanceof expectations.instanceOf)) {
        throw new AssertionError({
          assertion,
          message,
          savedError,
          actualStack,
          values: [
            formatWithLabel(`${prefix} unexpected exception:`, actual),
            formatWithLabel("Expected instance of:", expectations.instanceOf)
          ]
        });
      }
      if (typeof expectations.name === "string" && actual.name !== expectations.name) {
        throw new AssertionError({
          assertion,
          message,
          savedError,
          actualStack,
          values: [
            formatWithLabel(`${prefix} unexpected exception:`, actual),
            formatWithLabel("Expected name to equal:", expectations.name)
          ]
        });
      }
      if (typeof expectations.message === "string" && actual.message !== expectations.message) {
        throw new AssertionError({
          assertion,
          message,
          savedError,
          actualStack,
          values: [
            formatWithLabel(`${prefix} unexpected exception:`, actual),
            formatWithLabel("Expected message to equal:", expectations.message)
          ]
        });
      }
      if (expectations.message instanceof RegExp && !expectations.message.test(actual.message)) {
        throw new AssertionError({
          assertion,
          message,
          savedError,
          actualStack,
          values: [
            formatWithLabel(`${prefix} unexpected exception:`, actual),
            formatWithLabel("Expected message to match:", expectations.message)
          ]
        });
      }
      if (typeof expectations.code !== "undefined" && actual.code !== expectations.code) {
        throw new AssertionError({
          assertion,
          message,
          savedError,
          actualStack,
          values: [
            formatWithLabel(`${prefix} unexpected exception:`, actual),
            formatWithLabel("Expected code to equal:", expectations.code)
          ]
        });
      }
    }
    var Assertions = class {
      constructor({
        pass = notImplemented,
        pending = notImplemented,
        fail = notImplemented,
        skip = notImplemented,
        compareWithSnapshot = notImplemented,
        powerAssert,
        experiments = {},
        disableSnapshots = false
      } = {}) {
        const withSkip = (assertionFn) => {
          assertionFn.skip = skip;
          return assertionFn;
        };
        const withPowerAssert = (pattern, assertionFn) => powerAssert.empower(assertionFn, {
          onError: (event) => {
            if (event.powerAssertContext) {
              event.error.statements = powerAssert.format(event.powerAssertContext, formatPowerAssertValue);
            }
            fail(event.error);
          },
          onSuccess: () => {
            pass();
          },
          bindReceiver: false,
          patterns: [pattern]
        });
        const checkMessage = (assertion, message, powerAssert2 = false) => {
          const result = checkAssertionMessage(assertion, message);
          if (result === true) {
            return this.true;
          }
          if (powerAssert2) {
            throw result;
          }
          fail(result);
          return false;
        };
        this.pass = withSkip(() => {
          pass();
        });
        this.fail = withSkip((message) => {
          if (!checkMessage("fail", message)) {
            return;
          }
          fail(new AssertionError({
            assertion: "fail",
            message: message || "Test failed via `t.fail()`"
          }));
        });
        this.is = withSkip((actual, expected, message) => {
          if (!checkMessage("is", message)) {
            return;
          }
          if (Object.is(actual, expected)) {
            pass();
          } else {
            const result = concordance.compare(actual, expected, concordanceOptions);
            const actualDescriptor = result.actual || concordance.describe(actual, concordanceOptions);
            const expectedDescriptor = result.expected || concordance.describe(expected, concordanceOptions);
            if (result.pass) {
              fail(new AssertionError({
                assertion: "is",
                message,
                raw: { actual, expected },
                values: [formatDescriptorWithLabel("Values are deeply equal to each other, but they are not the same:", actualDescriptor)]
              }));
            } else {
              fail(new AssertionError({
                assertion: "is",
                message,
                raw: { actual, expected },
                values: [formatDescriptorDiff(actualDescriptor, expectedDescriptor)]
              }));
            }
          }
        });
        this.not = withSkip((actual, expected, message) => {
          if (!checkMessage("not", message)) {
            return;
          }
          if (Object.is(actual, expected)) {
            fail(new AssertionError({
              assertion: "not",
              message,
              raw: { actual, expected },
              values: [formatWithLabel("Value is the same as:", actual)]
            }));
          } else {
            pass();
          }
        });
        this.deepEqual = withSkip((actual, expected, message) => {
          if (!checkMessage("deepEqual", message)) {
            return;
          }
          const result = concordance.compare(actual, expected, concordanceOptions);
          if (result.pass) {
            pass();
          } else {
            const actualDescriptor = result.actual || concordance.describe(actual, concordanceOptions);
            const expectedDescriptor = result.expected || concordance.describe(expected, concordanceOptions);
            fail(new AssertionError({
              assertion: "deepEqual",
              message,
              raw: { actual, expected },
              values: [formatDescriptorDiff(actualDescriptor, expectedDescriptor)]
            }));
          }
        });
        this.notDeepEqual = withSkip((actual, expected, message) => {
          if (!checkMessage("notDeepEqual", message)) {
            return;
          }
          const result = concordance.compare(actual, expected, concordanceOptions);
          if (result.pass) {
            const actualDescriptor = result.actual || concordance.describe(actual, concordanceOptions);
            fail(new AssertionError({
              assertion: "notDeepEqual",
              message,
              raw: { actual, expected },
              values: [formatDescriptorWithLabel("Value is deeply equal:", actualDescriptor)]
            }));
          } else {
            pass();
          }
        });
        this.like = withSkip((actual, selector, message) => {
          if (!checkMessage("like", message)) {
            return;
          }
          if (!isLikeSelector(selector)) {
            fail(new AssertionError({
              assertion: "like",
              improperUsage: true,
              message: "`t.like()` selector must be a non-empty object",
              values: [formatWithLabel("Called with:", selector)]
            }));
            return;
          }
          let comparable;
          try {
            comparable = selectComparable(actual, selector);
          } catch (error) {
            if (error === CIRCULAR_SELECTOR) {
              fail(new AssertionError({
                assertion: "like",
                improperUsage: true,
                message: "`t.like()` selector must not contain circular references",
                values: [formatWithLabel("Called with:", selector)]
              }));
              return;
            }
            throw error;
          }
          const result = concordance.compare(comparable, selector, concordanceOptions);
          if (result.pass) {
            pass();
          } else {
            const actualDescriptor = result.actual || concordance.describe(comparable, concordanceOptions);
            const expectedDescriptor = result.expected || concordance.describe(selector, concordanceOptions);
            fail(new AssertionError({
              assertion: "like",
              message,
              values: [formatDescriptorDiff(actualDescriptor, expectedDescriptor)]
            }));
          }
        });
        this.throws = withSkip((...args) => {
          let [fn, expectations, message] = args;
          if (!checkMessage("throws", message)) {
            return;
          }
          if (typeof fn !== "function") {
            fail(new AssertionError({
              assertion: "throws",
              improperUsage: true,
              message: "`t.throws()` must be called with a function",
              values: [formatWithLabel("Called with:", fn)]
            }));
            return;
          }
          try {
            expectations = validateExpectations("throws", expectations, args.length, experiments);
          } catch (error) {
            fail(error);
            return;
          }
          let retval;
          let actual = null;
          try {
            retval = fn();
            if (isPromise(retval)) {
              Promise.resolve(retval).catch(noop);
              fail(new AssertionError({
                assertion: "throws",
                message,
                values: [formatWithLabel("Function returned a promise. Use `t.throwsAsync()` instead:", retval)]
              }));
              return;
            }
          } catch (error) {
            actual = error;
          }
          if (!actual) {
            fail(new AssertionError({
              assertion: "throws",
              message,
              values: [formatWithLabel("Function returned:", retval)]
            }));
            return;
          }
          try {
            assertExpectations({
              assertion: "throws",
              actual,
              expectations,
              message,
              prefix: "Function threw"
            });
            pass();
            return actual;
          } catch (error) {
            fail(error);
          }
        });
        this.throwsAsync = withSkip((...args) => {
          let [thrower, expectations, message] = args;
          if (!checkMessage("throwsAsync", message)) {
            return Promise.resolve();
          }
          if (typeof thrower !== "function" && !isPromise(thrower)) {
            fail(new AssertionError({
              assertion: "throwsAsync",
              improperUsage: true,
              message: "`t.throwsAsync()` must be called with a function or promise",
              values: [formatWithLabel("Called with:", thrower)]
            }));
            return Promise.resolve();
          }
          try {
            expectations = validateExpectations("throwsAsync", expectations, args.length, experiments);
          } catch (error) {
            fail(error);
            return Promise.resolve();
          }
          const handlePromise = (promise, wasReturned) => {
            const savedError = getErrorWithLongStackTrace();
            const intermediate = Promise.resolve(promise).then((value2) => {
              throw new AssertionError({
                assertion: "throwsAsync",
                message,
                savedError,
                values: [formatWithLabel(`${wasReturned ? "Returned promise" : "Promise"} resolved with:`, value2)]
              });
            }, (error) => {
              assertExpectations({
                assertion: "throwsAsync",
                actual: error,
                expectations,
                message,
                prefix: `${wasReturned ? "Returned promise" : "Promise"} rejected with`,
                savedError
              });
              return error;
            });
            pending(intermediate);
            return intermediate.catch(noop);
          };
          if (isPromise(thrower)) {
            return handlePromise(thrower, false);
          }
          let retval;
          let actual = null;
          try {
            retval = thrower();
          } catch (error) {
            actual = error;
          }
          if (actual) {
            fail(new AssertionError({
              assertion: "throwsAsync",
              message,
              actualStack: actual.stack,
              values: [formatWithLabel("Function threw synchronously. Use `t.throws()` instead:", actual)]
            }));
            return Promise.resolve();
          }
          if (isPromise(retval)) {
            return handlePromise(retval, true);
          }
          fail(new AssertionError({
            assertion: "throwsAsync",
            message,
            values: [formatWithLabel("Function returned:", retval)]
          }));
          return Promise.resolve();
        });
        this.notThrows = withSkip((fn, message) => {
          if (!checkMessage("notThrows", message)) {
            return;
          }
          if (typeof fn !== "function") {
            fail(new AssertionError({
              assertion: "notThrows",
              improperUsage: true,
              message: "`t.notThrows()` must be called with a function",
              values: [formatWithLabel("Called with:", fn)]
            }));
            return;
          }
          try {
            fn();
          } catch (error) {
            fail(new AssertionError({
              assertion: "notThrows",
              message,
              actualStack: error.stack,
              values: [formatWithLabel("Function threw:", error)]
            }));
            return;
          }
          pass();
        });
        this.notThrowsAsync = withSkip((nonThrower, message) => {
          if (!checkMessage("notThrowsAsync", message)) {
            return Promise.resolve();
          }
          if (typeof nonThrower !== "function" && !isPromise(nonThrower)) {
            fail(new AssertionError({
              assertion: "notThrowsAsync",
              improperUsage: true,
              message: "`t.notThrowsAsync()` must be called with a function or promise",
              values: [formatWithLabel("Called with:", nonThrower)]
            }));
            return Promise.resolve();
          }
          const handlePromise = (promise, wasReturned) => {
            const savedError = getErrorWithLongStackTrace();
            const intermediate = Promise.resolve(promise).then(noop, (error) => {
              throw new AssertionError({
                assertion: "notThrowsAsync",
                message,
                savedError,
                values: [formatWithLabel(`${wasReturned ? "Returned promise" : "Promise"} rejected with:`, error)]
              });
            });
            pending(intermediate);
            return intermediate.catch(noop);
          };
          if (isPromise(nonThrower)) {
            return handlePromise(nonThrower, false);
          }
          let retval;
          try {
            retval = nonThrower();
          } catch (error) {
            fail(new AssertionError({
              assertion: "notThrowsAsync",
              message,
              actualStack: error.stack,
              values: [formatWithLabel("Function threw:", error)]
            }));
            return Promise.resolve();
          }
          if (!isPromise(retval)) {
            fail(new AssertionError({
              assertion: "notThrowsAsync",
              message,
              values: [formatWithLabel("Function did not return a promise. Use `t.notThrows()` instead:", retval)]
            }));
            return Promise.resolve();
          }
          return handlePromise(retval, true);
        });
        this.snapshot = withSkip((expected, ...rest) => {
          if (disableSnapshots && experiments.disableSnapshotsInHooks) {
            fail(new AssertionError({
              assertion: "snapshot",
              message: "`t.snapshot()` can only be used in tests",
              improperUsage: true
            }));
            return;
          }
          let message;
          let snapshotOptions;
          if (rest.length > 1) {
            [snapshotOptions, message] = rest;
          } else {
            const [optionsOrMessage] = rest;
            if (typeof optionsOrMessage === "object") {
              snapshotOptions = optionsOrMessage;
            } else {
              message = optionsOrMessage;
            }
          }
          if (!checkMessage("snapshot", message)) {
            return;
          }
          let result;
          try {
            result = compareWithSnapshot({
              expected,
              id: snapshotOptions ? snapshotOptions.id : void 0,
              message
            });
          } catch (error) {
            if (!(error instanceof snapshotManager.SnapshotError)) {
              throw error;
            }
            const improperUsage = { name: error.name, snapPath: error.snapPath };
            if (error instanceof snapshotManager.VersionMismatchError) {
              improperUsage.snapVersion = error.snapVersion;
              improperUsage.expectedVersion = error.expectedVersion;
            }
            fail(new AssertionError({
              assertion: "snapshot",
              message: message || "Could not compare snapshot",
              improperUsage
            }));
            return;
          }
          if (result.pass) {
            pass();
          } else if (result.actual) {
            fail(new AssertionError({
              assertion: "snapshot",
              message: message || "Did not match snapshot",
              values: [formatDescriptorDiff(result.actual, result.expected, { invert: true })]
            }));
          } else {
            fail(new AssertionError({
              assertion: "snapshot",
              message: message || "No snapshot available \u2014 new snapshots are not created in CI environments"
            }));
          }
        });
        this.truthy = withSkip((actual, message) => {
          if (!checkMessage("truthy", message)) {
            return;
          }
          if (actual) {
            pass();
          } else {
            fail(new AssertionError({
              assertion: "truthy",
              message,
              operator: "!!",
              values: [formatWithLabel("Value is not truthy:", actual)]
            }));
          }
        });
        this.falsy = withSkip((actual, message) => {
          if (!checkMessage("falsy", message)) {
            return;
          }
          if (actual) {
            fail(new AssertionError({
              assertion: "falsy",
              message,
              operator: "!",
              values: [formatWithLabel("Value is not falsy:", actual)]
            }));
          } else {
            pass();
          }
        });
        this.true = withSkip((actual, message) => {
          if (!checkMessage("true", message)) {
            return;
          }
          if (actual === true) {
            pass();
          } else {
            fail(new AssertionError({
              assertion: "true",
              message,
              values: [formatWithLabel("Value is not `true`:", actual)]
            }));
          }
        });
        this.false = withSkip((actual, message) => {
          if (!checkMessage("false", message)) {
            return;
          }
          if (actual === false) {
            pass();
          } else {
            fail(new AssertionError({
              assertion: "false",
              message,
              values: [formatWithLabel("Value is not `false`:", actual)]
            }));
          }
        });
        this.regex = withSkip((string, regex, message) => {
          if (!checkMessage("regex", message)) {
            return;
          }
          if (typeof string !== "string") {
            fail(new AssertionError({
              assertion: "regex",
              improperUsage: true,
              message: "`t.regex()` must be called with a string",
              values: [formatWithLabel("Called with:", string)]
            }));
            return;
          }
          if (!(regex instanceof RegExp)) {
            fail(new AssertionError({
              assertion: "regex",
              improperUsage: true,
              message: "`t.regex()` must be called with a regular expression",
              values: [formatWithLabel("Called with:", regex)]
            }));
            return;
          }
          if (!regex.test(string)) {
            fail(new AssertionError({
              assertion: "regex",
              message,
              values: [
                formatWithLabel("Value must match expression:", string),
                formatWithLabel("Regular expression:", regex)
              ]
            }));
            return;
          }
          pass();
        });
        this.notRegex = withSkip((string, regex, message) => {
          if (!checkMessage("notRegex", message)) {
            return;
          }
          if (typeof string !== "string") {
            fail(new AssertionError({
              assertion: "notRegex",
              improperUsage: true,
              message: "`t.notRegex()` must be called with a string",
              values: [formatWithLabel("Called with:", string)]
            }));
            return;
          }
          if (!(regex instanceof RegExp)) {
            fail(new AssertionError({
              assertion: "notRegex",
              improperUsage: true,
              message: "`t.notRegex()` must be called with a regular expression",
              values: [formatWithLabel("Called with:", regex)]
            }));
            return;
          }
          if (regex.test(string)) {
            fail(new AssertionError({
              assertion: "notRegex",
              message,
              values: [
                formatWithLabel("Value must not match expression:", string),
                formatWithLabel("Regular expression:", regex)
              ]
            }));
            return;
          }
          pass();
        });
        if (powerAssert === void 0) {
          this.assert = withSkip((actual, message) => {
            if (!checkMessage("assert", message)) {
              return;
            }
            if (!actual) {
              fail(new AssertionError({
                assertion: "assert",
                message,
                operator: "!!",
                values: [formatWithLabel("Value is not truthy:", actual)]
              }));
              return;
            }
            pass();
          });
        } else {
          this.assert = withSkip(
            withPowerAssert(
              "assert(value, [message])",
              (actual, message) => {
                checkMessage("assert", message, true);
                if (!actual) {
                  throw new AssertionError({
                    assertion: "assert",
                    message,
                    operator: "!!",
                    values: [formatWithLabel("Value is not truthy:", actual)]
                  });
                }
              }
            )
          );
        }
      }
    };
    exports2.Assertions = Assertions;
  }
});

// node_modules/ava/lib/serialize-error.js
var require_serialize_error = __commonJS({
  "node_modules/ava/lib/serialize-error.js"(exports2, module2) {
    "use strict";
    var path = require("path");
    var cleanYamlObject = require_clean_yaml_object();
    var concordance = require_concordance();
    var isError = require_is_error();
    var slash = require_slash();
    var StackUtils = require_stack_utils();
    var assert = require_assert();
    var concordanceOptions = require_concordance_options().default;
    function isAvaAssertionError(source) {
      return source instanceof assert.AssertionError;
    }
    function filter(propertyName, isRoot) {
      return !isRoot || propertyName !== "message" && propertyName !== "name" && propertyName !== "stack";
    }
    var stackUtils = new StackUtils();
    function extractSource(stack, testFile) {
      if (!stack || !testFile) {
        return null;
      }
      const relFile = path.relative(process.cwd(), testFile);
      const normalizedFile = process.platform === "win32" ? slash(relFile) : relFile;
      for (const line of stack.split("\n")) {
        try {
          const callSite = stackUtils.parseLine(line);
          if (callSite.file === normalizedFile) {
            return {
              isDependency: false,
              isWithinProject: true,
              file: path.resolve(process.cwd(), callSite.file),
              line: callSite.line
            };
          }
        } catch {
        }
      }
      return null;
    }
    function buildSource(source) {
      if (!source) {
        return null;
      }
      const projectDir = process.cwd();
      const file = path.resolve(projectDir, source.file.trim());
      const rel = path.relative(projectDir, file);
      const [segment] = rel.split(path.sep);
      const isWithinProject = segment !== ".." && (process.platform !== "win32" || !segment.includes(":"));
      const isDependency = isWithinProject && path.dirname(rel).split(path.sep).includes("node_modules");
      return {
        isDependency,
        isWithinProject,
        file,
        line: source.line
      };
    }
    function trySerializeError(err, shouldBeautifyStack, testFile) {
      const stack = err.savedError ? err.savedError.stack : err.stack;
      const retval = {
        avaAssertionError: isAvaAssertionError(err),
        nonErrorObject: false,
        source: extractSource(stack, testFile),
        stack,
        shouldBeautifyStack
      };
      if (err.actualStack) {
        retval.stack = err.actualStack;
      }
      if (retval.avaAssertionError) {
        retval.improperUsage = err.improperUsage;
        retval.message = err.message;
        retval.name = err.name;
        retval.statements = err.statements;
        retval.values = err.values;
        if (err.fixedSource) {
          const source = buildSource(err.fixedSource);
          if (source) {
            retval.source = source;
          }
        }
        if (err.assertion) {
          retval.assertion = err.assertion;
        }
        if (err.operator) {
          retval.operator = err.operator;
        }
      } else {
        retval.object = cleanYamlObject(err, filter);
        if (typeof err.message === "string") {
          retval.message = err.message;
        }
        if (typeof err.name === "string") {
          retval.name = err.name;
        }
      }
      if (typeof err.stack === "string") {
        const lines = err.stack.split("\n");
        if (err.name === "SyntaxError" && !lines[0].startsWith("SyntaxError")) {
          retval.summary = "";
          for (const line of lines) {
            retval.summary += line + "\n";
            if (line.startsWith("SyntaxError")) {
              break;
            }
          }
          retval.summary = retval.summary.trim();
        } else {
          const start = lines.findIndex((line) => !/:\d+$/.test(line));
          retval.summary = "";
          for (let index = start; index < lines.length; index++) {
            if (lines[index].startsWith("    at")) {
              break;
            }
            const next = index + 1;
            const end = next === lines.length || lines[next].startsWith("    at");
            retval.summary += end ? lines[index] : lines[index] + "\n";
          }
        }
      }
      return retval;
    }
    function serializeError(origin, shouldBeautifyStack, err, testFile) {
      if (!isError(err)) {
        return {
          avaAssertionError: false,
          nonErrorObject: true,
          formatted: concordance.formatDescriptor(concordance.describe(err, concordanceOptions), concordanceOptions)
        };
      }
      try {
        return trySerializeError(err, shouldBeautifyStack, testFile);
      } catch {
        const replacement = new Error(`${origin}: Could not serialize error`);
        return {
          avaAssertionError: false,
          nonErrorObject: false,
          name: replacement.name,
          message: replacement.message,
          stack: replacement.stack,
          summary: replacement.message
        };
      }
    }
    module2.exports = serializeError;
  }
});

// node_modules/irregular-plurals/irregular-plurals.json
var require_irregular_plurals = __commonJS({
  "node_modules/irregular-plurals/irregular-plurals.json"(exports2, module2) {
    module2.exports = {
      addendum: "addenda",
      aircraft: "aircraft",
      alga: "algae",
      alumna: "alumnae",
      alumnus: "alumni",
      alveolus: "alveoli",
      amoeba: "amoebae",
      analysis: "analyses",
      antenna: "antennae",
      antithesis: "antitheses",
      apex: "apices",
      appendix: "appendices",
      automaton: "automata",
      axis: "axes",
      bacillus: "bacilli",
      bacterium: "bacteria",
      baculum: "bacula",
      barracks: "barracks",
      basis: "bases",
      beau: "beaux",
      bison: "bison",
      buffalo: "buffalo",
      bureau: "bureaus",
      cactus: "cacti",
      calf: "calves",
      carcinoma: "carcinomata",
      carp: "carp",
      census: "censuses",
      chassis: "chassis",
      cherub: "cherubim",
      child: "children",
      ch\u00E2teau: "ch\xE2teaus",
      cloaca: "cloacae",
      cod: "cod",
      codex: "codices",
      concerto: "concerti",
      consortium: "consortia",
      corpus: "corpora",
      crisis: "crises",
      criterion: "criteria",
      curriculum: "curricula",
      cystoma: "cystomata",
      datum: "data",
      deer: "deer",
      diagnosis: "diagnoses",
      die: "dice",
      dwarf: "dwarfs",
      echo: "echoes",
      elf: "elves",
      elk: "elk",
      ellipsis: "ellipses",
      embargo: "embargoes",
      emphasis: "emphases",
      erratum: "errata",
      "faux pas": "faux pas",
      fez: "fezes",
      firmware: "firmware",
      fish: "fish",
      focus: "foci",
      foot: "feet",
      formula: "formulae",
      fungus: "fungi",
      gallows: "gallows",
      genus: "genera",
      glomerulus: "glomeruli",
      goose: "geese",
      graffito: "graffiti",
      grouse: "grouse",
      half: "halves",
      hamulus: "hamuli",
      hero: "heroes",
      hippopotamus: "hippopotami",
      hoof: "hooves",
      hovercraft: "hovercraft",
      hypothesis: "hypotheses",
      iliac: "ilia",
      incubus: "incubi",
      index: "indices",
      interstitium: "interstitia",
      kakapo: "kakapo",
      knife: "knives",
      larva: "larvae",
      leaf: "leaves",
      libretto: "libretti",
      life: "lives",
      loaf: "loaves",
      loculus: "loculi",
      locus: "loci",
      louse: "lice",
      man: "men",
      matrix: "matrices",
      means: "means",
      measles: "measles",
      media: "media",
      medium: "media",
      memorandum: "memoranda",
      millennium: "millennia",
      minutia: "minutiae",
      moose: "moose",
      mouse: "mice",
      nebula: "nebulae",
      nemesis: "nemeses",
      neurosis: "neuroses",
      news: "news",
      nucleolus: "nucleoli",
      nucleus: "nuclei",
      oasis: "oases",
      occiput: "occipita",
      offspring: "offspring",
      omphalos: "omphaloi",
      opus: "opera",
      ovum: "ova",
      ox: "oxen",
      paralysis: "paralyses",
      parenthesis: "parentheses",
      person: "people",
      phenomenon: "phenomena",
      phylum: "phyla",
      pike: "pike",
      polyhedron: "polyhedra",
      potato: "potatoes",
      primus: "primi",
      prognosis: "prognoses",
      quiz: "quizzes",
      radius: "radii",
      referendum: "referenda",
      salmon: "salmon",
      scarf: "scarves",
      scrotum: "scrota",
      self: "selves",
      seminoma: "seminomata",
      series: "series",
      sheep: "sheep",
      shelf: "shelves",
      shrimp: "shrimp",
      simulacrum: "simulacra",
      soliloquy: "soliloquies",
      spacecraft: "spacecraft",
      species: "species",
      spectrum: "spectra",
      squid: "squid",
      stimulus: "stimuli",
      stratum: "strata",
      swine: "swine",
      syconium: "syconia",
      syllabus: "syllabi",
      symposium: "symposia",
      synopsis: "synopses",
      synthesis: "syntheses",
      tableau: "tableaus",
      testis: "testes",
      that: "those",
      thesis: "theses",
      thief: "thieves",
      this: "these",
      thrombus: "thrombi",
      tomato: "tomatoes",
      tooth: "teeth",
      torus: "tori",
      trout: "trout",
      tuna: "tuna",
      umbilicus: "umbilici",
      uterus: "uteri",
      vertebra: "vertebrae",
      vertex: "vertices",
      veto: "vetoes",
      vita: "vitae",
      vortex: "vortices",
      watercraft: "watercraft",
      wharf: "wharves",
      wife: "wives",
      wolf: "wolves",
      woman: "women"
    };
  }
});

// node_modules/irregular-plurals/index.js
var require_irregular_plurals2 = __commonJS({
  "node_modules/irregular-plurals/index.js"(exports2, module2) {
    "use strict";
    var irregularPlurals = require_irregular_plurals();
    module2.exports = new Map(Object.entries(irregularPlurals));
  }
});

// node_modules/plur/index.js
var require_plur = __commonJS({
  "node_modules/plur/index.js"(exports2, module2) {
    "use strict";
    var irregularPlurals = require_irregular_plurals2();
    module2.exports = (word, plural, count) => {
      if (typeof plural === "number") {
        count = plural;
      }
      if (irregularPlurals.has(word.toLowerCase())) {
        plural = irregularPlurals.get(word.toLowerCase());
        const firstLetter = word.charAt(0);
        const isFirstLetterUpperCase = firstLetter === firstLetter.toUpperCase();
        if (isFirstLetterUpperCase) {
          plural = firstLetter.toUpperCase() + plural.slice(1);
        }
        const isWholeWordUpperCase = word === word.toUpperCase();
        if (isWholeWordUpperCase) {
          plural = plural.toUpperCase();
        }
      } else if (typeof plural !== "string") {
        plural = (word.replace(/(?:s|x|z|ch|sh)$/i, "$&e").replace(/([^aeiou])y$/i, "$1ie") + "s").replace(/i?e?s$/i, (match) => {
          const isTailLowerCase = word.slice(-1) === word.slice(-1).toLowerCase();
          return isTailLowerCase ? match.toLowerCase() : match.toUpperCase();
        });
      }
      return Math.abs(count) === 1 ? word : plural;
    };
  }
});

// node_modules/ava/lib/test.js
var require_test = __commonJS({
  "node_modules/ava/lib/test.js"(exports2, module2) {
    "use strict";
    var concordance = require_concordance();
    var isPromise = require_is_promise();
    var plur = require_plur();
    var assert = require_assert();
    var nowAndTimers = require_now_and_timers();
    var parseTestArgs = require_parse_test_args();
    var concordanceOptions = require_concordance_options().default;
    function formatErrorValue(label, error) {
      const formatted = concordance.format(error, concordanceOptions);
      return { label, formatted };
    }
    var captureSavedError = () => {
      const limitBefore = Error.stackTraceLimit;
      Error.stackTraceLimit = 1;
      const err = new Error();
      Error.stackTraceLimit = limitBefore;
      return err;
    };
    var testMap = /* @__PURE__ */ new WeakMap();
    var ExecutionContext = class extends assert.Assertions {
      constructor(test) {
        super({
          pass: () => {
            test.countPassedAssertion();
          },
          pending: (promise) => {
            test.addPendingAssertion(promise);
          },
          fail: (err) => {
            test.addFailedAssertion(err);
          },
          skip: () => {
            test.countPassedAssertion();
          },
          compareWithSnapshot: (options) => {
            return test.compareWithSnapshot(options);
          },
          powerAssert: test.powerAssert,
          experiments: test.experiments,
          disableSnapshots: test.isHook === true
        });
        testMap.set(this, test);
        this.snapshot.skip = () => {
          test.skipSnapshot();
        };
        this.log = (...inputArgs) => {
          const args = inputArgs.map((value2) => {
            return typeof value2 === "string" ? value2 : concordance.format(value2, concordanceOptions);
          });
          if (args.length > 0) {
            test.addLog(args.join(" "));
          }
        };
        this.plan = (count) => {
          test.plan(count, captureSavedError());
        };
        this.plan.skip = () => {
        };
        this.timeout = (ms, message) => {
          test.timeout(ms, message);
        };
        this.teardown = (callback) => {
          test.addTeardown(callback);
        };
        this.try = async (...attemptArgs) => {
          if (test.isHook) {
            const error = new Error("`t.try()` can only be used in tests");
            test.saveFirstError(error);
            throw error;
          }
          const { args, buildTitle, implementations, receivedImplementationArray } = parseTestArgs(attemptArgs);
          if (implementations.length === 0) {
            throw new TypeError("Expected an implementation.");
          }
          const attemptPromises = implementations.map((implementation, index) => {
            let { title, isSet, isValid, isEmpty } = buildTitle(implementation);
            if (!isSet || isEmpty) {
              title = `${test.title} \u2500 attempt ${test.attemptCount + 1 + index}`;
            } else if (isValid) {
              title = `${test.title} \u2500 ${title}`;
            } else {
              throw new TypeError("`t.try()` titles must be strings");
            }
            if (!test.registerUniqueTitle(title)) {
              throw new Error(`Duplicate test title: ${title}`);
            }
            return { implementation, title };
          }).map(async ({ implementation, title }) => {
            let committed = false;
            let discarded = false;
            const { assertCount, deferredSnapshotRecordings, errors, logs, passed, snapshotCount, startingSnapshotCount } = await test.runAttempt(title, (t) => implementation(t, ...args));
            return {
              errors,
              logs: [...logs],
              // Don't allow modification of logs.
              passed,
              title,
              commit: ({ retainLogs = true } = {}) => {
                if (committed) {
                  return;
                }
                if (discarded) {
                  test.saveFirstError(new Error("Can\u2019t commit a result that was previously discarded"));
                  return;
                }
                committed = true;
                test.finishAttempt({
                  assertCount,
                  commit: true,
                  deferredSnapshotRecordings,
                  errors,
                  logs,
                  passed,
                  retainLogs,
                  snapshotCount,
                  startingSnapshotCount
                });
              },
              discard: ({ retainLogs = false } = {}) => {
                if (committed) {
                  test.saveFirstError(new Error("Can\u2019t discard a result that was previously committed"));
                  return;
                }
                if (discarded) {
                  return;
                }
                discarded = true;
                test.finishAttempt({
                  assertCount: 0,
                  commit: false,
                  deferredSnapshotRecordings,
                  errors,
                  logs,
                  passed,
                  retainLogs,
                  snapshotCount,
                  startingSnapshotCount
                });
              }
            };
          });
          const results = await Promise.all(attemptPromises);
          return receivedImplementationArray ? results : results[0];
        };
      }
      get end() {
        const end = testMap.get(this).bindEndCallback();
        const endFn = (error) => end(error, captureSavedError());
        return endFn;
      }
      get title() {
        return testMap.get(this).title;
      }
      get context() {
        return testMap.get(this).contextRef.get();
      }
      set context(context) {
        testMap.get(this).contextRef.set(context);
      }
      get passed() {
        const test = testMap.get(this);
        return test.isHook ? test.testPassed : !test.assertError;
      }
      _throwsArgStart(assertion, file, line) {
        testMap.get(this).trackThrows({ assertion, file, line });
      }
      _throwsArgEnd() {
        testMap.get(this).trackThrows(null);
      }
    };
    var Test = class _Test {
      constructor(options) {
        this.contextRef = options.contextRef;
        this.experiments = options.experiments || {};
        this.failWithoutAssertions = options.failWithoutAssertions;
        this.fn = options.fn;
        this.isHook = options.isHook === true;
        this.metadata = options.metadata;
        this.powerAssert = options.powerAssert;
        this.title = options.title;
        this.testPassed = options.testPassed;
        this.registerUniqueTitle = options.registerUniqueTitle;
        this.logs = [];
        this.teardowns = [];
        const { snapshotBelongsTo = this.title, nextSnapshotIndex = 0 } = options;
        this.snapshotBelongsTo = snapshotBelongsTo;
        this.nextSnapshotIndex = nextSnapshotIndex;
        this.snapshotCount = 0;
        const deferRecording = this.metadata.inline;
        this.deferredSnapshotRecordings = [];
        this.compareWithSnapshot = ({ expected, id, message }) => {
          this.snapshotCount++;
          const belongsTo = id || snapshotBelongsTo;
          const index = id ? 0 : this.nextSnapshotIndex++;
          const label = id ? "" : message || `Snapshot ${index + 1}`;
          const { taskIndex, associatedTaskIndex } = this.metadata;
          const { record, ...result } = options.compareTestSnapshot({
            belongsTo,
            deferRecording,
            expected,
            index,
            label,
            taskIndex,
            snapIndex: this.snapshotCount,
            associatedTaskIndex
          });
          if (record) {
            this.deferredSnapshotRecordings.push(record);
          }
          return result;
        };
        this.skipSnapshot = () => {
          if (typeof options.skipSnapshot === "function") {
            options.skipSnapshot();
          }
          if (options.updateSnapshots) {
            this.addFailedAssertion(new Error("Snapshot assertions cannot be skipped when updating snapshots"));
          } else {
            this.nextSnapshotIndex++;
            this.snapshotCount++;
            this.countPassedAssertion();
          }
        };
        this.runAttempt = async (title, fn) => {
          if (this.finishing) {
            this.saveFirstError(new Error("Running a `t.try()`, but the test has already finished"));
          }
          this.attemptCount++;
          this.pendingAttemptCount++;
          const { contextRef, snapshotBelongsTo: snapshotBelongsTo2, nextSnapshotIndex: nextSnapshotIndex2, snapshotCount: startingSnapshotCount } = this;
          const attempt = new _Test({
            ...options,
            fn,
            metadata: { ...options.metadata, callback: false, failing: false, inline: true },
            contextRef: contextRef.copy(),
            snapshotBelongsTo: snapshotBelongsTo2,
            nextSnapshotIndex: nextSnapshotIndex2,
            title
          });
          const { deferredSnapshotRecordings, error, logs, passed, assertCount, snapshotCount } = await attempt.run();
          const errors = error ? [error] : [];
          return { assertCount, deferredSnapshotRecordings, errors, logs, passed, snapshotCount, startingSnapshotCount };
        };
        this.assertCount = 0;
        this.assertError = void 0;
        this.attemptCount = 0;
        this.calledEnd = false;
        this.duration = null;
        this.endCallbackFinisher = null;
        this.finishDueToAttributedError = null;
        this.finishDueToInactivity = null;
        this.finishDueToTimeout = null;
        this.finishing = false;
        this.pendingAssertionCount = 0;
        this.pendingAttemptCount = 0;
        this.pendingThrowsAssertion = null;
        this.planCount = null;
        this.startedAt = 0;
        this.timeoutMs = 0;
        this.timeoutTimer = null;
      }
      bindEndCallback() {
        if (this.metadata.callback) {
          return (error, savedError) => {
            this.endCallback(error, savedError);
          };
        }
        const error_ = this.metadata.inline ? new Error("`t.end()` is not supported inside `t.try()`") : new Error('`t.end()` is not supported in this context. To use `t.end()` as a callback, you must use "callback mode" via `test.cb(testName, fn)`');
        throw error_;
      }
      endCallback(error, savedError) {
        if (this.calledEnd) {
          this.saveFirstError(new Error("`t.end()` called more than once"));
          return;
        }
        this.calledEnd = true;
        if (error) {
          this.saveFirstError(new assert.AssertionError({
            actual: error,
            message: "Callback called with an error",
            savedError,
            values: [formatErrorValue("Callback called with an error:", error)]
          }));
        }
        if (this.endCallbackFinisher) {
          this.endCallbackFinisher();
        }
      }
      createExecutionContext() {
        return new ExecutionContext(this);
      }
      countPassedAssertion() {
        if (this.finishing) {
          this.saveFirstError(new Error("Assertion passed, but test has already finished"));
        }
        if (this.pendingAttemptCount > 0) {
          this.saveFirstError(new Error("Assertion passed, but an attempt is pending. Use the attempt\u2019s assertions instead"));
        }
        this.assertCount++;
        this.refreshTimeout();
      }
      addLog(text) {
        this.logs.push(text);
      }
      addPendingAssertion(promise) {
        if (this.finishing) {
          this.saveFirstError(new Error("Assertion started, but test has already finished"));
        }
        if (this.pendingAttemptCount > 0) {
          this.saveFirstError(new Error("Assertion started, but an attempt is pending. Use the attempt\u2019s assertions instead"));
        }
        this.assertCount++;
        this.pendingAssertionCount++;
        this.refreshTimeout();
        promise.catch((error) => this.saveFirstError(error)).then(() => {
          this.pendingAssertionCount--;
          this.refreshTimeout();
        });
      }
      addFailedAssertion(error) {
        if (this.finishing) {
          this.saveFirstError(new Error("Assertion failed, but test has already finished"));
        }
        if (this.pendingAttemptCount > 0) {
          this.saveFirstError(new Error("Assertion failed, but an attempt is pending. Use the attempt\u2019s assertions instead"));
        }
        this.assertCount++;
        this.refreshTimeout();
        this.saveFirstError(error);
      }
      finishAttempt({ commit, deferredSnapshotRecordings, errors, logs, passed, retainLogs, snapshotCount, startingSnapshotCount }) {
        if (this.finishing) {
          if (commit) {
            this.saveFirstError(new Error("`t.try()` result was committed, but the test has already finished"));
          } else {
            this.saveFirstError(new Error("`t.try()` result was discarded, but the test has already finished"));
          }
        }
        if (commit) {
          this.assertCount++;
          if (startingSnapshotCount === this.snapshotCount) {
            this.snapshotCount += snapshotCount;
            this.nextSnapshotIndex += snapshotCount;
            for (const record of deferredSnapshotRecordings) {
              record();
            }
          } else {
            this.saveFirstError(new Error("Cannot commit `t.try()` result. Do not run concurrent snapshot assertions when using `t.try()`"));
          }
        }
        this.pendingAttemptCount--;
        if (commit && !passed) {
          this.saveFirstError(errors[0]);
        }
        if (retainLogs) {
          for (const log of logs) {
            this.addLog(log);
          }
        }
        this.refreshTimeout();
      }
      saveFirstError(error) {
        if (!this.assertError) {
          this.assertError = error;
        }
      }
      plan(count, planError) {
        if (typeof count !== "number") {
          throw new TypeError("Expected a number");
        }
        this.planCount = count;
        this.planError = planError;
      }
      timeout(ms, message) {
        const result = assert.checkAssertionMessage("timeout", message);
        if (result !== true) {
          this.saveFirstError(result);
          message = "";
        }
        if (this.finishing) {
          return;
        }
        this.clearTimeout();
        this.timeoutMs = ms;
        this.timeoutTimer = nowAndTimers.setTimeout(() => {
          this.saveFirstError(new Error(message || "Test timeout exceeded"));
          if (this.finishDueToTimeout) {
            this.finishDueToTimeout();
          }
        }, ms);
      }
      refreshTimeout() {
        if (!this.timeoutTimer) {
          return;
        }
        if (this.timeoutTimer.refresh) {
          this.timeoutTimer.refresh();
        } else {
          this.timeout(this.timeoutMs);
        }
      }
      clearTimeout() {
        nowAndTimers.clearTimeout(this.timeoutTimer);
        this.timeoutTimer = null;
      }
      addTeardown(callback) {
        if (this.isHook) {
          this.saveFirstError(new Error("`t.teardown()` is not allowed in hooks"));
          return;
        }
        if (this.finishing) {
          this.saveFirstError(new Error("`t.teardown()` cannot be used during teardown"));
          return;
        }
        if (typeof callback !== "function") {
          throw new TypeError("Expected a function");
        }
        this.teardowns.push(callback);
      }
      async runTeardowns() {
        const teardowns = [...this.teardowns];
        if (this.experiments.reverseTeardowns) {
          teardowns.reverse();
        }
        for (const teardown of teardowns) {
          try {
            await teardown();
          } catch (error) {
            this.saveFirstError(error);
          }
        }
      }
      verifyPlan() {
        if (!this.assertError && this.planCount !== null && this.planCount !== this.assertCount) {
          this.saveFirstError(new assert.AssertionError({
            assertion: "plan",
            message: `Planned for ${this.planCount} ${plur("assertion", this.planCount)}, but got ${this.assertCount}.`,
            operator: "===",
            savedError: this.planError
          }));
        }
      }
      verifyAssertions() {
        if (this.assertError) {
          return;
        }
        if (this.pendingAttemptCount > 0) {
          this.saveFirstError(new Error("Test finished, but not all attempts were committed or discarded"));
          return;
        }
        if (this.pendingAssertionCount > 0) {
          this.saveFirstError(new Error("Test finished, but an assertion is still pending"));
          return;
        }
        if (this.failWithoutAssertions) {
          if (this.planCount !== null) {
            return;
          }
          if (this.assertCount === 0 && !this.calledEnd) {
            this.saveFirstError(new Error("Test finished without running any assertions"));
          }
        }
      }
      trackThrows(pending) {
        this.pendingThrowsAssertion = pending;
      }
      detectImproperThrows(error) {
        if (!this.pendingThrowsAssertion) {
          return false;
        }
        const pending = this.pendingThrowsAssertion;
        this.pendingThrowsAssertion = null;
        const values = [];
        if (error) {
          values.push(formatErrorValue(`The following error was thrown, possibly before \`t.${pending.assertion}()\` could be called:`, error));
        }
        this.saveFirstError(new assert.AssertionError({
          assertion: pending.assertion,
          fixedSource: { file: pending.file, line: pending.line },
          improperUsage: true,
          message: `Improper usage of \`t.${pending.assertion}()\` detected`,
          savedError: error instanceof Error && error,
          values
        }));
        return true;
      }
      waitForPendingThrowsAssertion() {
        return new Promise((resolve) => {
          this.finishDueToAttributedError = () => {
            resolve(this.finish());
          };
          this.finishDueToInactivity = () => {
            this.detectImproperThrows();
            resolve(this.finish());
          };
          nowAndTimers.setTimeout(() => this.finishDueToInactivity(), 1e3).unref();
        });
      }
      attributeLeakedError(error) {
        if (!this.detectImproperThrows(error)) {
          return false;
        }
        this.finishDueToAttributedError();
        return true;
      }
      callFn() {
        try {
          return {
            ok: true,
            retval: this.fn.call(null, this.createExecutionContext())
          };
        } catch (error) {
          return {
            ok: false,
            error
          };
        }
      }
      run() {
        this.startedAt = nowAndTimers.now();
        const result = this.callFn();
        if (!result.ok) {
          if (!this.detectImproperThrows(result.error)) {
            this.saveFirstError(new assert.AssertionError({
              message: "Error thrown in test",
              savedError: result.error instanceof Error && result.error,
              values: [formatErrorValue("Error thrown in test:", result.error)]
            }));
          }
          return this.finish();
        }
        const returnedObservable = result.retval !== null && typeof result.retval === "object" && typeof result.retval.subscribe === "function";
        const returnedPromise = isPromise(result.retval);
        let promise;
        if (returnedObservable) {
          promise = new Promise((resolve, reject) => {
            result.retval.subscribe({
              error: reject,
              complete: () => resolve()
            });
          });
        } else if (returnedPromise) {
          promise = Promise.resolve(result.retval);
        }
        if (this.metadata.callback) {
          if (returnedObservable || returnedPromise) {
            const asyncType = returnedObservable ? "observables" : "promises";
            this.saveFirstError(new Error(`Do not return ${asyncType} from tests declared via \`test.cb(\u2026)\`. Use \`test.cb(\u2026)\` for legacy callback APIs. When using promises, observables or async functions, use \`test(\u2026)\`.`));
            return this.finish();
          }
          if (this.calledEnd) {
            return this.finish();
          }
          return new Promise((resolve) => {
            this.endCallbackFinisher = () => {
              resolve(this.finish());
            };
            this.finishDueToAttributedError = () => {
              resolve(this.finish());
            };
            this.finishDueToTimeout = () => {
              resolve(this.finish());
            };
            this.finishDueToInactivity = () => {
              this.saveFirstError(new Error("`t.end()` was never called"));
              resolve(this.finish());
            };
          });
        }
        if (promise) {
          return new Promise((resolve) => {
            this.finishDueToAttributedError = () => {
              resolve(this.finish());
            };
            this.finishDueToTimeout = () => {
              resolve(this.finish());
            };
            this.finishDueToInactivity = () => {
              const error = returnedObservable ? new Error("Observable returned by test never completed") : new Error("Promise returned by test never resolved");
              this.saveFirstError(error);
              resolve(this.finish());
            };
            promise.catch((error) => {
              if (!this.detectImproperThrows(error)) {
                this.saveFirstError(new assert.AssertionError({
                  message: "Rejected promise returned by test",
                  savedError: error instanceof Error && error,
                  values: [formatErrorValue("Rejected promise returned by test. Reason:", error)]
                }));
              }
            }).then(() => resolve(this.finish()));
          });
        }
        return this.finish();
      }
      async finish() {
        this.finishing = true;
        if (!this.assertError && this.pendingThrowsAssertion) {
          return this.waitForPendingThrowsAssertion();
        }
        this.clearTimeout();
        this.verifyPlan();
        this.verifyAssertions();
        await this.runTeardowns();
        this.duration = nowAndTimers.now() - this.startedAt;
        let error = this.assertError;
        let passed = !error;
        if (this.metadata.failing) {
          passed = !passed;
          error = passed ? null : new Error("Test was expected to fail, but succeeded, you should stop marking the test as failing");
        }
        return {
          deferredSnapshotRecordings: this.deferredSnapshotRecordings,
          duration: this.duration,
          error,
          logs: this.logs,
          metadata: this.metadata,
          passed,
          snapshotCount: this.snapshotCount,
          assertCount: this.assertCount,
          title: this.title
        };
      }
    };
    module2.exports = Test;
  }
});

// node_modules/ava/lib/runner.js
var require_runner = __commonJS({
  "node_modules/ava/lib/runner.js"(exports2, module2) {
    "use strict";
    var Emittery = require_emittery();
    var matcher = require_matcher2();
    var ContextRef = require_context_ref();
    var createChain = require_create_chain();
    var parseTestArgs = require_parse_test_args();
    var snapshotManager = require_snapshot_manager();
    var serializeError = require_serialize_error();
    var Runnable = require_test();
    var Runner = class extends Emittery {
      constructor(options = {}) {
        super();
        this.experiments = options.experiments || {};
        this.failFast = options.failFast === true;
        this.failWithoutAssertions = options.failWithoutAssertions !== false;
        this.file = options.file;
        this.checkSelectedByLineNumbers = options.checkSelectedByLineNumbers;
        this.match = options.match || [];
        this.powerAssert = void 0;
        this.projectDir = options.projectDir;
        this.recordNewSnapshots = options.recordNewSnapshots === true;
        this.runOnlyExclusive = options.runOnlyExclusive === true;
        this.serial = options.serial === true;
        this.skippingTests = false;
        this.snapshotDir = options.snapshotDir;
        this.updateSnapshots = options.updateSnapshots;
        this.activeRunnables = /* @__PURE__ */ new Set();
        this.boundCompareTestSnapshot = this.compareTestSnapshot.bind(this);
        this.skippedSnapshots = false;
        this.boundSkipSnapshot = this.skipSnapshot.bind(this);
        this.interrupted = false;
        this.snapshots = null;
        this.nextTaskIndex = 0;
        this.tasks = {
          after: [],
          afterAlways: [],
          afterEach: [],
          afterEachAlways: [],
          before: [],
          beforeEach: [],
          concurrent: [],
          serial: [],
          todo: []
        };
        this.waitForReady = [];
        const uniqueTestTitles = /* @__PURE__ */ new Set();
        this.registerUniqueTitle = (title) => {
          if (uniqueTestTitles.has(title)) {
            return false;
          }
          uniqueTestTitles.add(title);
          return true;
        };
        let hasStarted = false;
        let scheduledStart = false;
        const meta = Object.freeze({
          file: options.file,
          get snapshotDirectory() {
            const { file, snapshotDir: fixedLocation, projectDir } = options;
            return snapshotManager.determineSnapshotDir({ file, fixedLocation, projectDir });
          }
        });
        this.chain = createChain((metadata, testArgs) => {
          if (hasStarted) {
            throw new Error("All tests and hooks must be declared synchronously in your test file, and cannot be nested within other tests or hooks.");
          }
          if (!scheduledStart) {
            scheduledStart = true;
            process.nextTick(() => {
              hasStarted = true;
              this.start();
            });
          }
          metadata.taskIndex = this.nextTaskIndex++;
          const { args, buildTitle, implementations, rawTitle } = parseTestArgs(testArgs);
          if (this.checkSelectedByLineNumbers) {
            metadata.selected = this.checkSelectedByLineNumbers();
          }
          if (metadata.todo) {
            if (implementations.length > 0) {
              throw new TypeError("`todo` tests are not allowed to have an implementation. Use `test.skip()` for tests with an implementation.");
            }
            if (!rawTitle) {
              throw new TypeError("`todo` tests require a title");
            }
            if (!this.registerUniqueTitle(rawTitle)) {
              throw new Error(`Duplicate test title: ${rawTitle}`);
            }
            if (this.match.length > 0) {
              if (matcher([rawTitle], this.match).length === 1) {
                metadata.exclusive = true;
                this.runOnlyExclusive = true;
              }
            }
            this.tasks.todo.push({ title: rawTitle, metadata });
            this.emit("stateChange", {
              type: "declared-test",
              title: rawTitle,
              knownFailing: false,
              todo: true
            });
          } else {
            if (implementations.length === 0) {
              throw new TypeError("Expected an implementation. Use `test.todo()` for tests without an implementation.");
            }
            for (const implementation of implementations) {
              let { title, isSet, isValid, isEmpty } = buildTitle(implementation);
              if (isSet && !isValid) {
                throw new TypeError("Test & hook titles must be strings");
              }
              if (isEmpty) {
                if (metadata.type === "test") {
                  throw new TypeError("Tests must have a title");
                } else if (metadata.always) {
                  title = `${metadata.type}.always hook`;
                } else {
                  title = `${metadata.type} hook`;
                }
              }
              if (metadata.type === "test" && !this.registerUniqueTitle(title)) {
                throw new Error(`Duplicate test title: ${title}`);
              }
              const task = {
                title,
                implementation,
                args,
                metadata: { ...metadata }
              };
              if (metadata.type === "test") {
                if (this.match.length > 0) {
                  task.metadata.exclusive = matcher([title], this.match).length === 1;
                }
                if (task.metadata.skipped) {
                  this.skippingTests = true;
                }
                if (task.metadata.exclusive) {
                  this.runOnlyExclusive = true;
                }
                this.tasks[metadata.serial ? "serial" : "concurrent"].push(task);
                this.emit("stateChange", {
                  type: "declared-test",
                  title,
                  knownFailing: metadata.failing,
                  todo: false
                });
              } else if (!metadata.skipped) {
                this.tasks[metadata.type + (metadata.always ? "Always" : "")].push(task);
              }
            }
          }
        }, {
          serial: false,
          exclusive: false,
          skipped: false,
          todo: false,
          failing: false,
          callback: false,
          inline: false,
          // Set for attempt metadata created by `t.try()`
          always: false
        }, meta);
      }
      compareTestSnapshot(options) {
        if (!this.snapshots) {
          this.snapshots = snapshotManager.load({
            file: this.file,
            fixedLocation: this.snapshotDir,
            projectDir: this.projectDir,
            recordNewSnapshots: this.recordNewSnapshots,
            updating: this.updateSnapshots && !this.runOnlyExclusive && !this.skippingTests
          });
          this.emit("dependency", this.snapshots.snapPath);
        }
        return this.snapshots.compare(options);
      }
      skipSnapshot() {
        this.skippedSnapshots = true;
      }
      saveSnapshotState() {
        if (this.updateSnapshots && (this.runOnlyExclusive || this.skippingTests || this.skippedSnapshots)) {
          return { cannotSave: true };
        }
        if (this.snapshots) {
          return { touchedFiles: this.snapshots.save() };
        }
        if (this.updateSnapshots) {
          return { touchedFiles: snapshotManager.cleanSnapshots({
            file: this.file,
            fixedLocation: this.snapshotDir,
            projectDir: this.projectDir
          }) };
        }
        return {};
      }
      onRun(runnable) {
        this.activeRunnables.add(runnable);
      }
      onRunComplete(runnable) {
        this.activeRunnables.delete(runnable);
      }
      attributeLeakedError(err) {
        for (const runnable of this.activeRunnables) {
          if (runnable.attributeLeakedError(err)) {
            return true;
          }
        }
        return false;
      }
      beforeExitHandler() {
        for (const runnable of this.activeRunnables) {
          runnable.finishDueToInactivity();
        }
      }
      async runMultiple(runnables) {
        let allPassed = true;
        const storedResults = [];
        const runAndStoreResult = async (runnable) => {
          const result = await this.runSingle(runnable);
          if (!result.passed) {
            allPassed = false;
          }
          storedResults.push(result);
        };
        let waitForSerial = Promise.resolve();
        await runnables.reduce((previous, runnable) => {
          if (runnable.metadata.serial || this.serial) {
            waitForSerial = previous.then(() => {
              return (allPassed || runnable.metadata.always) && runAndStoreResult(runnable);
            });
            return waitForSerial;
          }
          return Promise.all([
            previous,
            waitForSerial.then(() => {
              return (allPassed || runnable.metadata.always) && runAndStoreResult(runnable);
            })
          ]);
        }, waitForSerial);
        return { allPassed, storedResults };
      }
      async runSingle(runnable) {
        this.onRun(runnable);
        const result = await runnable.run();
        this.onRunComplete(runnable);
        return result;
      }
      async runHooks(tasks, contextRef, { titleSuffix, testPassed, associatedTaskIndex } = {}) {
        const hooks = tasks.map((task) => new Runnable({
          contextRef,
          experiments: this.experiments,
          failWithoutAssertions: false,
          fn: task.args.length === 0 ? task.implementation : (t) => task.implementation.apply(null, [t].concat(task.args)),
          compareTestSnapshot: this.boundCompareTestSnapshot,
          skipSnapshot: this.boundSkipSnapshot,
          updateSnapshots: this.updateSnapshots,
          metadata: { ...task.metadata, associatedTaskIndex },
          powerAssert: this.powerAssert,
          title: `${task.title}${titleSuffix || ""}`,
          isHook: true,
          testPassed
        }));
        const outcome = await this.runMultiple(hooks, this.serial);
        for (const result of outcome.storedResults) {
          if (result.passed) {
            this.emit("stateChange", {
              type: "hook-finished",
              title: result.title,
              duration: result.duration,
              logs: result.logs
            });
          } else {
            this.emit("stateChange", {
              type: "hook-failed",
              title: result.title,
              err: serializeError("Hook failure", true, result.error),
              duration: result.duration,
              logs: result.logs
            });
          }
        }
        return outcome.allPassed;
      }
      async runTest(task, contextRef) {
        const hookSuffix = ` for ${task.title}`;
        let hooksOk = await this.runHooks(
          this.tasks.beforeEach,
          contextRef,
          {
            titleSuffix: hookSuffix,
            associatedTaskIndex: task.metadata.taskIndex
          }
        );
        let testOk = false;
        if (hooksOk) {
          const test = new Runnable({
            contextRef,
            experiments: this.experiments,
            failWithoutAssertions: this.failWithoutAssertions,
            fn: task.args.length === 0 ? task.implementation : (t) => task.implementation.apply(null, [t].concat(task.args)),
            compareTestSnapshot: this.boundCompareTestSnapshot,
            skipSnapshot: this.boundSkipSnapshot,
            updateSnapshots: this.updateSnapshots,
            metadata: task.metadata,
            powerAssert: this.powerAssert,
            title: task.title,
            registerUniqueTitle: this.registerUniqueTitle
          });
          const result = await this.runSingle(test);
          testOk = result.passed;
          if (testOk) {
            this.emit("stateChange", {
              type: "test-passed",
              title: result.title,
              duration: result.duration,
              knownFailing: result.metadata.failing,
              logs: result.logs
            });
            hooksOk = await this.runHooks(
              this.tasks.afterEach,
              contextRef,
              {
                titleSuffix: hookSuffix,
                testPassed: testOk,
                associatedTaskIndex: task.metadata.taskIndex
              }
            );
          } else {
            this.emit("stateChange", {
              type: "test-failed",
              title: result.title,
              err: serializeError("Test failure", true, result.error, this.file),
              duration: result.duration,
              knownFailing: result.metadata.failing,
              logs: result.logs
            });
          }
        }
        const alwaysOk = await this.runHooks(
          this.tasks.afterEachAlways,
          contextRef,
          {
            titleSuffix: hookSuffix,
            testPassed: testOk,
            associatedTaskIndex: task.metadata.taskIndex
          }
        );
        return alwaysOk && hooksOk && testOk;
      }
      async start() {
        const concurrentTests = [];
        const serialTests = [];
        for (const task of this.tasks.serial) {
          if (this.runOnlyExclusive && !task.metadata.exclusive) {
            continue;
          }
          if (this.checkSelectedByLineNumbers && !task.metadata.selected) {
            continue;
          }
          this.emit("stateChange", {
            type: "selected-test",
            title: task.title,
            knownFailing: task.metadata.failing,
            skip: task.metadata.skipped,
            todo: false
          });
          if (!task.metadata.skipped) {
            serialTests.push(task);
          }
        }
        for (const task of this.tasks.concurrent) {
          if (this.runOnlyExclusive && !task.metadata.exclusive) {
            continue;
          }
          if (this.checkSelectedByLineNumbers && !task.metadata.selected) {
            continue;
          }
          this.emit("stateChange", {
            type: "selected-test",
            title: task.title,
            knownFailing: task.metadata.failing,
            skip: task.metadata.skipped,
            todo: false
          });
          if (!task.metadata.skipped) {
            if (this.serial) {
              serialTests.push(task);
            } else {
              concurrentTests.push(task);
            }
          }
        }
        for (const task of this.tasks.todo) {
          if (this.runOnlyExclusive && !task.metadata.exclusive) {
            continue;
          }
          if (this.checkSelectedByLineNumbers && !task.metadata.selected) {
            continue;
          }
          this.emit("stateChange", {
            type: "selected-test",
            title: task.title,
            knownFailing: false,
            skip: false,
            todo: true
          });
        }
        await Promise.all(this.waitForReady);
        if (concurrentTests.length === 0 && serialTests.length === 0) {
          this.emit("finish");
          return;
        }
        const contextRef = new ContextRef();
        const beforePromise = this.runHooks(this.tasks.before, contextRef);
        const serialPromise = beforePromise.then((beforeHooksOk) => {
          if (!beforeHooksOk) {
            return false;
          }
          return serialTests.reduce(async (previous, task) => {
            const previousOk = await previous;
            if (this.interrupted) {
              return previousOk;
            }
            if (!previousOk && this.failFast) {
              return false;
            }
            return this.runTest(task, contextRef.copy());
          }, true);
        });
        const concurrentPromise = Promise.all([beforePromise, serialPromise]).then(async ([beforeHooksOk, serialOk]) => {
          if (!beforeHooksOk || !serialOk && this.failFast) {
            return false;
          }
          if (this.interrupted) {
            return true;
          }
          const allOkays = await Promise.all(concurrentTests.map((task) => {
            return this.runTest(task, contextRef.copy());
          }));
          return allOkays.every((ok) => ok);
        });
        const beforeExitHandler = this.beforeExitHandler.bind(this);
        process.on("beforeExit", beforeExitHandler);
        try {
          const ok = await concurrentPromise;
          if (ok) {
            await this.runHooks(this.tasks.after, contextRef);
          }
          await this.runHooks(this.tasks.afterAlways, contextRef);
          process.removeListener("beforeExit", beforeExitHandler);
          await this.emit("finish");
        } catch (error) {
          await this.emit("error", error);
        }
      }
      interrupt() {
        this.interrupted = true;
      }
    };
    module2.exports = Runner;
  }
});

// node_modules/ava/lib/worker/dependency-tracker.js
var require_dependency_tracker = __commonJS({
  "node_modules/ava/lib/worker/dependency-tracker.js"(exports2) {
    "use strict";
    var ipc = require_ipc();
    var seenDependencies = /* @__PURE__ */ new Set();
    var newDependencies = [];
    function flush() {
      if (newDependencies.length === 0) {
        return;
      }
      ipc.send({ type: "dependencies", dependencies: newDependencies });
      newDependencies = [];
    }
    exports2.flush = flush;
    function track(filename) {
      if (seenDependencies.has(filename)) {
        return;
      }
      if (newDependencies.length === 0) {
        process.nextTick(flush);
      }
      seenDependencies.add(filename);
      newDependencies.push(filename);
    }
    exports2.track = track;
    function install(testPath) {
      for (const ext of Object.keys(require.extensions)) {
        const wrappedHandler = require.extensions[ext];
        require.extensions[ext] = (module3, filename) => {
          if (filename !== testPath) {
            track(filename);
          }
          wrappedHandler(module3, filename);
        };
      }
    }
    exports2.install = install;
  }
});

// node_modules/acorn/dist/acorn.js
var require_acorn = __commonJS({
  "node_modules/acorn/dist/acorn.js"(exports2, module2) {
    "use strict";
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.acorn = {}));
    })(exports2, function(exports3) {
      "use strict";
      var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
      var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];
      var nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65";
      var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
      var reservedWords = {
        3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
        5: "class enum extends super const export import",
        6: "enum",
        strict: "implements interface let package private protected public static yield",
        strictBind: "eval arguments"
      };
      var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
      var keywords$1 = {
        5: ecma5AndLessKeywords,
        "5module": ecma5AndLessKeywords + " export import",
        6: ecma5AndLessKeywords + " const class extends export import super"
      };
      var keywordRelationalOperator = /^in(stanceof)?$/;
      var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
      var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
      function isInAstralSet(code, set) {
        var pos = 65536;
        for (var i2 = 0; i2 < set.length; i2 += 2) {
          pos += set[i2];
          if (pos > code) {
            return false;
          }
          pos += set[i2 + 1];
          if (pos >= code) {
            return true;
          }
        }
        return false;
      }
      function isIdentifierStart(code, astral) {
        if (code < 65) {
          return code === 36;
        }
        if (code < 91) {
          return true;
        }
        if (code < 97) {
          return code === 95;
        }
        if (code < 123) {
          return true;
        }
        if (code <= 65535) {
          return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
        }
        if (astral === false) {
          return false;
        }
        return isInAstralSet(code, astralIdentifierStartCodes);
      }
      function isIdentifierChar(code, astral) {
        if (code < 48) {
          return code === 36;
        }
        if (code < 58) {
          return true;
        }
        if (code < 65) {
          return false;
        }
        if (code < 91) {
          return true;
        }
        if (code < 97) {
          return code === 95;
        }
        if (code < 123) {
          return true;
        }
        if (code <= 65535) {
          return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
        }
        if (astral === false) {
          return false;
        }
        return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
      }
      var TokenType = function TokenType2(label, conf) {
        if (conf === void 0) conf = {};
        this.label = label;
        this.keyword = conf.keyword;
        this.beforeExpr = !!conf.beforeExpr;
        this.startsExpr = !!conf.startsExpr;
        this.isLoop = !!conf.isLoop;
        this.isAssign = !!conf.isAssign;
        this.prefix = !!conf.prefix;
        this.postfix = !!conf.postfix;
        this.binop = conf.binop || null;
        this.updateContext = null;
      };
      function binop(name, prec) {
        return new TokenType(name, { beforeExpr: true, binop: prec });
      }
      var beforeExpr = { beforeExpr: true }, startsExpr = { startsExpr: true };
      var keywords = {};
      function kw(name, options) {
        if (options === void 0) options = {};
        options.keyword = name;
        return keywords[name] = new TokenType(name, options);
      }
      var types$1 = {
        num: new TokenType("num", startsExpr),
        regexp: new TokenType("regexp", startsExpr),
        string: new TokenType("string", startsExpr),
        name: new TokenType("name", startsExpr),
        privateId: new TokenType("privateId", startsExpr),
        eof: new TokenType("eof"),
        // Punctuation token types.
        bracketL: new TokenType("[", { beforeExpr: true, startsExpr: true }),
        bracketR: new TokenType("]"),
        braceL: new TokenType("{", { beforeExpr: true, startsExpr: true }),
        braceR: new TokenType("}"),
        parenL: new TokenType("(", { beforeExpr: true, startsExpr: true }),
        parenR: new TokenType(")"),
        comma: new TokenType(",", beforeExpr),
        semi: new TokenType(";", beforeExpr),
        colon: new TokenType(":", beforeExpr),
        dot: new TokenType("."),
        question: new TokenType("?", beforeExpr),
        questionDot: new TokenType("?."),
        arrow: new TokenType("=>", beforeExpr),
        template: new TokenType("template"),
        invalidTemplate: new TokenType("invalidTemplate"),
        ellipsis: new TokenType("...", beforeExpr),
        backQuote: new TokenType("`", startsExpr),
        dollarBraceL: new TokenType("${", { beforeExpr: true, startsExpr: true }),
        // Operators. These carry several kinds of properties to help the
        // parser use them properly (the presence of these properties is
        // what categorizes them as operators).
        //
        // `binop`, when present, specifies that this operator is a binary
        // operator, and will refer to its precedence.
        //
        // `prefix` and `postfix` mark the operator as a prefix or postfix
        // unary operator.
        //
        // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
        // binary operators with a very low precedence, that should result
        // in AssignmentExpression nodes.
        eq: new TokenType("=", { beforeExpr: true, isAssign: true }),
        assign: new TokenType("_=", { beforeExpr: true, isAssign: true }),
        incDec: new TokenType("++/--", { prefix: true, postfix: true, startsExpr: true }),
        prefix: new TokenType("!/~", { beforeExpr: true, prefix: true, startsExpr: true }),
        logicalOR: binop("||", 1),
        logicalAND: binop("&&", 2),
        bitwiseOR: binop("|", 3),
        bitwiseXOR: binop("^", 4),
        bitwiseAND: binop("&", 5),
        equality: binop("==/!=/===/!==", 6),
        relational: binop("</>/<=/>=", 7),
        bitShift: binop("<</>>/>>>", 8),
        plusMin: new TokenType("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }),
        modulo: binop("%", 10),
        star: binop("*", 10),
        slash: binop("/", 10),
        starstar: new TokenType("**", { beforeExpr: true }),
        coalesce: binop("??", 1),
        // Keyword token types.
        _break: kw("break"),
        _case: kw("case", beforeExpr),
        _catch: kw("catch"),
        _continue: kw("continue"),
        _debugger: kw("debugger"),
        _default: kw("default", beforeExpr),
        _do: kw("do", { isLoop: true, beforeExpr: true }),
        _else: kw("else", beforeExpr),
        _finally: kw("finally"),
        _for: kw("for", { isLoop: true }),
        _function: kw("function", startsExpr),
        _if: kw("if"),
        _return: kw("return", beforeExpr),
        _switch: kw("switch"),
        _throw: kw("throw", beforeExpr),
        _try: kw("try"),
        _var: kw("var"),
        _const: kw("const"),
        _while: kw("while", { isLoop: true }),
        _with: kw("with"),
        _new: kw("new", { beforeExpr: true, startsExpr: true }),
        _this: kw("this", startsExpr),
        _super: kw("super", startsExpr),
        _class: kw("class", startsExpr),
        _extends: kw("extends", beforeExpr),
        _export: kw("export"),
        _import: kw("import", startsExpr),
        _null: kw("null", startsExpr),
        _true: kw("true", startsExpr),
        _false: kw("false", startsExpr),
        _in: kw("in", { beforeExpr: true, binop: 7 }),
        _instanceof: kw("instanceof", { beforeExpr: true, binop: 7 }),
        _typeof: kw("typeof", { beforeExpr: true, prefix: true, startsExpr: true }),
        _void: kw("void", { beforeExpr: true, prefix: true, startsExpr: true }),
        _delete: kw("delete", { beforeExpr: true, prefix: true, startsExpr: true })
      };
      var lineBreak = /\r\n?|\n|\u2028|\u2029/;
      var lineBreakG = new RegExp(lineBreak.source, "g");
      function isNewLine(code) {
        return code === 10 || code === 13 || code === 8232 || code === 8233;
      }
      function nextLineBreak(code, from, end) {
        if (end === void 0) end = code.length;
        for (var i2 = from; i2 < end; i2++) {
          var next = code.charCodeAt(i2);
          if (isNewLine(next)) {
            return i2 < end - 1 && next === 13 && code.charCodeAt(i2 + 1) === 10 ? i2 + 2 : i2 + 1;
          }
        }
        return -1;
      }
      var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
      var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
      var ref = Object.prototype;
      var hasOwnProperty = ref.hasOwnProperty;
      var toString = ref.toString;
      var hasOwn = Object.hasOwn || function(obj, propName) {
        return hasOwnProperty.call(obj, propName);
      };
      var isArray = Array.isArray || function(obj) {
        return toString.call(obj) === "[object Array]";
      };
      var regexpCache = /* @__PURE__ */ Object.create(null);
      function wordsRegexp(words) {
        return regexpCache[words] || (regexpCache[words] = new RegExp("^(?:" + words.replace(/ /g, "|") + ")$"));
      }
      function codePointToString(code) {
        if (code <= 65535) {
          return String.fromCharCode(code);
        }
        code -= 65536;
        return String.fromCharCode((code >> 10) + 55296, (code & 1023) + 56320);
      }
      var loneSurrogate = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;
      var Position = function Position2(line, col) {
        this.line = line;
        this.column = col;
      };
      Position.prototype.offset = function offset(n) {
        return new Position(this.line, this.column + n);
      };
      var SourceLocation = function SourceLocation2(p, start, end) {
        this.start = start;
        this.end = end;
        if (p.sourceFile !== null) {
          this.source = p.sourceFile;
        }
      };
      function getLineInfo(input, offset) {
        for (var line = 1, cur = 0; ; ) {
          var nextBreak = nextLineBreak(input, cur, offset);
          if (nextBreak < 0) {
            return new Position(line, offset - cur);
          }
          ++line;
          cur = nextBreak;
        }
      }
      var defaultOptions = {
        // `ecmaVersion` indicates the ECMAScript version to parse. Must be
        // either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10
        // (2019), 11 (2020), 12 (2021), 13 (2022), 14 (2023), or `"latest"`
        // (the latest version the library supports). This influences
        // support for strict mode, the set of reserved words, and support
        // for new syntax features.
        ecmaVersion: null,
        // `sourceType` indicates the mode the code should be parsed in.
        // Can be either `"script"` or `"module"`. This influences global
        // strict mode and parsing of `import` and `export` declarations.
        sourceType: "script",
        // `onInsertedSemicolon` can be a callback that will be called when
        // a semicolon is automatically inserted. It will be passed the
        // position of the inserted semicolon as an offset, and if
        // `locations` is enabled, it is given the location as a `{line,
        // column}` object as second argument.
        onInsertedSemicolon: null,
        // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
        // trailing commas.
        onTrailingComma: null,
        // By default, reserved words are only enforced if ecmaVersion >= 5.
        // Set `allowReserved` to a boolean value to explicitly turn this on
        // an off. When this option has the value "never", reserved words
        // and keywords can also not be used as property names.
        allowReserved: null,
        // When enabled, a return at the top level is not considered an
        // error.
        allowReturnOutsideFunction: false,
        // When enabled, import/export statements are not constrained to
        // appearing at the top of the program, and an import.meta expression
        // in a script isn't considered an error.
        allowImportExportEverywhere: false,
        // By default, await identifiers are allowed to appear at the top-level scope only if ecmaVersion >= 2022.
        // When enabled, await identifiers are allowed to appear at the top-level scope,
        // but they are still not allowed in non-async functions.
        allowAwaitOutsideFunction: null,
        // When enabled, super identifiers are not constrained to
        // appearing in methods and do not raise an error when they appear elsewhere.
        allowSuperOutsideMethod: null,
        // When enabled, hashbang directive in the beginning of file is
        // allowed and treated as a line comment. Enabled by default when
        // `ecmaVersion` >= 2023.
        allowHashBang: false,
        // By default, the parser will verify that private properties are
        // only used in places where they are valid and have been declared.
        // Set this to false to turn such checks off.
        checkPrivateFields: true,
        // When `locations` is on, `loc` properties holding objects with
        // `start` and `end` properties in `{line, column}` form (with
        // line being 1-based and column 0-based) will be attached to the
        // nodes.
        locations: false,
        // A function can be passed as `onToken` option, which will
        // cause Acorn to call that function with object in the same
        // format as tokens returned from `tokenizer().getToken()`. Note
        // that you are not allowed to call the parser from the
        // callback—that will corrupt its internal state.
        onToken: null,
        // A function can be passed as `onComment` option, which will
        // cause Acorn to call that function with `(block, text, start,
        // end)` parameters whenever a comment is skipped. `block` is a
        // boolean indicating whether this is a block (`/* */`) comment,
        // `text` is the content of the comment, and `start` and `end` are
        // character offsets that denote the start and end of the comment.
        // When the `locations` option is on, two more parameters are
        // passed, the full `{line, column}` locations of the start and
        // end of the comments. Note that you are not allowed to call the
        // parser from the callback—that will corrupt its internal state.
        // When this option has an array as value, objects representing the
        // comments are pushed to it.
        onComment: null,
        // Nodes have their start and end characters offsets recorded in
        // `start` and `end` properties (directly on the node, rather than
        // the `loc` object, which holds line/column data. To also add a
        // [semi-standardized][range] `range` property holding a `[start,
        // end]` array with the same numbers, set the `ranges` option to
        // `true`.
        //
        // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
        ranges: false,
        // It is possible to parse multiple files into a single AST by
        // passing the tree produced by parsing the first file as
        // `program` option in subsequent parses. This will add the
        // toplevel forms of the parsed file to the `Program` (top) node
        // of an existing parse tree.
        program: null,
        // When `locations` is on, you can pass this to record the source
        // file in every node's `loc` object.
        sourceFile: null,
        // This value, if given, is stored in every node, whether
        // `locations` is on or off.
        directSourceFile: null,
        // When enabled, parenthesized expressions are represented by
        // (non-standard) ParenthesizedExpression nodes
        preserveParens: false
      };
      var warnedAboutEcmaVersion = false;
      function getOptions(opts) {
        var options = {};
        for (var opt in defaultOptions) {
          options[opt] = opts && hasOwn(opts, opt) ? opts[opt] : defaultOptions[opt];
        }
        if (options.ecmaVersion === "latest") {
          options.ecmaVersion = 1e8;
        } else if (options.ecmaVersion == null) {
          if (!warnedAboutEcmaVersion && typeof console === "object" && console.warn) {
            warnedAboutEcmaVersion = true;
            console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.");
          }
          options.ecmaVersion = 11;
        } else if (options.ecmaVersion >= 2015) {
          options.ecmaVersion -= 2009;
        }
        if (options.allowReserved == null) {
          options.allowReserved = options.ecmaVersion < 5;
        }
        if (!opts || opts.allowHashBang == null) {
          options.allowHashBang = options.ecmaVersion >= 14;
        }
        if (isArray(options.onToken)) {
          var tokens = options.onToken;
          options.onToken = function(token) {
            return tokens.push(token);
          };
        }
        if (isArray(options.onComment)) {
          options.onComment = pushComment(options, options.onComment);
        }
        return options;
      }
      function pushComment(options, array) {
        return function(block, text, start, end, startLoc, endLoc) {
          var comment = {
            type: block ? "Block" : "Line",
            value: text,
            start,
            end
          };
          if (options.locations) {
            comment.loc = new SourceLocation(this, startLoc, endLoc);
          }
          if (options.ranges) {
            comment.range = [start, end];
          }
          array.push(comment);
        };
      }
      var SCOPE_TOP = 1, SCOPE_FUNCTION = 2, SCOPE_ASYNC = 4, SCOPE_GENERATOR = 8, SCOPE_ARROW = 16, SCOPE_SIMPLE_CATCH = 32, SCOPE_SUPER = 64, SCOPE_DIRECT_SUPER = 128, SCOPE_CLASS_STATIC_BLOCK = 256, SCOPE_CLASS_FIELD_INIT = 512, SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;
      function functionFlags(async, generator) {
        return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0);
      }
      var BIND_NONE = 0, BIND_VAR = 1, BIND_LEXICAL = 2, BIND_FUNCTION = 3, BIND_SIMPLE_CATCH = 4, BIND_OUTSIDE = 5;
      var Parser = function Parser2(options, input, startPos) {
        this.options = options = getOptions(options);
        this.sourceFile = options.sourceFile;
        this.keywords = wordsRegexp(keywords$1[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
        var reserved = "";
        if (options.allowReserved !== true) {
          reserved = reservedWords[options.ecmaVersion >= 6 ? 6 : options.ecmaVersion === 5 ? 5 : 3];
          if (options.sourceType === "module") {
            reserved += " await";
          }
        }
        this.reservedWords = wordsRegexp(reserved);
        var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
        this.reservedWordsStrict = wordsRegexp(reservedStrict);
        this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
        this.input = String(input);
        this.containsEsc = false;
        if (startPos) {
          this.pos = startPos;
          this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
          this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
        } else {
          this.pos = this.lineStart = 0;
          this.curLine = 1;
        }
        this.type = types$1.eof;
        this.value = null;
        this.start = this.end = this.pos;
        this.startLoc = this.endLoc = this.curPosition();
        this.lastTokEndLoc = this.lastTokStartLoc = null;
        this.lastTokStart = this.lastTokEnd = this.pos;
        this.context = this.initialContext();
        this.exprAllowed = true;
        this.inModule = options.sourceType === "module";
        this.strict = this.inModule || this.strictDirective(this.pos);
        this.potentialArrowAt = -1;
        this.potentialArrowInForAwait = false;
        this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
        this.labels = [];
        this.undefinedExports = /* @__PURE__ */ Object.create(null);
        if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!") {
          this.skipLineComment(2);
        }
        this.scopeStack = [];
        this.enterScope(SCOPE_TOP);
        this.regexpState = null;
        this.privateNameStack = [];
      };
      var prototypeAccessors = { inFunction: { configurable: true }, inGenerator: { configurable: true }, inAsync: { configurable: true }, canAwait: { configurable: true }, allowSuper: { configurable: true }, allowDirectSuper: { configurable: true }, treatFunctionsAsVar: { configurable: true }, allowNewDotTarget: { configurable: true }, inClassStaticBlock: { configurable: true } };
      Parser.prototype.parse = function parse2() {
        var node = this.options.program || this.startNode();
        this.nextToken();
        return this.parseTopLevel(node);
      };
      prototypeAccessors.inFunction.get = function() {
        return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;
      };
      prototypeAccessors.inGenerator.get = function() {
        return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0;
      };
      prototypeAccessors.inAsync.get = function() {
        return (this.currentVarScope().flags & SCOPE_ASYNC) > 0;
      };
      prototypeAccessors.canAwait.get = function() {
        for (var i2 = this.scopeStack.length - 1; i2 >= 0; i2--) {
          var ref2 = this.scopeStack[i2];
          var flags = ref2.flags;
          if (flags & (SCOPE_CLASS_STATIC_BLOCK | SCOPE_CLASS_FIELD_INIT)) {
            return false;
          }
          if (flags & SCOPE_FUNCTION) {
            return (flags & SCOPE_ASYNC) > 0;
          }
        }
        return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
      };
      prototypeAccessors.allowSuper.get = function() {
        var ref2 = this.currentThisScope();
        var flags = ref2.flags;
        return (flags & SCOPE_SUPER) > 0 || this.options.allowSuperOutsideMethod;
      };
      prototypeAccessors.allowDirectSuper.get = function() {
        return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;
      };
      prototypeAccessors.treatFunctionsAsVar.get = function() {
        return this.treatFunctionsAsVarInScope(this.currentScope());
      };
      prototypeAccessors.allowNewDotTarget.get = function() {
        for (var i2 = this.scopeStack.length - 1; i2 >= 0; i2--) {
          var ref2 = this.scopeStack[i2];
          var flags = ref2.flags;
          if (flags & (SCOPE_CLASS_STATIC_BLOCK | SCOPE_CLASS_FIELD_INIT) || flags & SCOPE_FUNCTION && !(flags & SCOPE_ARROW)) {
            return true;
          }
        }
        return false;
      };
      prototypeAccessors.inClassStaticBlock.get = function() {
        return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0;
      };
      Parser.extend = function extend() {
        var plugins = [], len = arguments.length;
        while (len--) plugins[len] = arguments[len];
        var cls = this;
        for (var i2 = 0; i2 < plugins.length; i2++) {
          cls = plugins[i2](cls);
        }
        return cls;
      };
      Parser.parse = function parse2(input, options) {
        return new this(options, input).parse();
      };
      Parser.parseExpressionAt = function parseExpressionAt2(input, pos, options) {
        var parser = new this(options, input, pos);
        parser.nextToken();
        return parser.parseExpression();
      };
      Parser.tokenizer = function tokenizer2(input, options) {
        return new this(options, input);
      };
      Object.defineProperties(Parser.prototype, prototypeAccessors);
      var pp$9 = Parser.prototype;
      var literal = /^(?:'((?:\\[^]|[^'\\])*?)'|"((?:\\[^]|[^"\\])*?)")/;
      pp$9.strictDirective = function(start) {
        if (this.options.ecmaVersion < 5) {
          return false;
        }
        for (; ; ) {
          skipWhiteSpace.lastIndex = start;
          start += skipWhiteSpace.exec(this.input)[0].length;
          var match = literal.exec(this.input.slice(start));
          if (!match) {
            return false;
          }
          if ((match[1] || match[2]) === "use strict") {
            skipWhiteSpace.lastIndex = start + match[0].length;
            var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
            var next = this.input.charAt(end);
            return next === ";" || next === "}" || lineBreak.test(spaceAfter[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "=");
          }
          start += match[0].length;
          skipWhiteSpace.lastIndex = start;
          start += skipWhiteSpace.exec(this.input)[0].length;
          if (this.input[start] === ";") {
            start++;
          }
        }
      };
      pp$9.eat = function(type) {
        if (this.type === type) {
          this.next();
          return true;
        } else {
          return false;
        }
      };
      pp$9.isContextual = function(name) {
        return this.type === types$1.name && this.value === name && !this.containsEsc;
      };
      pp$9.eatContextual = function(name) {
        if (!this.isContextual(name)) {
          return false;
        }
        this.next();
        return true;
      };
      pp$9.expectContextual = function(name) {
        if (!this.eatContextual(name)) {
          this.unexpected();
        }
      };
      pp$9.canInsertSemicolon = function() {
        return this.type === types$1.eof || this.type === types$1.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
      };
      pp$9.insertSemicolon = function() {
        if (this.canInsertSemicolon()) {
          if (this.options.onInsertedSemicolon) {
            this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
          }
          return true;
        }
      };
      pp$9.semicolon = function() {
        if (!this.eat(types$1.semi) && !this.insertSemicolon()) {
          this.unexpected();
        }
      };
      pp$9.afterTrailingComma = function(tokType, notNext) {
        if (this.type === tokType) {
          if (this.options.onTrailingComma) {
            this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
          }
          if (!notNext) {
            this.next();
          }
          return true;
        }
      };
      pp$9.expect = function(type) {
        this.eat(type) || this.unexpected();
      };
      pp$9.unexpected = function(pos) {
        this.raise(pos != null ? pos : this.start, "Unexpected token");
      };
      var DestructuringErrors = function DestructuringErrors2() {
        this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
      };
      pp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {
        if (!refDestructuringErrors) {
          return;
        }
        if (refDestructuringErrors.trailingComma > -1) {
          this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
        }
        var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
        if (parens > -1) {
          this.raiseRecoverable(parens, isAssign ? "Assigning to rvalue" : "Parenthesized pattern");
        }
      };
      pp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
        if (!refDestructuringErrors) {
          return false;
        }
        var shorthandAssign = refDestructuringErrors.shorthandAssign;
        var doubleProto = refDestructuringErrors.doubleProto;
        if (!andThrow) {
          return shorthandAssign >= 0 || doubleProto >= 0;
        }
        if (shorthandAssign >= 0) {
          this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns");
        }
        if (doubleProto >= 0) {
          this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property");
        }
      };
      pp$9.checkYieldAwaitInDefaultParams = function() {
        if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) {
          this.raise(this.yieldPos, "Yield expression cannot be a default value");
        }
        if (this.awaitPos) {
          this.raise(this.awaitPos, "Await expression cannot be a default value");
        }
      };
      pp$9.isSimpleAssignTarget = function(expr) {
        if (expr.type === "ParenthesizedExpression") {
          return this.isSimpleAssignTarget(expr.expression);
        }
        return expr.type === "Identifier" || expr.type === "MemberExpression";
      };
      var pp$8 = Parser.prototype;
      pp$8.parseTopLevel = function(node) {
        var exports4 = /* @__PURE__ */ Object.create(null);
        if (!node.body) {
          node.body = [];
        }
        while (this.type !== types$1.eof) {
          var stmt = this.parseStatement(null, true, exports4);
          node.body.push(stmt);
        }
        if (this.inModule) {
          for (var i2 = 0, list2 = Object.keys(this.undefinedExports); i2 < list2.length; i2 += 1) {
            var name = list2[i2];
            this.raiseRecoverable(this.undefinedExports[name].start, "Export '" + name + "' is not defined");
          }
        }
        this.adaptDirectivePrologue(node.body);
        this.next();
        node.sourceType = this.options.sourceType;
        return this.finishNode(node, "Program");
      };
      var loopLabel = { kind: "loop" }, switchLabel = { kind: "switch" };
      pp$8.isLet = function(context) {
        if (this.options.ecmaVersion < 6 || !this.isContextual("let")) {
          return false;
        }
        skipWhiteSpace.lastIndex = this.pos;
        var skip = skipWhiteSpace.exec(this.input);
        var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
        if (nextCh === 91 || nextCh === 92) {
          return true;
        }
        if (context) {
          return false;
        }
        if (nextCh === 123 || nextCh > 55295 && nextCh < 56320) {
          return true;
        }
        if (isIdentifierStart(nextCh, true)) {
          var pos = next + 1;
          while (isIdentifierChar(nextCh = this.input.charCodeAt(pos), true)) {
            ++pos;
          }
          if (nextCh === 92 || nextCh > 55295 && nextCh < 56320) {
            return true;
          }
          var ident = this.input.slice(next, pos);
          if (!keywordRelationalOperator.test(ident)) {
            return true;
          }
        }
        return false;
      };
      pp$8.isAsyncFunction = function() {
        if (this.options.ecmaVersion < 8 || !this.isContextual("async")) {
          return false;
        }
        skipWhiteSpace.lastIndex = this.pos;
        var skip = skipWhiteSpace.exec(this.input);
        var next = this.pos + skip[0].length, after;
        return !lineBreak.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === "function" && (next + 8 === this.input.length || !(isIdentifierChar(after = this.input.charCodeAt(next + 8)) || after > 55295 && after < 56320));
      };
      pp$8.isUsingKeyword = function(isAwaitUsing, isFor) {
        if (this.options.ecmaVersion < 17 || !this.isContextual(isAwaitUsing ? "await" : "using")) {
          return false;
        }
        skipWhiteSpace.lastIndex = this.pos;
        var skip = skipWhiteSpace.exec(this.input);
        var next = this.pos + skip[0].length;
        if (lineBreak.test(this.input.slice(this.pos, next))) {
          return false;
        }
        if (isAwaitUsing) {
          var awaitEndPos = next + 5, after;
          if (this.input.slice(next, awaitEndPos) !== "using" || awaitEndPos === this.input.length || isIdentifierChar(after = this.input.charCodeAt(awaitEndPos)) || after > 55295 && after < 56320) {
            return false;
          }
          skipWhiteSpace.lastIndex = awaitEndPos;
          var skipAfterUsing = skipWhiteSpace.exec(this.input);
          if (skipAfterUsing && lineBreak.test(this.input.slice(awaitEndPos, awaitEndPos + skipAfterUsing[0].length))) {
            return false;
          }
        }
        if (isFor) {
          var ofEndPos = next + 2, after$1;
          if (this.input.slice(next, ofEndPos) === "of") {
            if (ofEndPos === this.input.length || !isIdentifierChar(after$1 = this.input.charCodeAt(ofEndPos)) && !(after$1 > 55295 && after$1 < 56320)) {
              return false;
            }
          }
        }
        var ch = this.input.charCodeAt(next);
        return isIdentifierStart(ch, true) || ch === 92;
      };
      pp$8.isAwaitUsing = function(isFor) {
        return this.isUsingKeyword(true, isFor);
      };
      pp$8.isUsing = function(isFor) {
        return this.isUsingKeyword(false, isFor);
      };
      pp$8.parseStatement = function(context, topLevel, exports4) {
        var starttype = this.type, node = this.startNode(), kind;
        if (this.isLet(context)) {
          starttype = types$1._var;
          kind = "let";
        }
        switch (starttype) {
          case types$1._break:
          case types$1._continue:
            return this.parseBreakContinueStatement(node, starttype.keyword);
          case types$1._debugger:
            return this.parseDebuggerStatement(node);
          case types$1._do:
            return this.parseDoStatement(node);
          case types$1._for:
            return this.parseForStatement(node);
          case types$1._function:
            if (context && (this.strict || context !== "if" && context !== "label") && this.options.ecmaVersion >= 6) {
              this.unexpected();
            }
            return this.parseFunctionStatement(node, false, !context);
          case types$1._class:
            if (context) {
              this.unexpected();
            }
            return this.parseClass(node, true);
          case types$1._if:
            return this.parseIfStatement(node);
          case types$1._return:
            return this.parseReturnStatement(node);
          case types$1._switch:
            return this.parseSwitchStatement(node);
          case types$1._throw:
            return this.parseThrowStatement(node);
          case types$1._try:
            return this.parseTryStatement(node);
          case types$1._const:
          case types$1._var:
            kind = kind || this.value;
            if (context && kind !== "var") {
              this.unexpected();
            }
            return this.parseVarStatement(node, kind);
          case types$1._while:
            return this.parseWhileStatement(node);
          case types$1._with:
            return this.parseWithStatement(node);
          case types$1.braceL:
            return this.parseBlock(true, node);
          case types$1.semi:
            return this.parseEmptyStatement(node);
          case types$1._export:
          case types$1._import:
            if (this.options.ecmaVersion > 10 && starttype === types$1._import) {
              skipWhiteSpace.lastIndex = this.pos;
              var skip = skipWhiteSpace.exec(this.input);
              var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
              if (nextCh === 40 || nextCh === 46) {
                return this.parseExpressionStatement(node, this.parseExpression());
              }
            }
            if (!this.options.allowImportExportEverywhere) {
              if (!topLevel) {
                this.raise(this.start, "'import' and 'export' may only appear at the top level");
              }
              if (!this.inModule) {
                this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
              }
            }
            return starttype === types$1._import ? this.parseImport(node) : this.parseExport(node, exports4);
          // If the statement does not start with a statement keyword or a
          // brace, it's an ExpressionStatement or LabeledStatement. We
          // simply start parsing an expression, and afterwards, if the
          // next token is a colon and the expression was a simple
          // Identifier node, we switch to interpreting it as a label.
          default:
            if (this.isAsyncFunction()) {
              if (context) {
                this.unexpected();
              }
              this.next();
              return this.parseFunctionStatement(node, true, !context);
            }
            var usingKind = this.isAwaitUsing(false) ? "await using" : this.isUsing(false) ? "using" : null;
            if (usingKind) {
              if (topLevel && this.options.sourceType === "script") {
                this.raise(this.start, "Using declaration cannot appear in the top level when source type is `script`");
              }
              if (usingKind === "await using") {
                if (!this.canAwait) {
                  this.raise(this.start, "Await using cannot appear outside of async function");
                }
                this.next();
              }
              this.next();
              this.parseVar(node, false, usingKind);
              this.semicolon();
              return this.finishNode(node, "VariableDeclaration");
            }
            var maybeName = this.value, expr = this.parseExpression();
            if (starttype === types$1.name && expr.type === "Identifier" && this.eat(types$1.colon)) {
              return this.parseLabeledStatement(node, maybeName, expr, context);
            } else {
              return this.parseExpressionStatement(node, expr);
            }
        }
      };
      pp$8.parseBreakContinueStatement = function(node, keyword) {
        var isBreak = keyword === "break";
        this.next();
        if (this.eat(types$1.semi) || this.insertSemicolon()) {
          node.label = null;
        } else if (this.type !== types$1.name) {
          this.unexpected();
        } else {
          node.label = this.parseIdent();
          this.semicolon();
        }
        var i2 = 0;
        for (; i2 < this.labels.length; ++i2) {
          var lab = this.labels[i2];
          if (node.label == null || lab.name === node.label.name) {
            if (lab.kind != null && (isBreak || lab.kind === "loop")) {
              break;
            }
            if (node.label && isBreak) {
              break;
            }
          }
        }
        if (i2 === this.labels.length) {
          this.raise(node.start, "Unsyntactic " + keyword);
        }
        return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
      };
      pp$8.parseDebuggerStatement = function(node) {
        this.next();
        this.semicolon();
        return this.finishNode(node, "DebuggerStatement");
      };
      pp$8.parseDoStatement = function(node) {
        this.next();
        this.labels.push(loopLabel);
        node.body = this.parseStatement("do");
        this.labels.pop();
        this.expect(types$1._while);
        node.test = this.parseParenExpression();
        if (this.options.ecmaVersion >= 6) {
          this.eat(types$1.semi);
        } else {
          this.semicolon();
        }
        return this.finishNode(node, "DoWhileStatement");
      };
      pp$8.parseForStatement = function(node) {
        this.next();
        var awaitAt = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
        this.labels.push(loopLabel);
        this.enterScope(0);
        this.expect(types$1.parenL);
        if (this.type === types$1.semi) {
          if (awaitAt > -1) {
            this.unexpected(awaitAt);
          }
          return this.parseFor(node, null);
        }
        var isLet = this.isLet();
        if (this.type === types$1._var || this.type === types$1._const || isLet) {
          var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
          this.next();
          this.parseVar(init$1, true, kind);
          this.finishNode(init$1, "VariableDeclaration");
          return this.parseForAfterInit(node, init$1, awaitAt);
        }
        var startsWithLet = this.isContextual("let"), isForOf = false;
        var usingKind = this.isUsing(true) ? "using" : this.isAwaitUsing(true) ? "await using" : null;
        if (usingKind) {
          var init$2 = this.startNode();
          this.next();
          if (usingKind === "await using") {
            this.next();
          }
          this.parseVar(init$2, true, usingKind);
          this.finishNode(init$2, "VariableDeclaration");
          return this.parseForAfterInit(node, init$2, awaitAt);
        }
        var containsEsc = this.containsEsc;
        var refDestructuringErrors = new DestructuringErrors();
        var initPos = this.start;
        var init = awaitAt > -1 ? this.parseExprSubscripts(refDestructuringErrors, "await") : this.parseExpression(true, refDestructuringErrors);
        if (this.type === types$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
          if (awaitAt > -1) {
            if (this.type === types$1._in) {
              this.unexpected(awaitAt);
            }
            node.await = true;
          } else if (isForOf && this.options.ecmaVersion >= 8) {
            if (init.start === initPos && !containsEsc && init.type === "Identifier" && init.name === "async") {
              this.unexpected();
            } else if (this.options.ecmaVersion >= 9) {
              node.await = false;
            }
          }
          if (startsWithLet && isForOf) {
            this.raise(init.start, "The left-hand side of a for-of loop may not start with 'let'.");
          }
          this.toAssignable(init, false, refDestructuringErrors);
          this.checkLValPattern(init);
          return this.parseForIn(node, init);
        } else {
          this.checkExpressionErrors(refDestructuringErrors, true);
        }
        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }
        return this.parseFor(node, init);
      };
      pp$8.parseForAfterInit = function(node, init, awaitAt) {
        if ((this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && init.declarations.length === 1) {
          if (this.options.ecmaVersion >= 9) {
            if (this.type === types$1._in) {
              if (awaitAt > -1) {
                this.unexpected(awaitAt);
              }
            } else {
              node.await = awaitAt > -1;
            }
          }
          return this.parseForIn(node, init);
        }
        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }
        return this.parseFor(node, init);
      };
      pp$8.parseFunctionStatement = function(node, isAsync, declarationPosition) {
        this.next();
        return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync);
      };
      pp$8.parseIfStatement = function(node) {
        this.next();
        node.test = this.parseParenExpression();
        node.consequent = this.parseStatement("if");
        node.alternate = this.eat(types$1._else) ? this.parseStatement("if") : null;
        return this.finishNode(node, "IfStatement");
      };
      pp$8.parseReturnStatement = function(node) {
        if (!this.inFunction && !this.options.allowReturnOutsideFunction) {
          this.raise(this.start, "'return' outside of function");
        }
        this.next();
        if (this.eat(types$1.semi) || this.insertSemicolon()) {
          node.argument = null;
        } else {
          node.argument = this.parseExpression();
          this.semicolon();
        }
        return this.finishNode(node, "ReturnStatement");
      };
      pp$8.parseSwitchStatement = function(node) {
        this.next();
        node.discriminant = this.parseParenExpression();
        node.cases = [];
        this.expect(types$1.braceL);
        this.labels.push(switchLabel);
        this.enterScope(0);
        var cur;
        for (var sawDefault = false; this.type !== types$1.braceR; ) {
          if (this.type === types$1._case || this.type === types$1._default) {
            var isCase = this.type === types$1._case;
            if (cur) {
              this.finishNode(cur, "SwitchCase");
            }
            node.cases.push(cur = this.startNode());
            cur.consequent = [];
            this.next();
            if (isCase) {
              cur.test = this.parseExpression();
            } else {
              if (sawDefault) {
                this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
              }
              sawDefault = true;
              cur.test = null;
            }
            this.expect(types$1.colon);
          } else {
            if (!cur) {
              this.unexpected();
            }
            cur.consequent.push(this.parseStatement(null));
          }
        }
        this.exitScope();
        if (cur) {
          this.finishNode(cur, "SwitchCase");
        }
        this.next();
        this.labels.pop();
        return this.finishNode(node, "SwitchStatement");
      };
      pp$8.parseThrowStatement = function(node) {
        this.next();
        if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) {
          this.raise(this.lastTokEnd, "Illegal newline after throw");
        }
        node.argument = this.parseExpression();
        this.semicolon();
        return this.finishNode(node, "ThrowStatement");
      };
      var empty$1 = [];
      pp$8.parseCatchClauseParam = function() {
        var param = this.parseBindingAtom();
        var simple = param.type === "Identifier";
        this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
        this.checkLValPattern(param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
        this.expect(types$1.parenR);
        return param;
      };
      pp$8.parseTryStatement = function(node) {
        this.next();
        node.block = this.parseBlock();
        node.handler = null;
        if (this.type === types$1._catch) {
          var clause = this.startNode();
          this.next();
          if (this.eat(types$1.parenL)) {
            clause.param = this.parseCatchClauseParam();
          } else {
            if (this.options.ecmaVersion < 10) {
              this.unexpected();
            }
            clause.param = null;
            this.enterScope(0);
          }
          clause.body = this.parseBlock(false);
          this.exitScope();
          node.handler = this.finishNode(clause, "CatchClause");
        }
        node.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;
        if (!node.handler && !node.finalizer) {
          this.raise(node.start, "Missing catch or finally clause");
        }
        return this.finishNode(node, "TryStatement");
      };
      pp$8.parseVarStatement = function(node, kind, allowMissingInitializer) {
        this.next();
        this.parseVar(node, false, kind, allowMissingInitializer);
        this.semicolon();
        return this.finishNode(node, "VariableDeclaration");
      };
      pp$8.parseWhileStatement = function(node) {
        this.next();
        node.test = this.parseParenExpression();
        this.labels.push(loopLabel);
        node.body = this.parseStatement("while");
        this.labels.pop();
        return this.finishNode(node, "WhileStatement");
      };
      pp$8.parseWithStatement = function(node) {
        if (this.strict) {
          this.raise(this.start, "'with' in strict mode");
        }
        this.next();
        node.object = this.parseParenExpression();
        node.body = this.parseStatement("with");
        return this.finishNode(node, "WithStatement");
      };
      pp$8.parseEmptyStatement = function(node) {
        this.next();
        return this.finishNode(node, "EmptyStatement");
      };
      pp$8.parseLabeledStatement = function(node, maybeName, expr, context) {
        for (var i$1 = 0, list2 = this.labels; i$1 < list2.length; i$1 += 1) {
          var label = list2[i$1];
          if (label.name === maybeName) {
            this.raise(expr.start, "Label '" + maybeName + "' is already declared");
          }
        }
        var kind = this.type.isLoop ? "loop" : this.type === types$1._switch ? "switch" : null;
        for (var i2 = this.labels.length - 1; i2 >= 0; i2--) {
          var label$1 = this.labels[i2];
          if (label$1.statementStart === node.start) {
            label$1.statementStart = this.start;
            label$1.kind = kind;
          } else {
            break;
          }
        }
        this.labels.push({ name: maybeName, kind, statementStart: this.start });
        node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
        this.labels.pop();
        node.label = expr;
        return this.finishNode(node, "LabeledStatement");
      };
      pp$8.parseExpressionStatement = function(node, expr) {
        node.expression = expr;
        this.semicolon();
        return this.finishNode(node, "ExpressionStatement");
      };
      pp$8.parseBlock = function(createNewLexicalScope, node, exitStrict) {
        if (createNewLexicalScope === void 0) createNewLexicalScope = true;
        if (node === void 0) node = this.startNode();
        node.body = [];
        this.expect(types$1.braceL);
        if (createNewLexicalScope) {
          this.enterScope(0);
        }
        while (this.type !== types$1.braceR) {
          var stmt = this.parseStatement(null);
          node.body.push(stmt);
        }
        if (exitStrict) {
          this.strict = false;
        }
        this.next();
        if (createNewLexicalScope) {
          this.exitScope();
        }
        return this.finishNode(node, "BlockStatement");
      };
      pp$8.parseFor = function(node, init) {
        node.init = init;
        this.expect(types$1.semi);
        node.test = this.type === types$1.semi ? null : this.parseExpression();
        this.expect(types$1.semi);
        node.update = this.type === types$1.parenR ? null : this.parseExpression();
        this.expect(types$1.parenR);
        node.body = this.parseStatement("for");
        this.exitScope();
        this.labels.pop();
        return this.finishNode(node, "ForStatement");
      };
      pp$8.parseForIn = function(node, init) {
        var isForIn = this.type === types$1._in;
        this.next();
        if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) {
          this.raise(
            init.start,
            (isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer"
          );
        }
        node.left = init;
        node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
        this.expect(types$1.parenR);
        node.body = this.parseStatement("for");
        this.exitScope();
        this.labels.pop();
        return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
      };
      pp$8.parseVar = function(node, isFor, kind, allowMissingInitializer) {
        node.declarations = [];
        node.kind = kind;
        for (; ; ) {
          var decl = this.startNode();
          this.parseVarId(decl, kind);
          if (this.eat(types$1.eq)) {
            decl.init = this.parseMaybeAssign(isFor);
          } else if (!allowMissingInitializer && kind === "const" && !(this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
            this.unexpected();
          } else if (!allowMissingInitializer && (kind === "using" || kind === "await using") && this.options.ecmaVersion >= 17 && this.type !== types$1._in && !this.isContextual("of")) {
            this.raise(this.lastTokEnd, "Missing initializer in " + kind + " declaration");
          } else if (!allowMissingInitializer && decl.id.type !== "Identifier" && !(isFor && (this.type === types$1._in || this.isContextual("of")))) {
            this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
          } else {
            decl.init = null;
          }
          node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
          if (!this.eat(types$1.comma)) {
            break;
          }
        }
        return node;
      };
      pp$8.parseVarId = function(decl, kind) {
        decl.id = kind === "using" || kind === "await using" ? this.parseIdent() : this.parseBindingAtom();
        this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
      };
      var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;
      pp$8.parseFunction = function(node, statement, allowExpressionBody, isAsync, forInit) {
        this.initFunction(node);
        if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
          if (this.type === types$1.star && statement & FUNC_HANGING_STATEMENT) {
            this.unexpected();
          }
          node.generator = this.eat(types$1.star);
        }
        if (this.options.ecmaVersion >= 8) {
          node.async = !!isAsync;
        }
        if (statement & FUNC_STATEMENT) {
          node.id = statement & FUNC_NULLABLE_ID && this.type !== types$1.name ? null : this.parseIdent();
          if (node.id && !(statement & FUNC_HANGING_STATEMENT)) {
            this.checkLValSimple(node.id, this.strict || node.generator || node.async ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION);
          }
        }
        var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        this.enterScope(functionFlags(node.async, node.generator));
        if (!(statement & FUNC_STATEMENT)) {
          node.id = this.type === types$1.name ? this.parseIdent() : null;
        }
        this.parseFunctionParams(node);
        this.parseFunctionBody(node, allowExpressionBody, false, forInit);
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.finishNode(node, statement & FUNC_STATEMENT ? "FunctionDeclaration" : "FunctionExpression");
      };
      pp$8.parseFunctionParams = function(node) {
        this.expect(types$1.parenL);
        node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
        this.checkYieldAwaitInDefaultParams();
      };
      pp$8.parseClass = function(node, isStatement) {
        this.next();
        var oldStrict = this.strict;
        this.strict = true;
        this.parseClassId(node, isStatement);
        this.parseClassSuper(node);
        var privateNameMap = this.enterClassBody();
        var classBody = this.startNode();
        var hadConstructor = false;
        classBody.body = [];
        this.expect(types$1.braceL);
        while (this.type !== types$1.braceR) {
          var element = this.parseClassElement(node.superClass !== null);
          if (element) {
            classBody.body.push(element);
            if (element.type === "MethodDefinition" && element.kind === "constructor") {
              if (hadConstructor) {
                this.raiseRecoverable(element.start, "Duplicate constructor in the same class");
              }
              hadConstructor = true;
            } else if (element.key && element.key.type === "PrivateIdentifier" && isPrivateNameConflicted(privateNameMap, element)) {
              this.raiseRecoverable(element.key.start, "Identifier '#" + element.key.name + "' has already been declared");
            }
          }
        }
        this.strict = oldStrict;
        this.next();
        node.body = this.finishNode(classBody, "ClassBody");
        this.exitClassBody();
        return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
      };
      pp$8.parseClassElement = function(constructorAllowsSuper) {
        if (this.eat(types$1.semi)) {
          return null;
        }
        var ecmaVersion2 = this.options.ecmaVersion;
        var node = this.startNode();
        var keyName = "";
        var isGenerator = false;
        var isAsync = false;
        var kind = "method";
        var isStatic = false;
        if (this.eatContextual("static")) {
          if (ecmaVersion2 >= 13 && this.eat(types$1.braceL)) {
            this.parseClassStaticBlock(node);
            return node;
          }
          if (this.isClassElementNameStart() || this.type === types$1.star) {
            isStatic = true;
          } else {
            keyName = "static";
          }
        }
        node.static = isStatic;
        if (!keyName && ecmaVersion2 >= 8 && this.eatContextual("async")) {
          if ((this.isClassElementNameStart() || this.type === types$1.star) && !this.canInsertSemicolon()) {
            isAsync = true;
          } else {
            keyName = "async";
          }
        }
        if (!keyName && (ecmaVersion2 >= 9 || !isAsync) && this.eat(types$1.star)) {
          isGenerator = true;
        }
        if (!keyName && !isAsync && !isGenerator) {
          var lastValue = this.value;
          if (this.eatContextual("get") || this.eatContextual("set")) {
            if (this.isClassElementNameStart()) {
              kind = lastValue;
            } else {
              keyName = lastValue;
            }
          }
        }
        if (keyName) {
          node.computed = false;
          node.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
          node.key.name = keyName;
          this.finishNode(node.key, "Identifier");
        } else {
          this.parseClassElementName(node);
        }
        if (ecmaVersion2 < 13 || this.type === types$1.parenL || kind !== "method" || isGenerator || isAsync) {
          var isConstructor = !node.static && checkKeyName(node, "constructor");
          var allowsDirectSuper = isConstructor && constructorAllowsSuper;
          if (isConstructor && kind !== "method") {
            this.raise(node.key.start, "Constructor can't have get/set modifier");
          }
          node.kind = isConstructor ? "constructor" : kind;
          this.parseClassMethod(node, isGenerator, isAsync, allowsDirectSuper);
        } else {
          this.parseClassField(node);
        }
        return node;
      };
      pp$8.isClassElementNameStart = function() {
        return this.type === types$1.name || this.type === types$1.privateId || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword;
      };
      pp$8.parseClassElementName = function(element) {
        if (this.type === types$1.privateId) {
          if (this.value === "constructor") {
            this.raise(this.start, "Classes can't have an element named '#constructor'");
          }
          element.computed = false;
          element.key = this.parsePrivateIdent();
        } else {
          this.parsePropertyName(element);
        }
      };
      pp$8.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
        var key = method.key;
        if (method.kind === "constructor") {
          if (isGenerator) {
            this.raise(key.start, "Constructor can't be a generator");
          }
          if (isAsync) {
            this.raise(key.start, "Constructor can't be an async method");
          }
        } else if (method.static && checkKeyName(method, "prototype")) {
          this.raise(key.start, "Classes may not have a static property named prototype");
        }
        var value2 = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
        if (method.kind === "get" && value2.params.length !== 0) {
          this.raiseRecoverable(value2.start, "getter should have no params");
        }
        if (method.kind === "set" && value2.params.length !== 1) {
          this.raiseRecoverable(value2.start, "setter should have exactly one param");
        }
        if (method.kind === "set" && value2.params[0].type === "RestElement") {
          this.raiseRecoverable(value2.params[0].start, "Setter cannot use rest params");
        }
        return this.finishNode(method, "MethodDefinition");
      };
      pp$8.parseClassField = function(field) {
        if (checkKeyName(field, "constructor")) {
          this.raise(field.key.start, "Classes can't have a field named 'constructor'");
        } else if (field.static && checkKeyName(field, "prototype")) {
          this.raise(field.key.start, "Classes can't have a static field named 'prototype'");
        }
        if (this.eat(types$1.eq)) {
          this.enterScope(SCOPE_CLASS_FIELD_INIT | SCOPE_SUPER);
          field.value = this.parseMaybeAssign();
          this.exitScope();
        } else {
          field.value = null;
        }
        this.semicolon();
        return this.finishNode(field, "PropertyDefinition");
      };
      pp$8.parseClassStaticBlock = function(node) {
        node.body = [];
        var oldLabels = this.labels;
        this.labels = [];
        this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);
        while (this.type !== types$1.braceR) {
          var stmt = this.parseStatement(null);
          node.body.push(stmt);
        }
        this.next();
        this.exitScope();
        this.labels = oldLabels;
        return this.finishNode(node, "StaticBlock");
      };
      pp$8.parseClassId = function(node, isStatement) {
        if (this.type === types$1.name) {
          node.id = this.parseIdent();
          if (isStatement) {
            this.checkLValSimple(node.id, BIND_LEXICAL, false);
          }
        } else {
          if (isStatement === true) {
            this.unexpected();
          }
          node.id = null;
        }
      };
      pp$8.parseClassSuper = function(node) {
        node.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts(null, false) : null;
      };
      pp$8.enterClassBody = function() {
        var element = { declared: /* @__PURE__ */ Object.create(null), used: [] };
        this.privateNameStack.push(element);
        return element.declared;
      };
      pp$8.exitClassBody = function() {
        var ref2 = this.privateNameStack.pop();
        var declared = ref2.declared;
        var used = ref2.used;
        if (!this.options.checkPrivateFields) {
          return;
        }
        var len = this.privateNameStack.length;
        var parent = len === 0 ? null : this.privateNameStack[len - 1];
        for (var i2 = 0; i2 < used.length; ++i2) {
          var id = used[i2];
          if (!hasOwn(declared, id.name)) {
            if (parent) {
              parent.used.push(id);
            } else {
              this.raiseRecoverable(id.start, "Private field '#" + id.name + "' must be declared in an enclosing class");
            }
          }
        }
      };
      function isPrivateNameConflicted(privateNameMap, element) {
        var name = element.key.name;
        var curr = privateNameMap[name];
        var next = "true";
        if (element.type === "MethodDefinition" && (element.kind === "get" || element.kind === "set")) {
          next = (element.static ? "s" : "i") + element.kind;
        }
        if (curr === "iget" && next === "iset" || curr === "iset" && next === "iget" || curr === "sget" && next === "sset" || curr === "sset" && next === "sget") {
          privateNameMap[name] = "true";
          return false;
        } else if (!curr) {
          privateNameMap[name] = next;
          return false;
        } else {
          return true;
        }
      }
      function checkKeyName(node, name) {
        var computed = node.computed;
        var key = node.key;
        return !computed && (key.type === "Identifier" && key.name === name || key.type === "Literal" && key.value === name);
      }
      pp$8.parseExportAllDeclaration = function(node, exports4) {
        if (this.options.ecmaVersion >= 11) {
          if (this.eatContextual("as")) {
            node.exported = this.parseModuleExportName();
            this.checkExport(exports4, node.exported, this.lastTokStart);
          } else {
            node.exported = null;
          }
        }
        this.expectContextual("from");
        if (this.type !== types$1.string) {
          this.unexpected();
        }
        node.source = this.parseExprAtom();
        if (this.options.ecmaVersion >= 16) {
          node.attributes = this.parseWithClause();
        }
        this.semicolon();
        return this.finishNode(node, "ExportAllDeclaration");
      };
      pp$8.parseExport = function(node, exports4) {
        this.next();
        if (this.eat(types$1.star)) {
          return this.parseExportAllDeclaration(node, exports4);
        }
        if (this.eat(types$1._default)) {
          this.checkExport(exports4, "default", this.lastTokStart);
          node.declaration = this.parseExportDefaultDeclaration();
          return this.finishNode(node, "ExportDefaultDeclaration");
        }
        if (this.shouldParseExportStatement()) {
          node.declaration = this.parseExportDeclaration(node);
          if (node.declaration.type === "VariableDeclaration") {
            this.checkVariableExport(exports4, node.declaration.declarations);
          } else {
            this.checkExport(exports4, node.declaration.id, node.declaration.id.start);
          }
          node.specifiers = [];
          node.source = null;
          if (this.options.ecmaVersion >= 16) {
            node.attributes = [];
          }
        } else {
          node.declaration = null;
          node.specifiers = this.parseExportSpecifiers(exports4);
          if (this.eatContextual("from")) {
            if (this.type !== types$1.string) {
              this.unexpected();
            }
            node.source = this.parseExprAtom();
            if (this.options.ecmaVersion >= 16) {
              node.attributes = this.parseWithClause();
            }
          } else {
            for (var i2 = 0, list2 = node.specifiers; i2 < list2.length; i2 += 1) {
              var spec = list2[i2];
              this.checkUnreserved(spec.local);
              this.checkLocalExport(spec.local);
              if (spec.local.type === "Literal") {
                this.raise(spec.local.start, "A string literal cannot be used as an exported binding without `from`.");
              }
            }
            node.source = null;
            if (this.options.ecmaVersion >= 16) {
              node.attributes = [];
            }
          }
          this.semicolon();
        }
        return this.finishNode(node, "ExportNamedDeclaration");
      };
      pp$8.parseExportDeclaration = function(node) {
        return this.parseStatement(null);
      };
      pp$8.parseExportDefaultDeclaration = function() {
        var isAsync;
        if (this.type === types$1._function || (isAsync = this.isAsyncFunction())) {
          var fNode = this.startNode();
          this.next();
          if (isAsync) {
            this.next();
          }
          return this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
        } else if (this.type === types$1._class) {
          var cNode = this.startNode();
          return this.parseClass(cNode, "nullableID");
        } else {
          var declaration = this.parseMaybeAssign();
          this.semicolon();
          return declaration;
        }
      };
      pp$8.checkExport = function(exports4, name, pos) {
        if (!exports4) {
          return;
        }
        if (typeof name !== "string") {
          name = name.type === "Identifier" ? name.name : name.value;
        }
        if (hasOwn(exports4, name)) {
          this.raiseRecoverable(pos, "Duplicate export '" + name + "'");
        }
        exports4[name] = true;
      };
      pp$8.checkPatternExport = function(exports4, pat) {
        var type = pat.type;
        if (type === "Identifier") {
          this.checkExport(exports4, pat, pat.start);
        } else if (type === "ObjectPattern") {
          for (var i2 = 0, list2 = pat.properties; i2 < list2.length; i2 += 1) {
            var prop = list2[i2];
            this.checkPatternExport(exports4, prop);
          }
        } else if (type === "ArrayPattern") {
          for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
            var elt = list$1[i$1];
            if (elt) {
              this.checkPatternExport(exports4, elt);
            }
          }
        } else if (type === "Property") {
          this.checkPatternExport(exports4, pat.value);
        } else if (type === "AssignmentPattern") {
          this.checkPatternExport(exports4, pat.left);
        } else if (type === "RestElement") {
          this.checkPatternExport(exports4, pat.argument);
        }
      };
      pp$8.checkVariableExport = function(exports4, decls) {
        if (!exports4) {
          return;
        }
        for (var i2 = 0, list2 = decls; i2 < list2.length; i2 += 1) {
          var decl = list2[i2];
          this.checkPatternExport(exports4, decl.id);
        }
      };
      pp$8.shouldParseExportStatement = function() {
        return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
      };
      pp$8.parseExportSpecifier = function(exports4) {
        var node = this.startNode();
        node.local = this.parseModuleExportName();
        node.exported = this.eatContextual("as") ? this.parseModuleExportName() : node.local;
        this.checkExport(
          exports4,
          node.exported,
          node.exported.start
        );
        return this.finishNode(node, "ExportSpecifier");
      };
      pp$8.parseExportSpecifiers = function(exports4) {
        var nodes = [], first = true;
        this.expect(types$1.braceL);
        while (!this.eat(types$1.braceR)) {
          if (!first) {
            this.expect(types$1.comma);
            if (this.afterTrailingComma(types$1.braceR)) {
              break;
            }
          } else {
            first = false;
          }
          nodes.push(this.parseExportSpecifier(exports4));
        }
        return nodes;
      };
      pp$8.parseImport = function(node) {
        this.next();
        if (this.type === types$1.string) {
          node.specifiers = empty$1;
          node.source = this.parseExprAtom();
        } else {
          node.specifiers = this.parseImportSpecifiers();
          this.expectContextual("from");
          node.source = this.type === types$1.string ? this.parseExprAtom() : this.unexpected();
        }
        if (this.options.ecmaVersion >= 16) {
          node.attributes = this.parseWithClause();
        }
        this.semicolon();
        return this.finishNode(node, "ImportDeclaration");
      };
      pp$8.parseImportSpecifier = function() {
        var node = this.startNode();
        node.imported = this.parseModuleExportName();
        if (this.eatContextual("as")) {
          node.local = this.parseIdent();
        } else {
          this.checkUnreserved(node.imported);
          node.local = node.imported;
        }
        this.checkLValSimple(node.local, BIND_LEXICAL);
        return this.finishNode(node, "ImportSpecifier");
      };
      pp$8.parseImportDefaultSpecifier = function() {
        var node = this.startNode();
        node.local = this.parseIdent();
        this.checkLValSimple(node.local, BIND_LEXICAL);
        return this.finishNode(node, "ImportDefaultSpecifier");
      };
      pp$8.parseImportNamespaceSpecifier = function() {
        var node = this.startNode();
        this.next();
        this.expectContextual("as");
        node.local = this.parseIdent();
        this.checkLValSimple(node.local, BIND_LEXICAL);
        return this.finishNode(node, "ImportNamespaceSpecifier");
      };
      pp$8.parseImportSpecifiers = function() {
        var nodes = [], first = true;
        if (this.type === types$1.name) {
          nodes.push(this.parseImportDefaultSpecifier());
          if (!this.eat(types$1.comma)) {
            return nodes;
          }
        }
        if (this.type === types$1.star) {
          nodes.push(this.parseImportNamespaceSpecifier());
          return nodes;
        }
        this.expect(types$1.braceL);
        while (!this.eat(types$1.braceR)) {
          if (!first) {
            this.expect(types$1.comma);
            if (this.afterTrailingComma(types$1.braceR)) {
              break;
            }
          } else {
            first = false;
          }
          nodes.push(this.parseImportSpecifier());
        }
        return nodes;
      };
      pp$8.parseWithClause = function() {
        var nodes = [];
        if (!this.eat(types$1._with)) {
          return nodes;
        }
        this.expect(types$1.braceL);
        var attributeKeys = {};
        var first = true;
        while (!this.eat(types$1.braceR)) {
          if (!first) {
            this.expect(types$1.comma);
            if (this.afterTrailingComma(types$1.braceR)) {
              break;
            }
          } else {
            first = false;
          }
          var attr = this.parseImportAttribute();
          var keyName = attr.key.type === "Identifier" ? attr.key.name : attr.key.value;
          if (hasOwn(attributeKeys, keyName)) {
            this.raiseRecoverable(attr.key.start, "Duplicate attribute key '" + keyName + "'");
          }
          attributeKeys[keyName] = true;
          nodes.push(attr);
        }
        return nodes;
      };
      pp$8.parseImportAttribute = function() {
        var node = this.startNode();
        node.key = this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
        this.expect(types$1.colon);
        if (this.type !== types$1.string) {
          this.unexpected();
        }
        node.value = this.parseExprAtom();
        return this.finishNode(node, "ImportAttribute");
      };
      pp$8.parseModuleExportName = function() {
        if (this.options.ecmaVersion >= 13 && this.type === types$1.string) {
          var stringLiteral = this.parseLiteral(this.value);
          if (loneSurrogate.test(stringLiteral.value)) {
            this.raise(stringLiteral.start, "An export name cannot include a lone surrogate.");
          }
          return stringLiteral;
        }
        return this.parseIdent(true);
      };
      pp$8.adaptDirectivePrologue = function(statements) {
        for (var i2 = 0; i2 < statements.length && this.isDirectiveCandidate(statements[i2]); ++i2) {
          statements[i2].directive = statements[i2].expression.raw.slice(1, -1);
        }
      };
      pp$8.isDirectiveCandidate = function(statement) {
        return this.options.ecmaVersion >= 5 && statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && typeof statement.expression.value === "string" && // Reject parenthesized strings.
        (this.input[statement.start] === '"' || this.input[statement.start] === "'");
      };
      var pp$7 = Parser.prototype;
      pp$7.toAssignable = function(node, isBinding, refDestructuringErrors) {
        if (this.options.ecmaVersion >= 6 && node) {
          switch (node.type) {
            case "Identifier":
              if (this.inAsync && node.name === "await") {
                this.raise(node.start, "Cannot use 'await' as identifier inside an async function");
              }
              break;
            case "ObjectPattern":
            case "ArrayPattern":
            case "AssignmentPattern":
            case "RestElement":
              break;
            case "ObjectExpression":
              node.type = "ObjectPattern";
              if (refDestructuringErrors) {
                this.checkPatternErrors(refDestructuringErrors, true);
              }
              for (var i2 = 0, list2 = node.properties; i2 < list2.length; i2 += 1) {
                var prop = list2[i2];
                this.toAssignable(prop, isBinding);
                if (prop.type === "RestElement" && (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")) {
                  this.raise(prop.argument.start, "Unexpected token");
                }
              }
              break;
            case "Property":
              if (node.kind !== "init") {
                this.raise(node.key.start, "Object pattern can't contain getter or setter");
              }
              this.toAssignable(node.value, isBinding);
              break;
            case "ArrayExpression":
              node.type = "ArrayPattern";
              if (refDestructuringErrors) {
                this.checkPatternErrors(refDestructuringErrors, true);
              }
              this.toAssignableList(node.elements, isBinding);
              break;
            case "SpreadElement":
              node.type = "RestElement";
              this.toAssignable(node.argument, isBinding);
              if (node.argument.type === "AssignmentPattern") {
                this.raise(node.argument.start, "Rest elements cannot have a default value");
              }
              break;
            case "AssignmentExpression":
              if (node.operator !== "=") {
                this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
              }
              node.type = "AssignmentPattern";
              delete node.operator;
              this.toAssignable(node.left, isBinding);
              break;
            case "ParenthesizedExpression":
              this.toAssignable(node.expression, isBinding, refDestructuringErrors);
              break;
            case "ChainExpression":
              this.raiseRecoverable(node.start, "Optional chaining cannot appear in left-hand side");
              break;
            case "MemberExpression":
              if (!isBinding) {
                break;
              }
            default:
              this.raise(node.start, "Assigning to rvalue");
          }
        } else if (refDestructuringErrors) {
          this.checkPatternErrors(refDestructuringErrors, true);
        }
        return node;
      };
      pp$7.toAssignableList = function(exprList, isBinding) {
        var end = exprList.length;
        for (var i2 = 0; i2 < end; i2++) {
          var elt = exprList[i2];
          if (elt) {
            this.toAssignable(elt, isBinding);
          }
        }
        if (end) {
          var last = exprList[end - 1];
          if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier") {
            this.unexpected(last.argument.start);
          }
        }
        return exprList;
      };
      pp$7.parseSpread = function(refDestructuringErrors) {
        var node = this.startNode();
        this.next();
        node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
        return this.finishNode(node, "SpreadElement");
      };
      pp$7.parseRestBinding = function() {
        var node = this.startNode();
        this.next();
        if (this.options.ecmaVersion === 6 && this.type !== types$1.name) {
          this.unexpected();
        }
        node.argument = this.parseBindingAtom();
        return this.finishNode(node, "RestElement");
      };
      pp$7.parseBindingAtom = function() {
        if (this.options.ecmaVersion >= 6) {
          switch (this.type) {
            case types$1.bracketL:
              var node = this.startNode();
              this.next();
              node.elements = this.parseBindingList(types$1.bracketR, true, true);
              return this.finishNode(node, "ArrayPattern");
            case types$1.braceL:
              return this.parseObj(true);
          }
        }
        return this.parseIdent();
      };
      pp$7.parseBindingList = function(close, allowEmpty, allowTrailingComma, allowModifiers) {
        var elts = [], first = true;
        while (!this.eat(close)) {
          if (first) {
            first = false;
          } else {
            this.expect(types$1.comma);
          }
          if (allowEmpty && this.type === types$1.comma) {
            elts.push(null);
          } else if (allowTrailingComma && this.afterTrailingComma(close)) {
            break;
          } else if (this.type === types$1.ellipsis) {
            var rest = this.parseRestBinding();
            this.parseBindingListItem(rest);
            elts.push(rest);
            if (this.type === types$1.comma) {
              this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
            }
            this.expect(close);
            break;
          } else {
            elts.push(this.parseAssignableListItem(allowModifiers));
          }
        }
        return elts;
      };
      pp$7.parseAssignableListItem = function(allowModifiers) {
        var elem = this.parseMaybeDefault(this.start, this.startLoc);
        this.parseBindingListItem(elem);
        return elem;
      };
      pp$7.parseBindingListItem = function(param) {
        return param;
      };
      pp$7.parseMaybeDefault = function(startPos, startLoc, left) {
        left = left || this.parseBindingAtom();
        if (this.options.ecmaVersion < 6 || !this.eat(types$1.eq)) {
          return left;
        }
        var node = this.startNodeAt(startPos, startLoc);
        node.left = left;
        node.right = this.parseMaybeAssign();
        return this.finishNode(node, "AssignmentPattern");
      };
      pp$7.checkLValSimple = function(expr, bindingType, checkClashes) {
        if (bindingType === void 0) bindingType = BIND_NONE;
        var isBind = bindingType !== BIND_NONE;
        switch (expr.type) {
          case "Identifier":
            if (this.strict && this.reservedWordsStrictBind.test(expr.name)) {
              this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
            }
            if (isBind) {
              if (bindingType === BIND_LEXICAL && expr.name === "let") {
                this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name");
              }
              if (checkClashes) {
                if (hasOwn(checkClashes, expr.name)) {
                  this.raiseRecoverable(expr.start, "Argument name clash");
                }
                checkClashes[expr.name] = true;
              }
              if (bindingType !== BIND_OUTSIDE) {
                this.declareName(expr.name, bindingType, expr.start);
              }
            }
            break;
          case "ChainExpression":
            this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
            break;
          case "MemberExpression":
            if (isBind) {
              this.raiseRecoverable(expr.start, "Binding member expression");
            }
            break;
          case "ParenthesizedExpression":
            if (isBind) {
              this.raiseRecoverable(expr.start, "Binding parenthesized expression");
            }
            return this.checkLValSimple(expr.expression, bindingType, checkClashes);
          default:
            this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
        }
      };
      pp$7.checkLValPattern = function(expr, bindingType, checkClashes) {
        if (bindingType === void 0) bindingType = BIND_NONE;
        switch (expr.type) {
          case "ObjectPattern":
            for (var i2 = 0, list2 = expr.properties; i2 < list2.length; i2 += 1) {
              var prop = list2[i2];
              this.checkLValInnerPattern(prop, bindingType, checkClashes);
            }
            break;
          case "ArrayPattern":
            for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
              var elem = list$1[i$1];
              if (elem) {
                this.checkLValInnerPattern(elem, bindingType, checkClashes);
              }
            }
            break;
          default:
            this.checkLValSimple(expr, bindingType, checkClashes);
        }
      };
      pp$7.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
        if (bindingType === void 0) bindingType = BIND_NONE;
        switch (expr.type) {
          case "Property":
            this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
            break;
          case "AssignmentPattern":
            this.checkLValPattern(expr.left, bindingType, checkClashes);
            break;
          case "RestElement":
            this.checkLValPattern(expr.argument, bindingType, checkClashes);
            break;
          default:
            this.checkLValPattern(expr, bindingType, checkClashes);
        }
      };
      var TokContext = function TokContext2(token, isExpr, preserveSpace, override, generator) {
        this.token = token;
        this.isExpr = !!isExpr;
        this.preserveSpace = !!preserveSpace;
        this.override = override;
        this.generator = !!generator;
      };
      var types = {
        b_stat: new TokContext("{", false),
        b_expr: new TokContext("{", true),
        b_tmpl: new TokContext("${", false),
        p_stat: new TokContext("(", false),
        p_expr: new TokContext("(", true),
        q_tmpl: new TokContext("`", true, true, function(p) {
          return p.tryReadTemplateToken();
        }),
        f_stat: new TokContext("function", false),
        f_expr: new TokContext("function", true),
        f_expr_gen: new TokContext("function", true, false, null, true),
        f_gen: new TokContext("function", false, false, null, true)
      };
      var pp$6 = Parser.prototype;
      pp$6.initialContext = function() {
        return [types.b_stat];
      };
      pp$6.curContext = function() {
        return this.context[this.context.length - 1];
      };
      pp$6.braceIsBlock = function(prevType) {
        var parent = this.curContext();
        if (parent === types.f_expr || parent === types.f_stat) {
          return true;
        }
        if (prevType === types$1.colon && (parent === types.b_stat || parent === types.b_expr)) {
          return !parent.isExpr;
        }
        if (prevType === types$1._return || prevType === types$1.name && this.exprAllowed) {
          return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
        }
        if (prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow) {
          return true;
        }
        if (prevType === types$1.braceL) {
          return parent === types.b_stat;
        }
        if (prevType === types$1._var || prevType === types$1._const || prevType === types$1.name) {
          return false;
        }
        return !this.exprAllowed;
      };
      pp$6.inGeneratorContext = function() {
        for (var i2 = this.context.length - 1; i2 >= 1; i2--) {
          var context = this.context[i2];
          if (context.token === "function") {
            return context.generator;
          }
        }
        return false;
      };
      pp$6.updateContext = function(prevType) {
        var update, type = this.type;
        if (type.keyword && prevType === types$1.dot) {
          this.exprAllowed = false;
        } else if (update = type.updateContext) {
          update.call(this, prevType);
        } else {
          this.exprAllowed = type.beforeExpr;
        }
      };
      pp$6.overrideContext = function(tokenCtx) {
        if (this.curContext() !== tokenCtx) {
          this.context[this.context.length - 1] = tokenCtx;
        }
      };
      types$1.parenR.updateContext = types$1.braceR.updateContext = function() {
        if (this.context.length === 1) {
          this.exprAllowed = true;
          return;
        }
        var out = this.context.pop();
        if (out === types.b_stat && this.curContext().token === "function") {
          out = this.context.pop();
        }
        this.exprAllowed = !out.isExpr;
      };
      types$1.braceL.updateContext = function(prevType) {
        this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);
        this.exprAllowed = true;
      };
      types$1.dollarBraceL.updateContext = function() {
        this.context.push(types.b_tmpl);
        this.exprAllowed = true;
      };
      types$1.parenL.updateContext = function(prevType) {
        var statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;
        this.context.push(statementParens ? types.p_stat : types.p_expr);
        this.exprAllowed = true;
      };
      types$1.incDec.updateContext = function() {
      };
      types$1._function.updateContext = types$1._class.updateContext = function(prevType) {
        if (prevType.beforeExpr && prevType !== types$1._else && !(prevType === types$1.semi && this.curContext() !== types.p_stat) && !(prevType === types$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types.b_stat)) {
          this.context.push(types.f_expr);
        } else {
          this.context.push(types.f_stat);
        }
        this.exprAllowed = false;
      };
      types$1.colon.updateContext = function() {
        if (this.curContext().token === "function") {
          this.context.pop();
        }
        this.exprAllowed = true;
      };
      types$1.backQuote.updateContext = function() {
        if (this.curContext() === types.q_tmpl) {
          this.context.pop();
        } else {
          this.context.push(types.q_tmpl);
        }
        this.exprAllowed = false;
      };
      types$1.star.updateContext = function(prevType) {
        if (prevType === types$1._function) {
          var index = this.context.length - 1;
          if (this.context[index] === types.f_expr) {
            this.context[index] = types.f_expr_gen;
          } else {
            this.context[index] = types.f_gen;
          }
        }
        this.exprAllowed = true;
      };
      types$1.name.updateContext = function(prevType) {
        var allowed = false;
        if (this.options.ecmaVersion >= 6 && prevType !== types$1.dot) {
          if (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) {
            allowed = true;
          }
        }
        this.exprAllowed = allowed;
      };
      var pp$5 = Parser.prototype;
      pp$5.checkPropClash = function(prop, propHash, refDestructuringErrors) {
        if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement") {
          return;
        }
        if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) {
          return;
        }
        var key = prop.key;
        var name;
        switch (key.type) {
          case "Identifier":
            name = key.name;
            break;
          case "Literal":
            name = String(key.value);
            break;
          default:
            return;
        }
        var kind = prop.kind;
        if (this.options.ecmaVersion >= 6) {
          if (name === "__proto__" && kind === "init") {
            if (propHash.proto) {
              if (refDestructuringErrors) {
                if (refDestructuringErrors.doubleProto < 0) {
                  refDestructuringErrors.doubleProto = key.start;
                }
              } else {
                this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
              }
            }
            propHash.proto = true;
          }
          return;
        }
        name = "$" + name;
        var other = propHash[name];
        if (other) {
          var redefinition;
          if (kind === "init") {
            redefinition = this.strict && other.init || other.get || other.set;
          } else {
            redefinition = other.init || other[kind];
          }
          if (redefinition) {
            this.raiseRecoverable(key.start, "Redefinition of property");
          }
        } else {
          other = propHash[name] = {
            init: false,
            get: false,
            set: false
          };
        }
        other[kind] = true;
      };
      pp$5.parseExpression = function(forInit, refDestructuringErrors) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
        if (this.type === types$1.comma) {
          var node = this.startNodeAt(startPos, startLoc);
          node.expressions = [expr];
          while (this.eat(types$1.comma)) {
            node.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors));
          }
          return this.finishNode(node, "SequenceExpression");
        }
        return expr;
      };
      pp$5.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
        if (this.isContextual("yield")) {
          if (this.inGenerator) {
            return this.parseYield(forInit);
          } else {
            this.exprAllowed = false;
          }
        }
        var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
        if (refDestructuringErrors) {
          oldParenAssign = refDestructuringErrors.parenthesizedAssign;
          oldTrailingComma = refDestructuringErrors.trailingComma;
          oldDoubleProto = refDestructuringErrors.doubleProto;
          refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
        } else {
          refDestructuringErrors = new DestructuringErrors();
          ownDestructuringErrors = true;
        }
        var startPos = this.start, startLoc = this.startLoc;
        if (this.type === types$1.parenL || this.type === types$1.name) {
          this.potentialArrowAt = this.start;
          this.potentialArrowInForAwait = forInit === "await";
        }
        var left = this.parseMaybeConditional(forInit, refDestructuringErrors);
        if (afterLeftParse) {
          left = afterLeftParse.call(this, left, startPos, startLoc);
        }
        if (this.type.isAssign) {
          var node = this.startNodeAt(startPos, startLoc);
          node.operator = this.value;
          if (this.type === types$1.eq) {
            left = this.toAssignable(left, false, refDestructuringErrors);
          }
          if (!ownDestructuringErrors) {
            refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
          }
          if (refDestructuringErrors.shorthandAssign >= left.start) {
            refDestructuringErrors.shorthandAssign = -1;
          }
          if (this.type === types$1.eq) {
            this.checkLValPattern(left);
          } else {
            this.checkLValSimple(left);
          }
          node.left = left;
          this.next();
          node.right = this.parseMaybeAssign(forInit);
          if (oldDoubleProto > -1) {
            refDestructuringErrors.doubleProto = oldDoubleProto;
          }
          return this.finishNode(node, "AssignmentExpression");
        } else {
          if (ownDestructuringErrors) {
            this.checkExpressionErrors(refDestructuringErrors, true);
          }
        }
        if (oldParenAssign > -1) {
          refDestructuringErrors.parenthesizedAssign = oldParenAssign;
        }
        if (oldTrailingComma > -1) {
          refDestructuringErrors.trailingComma = oldTrailingComma;
        }
        return left;
      };
      pp$5.parseMaybeConditional = function(forInit, refDestructuringErrors) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseExprOps(forInit, refDestructuringErrors);
        if (this.checkExpressionErrors(refDestructuringErrors)) {
          return expr;
        }
        if (this.eat(types$1.question)) {
          var node = this.startNodeAt(startPos, startLoc);
          node.test = expr;
          node.consequent = this.parseMaybeAssign();
          this.expect(types$1.colon);
          node.alternate = this.parseMaybeAssign(forInit);
          return this.finishNode(node, "ConditionalExpression");
        }
        return expr;
      };
      pp$5.parseExprOps = function(forInit, refDestructuringErrors) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
        if (this.checkExpressionErrors(refDestructuringErrors)) {
          return expr;
        }
        return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit);
      };
      pp$5.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {
        var prec = this.type.binop;
        if (prec != null && (!forInit || this.type !== types$1._in)) {
          if (prec > minPrec) {
            var logical = this.type === types$1.logicalOR || this.type === types$1.logicalAND;
            var coalesce = this.type === types$1.coalesce;
            if (coalesce) {
              prec = types$1.logicalAND.binop;
            }
            var op = this.value;
            this.next();
            var startPos = this.start, startLoc = this.startLoc;
            var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);
            var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
            if (logical && this.type === types$1.coalesce || coalesce && (this.type === types$1.logicalOR || this.type === types$1.logicalAND)) {
              this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
            }
            return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, forInit);
          }
        }
        return left;
      };
      pp$5.buildBinary = function(startPos, startLoc, left, right, op, logical) {
        if (right.type === "PrivateIdentifier") {
          this.raise(right.start, "Private identifier can only be left side of binary expression");
        }
        var node = this.startNodeAt(startPos, startLoc);
        node.left = left;
        node.operator = op;
        node.right = right;
        return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression");
      };
      pp$5.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {
        var startPos = this.start, startLoc = this.startLoc, expr;
        if (this.isContextual("await") && this.canAwait) {
          expr = this.parseAwait(forInit);
          sawUnary = true;
        } else if (this.type.prefix) {
          var node = this.startNode(), update = this.type === types$1.incDec;
          node.operator = this.value;
          node.prefix = true;
          this.next();
          node.argument = this.parseMaybeUnary(null, true, update, forInit);
          this.checkExpressionErrors(refDestructuringErrors, true);
          if (update) {
            this.checkLValSimple(node.argument);
          } else if (this.strict && node.operator === "delete" && isLocalVariableAccess(node.argument)) {
            this.raiseRecoverable(node.start, "Deleting local variable in strict mode");
          } else if (node.operator === "delete" && isPrivateFieldAccess(node.argument)) {
            this.raiseRecoverable(node.start, "Private fields can not be deleted");
          } else {
            sawUnary = true;
          }
          expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
        } else if (!sawUnary && this.type === types$1.privateId) {
          if ((forInit || this.privateNameStack.length === 0) && this.options.checkPrivateFields) {
            this.unexpected();
          }
          expr = this.parsePrivateIdent();
          if (this.type !== types$1._in) {
            this.unexpected();
          }
        } else {
          expr = this.parseExprSubscripts(refDestructuringErrors, forInit);
          if (this.checkExpressionErrors(refDestructuringErrors)) {
            return expr;
          }
          while (this.type.postfix && !this.canInsertSemicolon()) {
            var node$1 = this.startNodeAt(startPos, startLoc);
            node$1.operator = this.value;
            node$1.prefix = false;
            node$1.argument = expr;
            this.checkLValSimple(expr);
            this.next();
            expr = this.finishNode(node$1, "UpdateExpression");
          }
        }
        if (!incDec && this.eat(types$1.starstar)) {
          if (sawUnary) {
            this.unexpected(this.lastTokStart);
          } else {
            return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), "**", false);
          }
        } else {
          return expr;
        }
      };
      function isLocalVariableAccess(node) {
        return node.type === "Identifier" || node.type === "ParenthesizedExpression" && isLocalVariableAccess(node.expression);
      }
      function isPrivateFieldAccess(node) {
        return node.type === "MemberExpression" && node.property.type === "PrivateIdentifier" || node.type === "ChainExpression" && isPrivateFieldAccess(node.expression) || node.type === "ParenthesizedExpression" && isPrivateFieldAccess(node.expression);
      }
      pp$5.parseExprSubscripts = function(refDestructuringErrors, forInit) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseExprAtom(refDestructuringErrors, forInit);
        if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")") {
          return expr;
        }
        var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);
        if (refDestructuringErrors && result.type === "MemberExpression") {
          if (refDestructuringErrors.parenthesizedAssign >= result.start) {
            refDestructuringErrors.parenthesizedAssign = -1;
          }
          if (refDestructuringErrors.parenthesizedBind >= result.start) {
            refDestructuringErrors.parenthesizedBind = -1;
          }
          if (refDestructuringErrors.trailingComma >= result.start) {
            refDestructuringErrors.trailingComma = -1;
          }
        }
        return result;
      };
      pp$5.parseSubscripts = function(base, startPos, startLoc, noCalls, forInit) {
        var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" && this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && this.potentialArrowAt === base.start;
        var optionalChained = false;
        while (true) {
          var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);
          if (element.optional) {
            optionalChained = true;
          }
          if (element === base || element.type === "ArrowFunctionExpression") {
            if (optionalChained) {
              var chainNode = this.startNodeAt(startPos, startLoc);
              chainNode.expression = element;
              element = this.finishNode(chainNode, "ChainExpression");
            }
            return element;
          }
          base = element;
        }
      };
      pp$5.shouldParseAsyncArrow = function() {
        return !this.canInsertSemicolon() && this.eat(types$1.arrow);
      };
      pp$5.parseSubscriptAsyncArrow = function(startPos, startLoc, exprList, forInit) {
        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit);
      };
      pp$5.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
        var optionalSupported = this.options.ecmaVersion >= 11;
        var optional = optionalSupported && this.eat(types$1.questionDot);
        if (noCalls && optional) {
          this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
        }
        var computed = this.eat(types$1.bracketL);
        if (computed || optional && this.type !== types$1.parenL && this.type !== types$1.backQuote || this.eat(types$1.dot)) {
          var node = this.startNodeAt(startPos, startLoc);
          node.object = base;
          if (computed) {
            node.property = this.parseExpression();
            this.expect(types$1.bracketR);
          } else if (this.type === types$1.privateId && base.type !== "Super") {
            node.property = this.parsePrivateIdent();
          } else {
            node.property = this.parseIdent(this.options.allowReserved !== "never");
          }
          node.computed = !!computed;
          if (optionalSupported) {
            node.optional = optional;
          }
          base = this.finishNode(node, "MemberExpression");
        } else if (!noCalls && this.eat(types$1.parenL)) {
          var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
          this.yieldPos = 0;
          this.awaitPos = 0;
          this.awaitIdentPos = 0;
          var exprList = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
          if (maybeAsyncArrow && !optional && this.shouldParseAsyncArrow()) {
            this.checkPatternErrors(refDestructuringErrors, false);
            this.checkYieldAwaitInDefaultParams();
            if (this.awaitIdentPos > 0) {
              this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function");
            }
            this.yieldPos = oldYieldPos;
            this.awaitPos = oldAwaitPos;
            this.awaitIdentPos = oldAwaitIdentPos;
            return this.parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit);
          }
          this.checkExpressionErrors(refDestructuringErrors, true);
          this.yieldPos = oldYieldPos || this.yieldPos;
          this.awaitPos = oldAwaitPos || this.awaitPos;
          this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
          var node$1 = this.startNodeAt(startPos, startLoc);
          node$1.callee = base;
          node$1.arguments = exprList;
          if (optionalSupported) {
            node$1.optional = optional;
          }
          base = this.finishNode(node$1, "CallExpression");
        } else if (this.type === types$1.backQuote) {
          if (optional || optionalChained) {
            this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
          }
          var node$2 = this.startNodeAt(startPos, startLoc);
          node$2.tag = base;
          node$2.quasi = this.parseTemplate({ isTagged: true });
          base = this.finishNode(node$2, "TaggedTemplateExpression");
        }
        return base;
      };
      pp$5.parseExprAtom = function(refDestructuringErrors, forInit, forNew) {
        if (this.type === types$1.slash) {
          this.readRegexp();
        }
        var node, canBeArrow = this.potentialArrowAt === this.start;
        switch (this.type) {
          case types$1._super:
            if (!this.allowSuper) {
              this.raise(this.start, "'super' keyword outside a method");
            }
            node = this.startNode();
            this.next();
            if (this.type === types$1.parenL && !this.allowDirectSuper) {
              this.raise(node.start, "super() call outside constructor of a subclass");
            }
            if (this.type !== types$1.dot && this.type !== types$1.bracketL && this.type !== types$1.parenL) {
              this.unexpected();
            }
            return this.finishNode(node, "Super");
          case types$1._this:
            node = this.startNode();
            this.next();
            return this.finishNode(node, "ThisExpression");
          case types$1.name:
            var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
            var id = this.parseIdent(false);
            if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types$1._function)) {
              this.overrideContext(types.f_expr);
              return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit);
            }
            if (canBeArrow && !this.canInsertSemicolon()) {
              if (this.eat(types$1.arrow)) {
                return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false, forInit);
              }
              if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types$1.name && !containsEsc && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
                id = this.parseIdent(false);
                if (this.canInsertSemicolon() || !this.eat(types$1.arrow)) {
                  this.unexpected();
                }
                return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true, forInit);
              }
            }
            return id;
          case types$1.regexp:
            var value2 = this.value;
            node = this.parseLiteral(value2.value);
            node.regex = { pattern: value2.pattern, flags: value2.flags };
            return node;
          case types$1.num:
          case types$1.string:
            return this.parseLiteral(this.value);
          case types$1._null:
          case types$1._true:
          case types$1._false:
            node = this.startNode();
            node.value = this.type === types$1._null ? null : this.type === types$1._true;
            node.raw = this.type.keyword;
            this.next();
            return this.finishNode(node, "Literal");
          case types$1.parenL:
            var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
            if (refDestructuringErrors) {
              if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) {
                refDestructuringErrors.parenthesizedAssign = start;
              }
              if (refDestructuringErrors.parenthesizedBind < 0) {
                refDestructuringErrors.parenthesizedBind = start;
              }
            }
            return expr;
          case types$1.bracketL:
            node = this.startNode();
            this.next();
            node.elements = this.parseExprList(types$1.bracketR, true, true, refDestructuringErrors);
            return this.finishNode(node, "ArrayExpression");
          case types$1.braceL:
            this.overrideContext(types.b_expr);
            return this.parseObj(false, refDestructuringErrors);
          case types$1._function:
            node = this.startNode();
            this.next();
            return this.parseFunction(node, 0);
          case types$1._class:
            return this.parseClass(this.startNode(), false);
          case types$1._new:
            return this.parseNew();
          case types$1.backQuote:
            return this.parseTemplate();
          case types$1._import:
            if (this.options.ecmaVersion >= 11) {
              return this.parseExprImport(forNew);
            } else {
              return this.unexpected();
            }
          default:
            return this.parseExprAtomDefault();
        }
      };
      pp$5.parseExprAtomDefault = function() {
        this.unexpected();
      };
      pp$5.parseExprImport = function(forNew) {
        var node = this.startNode();
        if (this.containsEsc) {
          this.raiseRecoverable(this.start, "Escape sequence in keyword import");
        }
        this.next();
        if (this.type === types$1.parenL && !forNew) {
          return this.parseDynamicImport(node);
        } else if (this.type === types$1.dot) {
          var meta = this.startNodeAt(node.start, node.loc && node.loc.start);
          meta.name = "import";
          node.meta = this.finishNode(meta, "Identifier");
          return this.parseImportMeta(node);
        } else {
          this.unexpected();
        }
      };
      pp$5.parseDynamicImport = function(node) {
        this.next();
        node.source = this.parseMaybeAssign();
        if (this.options.ecmaVersion >= 16) {
          if (!this.eat(types$1.parenR)) {
            this.expect(types$1.comma);
            if (!this.afterTrailingComma(types$1.parenR)) {
              node.options = this.parseMaybeAssign();
              if (!this.eat(types$1.parenR)) {
                this.expect(types$1.comma);
                if (!this.afterTrailingComma(types$1.parenR)) {
                  this.unexpected();
                }
              }
            } else {
              node.options = null;
            }
          } else {
            node.options = null;
          }
        } else {
          if (!this.eat(types$1.parenR)) {
            var errorPos = this.start;
            if (this.eat(types$1.comma) && this.eat(types$1.parenR)) {
              this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
            } else {
              this.unexpected(errorPos);
            }
          }
        }
        return this.finishNode(node, "ImportExpression");
      };
      pp$5.parseImportMeta = function(node) {
        this.next();
        var containsEsc = this.containsEsc;
        node.property = this.parseIdent(true);
        if (node.property.name !== "meta") {
          this.raiseRecoverable(node.property.start, "The only valid meta property for import is 'import.meta'");
        }
        if (containsEsc) {
          this.raiseRecoverable(node.start, "'import.meta' must not contain escaped characters");
        }
        if (this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere) {
          this.raiseRecoverable(node.start, "Cannot use 'import.meta' outside a module");
        }
        return this.finishNode(node, "MetaProperty");
      };
      pp$5.parseLiteral = function(value2) {
        var node = this.startNode();
        node.value = value2;
        node.raw = this.input.slice(this.start, this.end);
        if (node.raw.charCodeAt(node.raw.length - 1) === 110) {
          node.bigint = node.value != null ? node.value.toString() : node.raw.slice(0, -1).replace(/_/g, "");
        }
        this.next();
        return this.finishNode(node, "Literal");
      };
      pp$5.parseParenExpression = function() {
        this.expect(types$1.parenL);
        var val = this.parseExpression();
        this.expect(types$1.parenR);
        return val;
      };
      pp$5.shouldParseArrow = function(exprList) {
        return !this.canInsertSemicolon();
      };
      pp$5.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {
        var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
        if (this.options.ecmaVersion >= 6) {
          this.next();
          var innerStartPos = this.start, innerStartLoc = this.startLoc;
          var exprList = [], first = true, lastIsComma = false;
          var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
          this.yieldPos = 0;
          this.awaitPos = 0;
          while (this.type !== types$1.parenR) {
            first ? first = false : this.expect(types$1.comma);
            if (allowTrailingComma && this.afterTrailingComma(types$1.parenR, true)) {
              lastIsComma = true;
              break;
            } else if (this.type === types$1.ellipsis) {
              spreadStart = this.start;
              exprList.push(this.parseParenItem(this.parseRestBinding()));
              if (this.type === types$1.comma) {
                this.raiseRecoverable(
                  this.start,
                  "Comma is not permitted after the rest element"
                );
              }
              break;
            } else {
              exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
            }
          }
          var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
          this.expect(types$1.parenR);
          if (canBeArrow && this.shouldParseArrow(exprList) && this.eat(types$1.arrow)) {
            this.checkPatternErrors(refDestructuringErrors, false);
            this.checkYieldAwaitInDefaultParams();
            this.yieldPos = oldYieldPos;
            this.awaitPos = oldAwaitPos;
            return this.parseParenArrowList(startPos, startLoc, exprList, forInit);
          }
          if (!exprList.length || lastIsComma) {
            this.unexpected(this.lastTokStart);
          }
          if (spreadStart) {
            this.unexpected(spreadStart);
          }
          this.checkExpressionErrors(refDestructuringErrors, true);
          this.yieldPos = oldYieldPos || this.yieldPos;
          this.awaitPos = oldAwaitPos || this.awaitPos;
          if (exprList.length > 1) {
            val = this.startNodeAt(innerStartPos, innerStartLoc);
            val.expressions = exprList;
            this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
          } else {
            val = exprList[0];
          }
        } else {
          val = this.parseParenExpression();
        }
        if (this.options.preserveParens) {
          var par = this.startNodeAt(startPos, startLoc);
          par.expression = val;
          return this.finishNode(par, "ParenthesizedExpression");
        } else {
          return val;
        }
      };
      pp$5.parseParenItem = function(item) {
        return item;
      };
      pp$5.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {
        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit);
      };
      var empty = [];
      pp$5.parseNew = function() {
        if (this.containsEsc) {
          this.raiseRecoverable(this.start, "Escape sequence in keyword new");
        }
        var node = this.startNode();
        this.next();
        if (this.options.ecmaVersion >= 6 && this.type === types$1.dot) {
          var meta = this.startNodeAt(node.start, node.loc && node.loc.start);
          meta.name = "new";
          node.meta = this.finishNode(meta, "Identifier");
          this.next();
          var containsEsc = this.containsEsc;
          node.property = this.parseIdent(true);
          if (node.property.name !== "target") {
            this.raiseRecoverable(node.property.start, "The only valid meta property for new is 'new.target'");
          }
          if (containsEsc) {
            this.raiseRecoverable(node.start, "'new.target' must not contain escaped characters");
          }
          if (!this.allowNewDotTarget) {
            this.raiseRecoverable(node.start, "'new.target' can only be used in functions and class static block");
          }
          return this.finishNode(node, "MetaProperty");
        }
        var startPos = this.start, startLoc = this.startLoc;
        node.callee = this.parseSubscripts(this.parseExprAtom(null, false, true), startPos, startLoc, true, false);
        if (this.eat(types$1.parenL)) {
          node.arguments = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false);
        } else {
          node.arguments = empty;
        }
        return this.finishNode(node, "NewExpression");
      };
      pp$5.parseTemplateElement = function(ref2) {
        var isTagged = ref2.isTagged;
        var elem = this.startNode();
        if (this.type === types$1.invalidTemplate) {
          if (!isTagged) {
            this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
          }
          elem.value = {
            raw: this.value.replace(/\r\n?/g, "\n"),
            cooked: null
          };
        } else {
          elem.value = {
            raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
            cooked: this.value
          };
        }
        this.next();
        elem.tail = this.type === types$1.backQuote;
        return this.finishNode(elem, "TemplateElement");
      };
      pp$5.parseTemplate = function(ref2) {
        if (ref2 === void 0) ref2 = {};
        var isTagged = ref2.isTagged;
        if (isTagged === void 0) isTagged = false;
        var node = this.startNode();
        this.next();
        node.expressions = [];
        var curElt = this.parseTemplateElement({ isTagged });
        node.quasis = [curElt];
        while (!curElt.tail) {
          if (this.type === types$1.eof) {
            this.raise(this.pos, "Unterminated template literal");
          }
          this.expect(types$1.dollarBraceL);
          node.expressions.push(this.parseExpression());
          this.expect(types$1.braceR);
          node.quasis.push(curElt = this.parseTemplateElement({ isTagged }));
        }
        this.next();
        return this.finishNode(node, "TemplateLiteral");
      };
      pp$5.isAsyncProp = function(prop) {
        return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" && (this.type === types$1.name || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types$1.star) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
      };
      pp$5.parseObj = function(isPattern, refDestructuringErrors) {
        var node = this.startNode(), first = true, propHash = {};
        node.properties = [];
        this.next();
        while (!this.eat(types$1.braceR)) {
          if (!first) {
            this.expect(types$1.comma);
            if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1.braceR)) {
              break;
            }
          } else {
            first = false;
          }
          var prop = this.parseProperty(isPattern, refDestructuringErrors);
          if (!isPattern) {
            this.checkPropClash(prop, propHash, refDestructuringErrors);
          }
          node.properties.push(prop);
        }
        return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
      };
      pp$5.parseProperty = function(isPattern, refDestructuringErrors) {
        var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
        if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) {
          if (isPattern) {
            prop.argument = this.parseIdent(false);
            if (this.type === types$1.comma) {
              this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
            }
            return this.finishNode(prop, "RestElement");
          }
          prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
          if (this.type === types$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
            refDestructuringErrors.trailingComma = this.start;
          }
          return this.finishNode(prop, "SpreadElement");
        }
        if (this.options.ecmaVersion >= 6) {
          prop.method = false;
          prop.shorthand = false;
          if (isPattern || refDestructuringErrors) {
            startPos = this.start;
            startLoc = this.startLoc;
          }
          if (!isPattern) {
            isGenerator = this.eat(types$1.star);
          }
        }
        var containsEsc = this.containsEsc;
        this.parsePropertyName(prop);
        if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
          isAsync = true;
          isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1.star);
          this.parsePropertyName(prop);
        } else {
          isAsync = false;
        }
        this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
        return this.finishNode(prop, "Property");
      };
      pp$5.parseGetterSetter = function(prop) {
        var kind = prop.key.name;
        this.parsePropertyName(prop);
        prop.value = this.parseMethod(false);
        prop.kind = kind;
        var paramCount = prop.kind === "get" ? 0 : 1;
        if (prop.value.params.length !== paramCount) {
          var start = prop.value.start;
          if (prop.kind === "get") {
            this.raiseRecoverable(start, "getter should have no params");
          } else {
            this.raiseRecoverable(start, "setter should have exactly one param");
          }
        } else {
          if (prop.kind === "set" && prop.value.params[0].type === "RestElement") {
            this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
          }
        }
      };
      pp$5.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
        if ((isGenerator || isAsync) && this.type === types$1.colon) {
          this.unexpected();
        }
        if (this.eat(types$1.colon)) {
          prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
          prop.kind = "init";
        } else if (this.options.ecmaVersion >= 6 && this.type === types$1.parenL) {
          if (isPattern) {
            this.unexpected();
          }
          prop.method = true;
          prop.value = this.parseMethod(isGenerator, isAsync);
          prop.kind = "init";
        } else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && (this.type !== types$1.comma && this.type !== types$1.braceR && this.type !== types$1.eq)) {
          if (isGenerator || isAsync) {
            this.unexpected();
          }
          this.parseGetterSetter(prop);
        } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
          if (isGenerator || isAsync) {
            this.unexpected();
          }
          this.checkUnreserved(prop.key);
          if (prop.key.name === "await" && !this.awaitIdentPos) {
            this.awaitIdentPos = startPos;
          }
          if (isPattern) {
            prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
          } else if (this.type === types$1.eq && refDestructuringErrors) {
            if (refDestructuringErrors.shorthandAssign < 0) {
              refDestructuringErrors.shorthandAssign = this.start;
            }
            prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
          } else {
            prop.value = this.copyNode(prop.key);
          }
          prop.kind = "init";
          prop.shorthand = true;
        } else {
          this.unexpected();
        }
      };
      pp$5.parsePropertyName = function(prop) {
        if (this.options.ecmaVersion >= 6) {
          if (this.eat(types$1.bracketL)) {
            prop.computed = true;
            prop.key = this.parseMaybeAssign();
            this.expect(types$1.bracketR);
            return prop.key;
          } else {
            prop.computed = false;
          }
        }
        return prop.key = this.type === types$1.num || this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
      };
      pp$5.initFunction = function(node) {
        node.id = null;
        if (this.options.ecmaVersion >= 6) {
          node.generator = node.expression = false;
        }
        if (this.options.ecmaVersion >= 8) {
          node.async = false;
        }
      };
      pp$5.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
        var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.initFunction(node);
        if (this.options.ecmaVersion >= 6) {
          node.generator = isGenerator;
        }
        if (this.options.ecmaVersion >= 8) {
          node.async = !!isAsync;
        }
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
        this.expect(types$1.parenL);
        node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
        this.checkYieldAwaitInDefaultParams();
        this.parseFunctionBody(node, false, true, false);
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.finishNode(node, "FunctionExpression");
      };
      pp$5.parseArrowExpression = function(node, params, isAsync, forInit) {
        var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
        this.initFunction(node);
        if (this.options.ecmaVersion >= 8) {
          node.async = !!isAsync;
        }
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        node.params = this.toAssignableList(params, true);
        this.parseFunctionBody(node, true, false, forInit);
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.finishNode(node, "ArrowFunctionExpression");
      };
      pp$5.parseFunctionBody = function(node, isArrowFunction, isMethod, forInit) {
        var isExpression = isArrowFunction && this.type !== types$1.braceL;
        var oldStrict = this.strict, useStrict = false;
        if (isExpression) {
          node.body = this.parseMaybeAssign(forInit);
          node.expression = true;
          this.checkParams(node, false);
        } else {
          var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
          if (!oldStrict || nonSimple) {
            useStrict = this.strictDirective(this.end);
            if (useStrict && nonSimple) {
              this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list");
            }
          }
          var oldLabels = this.labels;
          this.labels = [];
          if (useStrict) {
            this.strict = true;
          }
          this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
          if (this.strict && node.id) {
            this.checkLValSimple(node.id, BIND_OUTSIDE);
          }
          node.body = this.parseBlock(false, void 0, useStrict && !oldStrict);
          node.expression = false;
          this.adaptDirectivePrologue(node.body.body);
          this.labels = oldLabels;
        }
        this.exitScope();
      };
      pp$5.isSimpleParamList = function(params) {
        for (var i2 = 0, list2 = params; i2 < list2.length; i2 += 1) {
          var param = list2[i2];
          if (param.type !== "Identifier") {
            return false;
          }
        }
        return true;
      };
      pp$5.checkParams = function(node, allowDuplicates) {
        var nameHash = /* @__PURE__ */ Object.create(null);
        for (var i2 = 0, list2 = node.params; i2 < list2.length; i2 += 1) {
          var param = list2[i2];
          this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);
        }
      };
      pp$5.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
        var elts = [], first = true;
        while (!this.eat(close)) {
          if (!first) {
            this.expect(types$1.comma);
            if (allowTrailingComma && this.afterTrailingComma(close)) {
              break;
            }
          } else {
            first = false;
          }
          var elt = void 0;
          if (allowEmpty && this.type === types$1.comma) {
            elt = null;
          } else if (this.type === types$1.ellipsis) {
            elt = this.parseSpread(refDestructuringErrors);
            if (refDestructuringErrors && this.type === types$1.comma && refDestructuringErrors.trailingComma < 0) {
              refDestructuringErrors.trailingComma = this.start;
            }
          } else {
            elt = this.parseMaybeAssign(false, refDestructuringErrors);
          }
          elts.push(elt);
        }
        return elts;
      };
      pp$5.checkUnreserved = function(ref2) {
        var start = ref2.start;
        var end = ref2.end;
        var name = ref2.name;
        if (this.inGenerator && name === "yield") {
          this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator");
        }
        if (this.inAsync && name === "await") {
          this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function");
        }
        if (!(this.currentThisScope().flags & SCOPE_VAR) && name === "arguments") {
          this.raiseRecoverable(start, "Cannot use 'arguments' in class field initializer");
        }
        if (this.inClassStaticBlock && (name === "arguments" || name === "await")) {
          this.raise(start, "Cannot use " + name + " in class static initialization block");
        }
        if (this.keywords.test(name)) {
          this.raise(start, "Unexpected keyword '" + name + "'");
        }
        if (this.options.ecmaVersion < 6 && this.input.slice(start, end).indexOf("\\") !== -1) {
          return;
        }
        var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
        if (re.test(name)) {
          if (!this.inAsync && name === "await") {
            this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function");
          }
          this.raiseRecoverable(start, "The keyword '" + name + "' is reserved");
        }
      };
      pp$5.parseIdent = function(liberal) {
        var node = this.parseIdentNode();
        this.next(!!liberal);
        this.finishNode(node, "Identifier");
        if (!liberal) {
          this.checkUnreserved(node);
          if (node.name === "await" && !this.awaitIdentPos) {
            this.awaitIdentPos = node.start;
          }
        }
        return node;
      };
      pp$5.parseIdentNode = function() {
        var node = this.startNode();
        if (this.type === types$1.name) {
          node.name = this.value;
        } else if (this.type.keyword) {
          node.name = this.type.keyword;
          if ((node.name === "class" || node.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
            this.context.pop();
          }
          this.type = types$1.name;
        } else {
          this.unexpected();
        }
        return node;
      };
      pp$5.parsePrivateIdent = function() {
        var node = this.startNode();
        if (this.type === types$1.privateId) {
          node.name = this.value;
        } else {
          this.unexpected();
        }
        this.next();
        this.finishNode(node, "PrivateIdentifier");
        if (this.options.checkPrivateFields) {
          if (this.privateNameStack.length === 0) {
            this.raise(node.start, "Private field '#" + node.name + "' must be declared in an enclosing class");
          } else {
            this.privateNameStack[this.privateNameStack.length - 1].used.push(node);
          }
        }
        return node;
      };
      pp$5.parseYield = function(forInit) {
        if (!this.yieldPos) {
          this.yieldPos = this.start;
        }
        var node = this.startNode();
        this.next();
        if (this.type === types$1.semi || this.canInsertSemicolon() || this.type !== types$1.star && !this.type.startsExpr) {
          node.delegate = false;
          node.argument = null;
        } else {
          node.delegate = this.eat(types$1.star);
          node.argument = this.parseMaybeAssign(forInit);
        }
        return this.finishNode(node, "YieldExpression");
      };
      pp$5.parseAwait = function(forInit) {
        if (!this.awaitPos) {
          this.awaitPos = this.start;
        }
        var node = this.startNode();
        this.next();
        node.argument = this.parseMaybeUnary(null, true, false, forInit);
        return this.finishNode(node, "AwaitExpression");
      };
      var pp$4 = Parser.prototype;
      pp$4.raise = function(pos, message) {
        var loc = getLineInfo(this.input, pos);
        message += " (" + loc.line + ":" + loc.column + ")";
        if (this.sourceFile) {
          message += " in " + this.sourceFile;
        }
        var err = new SyntaxError(message);
        err.pos = pos;
        err.loc = loc;
        err.raisedAt = this.pos;
        throw err;
      };
      pp$4.raiseRecoverable = pp$4.raise;
      pp$4.curPosition = function() {
        if (this.options.locations) {
          return new Position(this.curLine, this.pos - this.lineStart);
        }
      };
      var pp$3 = Parser.prototype;
      var Scope = function Scope2(flags) {
        this.flags = flags;
        this.var = [];
        this.lexical = [];
        this.functions = [];
      };
      pp$3.enterScope = function(flags) {
        this.scopeStack.push(new Scope(flags));
      };
      pp$3.exitScope = function() {
        this.scopeStack.pop();
      };
      pp$3.treatFunctionsAsVarInScope = function(scope) {
        return scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_TOP;
      };
      pp$3.declareName = function(name, bindingType, pos) {
        var redeclared = false;
        if (bindingType === BIND_LEXICAL) {
          var scope = this.currentScope();
          redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
          scope.lexical.push(name);
          if (this.inModule && scope.flags & SCOPE_TOP) {
            delete this.undefinedExports[name];
          }
        } else if (bindingType === BIND_SIMPLE_CATCH) {
          var scope$1 = this.currentScope();
          scope$1.lexical.push(name);
        } else if (bindingType === BIND_FUNCTION) {
          var scope$2 = this.currentScope();
          if (this.treatFunctionsAsVar) {
            redeclared = scope$2.lexical.indexOf(name) > -1;
          } else {
            redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1;
          }
          scope$2.functions.push(name);
        } else {
          for (var i2 = this.scopeStack.length - 1; i2 >= 0; --i2) {
            var scope$3 = this.scopeStack[i2];
            if (scope$3.lexical.indexOf(name) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH && scope$3.lexical[0] === name) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
              redeclared = true;
              break;
            }
            scope$3.var.push(name);
            if (this.inModule && scope$3.flags & SCOPE_TOP) {
              delete this.undefinedExports[name];
            }
            if (scope$3.flags & SCOPE_VAR) {
              break;
            }
          }
        }
        if (redeclared) {
          this.raiseRecoverable(pos, "Identifier '" + name + "' has already been declared");
        }
      };
      pp$3.checkLocalExport = function(id) {
        if (this.scopeStack[0].lexical.indexOf(id.name) === -1 && this.scopeStack[0].var.indexOf(id.name) === -1) {
          this.undefinedExports[id.name] = id;
        }
      };
      pp$3.currentScope = function() {
        return this.scopeStack[this.scopeStack.length - 1];
      };
      pp$3.currentVarScope = function() {
        for (var i2 = this.scopeStack.length - 1; ; i2--) {
          var scope = this.scopeStack[i2];
          if (scope.flags & (SCOPE_VAR | SCOPE_CLASS_FIELD_INIT | SCOPE_CLASS_STATIC_BLOCK)) {
            return scope;
          }
        }
      };
      pp$3.currentThisScope = function() {
        for (var i2 = this.scopeStack.length - 1; ; i2--) {
          var scope = this.scopeStack[i2];
          if (scope.flags & (SCOPE_VAR | SCOPE_CLASS_FIELD_INIT | SCOPE_CLASS_STATIC_BLOCK) && !(scope.flags & SCOPE_ARROW)) {
            return scope;
          }
        }
      };
      var Node = function Node2(parser, pos, loc) {
        this.type = "";
        this.start = pos;
        this.end = 0;
        if (parser.options.locations) {
          this.loc = new SourceLocation(parser, loc);
        }
        if (parser.options.directSourceFile) {
          this.sourceFile = parser.options.directSourceFile;
        }
        if (parser.options.ranges) {
          this.range = [pos, 0];
        }
      };
      var pp$2 = Parser.prototype;
      pp$2.startNode = function() {
        return new Node(this, this.start, this.startLoc);
      };
      pp$2.startNodeAt = function(pos, loc) {
        return new Node(this, pos, loc);
      };
      function finishNodeAt(node, type, pos, loc) {
        node.type = type;
        node.end = pos;
        if (this.options.locations) {
          node.loc.end = loc;
        }
        if (this.options.ranges) {
          node.range[1] = pos;
        }
        return node;
      }
      pp$2.finishNode = function(node, type) {
        return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc);
      };
      pp$2.finishNodeAt = function(node, type, pos, loc) {
        return finishNodeAt.call(this, node, type, pos, loc);
      };
      pp$2.copyNode = function(node) {
        var newNode = new Node(this, node.start, this.startLoc);
        for (var prop in node) {
          newNode[prop] = node[prop];
        }
        return newNode;
      };
      var scriptValuesAddedInUnicode = "Gara Garay Gukh Gurung_Khema Hrkt Katakana_Or_Hiragana Kawi Kirat_Rai Krai Nag_Mundari Nagm Ol_Onal Onao Sunu Sunuwar Todhri Todr Tulu_Tigalari Tutg Unknown Zzzz";
      var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
      var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
      var ecma11BinaryProperties = ecma10BinaryProperties;
      var ecma12BinaryProperties = ecma11BinaryProperties + " EBase EComp EMod EPres ExtPict";
      var ecma13BinaryProperties = ecma12BinaryProperties;
      var ecma14BinaryProperties = ecma13BinaryProperties;
      var unicodeBinaryProperties = {
        9: ecma9BinaryProperties,
        10: ecma10BinaryProperties,
        11: ecma11BinaryProperties,
        12: ecma12BinaryProperties,
        13: ecma13BinaryProperties,
        14: ecma14BinaryProperties
      };
      var ecma14BinaryPropertiesOfStrings = "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji";
      var unicodeBinaryPropertiesOfStrings = {
        9: "",
        10: "",
        11: "",
        12: "",
        13: "",
        14: ecma14BinaryPropertiesOfStrings
      };
      var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";
      var ecma9ScriptValues = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
      var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
      var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
      var ecma12ScriptValues = ecma11ScriptValues + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
      var ecma13ScriptValues = ecma12ScriptValues + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith";
      var ecma14ScriptValues = ecma13ScriptValues + " " + scriptValuesAddedInUnicode;
      var unicodeScriptValues = {
        9: ecma9ScriptValues,
        10: ecma10ScriptValues,
        11: ecma11ScriptValues,
        12: ecma12ScriptValues,
        13: ecma13ScriptValues,
        14: ecma14ScriptValues
      };
      var data = {};
      function buildUnicodeData(ecmaVersion2) {
        var d = data[ecmaVersion2] = {
          binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion2] + " " + unicodeGeneralCategoryValues),
          binaryOfStrings: wordsRegexp(unicodeBinaryPropertiesOfStrings[ecmaVersion2]),
          nonBinary: {
            General_Category: wordsRegexp(unicodeGeneralCategoryValues),
            Script: wordsRegexp(unicodeScriptValues[ecmaVersion2])
          }
        };
        d.nonBinary.Script_Extensions = d.nonBinary.Script;
        d.nonBinary.gc = d.nonBinary.General_Category;
        d.nonBinary.sc = d.nonBinary.Script;
        d.nonBinary.scx = d.nonBinary.Script_Extensions;
      }
      for (var i = 0, list = [9, 10, 11, 12, 13, 14]; i < list.length; i += 1) {
        var ecmaVersion = list[i];
        buildUnicodeData(ecmaVersion);
      }
      var pp$1 = Parser.prototype;
      var BranchID = function BranchID2(parent, base) {
        this.parent = parent;
        this.base = base || this;
      };
      BranchID.prototype.separatedFrom = function separatedFrom(alt) {
        for (var self2 = this; self2; self2 = self2.parent) {
          for (var other = alt; other; other = other.parent) {
            if (self2.base === other.base && self2 !== other) {
              return true;
            }
          }
        }
        return false;
      };
      BranchID.prototype.sibling = function sibling() {
        return new BranchID(this.parent, this.base);
      };
      var RegExpValidationState = function RegExpValidationState2(parser) {
        this.parser = parser;
        this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "") + (parser.options.ecmaVersion >= 13 ? "d" : "") + (parser.options.ecmaVersion >= 15 ? "v" : "");
        this.unicodeProperties = data[parser.options.ecmaVersion >= 14 ? 14 : parser.options.ecmaVersion];
        this.source = "";
        this.flags = "";
        this.start = 0;
        this.switchU = false;
        this.switchV = false;
        this.switchN = false;
        this.pos = 0;
        this.lastIntValue = 0;
        this.lastStringValue = "";
        this.lastAssertionIsQuantifiable = false;
        this.numCapturingParens = 0;
        this.maxBackReference = 0;
        this.groupNames = /* @__PURE__ */ Object.create(null);
        this.backReferenceNames = [];
        this.branchID = null;
      };
      RegExpValidationState.prototype.reset = function reset(start, pattern, flags) {
        var unicodeSets = flags.indexOf("v") !== -1;
        var unicode = flags.indexOf("u") !== -1;
        this.start = start | 0;
        this.source = pattern + "";
        this.flags = flags;
        if (unicodeSets && this.parser.options.ecmaVersion >= 15) {
          this.switchU = true;
          this.switchV = true;
          this.switchN = true;
        } else {
          this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
          this.switchV = false;
          this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
        }
      };
      RegExpValidationState.prototype.raise = function raise(message) {
        this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + message);
      };
      RegExpValidationState.prototype.at = function at(i2, forceU) {
        if (forceU === void 0) forceU = false;
        var s = this.source;
        var l = s.length;
        if (i2 >= l) {
          return -1;
        }
        var c = s.charCodeAt(i2);
        if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i2 + 1 >= l) {
          return c;
        }
        var next = s.charCodeAt(i2 + 1);
        return next >= 56320 && next <= 57343 ? (c << 10) + next - 56613888 : c;
      };
      RegExpValidationState.prototype.nextIndex = function nextIndex(i2, forceU) {
        if (forceU === void 0) forceU = false;
        var s = this.source;
        var l = s.length;
        if (i2 >= l) {
          return l;
        }
        var c = s.charCodeAt(i2), next;
        if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i2 + 1 >= l || (next = s.charCodeAt(i2 + 1)) < 56320 || next > 57343) {
          return i2 + 1;
        }
        return i2 + 2;
      };
      RegExpValidationState.prototype.current = function current(forceU) {
        if (forceU === void 0) forceU = false;
        return this.at(this.pos, forceU);
      };
      RegExpValidationState.prototype.lookahead = function lookahead(forceU) {
        if (forceU === void 0) forceU = false;
        return this.at(this.nextIndex(this.pos, forceU), forceU);
      };
      RegExpValidationState.prototype.advance = function advance(forceU) {
        if (forceU === void 0) forceU = false;
        this.pos = this.nextIndex(this.pos, forceU);
      };
      RegExpValidationState.prototype.eat = function eat(ch, forceU) {
        if (forceU === void 0) forceU = false;
        if (this.current(forceU) === ch) {
          this.advance(forceU);
          return true;
        }
        return false;
      };
      RegExpValidationState.prototype.eatChars = function eatChars(chs, forceU) {
        if (forceU === void 0) forceU = false;
        var pos = this.pos;
        for (var i2 = 0, list2 = chs; i2 < list2.length; i2 += 1) {
          var ch = list2[i2];
          var current = this.at(pos, forceU);
          if (current === -1 || current !== ch) {
            return false;
          }
          pos = this.nextIndex(pos, forceU);
        }
        this.pos = pos;
        return true;
      };
      pp$1.validateRegExpFlags = function(state) {
        var validFlags = state.validFlags;
        var flags = state.flags;
        var u = false;
        var v = false;
        for (var i2 = 0; i2 < flags.length; i2++) {
          var flag = flags.charAt(i2);
          if (validFlags.indexOf(flag) === -1) {
            this.raise(state.start, "Invalid regular expression flag");
          }
          if (flags.indexOf(flag, i2 + 1) > -1) {
            this.raise(state.start, "Duplicate regular expression flag");
          }
          if (flag === "u") {
            u = true;
          }
          if (flag === "v") {
            v = true;
          }
        }
        if (this.options.ecmaVersion >= 15 && u && v) {
          this.raise(state.start, "Invalid regular expression flag");
        }
      };
      function hasProp(obj) {
        for (var _2 in obj) {
          return true;
        }
        return false;
      }
      pp$1.validateRegExpPattern = function(state) {
        this.regexp_pattern(state);
        if (!state.switchN && this.options.ecmaVersion >= 9 && hasProp(state.groupNames)) {
          state.switchN = true;
          this.regexp_pattern(state);
        }
      };
      pp$1.regexp_pattern = function(state) {
        state.pos = 0;
        state.lastIntValue = 0;
        state.lastStringValue = "";
        state.lastAssertionIsQuantifiable = false;
        state.numCapturingParens = 0;
        state.maxBackReference = 0;
        state.groupNames = /* @__PURE__ */ Object.create(null);
        state.backReferenceNames.length = 0;
        state.branchID = null;
        this.regexp_disjunction(state);
        if (state.pos !== state.source.length) {
          if (state.eat(
            41
            /* ) */
          )) {
            state.raise("Unmatched ')'");
          }
          if (state.eat(
            93
            /* ] */
          ) || state.eat(
            125
            /* } */
          )) {
            state.raise("Lone quantifier brackets");
          }
        }
        if (state.maxBackReference > state.numCapturingParens) {
          state.raise("Invalid escape");
        }
        for (var i2 = 0, list2 = state.backReferenceNames; i2 < list2.length; i2 += 1) {
          var name = list2[i2];
          if (!state.groupNames[name]) {
            state.raise("Invalid named capture referenced");
          }
        }
      };
      pp$1.regexp_disjunction = function(state) {
        var trackDisjunction = this.options.ecmaVersion >= 16;
        if (trackDisjunction) {
          state.branchID = new BranchID(state.branchID, null);
        }
        this.regexp_alternative(state);
        while (state.eat(
          124
          /* | */
        )) {
          if (trackDisjunction) {
            state.branchID = state.branchID.sibling();
          }
          this.regexp_alternative(state);
        }
        if (trackDisjunction) {
          state.branchID = state.branchID.parent;
        }
        if (this.regexp_eatQuantifier(state, true)) {
          state.raise("Nothing to repeat");
        }
        if (state.eat(
          123
          /* { */
        )) {
          state.raise("Lone quantifier brackets");
        }
      };
      pp$1.regexp_alternative = function(state) {
        while (state.pos < state.source.length && this.regexp_eatTerm(state)) {
        }
      };
      pp$1.regexp_eatTerm = function(state) {
        if (this.regexp_eatAssertion(state)) {
          if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
            if (state.switchU) {
              state.raise("Invalid quantifier");
            }
          }
          return true;
        }
        if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
          this.regexp_eatQuantifier(state);
          return true;
        }
        return false;
      };
      pp$1.regexp_eatAssertion = function(state) {
        var start = state.pos;
        state.lastAssertionIsQuantifiable = false;
        if (state.eat(
          94
          /* ^ */
        ) || state.eat(
          36
          /* $ */
        )) {
          return true;
        }
        if (state.eat(
          92
          /* \ */
        )) {
          if (state.eat(
            66
            /* B */
          ) || state.eat(
            98
            /* b */
          )) {
            return true;
          }
          state.pos = start;
        }
        if (state.eat(
          40
          /* ( */
        ) && state.eat(
          63
          /* ? */
        )) {
          var lookbehind = false;
          if (this.options.ecmaVersion >= 9) {
            lookbehind = state.eat(
              60
              /* < */
            );
          }
          if (state.eat(
            61
            /* = */
          ) || state.eat(
            33
            /* ! */
          )) {
            this.regexp_disjunction(state);
            if (!state.eat(
              41
              /* ) */
            )) {
              state.raise("Unterminated group");
            }
            state.lastAssertionIsQuantifiable = !lookbehind;
            return true;
          }
        }
        state.pos = start;
        return false;
      };
      pp$1.regexp_eatQuantifier = function(state, noError) {
        if (noError === void 0) noError = false;
        if (this.regexp_eatQuantifierPrefix(state, noError)) {
          state.eat(
            63
            /* ? */
          );
          return true;
        }
        return false;
      };
      pp$1.regexp_eatQuantifierPrefix = function(state, noError) {
        return state.eat(
          42
          /* * */
        ) || state.eat(
          43
          /* + */
        ) || state.eat(
          63
          /* ? */
        ) || this.regexp_eatBracedQuantifier(state, noError);
      };
      pp$1.regexp_eatBracedQuantifier = function(state, noError) {
        var start = state.pos;
        if (state.eat(
          123
          /* { */
        )) {
          var min = 0, max = -1;
          if (this.regexp_eatDecimalDigits(state)) {
            min = state.lastIntValue;
            if (state.eat(
              44
              /* , */
            ) && this.regexp_eatDecimalDigits(state)) {
              max = state.lastIntValue;
            }
            if (state.eat(
              125
              /* } */
            )) {
              if (max !== -1 && max < min && !noError) {
                state.raise("numbers out of order in {} quantifier");
              }
              return true;
            }
          }
          if (state.switchU && !noError) {
            state.raise("Incomplete quantifier");
          }
          state.pos = start;
        }
        return false;
      };
      pp$1.regexp_eatAtom = function(state) {
        return this.regexp_eatPatternCharacters(state) || state.eat(
          46
          /* . */
        ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);
      };
      pp$1.regexp_eatReverseSolidusAtomEscape = function(state) {
        var start = state.pos;
        if (state.eat(
          92
          /* \ */
        )) {
          if (this.regexp_eatAtomEscape(state)) {
            return true;
          }
          state.pos = start;
        }
        return false;
      };
      pp$1.regexp_eatUncapturingGroup = function(state) {
        var start = state.pos;
        if (state.eat(
          40
          /* ( */
        )) {
          if (state.eat(
            63
            /* ? */
          )) {
            if (this.options.ecmaVersion >= 16) {
              var addModifiers = this.regexp_eatModifiers(state);
              var hasHyphen = state.eat(
                45
                /* - */
              );
              if (addModifiers || hasHyphen) {
                for (var i2 = 0; i2 < addModifiers.length; i2++) {
                  var modifier = addModifiers.charAt(i2);
                  if (addModifiers.indexOf(modifier, i2 + 1) > -1) {
                    state.raise("Duplicate regular expression modifiers");
                  }
                }
                if (hasHyphen) {
                  var removeModifiers = this.regexp_eatModifiers(state);
                  if (!addModifiers && !removeModifiers && state.current() === 58) {
                    state.raise("Invalid regular expression modifiers");
                  }
                  for (var i$1 = 0; i$1 < removeModifiers.length; i$1++) {
                    var modifier$1 = removeModifiers.charAt(i$1);
                    if (removeModifiers.indexOf(modifier$1, i$1 + 1) > -1 || addModifiers.indexOf(modifier$1) > -1) {
                      state.raise("Duplicate regular expression modifiers");
                    }
                  }
                }
              }
            }
            if (state.eat(
              58
              /* : */
            )) {
              this.regexp_disjunction(state);
              if (state.eat(
                41
                /* ) */
              )) {
                return true;
              }
              state.raise("Unterminated group");
            }
          }
          state.pos = start;
        }
        return false;
      };
      pp$1.regexp_eatCapturingGroup = function(state) {
        if (state.eat(
          40
          /* ( */
        )) {
          if (this.options.ecmaVersion >= 9) {
            this.regexp_groupSpecifier(state);
          } else if (state.current() === 63) {
            state.raise("Invalid group");
          }
          this.regexp_disjunction(state);
          if (state.eat(
            41
            /* ) */
          )) {
            state.numCapturingParens += 1;
            return true;
          }
          state.raise("Unterminated group");
        }
        return false;
      };
      pp$1.regexp_eatModifiers = function(state) {
        var modifiers = "";
        var ch = 0;
        while ((ch = state.current()) !== -1 && isRegularExpressionModifier(ch)) {
          modifiers += codePointToString(ch);
          state.advance();
        }
        return modifiers;
      };
      function isRegularExpressionModifier(ch) {
        return ch === 105 || ch === 109 || ch === 115;
      }
      pp$1.regexp_eatExtendedAtom = function(state) {
        return state.eat(
          46
          /* . */
        ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);
      };
      pp$1.regexp_eatInvalidBracedQuantifier = function(state) {
        if (this.regexp_eatBracedQuantifier(state, true)) {
          state.raise("Nothing to repeat");
        }
        return false;
      };
      pp$1.regexp_eatSyntaxCharacter = function(state) {
        var ch = state.current();
        if (isSyntaxCharacter(ch)) {
          state.lastIntValue = ch;
          state.advance();
          return true;
        }
        return false;
      };
      function isSyntaxCharacter(ch) {
        return ch === 36 || ch >= 40 && ch <= 43 || ch === 46 || ch === 63 || ch >= 91 && ch <= 94 || ch >= 123 && ch <= 125;
      }
      pp$1.regexp_eatPatternCharacters = function(state) {
        var start = state.pos;
        var ch = 0;
        while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
          state.advance();
        }
        return state.pos !== start;
      };
      pp$1.regexp_eatExtendedPatternCharacter = function(state) {
        var ch = state.current();
        if (ch !== -1 && ch !== 36 && !(ch >= 40 && ch <= 43) && ch !== 46 && ch !== 63 && ch !== 91 && ch !== 94 && ch !== 124) {
          state.advance();
          return true;
        }
        return false;
      };
      pp$1.regexp_groupSpecifier = function(state) {
        if (state.eat(
          63
          /* ? */
        )) {
          if (!this.regexp_eatGroupName(state)) {
            state.raise("Invalid group");
          }
          var trackDisjunction = this.options.ecmaVersion >= 16;
          var known = state.groupNames[state.lastStringValue];
          if (known) {
            if (trackDisjunction) {
              for (var i2 = 0, list2 = known; i2 < list2.length; i2 += 1) {
                var altID = list2[i2];
                if (!altID.separatedFrom(state.branchID)) {
                  state.raise("Duplicate capture group name");
                }
              }
            } else {
              state.raise("Duplicate capture group name");
            }
          }
          if (trackDisjunction) {
            (known || (state.groupNames[state.lastStringValue] = [])).push(state.branchID);
          } else {
            state.groupNames[state.lastStringValue] = true;
          }
        }
      };
      pp$1.regexp_eatGroupName = function(state) {
        state.lastStringValue = "";
        if (state.eat(
          60
          /* < */
        )) {
          if (this.regexp_eatRegExpIdentifierName(state) && state.eat(
            62
            /* > */
          )) {
            return true;
          }
          state.raise("Invalid capture group name");
        }
        return false;
      };
      pp$1.regexp_eatRegExpIdentifierName = function(state) {
        state.lastStringValue = "";
        if (this.regexp_eatRegExpIdentifierStart(state)) {
          state.lastStringValue += codePointToString(state.lastIntValue);
          while (this.regexp_eatRegExpIdentifierPart(state)) {
            state.lastStringValue += codePointToString(state.lastIntValue);
          }
          return true;
        }
        return false;
      };
      pp$1.regexp_eatRegExpIdentifierStart = function(state) {
        var start = state.pos;
        var forceU = this.options.ecmaVersion >= 11;
        var ch = state.current(forceU);
        state.advance(forceU);
        if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
          ch = state.lastIntValue;
        }
        if (isRegExpIdentifierStart(ch)) {
          state.lastIntValue = ch;
          return true;
        }
        state.pos = start;
        return false;
      };
      function isRegExpIdentifierStart(ch) {
        return isIdentifierStart(ch, true) || ch === 36 || ch === 95;
      }
      pp$1.regexp_eatRegExpIdentifierPart = function(state) {
        var start = state.pos;
        var forceU = this.options.ecmaVersion >= 11;
        var ch = state.current(forceU);
        state.advance(forceU);
        if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
          ch = state.lastIntValue;
        }
        if (isRegExpIdentifierPart(ch)) {
          state.lastIntValue = ch;
          return true;
        }
        state.pos = start;
        return false;
      };
      function isRegExpIdentifierPart(ch) {
        return isIdentifierChar(ch, true) || ch === 36 || ch === 95 || ch === 8204 || ch === 8205;
      }
      pp$1.regexp_eatAtomEscape = function(state) {
        if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) {
          return true;
        }
        if (state.switchU) {
          if (state.current() === 99) {
            state.raise("Invalid unicode escape");
          }
          state.raise("Invalid escape");
        }
        return false;
      };
      pp$1.regexp_eatBackReference = function(state) {
        var start = state.pos;
        if (this.regexp_eatDecimalEscape(state)) {
          var n = state.lastIntValue;
          if (state.switchU) {
            if (n > state.maxBackReference) {
              state.maxBackReference = n;
            }
            return true;
          }
          if (n <= state.numCapturingParens) {
            return true;
          }
          state.pos = start;
        }
        return false;
      };
      pp$1.regexp_eatKGroupName = function(state) {
        if (state.eat(
          107
          /* k */
        )) {
          if (this.regexp_eatGroupName(state)) {
            state.backReferenceNames.push(state.lastStringValue);
            return true;
          }
          state.raise("Invalid named reference");
        }
        return false;
      };
      pp$1.regexp_eatCharacterEscape = function(state) {
        return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state, false) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);
      };
      pp$1.regexp_eatCControlLetter = function(state) {
        var start = state.pos;
        if (state.eat(
          99
          /* c */
        )) {
          if (this.regexp_eatControlLetter(state)) {
            return true;
          }
          state.pos = start;
        }
        return false;
      };
      pp$1.regexp_eatZero = function(state) {
        if (state.current() === 48 && !isDecimalDigit(state.lookahead())) {
          state.lastIntValue = 0;
          state.advance();
          return true;
        }
        return false;
      };
      pp$1.regexp_eatControlEscape = function(state) {
        var ch = state.current();
        if (ch === 116) {
          state.lastIntValue = 9;
          state.advance();
          return true;
        }
        if (ch === 110) {
          state.lastIntValue = 10;
          state.advance();
          return true;
        }
        if (ch === 118) {
          state.lastIntValue = 11;
          state.advance();
          return true;
        }
        if (ch === 102) {
          state.lastIntValue = 12;
          state.advance();
          return true;
        }
        if (ch === 114) {
          state.lastIntValue = 13;
          state.advance();
          return true;
        }
        return false;
      };
      pp$1.regexp_eatControlLetter = function(state) {
        var ch = state.current();
        if (isControlLetter(ch)) {
          state.lastIntValue = ch % 32;
          state.advance();
          return true;
        }
        return false;
      };
      function isControlLetter(ch) {
        return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122;
      }
      pp$1.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
        if (forceU === void 0) forceU = false;
        var start = state.pos;
        var switchU = forceU || state.switchU;
        if (state.eat(
          117
          /* u */
        )) {
          if (this.regexp_eatFixedHexDigits(state, 4)) {
            var lead = state.lastIntValue;
            if (switchU && lead >= 55296 && lead <= 56319) {
              var leadSurrogateEnd = state.pos;
              if (state.eat(
                92
                /* \ */
              ) && state.eat(
                117
                /* u */
              ) && this.regexp_eatFixedHexDigits(state, 4)) {
                var trail = state.lastIntValue;
                if (trail >= 56320 && trail <= 57343) {
                  state.lastIntValue = (lead - 55296) * 1024 + (trail - 56320) + 65536;
                  return true;
                }
              }
              state.pos = leadSurrogateEnd;
              state.lastIntValue = lead;
            }
            return true;
          }
          if (switchU && state.eat(
            123
            /* { */
          ) && this.regexp_eatHexDigits(state) && state.eat(
            125
            /* } */
          ) && isValidUnicode(state.lastIntValue)) {
            return true;
          }
          if (switchU) {
            state.raise("Invalid unicode escape");
          }
          state.pos = start;
        }
        return false;
      };
      function isValidUnicode(ch) {
        return ch >= 0 && ch <= 1114111;
      }
      pp$1.regexp_eatIdentityEscape = function(state) {
        if (state.switchU) {
          if (this.regexp_eatSyntaxCharacter(state)) {
            return true;
          }
          if (state.eat(
            47
            /* / */
          )) {
            state.lastIntValue = 47;
            return true;
          }
          return false;
        }
        var ch = state.current();
        if (ch !== 99 && (!state.switchN || ch !== 107)) {
          state.lastIntValue = ch;
          state.advance();
          return true;
        }
        return false;
      };
      pp$1.regexp_eatDecimalEscape = function(state) {
        state.lastIntValue = 0;
        var ch = state.current();
        if (ch >= 49 && ch <= 57) {
          do {
            state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
            state.advance();
          } while ((ch = state.current()) >= 48 && ch <= 57);
          return true;
        }
        return false;
      };
      var CharSetNone = 0;
      var CharSetOk = 1;
      var CharSetString = 2;
      pp$1.regexp_eatCharacterClassEscape = function(state) {
        var ch = state.current();
        if (isCharacterClassEscape(ch)) {
          state.lastIntValue = -1;
          state.advance();
          return CharSetOk;
        }
        var negate = false;
        if (state.switchU && this.options.ecmaVersion >= 9 && ((negate = ch === 80) || ch === 112)) {
          state.lastIntValue = -1;
          state.advance();
          var result;
          if (state.eat(
            123
            /* { */
          ) && (result = this.regexp_eatUnicodePropertyValueExpression(state)) && state.eat(
            125
            /* } */
          )) {
            if (negate && result === CharSetString) {
              state.raise("Invalid property name");
            }
            return result;
          }
          state.raise("Invalid property name");
        }
        return CharSetNone;
      };
      function isCharacterClassEscape(ch) {
        return ch === 100 || ch === 68 || ch === 115 || ch === 83 || ch === 119 || ch === 87;
      }
      pp$1.regexp_eatUnicodePropertyValueExpression = function(state) {
        var start = state.pos;
        if (this.regexp_eatUnicodePropertyName(state) && state.eat(
          61
          /* = */
        )) {
          var name = state.lastStringValue;
          if (this.regexp_eatUnicodePropertyValue(state)) {
            var value2 = state.lastStringValue;
            this.regexp_validateUnicodePropertyNameAndValue(state, name, value2);
            return CharSetOk;
          }
        }
        state.pos = start;
        if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
          var nameOrValue = state.lastStringValue;
          return this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
        }
        return CharSetNone;
      };
      pp$1.regexp_validateUnicodePropertyNameAndValue = function(state, name, value2) {
        if (!hasOwn(state.unicodeProperties.nonBinary, name)) {
          state.raise("Invalid property name");
        }
        if (!state.unicodeProperties.nonBinary[name].test(value2)) {
          state.raise("Invalid property value");
        }
      };
      pp$1.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
        if (state.unicodeProperties.binary.test(nameOrValue)) {
          return CharSetOk;
        }
        if (state.switchV && state.unicodeProperties.binaryOfStrings.test(nameOrValue)) {
          return CharSetString;
        }
        state.raise("Invalid property name");
      };
      pp$1.regexp_eatUnicodePropertyName = function(state) {
        var ch = 0;
        state.lastStringValue = "";
        while (isUnicodePropertyNameCharacter(ch = state.current())) {
          state.lastStringValue += codePointToString(ch);
          state.advance();
        }
        return state.lastStringValue !== "";
      };
      function isUnicodePropertyNameCharacter(ch) {
        return isControlLetter(ch) || ch === 95;
      }
      pp$1.regexp_eatUnicodePropertyValue = function(state) {
        var ch = 0;
        state.lastStringValue = "";
        while (isUnicodePropertyValueCharacter(ch = state.current())) {
          state.lastStringValue += codePointToString(ch);
          state.advance();
        }
        return state.lastStringValue !== "";
      };
      function isUnicodePropertyValueCharacter(ch) {
        return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch);
      }
      pp$1.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
        return this.regexp_eatUnicodePropertyValue(state);
      };
      pp$1.regexp_eatCharacterClass = function(state) {
        if (state.eat(
          91
          /* [ */
        )) {
          var negate = state.eat(
            94
            /* ^ */
          );
          var result = this.regexp_classContents(state);
          if (!state.eat(
            93
            /* ] */
          )) {
            state.raise("Unterminated character class");
          }
          if (negate && result === CharSetString) {
            state.raise("Negated character class may contain strings");
          }
          return true;
        }
        return false;
      };
      pp$1.regexp_classContents = function(state) {
        if (state.current() === 93) {
          return CharSetOk;
        }
        if (state.switchV) {
          return this.regexp_classSetExpression(state);
        }
        this.regexp_nonEmptyClassRanges(state);
        return CharSetOk;
      };
      pp$1.regexp_nonEmptyClassRanges = function(state) {
        while (this.regexp_eatClassAtom(state)) {
          var left = state.lastIntValue;
          if (state.eat(
            45
            /* - */
          ) && this.regexp_eatClassAtom(state)) {
            var right = state.lastIntValue;
            if (state.switchU && (left === -1 || right === -1)) {
              state.raise("Invalid character class");
            }
            if (left !== -1 && right !== -1 && left > right) {
              state.raise("Range out of order in character class");
            }
          }
        }
      };
      pp$1.regexp_eatClassAtom = function(state) {
        var start = state.pos;
        if (state.eat(
          92
          /* \ */
        )) {
          if (this.regexp_eatClassEscape(state)) {
            return true;
          }
          if (state.switchU) {
            var ch$1 = state.current();
            if (ch$1 === 99 || isOctalDigit(ch$1)) {
              state.raise("Invalid class escape");
            }
            state.raise("Invalid escape");
          }
          state.pos = start;
        }
        var ch = state.current();
        if (ch !== 93) {
          state.lastIntValue = ch;
          state.advance();
          return true;
        }
        return false;
      };
      pp$1.regexp_eatClassEscape = function(state) {
        var start = state.pos;
        if (state.eat(
          98
          /* b */
        )) {
          state.lastIntValue = 8;
          return true;
        }
        if (state.switchU && state.eat(
          45
          /* - */
        )) {
          state.lastIntValue = 45;
          return true;
        }
        if (!state.switchU && state.eat(
          99
          /* c */
        )) {
          if (this.regexp_eatClassControlLetter(state)) {
            return true;
          }
          state.pos = start;
        }
        return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);
      };
      pp$1.regexp_classSetExpression = function(state) {
        var result = CharSetOk, subResult;
        if (this.regexp_eatClassSetRange(state)) ;
        else if (subResult = this.regexp_eatClassSetOperand(state)) {
          if (subResult === CharSetString) {
            result = CharSetString;
          }
          var start = state.pos;
          while (state.eatChars(
            [38, 38]
            /* && */
          )) {
            if (state.current() !== 38 && (subResult = this.regexp_eatClassSetOperand(state))) {
              if (subResult !== CharSetString) {
                result = CharSetOk;
              }
              continue;
            }
            state.raise("Invalid character in character class");
          }
          if (start !== state.pos) {
            return result;
          }
          while (state.eatChars(
            [45, 45]
            /* -- */
          )) {
            if (this.regexp_eatClassSetOperand(state)) {
              continue;
            }
            state.raise("Invalid character in character class");
          }
          if (start !== state.pos) {
            return result;
          }
        } else {
          state.raise("Invalid character in character class");
        }
        for (; ; ) {
          if (this.regexp_eatClassSetRange(state)) {
            continue;
          }
          subResult = this.regexp_eatClassSetOperand(state);
          if (!subResult) {
            return result;
          }
          if (subResult === CharSetString) {
            result = CharSetString;
          }
        }
      };
      pp$1.regexp_eatClassSetRange = function(state) {
        var start = state.pos;
        if (this.regexp_eatClassSetCharacter(state)) {
          var left = state.lastIntValue;
          if (state.eat(
            45
            /* - */
          ) && this.regexp_eatClassSetCharacter(state)) {
            var right = state.lastIntValue;
            if (left !== -1 && right !== -1 && left > right) {
              state.raise("Range out of order in character class");
            }
            return true;
          }
          state.pos = start;
        }
        return false;
      };
      pp$1.regexp_eatClassSetOperand = function(state) {
        if (this.regexp_eatClassSetCharacter(state)) {
          return CharSetOk;
        }
        return this.regexp_eatClassStringDisjunction(state) || this.regexp_eatNestedClass(state);
      };
      pp$1.regexp_eatNestedClass = function(state) {
        var start = state.pos;
        if (state.eat(
          91
          /* [ */
        )) {
          var negate = state.eat(
            94
            /* ^ */
          );
          var result = this.regexp_classContents(state);
          if (state.eat(
            93
            /* ] */
          )) {
            if (negate && result === CharSetString) {
              state.raise("Negated character class may contain strings");
            }
            return result;
          }
          state.pos = start;
        }
        if (state.eat(
          92
          /* \ */
        )) {
          var result$1 = this.regexp_eatCharacterClassEscape(state);
          if (result$1) {
            return result$1;
          }
          state.pos = start;
        }
        return null;
      };
      pp$1.regexp_eatClassStringDisjunction = function(state) {
        var start = state.pos;
        if (state.eatChars(
          [92, 113]
          /* \q */
        )) {
          if (state.eat(
            123
            /* { */
          )) {
            var result = this.regexp_classStringDisjunctionContents(state);
            if (state.eat(
              125
              /* } */
            )) {
              return result;
            }
          } else {
            state.raise("Invalid escape");
          }
          state.pos = start;
        }
        return null;
      };
      pp$1.regexp_classStringDisjunctionContents = function(state) {
        var result = this.regexp_classString(state);
        while (state.eat(
          124
          /* | */
        )) {
          if (this.regexp_classString(state) === CharSetString) {
            result = CharSetString;
          }
        }
        return result;
      };
      pp$1.regexp_classString = function(state) {
        var count = 0;
        while (this.regexp_eatClassSetCharacter(state)) {
          count++;
        }
        return count === 1 ? CharSetOk : CharSetString;
      };
      pp$1.regexp_eatClassSetCharacter = function(state) {
        var start = state.pos;
        if (state.eat(
          92
          /* \ */
        )) {
          if (this.regexp_eatCharacterEscape(state) || this.regexp_eatClassSetReservedPunctuator(state)) {
            return true;
          }
          if (state.eat(
            98
            /* b */
          )) {
            state.lastIntValue = 8;
            return true;
          }
          state.pos = start;
          return false;
        }
        var ch = state.current();
        if (ch < 0 || ch === state.lookahead() && isClassSetReservedDoublePunctuatorCharacter(ch)) {
          return false;
        }
        if (isClassSetSyntaxCharacter(ch)) {
          return false;
        }
        state.advance();
        state.lastIntValue = ch;
        return true;
      };
      function isClassSetReservedDoublePunctuatorCharacter(ch) {
        return ch === 33 || ch >= 35 && ch <= 38 || ch >= 42 && ch <= 44 || ch === 46 || ch >= 58 && ch <= 64 || ch === 94 || ch === 96 || ch === 126;
      }
      function isClassSetSyntaxCharacter(ch) {
        return ch === 40 || ch === 41 || ch === 45 || ch === 47 || ch >= 91 && ch <= 93 || ch >= 123 && ch <= 125;
      }
      pp$1.regexp_eatClassSetReservedPunctuator = function(state) {
        var ch = state.current();
        if (isClassSetReservedPunctuator(ch)) {
          state.lastIntValue = ch;
          state.advance();
          return true;
        }
        return false;
      };
      function isClassSetReservedPunctuator(ch) {
        return ch === 33 || ch === 35 || ch === 37 || ch === 38 || ch === 44 || ch === 45 || ch >= 58 && ch <= 62 || ch === 64 || ch === 96 || ch === 126;
      }
      pp$1.regexp_eatClassControlLetter = function(state) {
        var ch = state.current();
        if (isDecimalDigit(ch) || ch === 95) {
          state.lastIntValue = ch % 32;
          state.advance();
          return true;
        }
        return false;
      };
      pp$1.regexp_eatHexEscapeSequence = function(state) {
        var start = state.pos;
        if (state.eat(
          120
          /* x */
        )) {
          if (this.regexp_eatFixedHexDigits(state, 2)) {
            return true;
          }
          if (state.switchU) {
            state.raise("Invalid escape");
          }
          state.pos = start;
        }
        return false;
      };
      pp$1.regexp_eatDecimalDigits = function(state) {
        var start = state.pos;
        var ch = 0;
        state.lastIntValue = 0;
        while (isDecimalDigit(ch = state.current())) {
          state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
          state.advance();
        }
        return state.pos !== start;
      };
      function isDecimalDigit(ch) {
        return ch >= 48 && ch <= 57;
      }
      pp$1.regexp_eatHexDigits = function(state) {
        var start = state.pos;
        var ch = 0;
        state.lastIntValue = 0;
        while (isHexDigit(ch = state.current())) {
          state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
          state.advance();
        }
        return state.pos !== start;
      };
      function isHexDigit(ch) {
        return ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102;
      }
      function hexToInt(ch) {
        if (ch >= 65 && ch <= 70) {
          return 10 + (ch - 65);
        }
        if (ch >= 97 && ch <= 102) {
          return 10 + (ch - 97);
        }
        return ch - 48;
      }
      pp$1.regexp_eatLegacyOctalEscapeSequence = function(state) {
        if (this.regexp_eatOctalDigit(state)) {
          var n1 = state.lastIntValue;
          if (this.regexp_eatOctalDigit(state)) {
            var n2 = state.lastIntValue;
            if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
              state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
            } else {
              state.lastIntValue = n1 * 8 + n2;
            }
          } else {
            state.lastIntValue = n1;
          }
          return true;
        }
        return false;
      };
      pp$1.regexp_eatOctalDigit = function(state) {
        var ch = state.current();
        if (isOctalDigit(ch)) {
          state.lastIntValue = ch - 48;
          state.advance();
          return true;
        }
        state.lastIntValue = 0;
        return false;
      };
      function isOctalDigit(ch) {
        return ch >= 48 && ch <= 55;
      }
      pp$1.regexp_eatFixedHexDigits = function(state, length) {
        var start = state.pos;
        state.lastIntValue = 0;
        for (var i2 = 0; i2 < length; ++i2) {
          var ch = state.current();
          if (!isHexDigit(ch)) {
            state.pos = start;
            return false;
          }
          state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
          state.advance();
        }
        return true;
      };
      var Token = function Token2(p) {
        this.type = p.type;
        this.value = p.value;
        this.start = p.start;
        this.end = p.end;
        if (p.options.locations) {
          this.loc = new SourceLocation(p, p.startLoc, p.endLoc);
        }
        if (p.options.ranges) {
          this.range = [p.start, p.end];
        }
      };
      var pp = Parser.prototype;
      pp.next = function(ignoreEscapeSequenceInKeyword) {
        if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc) {
          this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword);
        }
        if (this.options.onToken) {
          this.options.onToken(new Token(this));
        }
        this.lastTokEnd = this.end;
        this.lastTokStart = this.start;
        this.lastTokEndLoc = this.endLoc;
        this.lastTokStartLoc = this.startLoc;
        this.nextToken();
      };
      pp.getToken = function() {
        this.next();
        return new Token(this);
      };
      if (typeof Symbol !== "undefined") {
        pp[Symbol.iterator] = function() {
          var this$1$1 = this;
          return {
            next: function() {
              var token = this$1$1.getToken();
              return {
                done: token.type === types$1.eof,
                value: token
              };
            }
          };
        };
      }
      pp.nextToken = function() {
        var curContext = this.curContext();
        if (!curContext || !curContext.preserveSpace) {
          this.skipSpace();
        }
        this.start = this.pos;
        if (this.options.locations) {
          this.startLoc = this.curPosition();
        }
        if (this.pos >= this.input.length) {
          return this.finishToken(types$1.eof);
        }
        if (curContext.override) {
          return curContext.override(this);
        } else {
          this.readToken(this.fullCharCodeAtPos());
        }
      };
      pp.readToken = function(code) {
        if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92) {
          return this.readWord();
        }
        return this.getTokenFromCode(code);
      };
      pp.fullCharCodeAtPos = function() {
        var code = this.input.charCodeAt(this.pos);
        if (code <= 55295 || code >= 56320) {
          return code;
        }
        var next = this.input.charCodeAt(this.pos + 1);
        return next <= 56319 || next >= 57344 ? code : (code << 10) + next - 56613888;
      };
      pp.skipBlockComment = function() {
        var startLoc = this.options.onComment && this.curPosition();
        var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
        if (end === -1) {
          this.raise(this.pos - 2, "Unterminated comment");
        }
        this.pos = end + 2;
        if (this.options.locations) {
          for (var nextBreak = void 0, pos = start; (nextBreak = nextLineBreak(this.input, pos, this.pos)) > -1; ) {
            ++this.curLine;
            pos = this.lineStart = nextBreak;
          }
        }
        if (this.options.onComment) {
          this.options.onComment(
            true,
            this.input.slice(start + 2, end),
            start,
            this.pos,
            startLoc,
            this.curPosition()
          );
        }
      };
      pp.skipLineComment = function(startSkip) {
        var start = this.pos;
        var startLoc = this.options.onComment && this.curPosition();
        var ch = this.input.charCodeAt(this.pos += startSkip);
        while (this.pos < this.input.length && !isNewLine(ch)) {
          ch = this.input.charCodeAt(++this.pos);
        }
        if (this.options.onComment) {
          this.options.onComment(
            false,
            this.input.slice(start + startSkip, this.pos),
            start,
            this.pos,
            startLoc,
            this.curPosition()
          );
        }
      };
      pp.skipSpace = function() {
        loop: while (this.pos < this.input.length) {
          var ch = this.input.charCodeAt(this.pos);
          switch (ch) {
            case 32:
            case 160:
              ++this.pos;
              break;
            case 13:
              if (this.input.charCodeAt(this.pos + 1) === 10) {
                ++this.pos;
              }
            case 10:
            case 8232:
            case 8233:
              ++this.pos;
              if (this.options.locations) {
                ++this.curLine;
                this.lineStart = this.pos;
              }
              break;
            case 47:
              switch (this.input.charCodeAt(this.pos + 1)) {
                case 42:
                  this.skipBlockComment();
                  break;
                case 47:
                  this.skipLineComment(2);
                  break;
                default:
                  break loop;
              }
              break;
            default:
              if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
                ++this.pos;
              } else {
                break loop;
              }
          }
        }
      };
      pp.finishToken = function(type, val) {
        this.end = this.pos;
        if (this.options.locations) {
          this.endLoc = this.curPosition();
        }
        var prevType = this.type;
        this.type = type;
        this.value = val;
        this.updateContext(prevType);
      };
      pp.readToken_dot = function() {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next >= 48 && next <= 57) {
          return this.readNumber(true);
        }
        var next2 = this.input.charCodeAt(this.pos + 2);
        if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
          this.pos += 3;
          return this.finishToken(types$1.ellipsis);
        } else {
          ++this.pos;
          return this.finishToken(types$1.dot);
        }
      };
      pp.readToken_slash = function() {
        var next = this.input.charCodeAt(this.pos + 1);
        if (this.exprAllowed) {
          ++this.pos;
          return this.readRegexp();
        }
        if (next === 61) {
          return this.finishOp(types$1.assign, 2);
        }
        return this.finishOp(types$1.slash, 1);
      };
      pp.readToken_mult_modulo_exp = function(code) {
        var next = this.input.charCodeAt(this.pos + 1);
        var size = 1;
        var tokentype = code === 42 ? types$1.star : types$1.modulo;
        if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
          ++size;
          tokentype = types$1.starstar;
          next = this.input.charCodeAt(this.pos + 2);
        }
        if (next === 61) {
          return this.finishOp(types$1.assign, size + 1);
        }
        return this.finishOp(tokentype, size);
      };
      pp.readToken_pipe_amp = function(code) {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === code) {
          if (this.options.ecmaVersion >= 12) {
            var next2 = this.input.charCodeAt(this.pos + 2);
            if (next2 === 61) {
              return this.finishOp(types$1.assign, 3);
            }
          }
          return this.finishOp(code === 124 ? types$1.logicalOR : types$1.logicalAND, 2);
        }
        if (next === 61) {
          return this.finishOp(types$1.assign, 2);
        }
        return this.finishOp(code === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1);
      };
      pp.readToken_caret = function() {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === 61) {
          return this.finishOp(types$1.assign, 2);
        }
        return this.finishOp(types$1.bitwiseXOR, 1);
      };
      pp.readToken_plus_min = function(code) {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === code) {
          if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
            this.skipLineComment(3);
            this.skipSpace();
            return this.nextToken();
          }
          return this.finishOp(types$1.incDec, 2);
        }
        if (next === 61) {
          return this.finishOp(types$1.assign, 2);
        }
        return this.finishOp(types$1.plusMin, 1);
      };
      pp.readToken_lt_gt = function(code) {
        var next = this.input.charCodeAt(this.pos + 1);
        var size = 1;
        if (next === code) {
          size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
          if (this.input.charCodeAt(this.pos + size) === 61) {
            return this.finishOp(types$1.assign, size + 1);
          }
          return this.finishOp(types$1.bitShift, size);
        }
        if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {
          this.skipLineComment(4);
          this.skipSpace();
          return this.nextToken();
        }
        if (next === 61) {
          size = 2;
        }
        return this.finishOp(types$1.relational, size);
      };
      pp.readToken_eq_excl = function(code) {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === 61) {
          return this.finishOp(types$1.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
        }
        if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {
          this.pos += 2;
          return this.finishToken(types$1.arrow);
        }
        return this.finishOp(code === 61 ? types$1.eq : types$1.prefix, 1);
      };
      pp.readToken_question = function() {
        var ecmaVersion2 = this.options.ecmaVersion;
        if (ecmaVersion2 >= 11) {
          var next = this.input.charCodeAt(this.pos + 1);
          if (next === 46) {
            var next2 = this.input.charCodeAt(this.pos + 2);
            if (next2 < 48 || next2 > 57) {
              return this.finishOp(types$1.questionDot, 2);
            }
          }
          if (next === 63) {
            if (ecmaVersion2 >= 12) {
              var next2$1 = this.input.charCodeAt(this.pos + 2);
              if (next2$1 === 61) {
                return this.finishOp(types$1.assign, 3);
              }
            }
            return this.finishOp(types$1.coalesce, 2);
          }
        }
        return this.finishOp(types$1.question, 1);
      };
      pp.readToken_numberSign = function() {
        var ecmaVersion2 = this.options.ecmaVersion;
        var code = 35;
        if (ecmaVersion2 >= 13) {
          ++this.pos;
          code = this.fullCharCodeAtPos();
          if (isIdentifierStart(code, true) || code === 92) {
            return this.finishToken(types$1.privateId, this.readWord1());
          }
        }
        this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
      };
      pp.getTokenFromCode = function(code) {
        switch (code) {
          // The interpretation of a dot depends on whether it is followed
          // by a digit or another two dots.
          case 46:
            return this.readToken_dot();
          // Punctuation tokens.
          case 40:
            ++this.pos;
            return this.finishToken(types$1.parenL);
          case 41:
            ++this.pos;
            return this.finishToken(types$1.parenR);
          case 59:
            ++this.pos;
            return this.finishToken(types$1.semi);
          case 44:
            ++this.pos;
            return this.finishToken(types$1.comma);
          case 91:
            ++this.pos;
            return this.finishToken(types$1.bracketL);
          case 93:
            ++this.pos;
            return this.finishToken(types$1.bracketR);
          case 123:
            ++this.pos;
            return this.finishToken(types$1.braceL);
          case 125:
            ++this.pos;
            return this.finishToken(types$1.braceR);
          case 58:
            ++this.pos;
            return this.finishToken(types$1.colon);
          case 96:
            if (this.options.ecmaVersion < 6) {
              break;
            }
            ++this.pos;
            return this.finishToken(types$1.backQuote);
          case 48:
            var next = this.input.charCodeAt(this.pos + 1);
            if (next === 120 || next === 88) {
              return this.readRadixNumber(16);
            }
            if (this.options.ecmaVersion >= 6) {
              if (next === 111 || next === 79) {
                return this.readRadixNumber(8);
              }
              if (next === 98 || next === 66) {
                return this.readRadixNumber(2);
              }
            }
          // Anything else beginning with a digit is an integer, octal
          // number, or float.
          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
          case 55:
          case 56:
          case 57:
            return this.readNumber(false);
          // Quotes produce strings.
          case 34:
          case 39:
            return this.readString(code);
          // Operators are parsed inline in tiny state machines. '=' (61) is
          // often referred to. `finishOp` simply skips the amount of
          // characters it is given as second argument, and returns a token
          // of the type given by its first argument.
          case 47:
            return this.readToken_slash();
          case 37:
          case 42:
            return this.readToken_mult_modulo_exp(code);
          case 124:
          case 38:
            return this.readToken_pipe_amp(code);
          case 94:
            return this.readToken_caret();
          case 43:
          case 45:
            return this.readToken_plus_min(code);
          case 60:
          case 62:
            return this.readToken_lt_gt(code);
          case 61:
          case 33:
            return this.readToken_eq_excl(code);
          case 63:
            return this.readToken_question();
          case 126:
            return this.finishOp(types$1.prefix, 1);
          case 35:
            return this.readToken_numberSign();
        }
        this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
      };
      pp.finishOp = function(type, size) {
        var str = this.input.slice(this.pos, this.pos + size);
        this.pos += size;
        return this.finishToken(type, str);
      };
      pp.readRegexp = function() {
        var escaped, inClass, start = this.pos;
        for (; ; ) {
          if (this.pos >= this.input.length) {
            this.raise(start, "Unterminated regular expression");
          }
          var ch = this.input.charAt(this.pos);
          if (lineBreak.test(ch)) {
            this.raise(start, "Unterminated regular expression");
          }
          if (!escaped) {
            if (ch === "[") {
              inClass = true;
            } else if (ch === "]" && inClass) {
              inClass = false;
            } else if (ch === "/" && !inClass) {
              break;
            }
            escaped = ch === "\\";
          } else {
            escaped = false;
          }
          ++this.pos;
        }
        var pattern = this.input.slice(start, this.pos);
        ++this.pos;
        var flagsStart = this.pos;
        var flags = this.readWord1();
        if (this.containsEsc) {
          this.unexpected(flagsStart);
        }
        var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
        state.reset(start, pattern, flags);
        this.validateRegExpFlags(state);
        this.validateRegExpPattern(state);
        var value2 = null;
        try {
          value2 = new RegExp(pattern, flags);
        } catch (e) {
        }
        return this.finishToken(types$1.regexp, { pattern, flags, value: value2 });
      };
      pp.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
        var allowSeparators = this.options.ecmaVersion >= 12 && len === void 0;
        var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;
        var start = this.pos, total = 0, lastCode = 0;
        for (var i2 = 0, e = len == null ? Infinity : len; i2 < e; ++i2, ++this.pos) {
          var code = this.input.charCodeAt(this.pos), val = void 0;
          if (allowSeparators && code === 95) {
            if (isLegacyOctalNumericLiteral) {
              this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals");
            }
            if (lastCode === 95) {
              this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore");
            }
            if (i2 === 0) {
              this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits");
            }
            lastCode = code;
            continue;
          }
          if (code >= 97) {
            val = code - 97 + 10;
          } else if (code >= 65) {
            val = code - 65 + 10;
          } else if (code >= 48 && code <= 57) {
            val = code - 48;
          } else {
            val = Infinity;
          }
          if (val >= radix) {
            break;
          }
          lastCode = code;
          total = total * radix + val;
        }
        if (allowSeparators && lastCode === 95) {
          this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits");
        }
        if (this.pos === start || len != null && this.pos - start !== len) {
          return null;
        }
        return total;
      };
      function stringToNumber(str, isLegacyOctalNumericLiteral) {
        if (isLegacyOctalNumericLiteral) {
          return parseInt(str, 8);
        }
        return parseFloat(str.replace(/_/g, ""));
      }
      function stringToBigInt(str) {
        if (typeof BigInt !== "function") {
          return null;
        }
        return BigInt(str.replace(/_/g, ""));
      }
      pp.readRadixNumber = function(radix) {
        var start = this.pos;
        this.pos += 2;
        var val = this.readInt(radix);
        if (val == null) {
          this.raise(this.start + 2, "Expected number in radix " + radix);
        }
        if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
          val = stringToBigInt(this.input.slice(start, this.pos));
          ++this.pos;
        } else if (isIdentifierStart(this.fullCharCodeAtPos())) {
          this.raise(this.pos, "Identifier directly after number");
        }
        return this.finishToken(types$1.num, val);
      };
      pp.readNumber = function(startsWithDot) {
        var start = this.pos;
        if (!startsWithDot && this.readInt(10, void 0, true) === null) {
          this.raise(start, "Invalid number");
        }
        var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
        if (octal && this.strict) {
          this.raise(start, "Invalid number");
        }
        var next = this.input.charCodeAt(this.pos);
        if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
          var val$1 = stringToBigInt(this.input.slice(start, this.pos));
          ++this.pos;
          if (isIdentifierStart(this.fullCharCodeAtPos())) {
            this.raise(this.pos, "Identifier directly after number");
          }
          return this.finishToken(types$1.num, val$1);
        }
        if (octal && /[89]/.test(this.input.slice(start, this.pos))) {
          octal = false;
        }
        if (next === 46 && !octal) {
          ++this.pos;
          this.readInt(10);
          next = this.input.charCodeAt(this.pos);
        }
        if ((next === 69 || next === 101) && !octal) {
          next = this.input.charCodeAt(++this.pos);
          if (next === 43 || next === 45) {
            ++this.pos;
          }
          if (this.readInt(10) === null) {
            this.raise(start, "Invalid number");
          }
        }
        if (isIdentifierStart(this.fullCharCodeAtPos())) {
          this.raise(this.pos, "Identifier directly after number");
        }
        var val = stringToNumber(this.input.slice(start, this.pos), octal);
        return this.finishToken(types$1.num, val);
      };
      pp.readCodePoint = function() {
        var ch = this.input.charCodeAt(this.pos), code;
        if (ch === 123) {
          if (this.options.ecmaVersion < 6) {
            this.unexpected();
          }
          var codePos = ++this.pos;
          code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
          ++this.pos;
          if (code > 1114111) {
            this.invalidStringToken(codePos, "Code point out of bounds");
          }
        } else {
          code = this.readHexChar(4);
        }
        return code;
      };
      pp.readString = function(quote) {
        var out = "", chunkStart = ++this.pos;
        for (; ; ) {
          if (this.pos >= this.input.length) {
            this.raise(this.start, "Unterminated string constant");
          }
          var ch = this.input.charCodeAt(this.pos);
          if (ch === quote) {
            break;
          }
          if (ch === 92) {
            out += this.input.slice(chunkStart, this.pos);
            out += this.readEscapedChar(false);
            chunkStart = this.pos;
          } else if (ch === 8232 || ch === 8233) {
            if (this.options.ecmaVersion < 10) {
              this.raise(this.start, "Unterminated string constant");
            }
            ++this.pos;
            if (this.options.locations) {
              this.curLine++;
              this.lineStart = this.pos;
            }
          } else {
            if (isNewLine(ch)) {
              this.raise(this.start, "Unterminated string constant");
            }
            ++this.pos;
          }
        }
        out += this.input.slice(chunkStart, this.pos++);
        return this.finishToken(types$1.string, out);
      };
      var INVALID_TEMPLATE_ESCAPE_ERROR = {};
      pp.tryReadTemplateToken = function() {
        this.inTemplateElement = true;
        try {
          this.readTmplToken();
        } catch (err) {
          if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
            this.readInvalidTemplateToken();
          } else {
            throw err;
          }
        }
        this.inTemplateElement = false;
      };
      pp.invalidStringToken = function(position, message) {
        if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
          throw INVALID_TEMPLATE_ESCAPE_ERROR;
        } else {
          this.raise(position, message);
        }
      };
      pp.readTmplToken = function() {
        var out = "", chunkStart = this.pos;
        for (; ; ) {
          if (this.pos >= this.input.length) {
            this.raise(this.start, "Unterminated template");
          }
          var ch = this.input.charCodeAt(this.pos);
          if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
            if (this.pos === this.start && (this.type === types$1.template || this.type === types$1.invalidTemplate)) {
              if (ch === 36) {
                this.pos += 2;
                return this.finishToken(types$1.dollarBraceL);
              } else {
                ++this.pos;
                return this.finishToken(types$1.backQuote);
              }
            }
            out += this.input.slice(chunkStart, this.pos);
            return this.finishToken(types$1.template, out);
          }
          if (ch === 92) {
            out += this.input.slice(chunkStart, this.pos);
            out += this.readEscapedChar(true);
            chunkStart = this.pos;
          } else if (isNewLine(ch)) {
            out += this.input.slice(chunkStart, this.pos);
            ++this.pos;
            switch (ch) {
              case 13:
                if (this.input.charCodeAt(this.pos) === 10) {
                  ++this.pos;
                }
              case 10:
                out += "\n";
                break;
              default:
                out += String.fromCharCode(ch);
                break;
            }
            if (this.options.locations) {
              ++this.curLine;
              this.lineStart = this.pos;
            }
            chunkStart = this.pos;
          } else {
            ++this.pos;
          }
        }
      };
      pp.readInvalidTemplateToken = function() {
        for (; this.pos < this.input.length; this.pos++) {
          switch (this.input[this.pos]) {
            case "\\":
              ++this.pos;
              break;
            case "$":
              if (this.input[this.pos + 1] !== "{") {
                break;
              }
            // fall through
            case "`":
              return this.finishToken(types$1.invalidTemplate, this.input.slice(this.start, this.pos));
            case "\r":
              if (this.input[this.pos + 1] === "\n") {
                ++this.pos;
              }
            // fall through
            case "\n":
            case "\u2028":
            case "\u2029":
              ++this.curLine;
              this.lineStart = this.pos + 1;
              break;
          }
        }
        this.raise(this.start, "Unterminated template");
      };
      pp.readEscapedChar = function(inTemplate) {
        var ch = this.input.charCodeAt(++this.pos);
        ++this.pos;
        switch (ch) {
          case 110:
            return "\n";
          // 'n' -> '\n'
          case 114:
            return "\r";
          // 'r' -> '\r'
          case 120:
            return String.fromCharCode(this.readHexChar(2));
          // 'x'
          case 117:
            return codePointToString(this.readCodePoint());
          // 'u'
          case 116:
            return "	";
          // 't' -> '\t'
          case 98:
            return "\b";
          // 'b' -> '\b'
          case 118:
            return "\v";
          // 'v' -> '\u000b'
          case 102:
            return "\f";
          // 'f' -> '\f'
          case 13:
            if (this.input.charCodeAt(this.pos) === 10) {
              ++this.pos;
            }
          // '\r\n'
          case 10:
            if (this.options.locations) {
              this.lineStart = this.pos;
              ++this.curLine;
            }
            return "";
          case 56:
          case 57:
            if (this.strict) {
              this.invalidStringToken(
                this.pos - 1,
                "Invalid escape sequence"
              );
            }
            if (inTemplate) {
              var codePos = this.pos - 1;
              this.invalidStringToken(
                codePos,
                "Invalid escape sequence in template string"
              );
            }
          default:
            if (ch >= 48 && ch <= 55) {
              var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
              var octal = parseInt(octalStr, 8);
              if (octal > 255) {
                octalStr = octalStr.slice(0, -1);
                octal = parseInt(octalStr, 8);
              }
              this.pos += octalStr.length - 1;
              ch = this.input.charCodeAt(this.pos);
              if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
                this.invalidStringToken(
                  this.pos - 1 - octalStr.length,
                  inTemplate ? "Octal literal in template string" : "Octal literal in strict mode"
                );
              }
              return String.fromCharCode(octal);
            }
            if (isNewLine(ch)) {
              if (this.options.locations) {
                this.lineStart = this.pos;
                ++this.curLine;
              }
              return "";
            }
            return String.fromCharCode(ch);
        }
      };
      pp.readHexChar = function(len) {
        var codePos = this.pos;
        var n = this.readInt(16, len);
        if (n === null) {
          this.invalidStringToken(codePos, "Bad character escape sequence");
        }
        return n;
      };
      pp.readWord1 = function() {
        this.containsEsc = false;
        var word = "", first = true, chunkStart = this.pos;
        var astral = this.options.ecmaVersion >= 6;
        while (this.pos < this.input.length) {
          var ch = this.fullCharCodeAtPos();
          if (isIdentifierChar(ch, astral)) {
            this.pos += ch <= 65535 ? 1 : 2;
          } else if (ch === 92) {
            this.containsEsc = true;
            word += this.input.slice(chunkStart, this.pos);
            var escStart = this.pos;
            if (this.input.charCodeAt(++this.pos) !== 117) {
              this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX");
            }
            ++this.pos;
            var esc = this.readCodePoint();
            if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral)) {
              this.invalidStringToken(escStart, "Invalid Unicode escape");
            }
            word += codePointToString(esc);
            chunkStart = this.pos;
          } else {
            break;
          }
          first = false;
        }
        return word + this.input.slice(chunkStart, this.pos);
      };
      pp.readWord = function() {
        var word = this.readWord1();
        var type = types$1.name;
        if (this.keywords.test(word)) {
          type = keywords[word];
        }
        return this.finishToken(type, word);
      };
      var version = "8.15.0";
      Parser.acorn = {
        Parser,
        version,
        defaultOptions,
        Position,
        SourceLocation,
        getLineInfo,
        Node,
        TokenType,
        tokTypes: types$1,
        keywordTypes: keywords,
        TokContext,
        tokContexts: types,
        isIdentifierChar,
        isIdentifierStart,
        Token,
        isNewLine,
        lineBreak,
        lineBreakG,
        nonASCIIwhitespace
      };
      function parse(input, options) {
        return Parser.parse(input, options);
      }
      function parseExpressionAt(input, pos, options) {
        return Parser.parseExpressionAt(input, pos, options);
      }
      function tokenizer(input, options) {
        return Parser.tokenizer(input, options);
      }
      exports3.Node = Node;
      exports3.Parser = Parser;
      exports3.Position = Position;
      exports3.SourceLocation = SourceLocation;
      exports3.TokContext = TokContext;
      exports3.Token = Token;
      exports3.TokenType = TokenType;
      exports3.defaultOptions = defaultOptions;
      exports3.getLineInfo = getLineInfo;
      exports3.isIdentifierChar = isIdentifierChar;
      exports3.isIdentifierStart = isIdentifierStart;
      exports3.isNewLine = isNewLine;
      exports3.keywordTypes = keywords;
      exports3.lineBreak = lineBreak;
      exports3.lineBreakG = lineBreakG;
      exports3.nonASCIIwhitespace = nonASCIIwhitespace;
      exports3.parse = parse;
      exports3.parseExpressionAt = parseExpressionAt;
      exports3.tokContexts = types;
      exports3.tokTypes = types$1;
      exports3.tokenizer = tokenizer;
      exports3.version = version;
    });
  }
});

// node_modules/acorn-walk/dist/walk.js
var require_walk = __commonJS({
  "node_modules/acorn-walk/dist/walk.js"(exports2, module2) {
    "use strict";
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = global2 || self, factory((global2.acorn = global2.acorn || {}, global2.acorn.walk = {})));
    })(exports2, function(exports3) {
      "use strict";
      function simple(node, visitors, baseVisitor, state, override) {
        if (!baseVisitor) {
          baseVisitor = base;
        }
        (function c(node2, st, override2) {
          var type = override2 || node2.type, found = visitors[type];
          baseVisitor[type](node2, st, c);
          if (found) {
            found(node2, st);
          }
        })(node, state, override);
      }
      function ancestor(node, visitors, baseVisitor, state, override) {
        var ancestors = [];
        if (!baseVisitor) {
          baseVisitor = base;
        }
        (function c(node2, st, override2) {
          var type = override2 || node2.type, found = visitors[type];
          var isNew = node2 !== ancestors[ancestors.length - 1];
          if (isNew) {
            ancestors.push(node2);
          }
          baseVisitor[type](node2, st, c);
          if (found) {
            found(node2, st || ancestors, ancestors);
          }
          if (isNew) {
            ancestors.pop();
          }
        })(node, state, override);
      }
      function recursive(node, state, funcs, baseVisitor, override) {
        var visitor = funcs ? make(funcs, baseVisitor || void 0) : baseVisitor;
        (function c(node2, st, override2) {
          visitor[override2 || node2.type](node2, st, c);
        })(node, state, override);
      }
      function makeTest(test) {
        if (typeof test === "string") {
          return function(type) {
            return type === test;
          };
        } else if (!test) {
          return function() {
            return true;
          };
        } else {
          return test;
        }
      }
      var Found = function Found2(node, state) {
        this.node = node;
        this.state = state;
      };
      function full(node, callback, baseVisitor, state, override) {
        if (!baseVisitor) {
          baseVisitor = base;
        }
        var last;
        (function c(node2, st, override2) {
          var type = override2 || node2.type;
          baseVisitor[type](node2, st, c);
          if (last !== node2) {
            callback(node2, st, type);
            last = node2;
          }
        })(node, state, override);
      }
      function fullAncestor(node, callback, baseVisitor, state) {
        if (!baseVisitor) {
          baseVisitor = base;
        }
        var ancestors = [], last;
        (function c(node2, st, override) {
          var type = override || node2.type;
          var isNew = node2 !== ancestors[ancestors.length - 1];
          if (isNew) {
            ancestors.push(node2);
          }
          baseVisitor[type](node2, st, c);
          if (last !== node2) {
            callback(node2, st || ancestors, ancestors, type);
            last = node2;
          }
          if (isNew) {
            ancestors.pop();
          }
        })(node, state);
      }
      function findNodeAt(node, start, end, test, baseVisitor, state) {
        if (!baseVisitor) {
          baseVisitor = base;
        }
        test = makeTest(test);
        try {
          (function c(node2, st, override) {
            var type = override || node2.type;
            if ((start == null || node2.start <= start) && (end == null || node2.end >= end)) {
              baseVisitor[type](node2, st, c);
            }
            if ((start == null || node2.start === start) && (end == null || node2.end === end) && test(type, node2)) {
              throw new Found(node2, st);
            }
          })(node, state);
        } catch (e) {
          if (e instanceof Found) {
            return e;
          }
          throw e;
        }
      }
      function findNodeAround(node, pos, test, baseVisitor, state) {
        test = makeTest(test);
        if (!baseVisitor) {
          baseVisitor = base;
        }
        try {
          (function c(node2, st, override) {
            var type = override || node2.type;
            if (node2.start > pos || node2.end < pos) {
              return;
            }
            baseVisitor[type](node2, st, c);
            if (test(type, node2)) {
              throw new Found(node2, st);
            }
          })(node, state);
        } catch (e) {
          if (e instanceof Found) {
            return e;
          }
          throw e;
        }
      }
      function findNodeAfter(node, pos, test, baseVisitor, state) {
        test = makeTest(test);
        if (!baseVisitor) {
          baseVisitor = base;
        }
        try {
          (function c(node2, st, override) {
            if (node2.end < pos) {
              return;
            }
            var type = override || node2.type;
            if (node2.start >= pos && test(type, node2)) {
              throw new Found(node2, st);
            }
            baseVisitor[type](node2, st, c);
          })(node, state);
        } catch (e) {
          if (e instanceof Found) {
            return e;
          }
          throw e;
        }
      }
      function findNodeBefore(node, pos, test, baseVisitor, state) {
        test = makeTest(test);
        if (!baseVisitor) {
          baseVisitor = base;
        }
        var max;
        (function c(node2, st, override) {
          if (node2.start > pos) {
            return;
          }
          var type = override || node2.type;
          if (node2.end <= pos && (!max || max.node.end < node2.end) && test(type, node2)) {
            max = new Found(node2, st);
          }
          baseVisitor[type](node2, st, c);
        })(node, state);
        return max;
      }
      function make(funcs, baseVisitor) {
        var visitor = Object.create(baseVisitor || base);
        for (var type in funcs) {
          visitor[type] = funcs[type];
        }
        return visitor;
      }
      function skipThrough(node, st, c) {
        c(node, st);
      }
      function ignore(_node, _st, _c) {
      }
      var base = {};
      base.Program = base.BlockStatement = base.StaticBlock = function(node, st, c) {
        for (var i = 0, list = node.body; i < list.length; i += 1) {
          var stmt = list[i];
          c(stmt, st, "Statement");
        }
      };
      base.Statement = skipThrough;
      base.EmptyStatement = ignore;
      base.ExpressionStatement = base.ParenthesizedExpression = base.ChainExpression = function(node, st, c) {
        return c(node.expression, st, "Expression");
      };
      base.IfStatement = function(node, st, c) {
        c(node.test, st, "Expression");
        c(node.consequent, st, "Statement");
        if (node.alternate) {
          c(node.alternate, st, "Statement");
        }
      };
      base.LabeledStatement = function(node, st, c) {
        return c(node.body, st, "Statement");
      };
      base.BreakStatement = base.ContinueStatement = ignore;
      base.WithStatement = function(node, st, c) {
        c(node.object, st, "Expression");
        c(node.body, st, "Statement");
      };
      base.SwitchStatement = function(node, st, c) {
        c(node.discriminant, st, "Expression");
        for (var i$1 = 0, list$1 = node.cases; i$1 < list$1.length; i$1 += 1) {
          var cs = list$1[i$1];
          if (cs.test) {
            c(cs.test, st, "Expression");
          }
          for (var i = 0, list = cs.consequent; i < list.length; i += 1) {
            var cons = list[i];
            c(cons, st, "Statement");
          }
        }
      };
      base.SwitchCase = function(node, st, c) {
        if (node.test) {
          c(node.test, st, "Expression");
        }
        for (var i = 0, list = node.consequent; i < list.length; i += 1) {
          var cons = list[i];
          c(cons, st, "Statement");
        }
      };
      base.ReturnStatement = base.YieldExpression = base.AwaitExpression = function(node, st, c) {
        if (node.argument) {
          c(node.argument, st, "Expression");
        }
      };
      base.ThrowStatement = base.SpreadElement = function(node, st, c) {
        return c(node.argument, st, "Expression");
      };
      base.TryStatement = function(node, st, c) {
        c(node.block, st, "Statement");
        if (node.handler) {
          c(node.handler, st);
        }
        if (node.finalizer) {
          c(node.finalizer, st, "Statement");
        }
      };
      base.CatchClause = function(node, st, c) {
        if (node.param) {
          c(node.param, st, "Pattern");
        }
        c(node.body, st, "Statement");
      };
      base.WhileStatement = base.DoWhileStatement = function(node, st, c) {
        c(node.test, st, "Expression");
        c(node.body, st, "Statement");
      };
      base.ForStatement = function(node, st, c) {
        if (node.init) {
          c(node.init, st, "ForInit");
        }
        if (node.test) {
          c(node.test, st, "Expression");
        }
        if (node.update) {
          c(node.update, st, "Expression");
        }
        c(node.body, st, "Statement");
      };
      base.ForInStatement = base.ForOfStatement = function(node, st, c) {
        c(node.left, st, "ForInit");
        c(node.right, st, "Expression");
        c(node.body, st, "Statement");
      };
      base.ForInit = function(node, st, c) {
        if (node.type === "VariableDeclaration") {
          c(node, st);
        } else {
          c(node, st, "Expression");
        }
      };
      base.DebuggerStatement = ignore;
      base.FunctionDeclaration = function(node, st, c) {
        return c(node, st, "Function");
      };
      base.VariableDeclaration = function(node, st, c) {
        for (var i = 0, list = node.declarations; i < list.length; i += 1) {
          var decl = list[i];
          c(decl, st);
        }
      };
      base.VariableDeclarator = function(node, st, c) {
        c(node.id, st, "Pattern");
        if (node.init) {
          c(node.init, st, "Expression");
        }
      };
      base.Function = function(node, st, c) {
        if (node.id) {
          c(node.id, st, "Pattern");
        }
        for (var i = 0, list = node.params; i < list.length; i += 1) {
          var param = list[i];
          c(param, st, "Pattern");
        }
        c(node.body, st, node.expression ? "Expression" : "Statement");
      };
      base.Pattern = function(node, st, c) {
        if (node.type === "Identifier") {
          c(node, st, "VariablePattern");
        } else if (node.type === "MemberExpression") {
          c(node, st, "MemberPattern");
        } else {
          c(node, st);
        }
      };
      base.VariablePattern = ignore;
      base.MemberPattern = skipThrough;
      base.RestElement = function(node, st, c) {
        return c(node.argument, st, "Pattern");
      };
      base.ArrayPattern = function(node, st, c) {
        for (var i = 0, list = node.elements; i < list.length; i += 1) {
          var elt = list[i];
          if (elt) {
            c(elt, st, "Pattern");
          }
        }
      };
      base.ObjectPattern = function(node, st, c) {
        for (var i = 0, list = node.properties; i < list.length; i += 1) {
          var prop = list[i];
          if (prop.type === "Property") {
            if (prop.computed) {
              c(prop.key, st, "Expression");
            }
            c(prop.value, st, "Pattern");
          } else if (prop.type === "RestElement") {
            c(prop.argument, st, "Pattern");
          }
        }
      };
      base.Expression = skipThrough;
      base.ThisExpression = base.Super = base.MetaProperty = ignore;
      base.ArrayExpression = function(node, st, c) {
        for (var i = 0, list = node.elements; i < list.length; i += 1) {
          var elt = list[i];
          if (elt) {
            c(elt, st, "Expression");
          }
        }
      };
      base.ObjectExpression = function(node, st, c) {
        for (var i = 0, list = node.properties; i < list.length; i += 1) {
          var prop = list[i];
          c(prop, st);
        }
      };
      base.FunctionExpression = base.ArrowFunctionExpression = base.FunctionDeclaration;
      base.SequenceExpression = function(node, st, c) {
        for (var i = 0, list = node.expressions; i < list.length; i += 1) {
          var expr = list[i];
          c(expr, st, "Expression");
        }
      };
      base.TemplateLiteral = function(node, st, c) {
        for (var i = 0, list = node.quasis; i < list.length; i += 1) {
          var quasi = list[i];
          c(quasi, st);
        }
        for (var i$1 = 0, list$1 = node.expressions; i$1 < list$1.length; i$1 += 1) {
          var expr = list$1[i$1];
          c(expr, st, "Expression");
        }
      };
      base.TemplateElement = ignore;
      base.UnaryExpression = base.UpdateExpression = function(node, st, c) {
        c(node.argument, st, "Expression");
      };
      base.BinaryExpression = base.LogicalExpression = function(node, st, c) {
        c(node.left, st, "Expression");
        c(node.right, st, "Expression");
      };
      base.AssignmentExpression = base.AssignmentPattern = function(node, st, c) {
        c(node.left, st, "Pattern");
        c(node.right, st, "Expression");
      };
      base.ConditionalExpression = function(node, st, c) {
        c(node.test, st, "Expression");
        c(node.consequent, st, "Expression");
        c(node.alternate, st, "Expression");
      };
      base.NewExpression = base.CallExpression = function(node, st, c) {
        c(node.callee, st, "Expression");
        if (node.arguments) {
          for (var i = 0, list = node.arguments; i < list.length; i += 1) {
            var arg = list[i];
            c(arg, st, "Expression");
          }
        }
      };
      base.MemberExpression = function(node, st, c) {
        c(node.object, st, "Expression");
        if (node.computed) {
          c(node.property, st, "Expression");
        }
      };
      base.ExportNamedDeclaration = base.ExportDefaultDeclaration = function(node, st, c) {
        if (node.declaration) {
          c(node.declaration, st, node.type === "ExportNamedDeclaration" || node.declaration.id ? "Statement" : "Expression");
        }
        if (node.source) {
          c(node.source, st, "Expression");
        }
      };
      base.ExportAllDeclaration = function(node, st, c) {
        if (node.exported) {
          c(node.exported, st);
        }
        c(node.source, st, "Expression");
      };
      base.ImportDeclaration = function(node, st, c) {
        for (var i = 0, list = node.specifiers; i < list.length; i += 1) {
          var spec = list[i];
          c(spec, st);
        }
        c(node.source, st, "Expression");
      };
      base.ImportExpression = function(node, st, c) {
        c(node.source, st, "Expression");
      };
      base.ImportSpecifier = base.ImportDefaultSpecifier = base.ImportNamespaceSpecifier = base.Identifier = base.PrivateIdentifier = base.Literal = ignore;
      base.TaggedTemplateExpression = function(node, st, c) {
        c(node.tag, st, "Expression");
        c(node.quasi, st, "Expression");
      };
      base.ClassDeclaration = base.ClassExpression = function(node, st, c) {
        return c(node, st, "Class");
      };
      base.Class = function(node, st, c) {
        if (node.id) {
          c(node.id, st, "Pattern");
        }
        if (node.superClass) {
          c(node.superClass, st, "Expression");
        }
        c(node.body, st);
      };
      base.ClassBody = function(node, st, c) {
        for (var i = 0, list = node.body; i < list.length; i += 1) {
          var elt = list[i];
          c(elt, st);
        }
      };
      base.MethodDefinition = base.PropertyDefinition = base.Property = function(node, st, c) {
        if (node.computed) {
          c(node.key, st, "Expression");
        }
        if (node.value) {
          c(node.value, st, "Expression");
        }
      };
      exports3.ancestor = ancestor;
      exports3.base = base;
      exports3.findNodeAfter = findNodeAfter;
      exports3.findNodeAround = findNodeAround;
      exports3.findNodeAt = findNodeAt;
      exports3.findNodeBefore = findNodeBefore;
      exports3.full = full;
      exports3.fullAncestor = fullAncestor;
      exports3.make = make;
      exports3.recursive = recursive;
      exports3.simple = simple;
      Object.defineProperty(exports3, "__esModule", { value: true });
    });
  }
});

// node_modules/callsites/index.js
var require_callsites = __commonJS({
  "node_modules/callsites/index.js"(exports2, module2) {
    "use strict";
    var callsites = () => {
      const _prepareStackTrace = Error.prepareStackTrace;
      Error.prepareStackTrace = (_2, stack2) => stack2;
      const stack = new Error().stack.slice(1);
      Error.prepareStackTrace = _prepareStackTrace;
      return stack;
    };
    module2.exports = callsites;
    module2.exports.default = callsites;
  }
});

// node_modules/source-map/lib/base64.js
var require_base64 = __commonJS({
  "node_modules/source-map/lib/base64.js"(exports2) {
    "use strict";
    var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
    exports2.encode = function(number) {
      if (0 <= number && number < intToCharMap.length) {
        return intToCharMap[number];
      }
      throw new TypeError("Must be between 0 and 63: " + number);
    };
    exports2.decode = function(charCode) {
      var bigA = 65;
      var bigZ = 90;
      var littleA = 97;
      var littleZ = 122;
      var zero = 48;
      var nine = 57;
      var plus = 43;
      var slash = 47;
      var littleOffset = 26;
      var numberOffset = 52;
      if (bigA <= charCode && charCode <= bigZ) {
        return charCode - bigA;
      }
      if (littleA <= charCode && charCode <= littleZ) {
        return charCode - littleA + littleOffset;
      }
      if (zero <= charCode && charCode <= nine) {
        return charCode - zero + numberOffset;
      }
      if (charCode == plus) {
        return 62;
      }
      if (charCode == slash) {
        return 63;
      }
      return -1;
    };
  }
});

// node_modules/source-map/lib/base64-vlq.js
var require_base64_vlq = __commonJS({
  "node_modules/source-map/lib/base64-vlq.js"(exports2) {
    "use strict";
    var base64 = require_base64();
    var VLQ_BASE_SHIFT = 5;
    var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
    var VLQ_BASE_MASK = VLQ_BASE - 1;
    var VLQ_CONTINUATION_BIT = VLQ_BASE;
    function toVLQSigned(aValue) {
      return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
    }
    function fromVLQSigned(aValue) {
      var isNegative = (aValue & 1) === 1;
      var shifted = aValue >> 1;
      return isNegative ? -shifted : shifted;
    }
    exports2.encode = function base64VLQ_encode(aValue) {
      var encoded = "";
      var digit;
      var vlq = toVLQSigned(aValue);
      do {
        digit = vlq & VLQ_BASE_MASK;
        vlq >>>= VLQ_BASE_SHIFT;
        if (vlq > 0) {
          digit |= VLQ_CONTINUATION_BIT;
        }
        encoded += base64.encode(digit);
      } while (vlq > 0);
      return encoded;
    };
    exports2.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
      var strLen = aStr.length;
      var result = 0;
      var shift = 0;
      var continuation, digit;
      do {
        if (aIndex >= strLen) {
          throw new Error("Expected more digits in base 64 VLQ value.");
        }
        digit = base64.decode(aStr.charCodeAt(aIndex++));
        if (digit === -1) {
          throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
        }
        continuation = !!(digit & VLQ_CONTINUATION_BIT);
        digit &= VLQ_BASE_MASK;
        result = result + (digit << shift);
        shift += VLQ_BASE_SHIFT;
      } while (continuation);
      aOutParam.value = fromVLQSigned(result);
      aOutParam.rest = aIndex;
    };
  }
});

// node_modules/source-map/lib/util.js
var require_util2 = __commonJS({
  "node_modules/source-map/lib/util.js"(exports2) {
    "use strict";
    function getArg(aArgs, aName, aDefaultValue) {
      if (aName in aArgs) {
        return aArgs[aName];
      } else if (arguments.length === 3) {
        return aDefaultValue;
      } else {
        throw new Error('"' + aName + '" is a required argument.');
      }
    }
    exports2.getArg = getArg;
    var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
    var dataUrlRegexp = /^data:.+\,.+$/;
    function urlParse(aUrl) {
      var match = aUrl.match(urlRegexp);
      if (!match) {
        return null;
      }
      return {
        scheme: match[1],
        auth: match[2],
        host: match[3],
        port: match[4],
        path: match[5]
      };
    }
    exports2.urlParse = urlParse;
    function urlGenerate(aParsedUrl) {
      var url = "";
      if (aParsedUrl.scheme) {
        url += aParsedUrl.scheme + ":";
      }
      url += "//";
      if (aParsedUrl.auth) {
        url += aParsedUrl.auth + "@";
      }
      if (aParsedUrl.host) {
        url += aParsedUrl.host;
      }
      if (aParsedUrl.port) {
        url += ":" + aParsedUrl.port;
      }
      if (aParsedUrl.path) {
        url += aParsedUrl.path;
      }
      return url;
    }
    exports2.urlGenerate = urlGenerate;
    function normalize(aPath) {
      var path = aPath;
      var url = urlParse(aPath);
      if (url) {
        if (!url.path) {
          return aPath;
        }
        path = url.path;
      }
      var isAbsolute = exports2.isAbsolute(path);
      var parts = path.split(/\/+/);
      for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
        part = parts[i];
        if (part === ".") {
          parts.splice(i, 1);
        } else if (part === "..") {
          up++;
        } else if (up > 0) {
          if (part === "") {
            parts.splice(i + 1, up);
            up = 0;
          } else {
            parts.splice(i, 2);
            up--;
          }
        }
      }
      path = parts.join("/");
      if (path === "") {
        path = isAbsolute ? "/" : ".";
      }
      if (url) {
        url.path = path;
        return urlGenerate(url);
      }
      return path;
    }
    exports2.normalize = normalize;
    function join(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      if (aPath === "") {
        aPath = ".";
      }
      var aPathUrl = urlParse(aPath);
      var aRootUrl = urlParse(aRoot);
      if (aRootUrl) {
        aRoot = aRootUrl.path || "/";
      }
      if (aPathUrl && !aPathUrl.scheme) {
        if (aRootUrl) {
          aPathUrl.scheme = aRootUrl.scheme;
        }
        return urlGenerate(aPathUrl);
      }
      if (aPathUrl || aPath.match(dataUrlRegexp)) {
        return aPath;
      }
      if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
        aRootUrl.host = aPath;
        return urlGenerate(aRootUrl);
      }
      var joined = aPath.charAt(0) === "/" ? aPath : normalize(aRoot.replace(/\/+$/, "") + "/" + aPath);
      if (aRootUrl) {
        aRootUrl.path = joined;
        return urlGenerate(aRootUrl);
      }
      return joined;
    }
    exports2.join = join;
    exports2.isAbsolute = function(aPath) {
      return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
    };
    function relative(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      aRoot = aRoot.replace(/\/$/, "");
      var level = 0;
      while (aPath.indexOf(aRoot + "/") !== 0) {
        var index = aRoot.lastIndexOf("/");
        if (index < 0) {
          return aPath;
        }
        aRoot = aRoot.slice(0, index);
        if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
          return aPath;
        }
        ++level;
      }
      return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
    }
    exports2.relative = relative;
    var supportsNullProto = function() {
      var obj = /* @__PURE__ */ Object.create(null);
      return !("__proto__" in obj);
    }();
    function identity(s) {
      return s;
    }
    function toSetString(aStr) {
      if (isProtoString(aStr)) {
        return "$" + aStr;
      }
      return aStr;
    }
    exports2.toSetString = supportsNullProto ? identity : toSetString;
    function fromSetString(aStr) {
      if (isProtoString(aStr)) {
        return aStr.slice(1);
      }
      return aStr;
    }
    exports2.fromSetString = supportsNullProto ? identity : fromSetString;
    function isProtoString(s) {
      if (!s) {
        return false;
      }
      var length = s.length;
      if (length < 9) {
        return false;
      }
      if (s.charCodeAt(length - 1) !== 95 || s.charCodeAt(length - 2) !== 95 || s.charCodeAt(length - 3) !== 111 || s.charCodeAt(length - 4) !== 116 || s.charCodeAt(length - 5) !== 111 || s.charCodeAt(length - 6) !== 114 || s.charCodeAt(length - 7) !== 112 || s.charCodeAt(length - 8) !== 95 || s.charCodeAt(length - 9) !== 95) {
        return false;
      }
      for (var i = length - 10; i >= 0; i--) {
        if (s.charCodeAt(i) !== 36) {
          return false;
        }
      }
      return true;
    }
    function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
      var cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0 || onlyCompareOriginal) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports2.compareByOriginalPositions = compareByOriginalPositions;
    function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0 || onlyCompareGenerated) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports2.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
    function strcmp(aStr1, aStr2) {
      if (aStr1 === aStr2) {
        return 0;
      }
      if (aStr1 === null) {
        return 1;
      }
      if (aStr2 === null) {
        return -1;
      }
      if (aStr1 > aStr2) {
        return 1;
      }
      return -1;
    }
    function compareByGeneratedPositionsInflated(mappingA, mappingB) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports2.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
    function parseSourceMapInput(str) {
      return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
    }
    exports2.parseSourceMapInput = parseSourceMapInput;
    function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
      sourceURL = sourceURL || "";
      if (sourceRoot) {
        if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") {
          sourceRoot += "/";
        }
        sourceURL = sourceRoot + sourceURL;
      }
      if (sourceMapURL) {
        var parsed = urlParse(sourceMapURL);
        if (!parsed) {
          throw new Error("sourceMapURL could not be parsed");
        }
        if (parsed.path) {
          var index = parsed.path.lastIndexOf("/");
          if (index >= 0) {
            parsed.path = parsed.path.substring(0, index + 1);
          }
        }
        sourceURL = join(urlGenerate(parsed), sourceURL);
      }
      return normalize(sourceURL);
    }
    exports2.computeSourceURL = computeSourceURL;
  }
});

// node_modules/source-map/lib/array-set.js
var require_array_set = __commonJS({
  "node_modules/source-map/lib/array-set.js"(exports2) {
    "use strict";
    var util = require_util2();
    var has = Object.prototype.hasOwnProperty;
    var hasNativeMap = typeof Map !== "undefined";
    function ArraySet() {
      this._array = [];
      this._set = hasNativeMap ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
    }
    ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
      var set = new ArraySet();
      for (var i = 0, len = aArray.length; i < len; i++) {
        set.add(aArray[i], aAllowDuplicates);
      }
      return set;
    };
    ArraySet.prototype.size = function ArraySet_size() {
      return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
    };
    ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
      var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
      var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
      var idx = this._array.length;
      if (!isDuplicate || aAllowDuplicates) {
        this._array.push(aStr);
      }
      if (!isDuplicate) {
        if (hasNativeMap) {
          this._set.set(aStr, idx);
        } else {
          this._set[sStr] = idx;
        }
      }
    };
    ArraySet.prototype.has = function ArraySet_has(aStr) {
      if (hasNativeMap) {
        return this._set.has(aStr);
      } else {
        var sStr = util.toSetString(aStr);
        return has.call(this._set, sStr);
      }
    };
    ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
      if (hasNativeMap) {
        var idx = this._set.get(aStr);
        if (idx >= 0) {
          return idx;
        }
      } else {
        var sStr = util.toSetString(aStr);
        if (has.call(this._set, sStr)) {
          return this._set[sStr];
        }
      }
      throw new Error('"' + aStr + '" is not in the set.');
    };
    ArraySet.prototype.at = function ArraySet_at(aIdx) {
      if (aIdx >= 0 && aIdx < this._array.length) {
        return this._array[aIdx];
      }
      throw new Error("No element indexed by " + aIdx);
    };
    ArraySet.prototype.toArray = function ArraySet_toArray() {
      return this._array.slice();
    };
    exports2.ArraySet = ArraySet;
  }
});

// node_modules/source-map/lib/mapping-list.js
var require_mapping_list = __commonJS({
  "node_modules/source-map/lib/mapping-list.js"(exports2) {
    "use strict";
    var util = require_util2();
    function generatedPositionAfter(mappingA, mappingB) {
      var lineA = mappingA.generatedLine;
      var lineB = mappingB.generatedLine;
      var columnA = mappingA.generatedColumn;
      var columnB = mappingB.generatedColumn;
      return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
    }
    function MappingList() {
      this._array = [];
      this._sorted = true;
      this._last = { generatedLine: -1, generatedColumn: 0 };
    }
    MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
      this._array.forEach(aCallback, aThisArg);
    };
    MappingList.prototype.add = function MappingList_add(aMapping) {
      if (generatedPositionAfter(this._last, aMapping)) {
        this._last = aMapping;
        this._array.push(aMapping);
      } else {
        this._sorted = false;
        this._array.push(aMapping);
      }
    };
    MappingList.prototype.toArray = function MappingList_toArray() {
      if (!this._sorted) {
        this._array.sort(util.compareByGeneratedPositionsInflated);
        this._sorted = true;
      }
      return this._array;
    };
    exports2.MappingList = MappingList;
  }
});

// node_modules/source-map/lib/source-map-generator.js
var require_source_map_generator = __commonJS({
  "node_modules/source-map/lib/source-map-generator.js"(exports2) {
    "use strict";
    var base64VLQ = require_base64_vlq();
    var util = require_util2();
    var ArraySet = require_array_set().ArraySet;
    var MappingList = require_mapping_list().MappingList;
    function SourceMapGenerator(aArgs) {
      if (!aArgs) {
        aArgs = {};
      }
      this._file = util.getArg(aArgs, "file", null);
      this._sourceRoot = util.getArg(aArgs, "sourceRoot", null);
      this._skipValidation = util.getArg(aArgs, "skipValidation", false);
      this._sources = new ArraySet();
      this._names = new ArraySet();
      this._mappings = new MappingList();
      this._sourcesContents = null;
    }
    SourceMapGenerator.prototype._version = 3;
    SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
      var sourceRoot = aSourceMapConsumer.sourceRoot;
      var generator = new SourceMapGenerator({
        file: aSourceMapConsumer.file,
        sourceRoot
      });
      aSourceMapConsumer.eachMapping(function(mapping) {
        var newMapping = {
          generated: {
            line: mapping.generatedLine,
            column: mapping.generatedColumn
          }
        };
        if (mapping.source != null) {
          newMapping.source = mapping.source;
          if (sourceRoot != null) {
            newMapping.source = util.relative(sourceRoot, newMapping.source);
          }
          newMapping.original = {
            line: mapping.originalLine,
            column: mapping.originalColumn
          };
          if (mapping.name != null) {
            newMapping.name = mapping.name;
          }
        }
        generator.addMapping(newMapping);
      });
      aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var sourceRelative = sourceFile;
        if (sourceRoot !== null) {
          sourceRelative = util.relative(sourceRoot, sourceFile);
        }
        if (!generator._sources.has(sourceRelative)) {
          generator._sources.add(sourceRelative);
        }
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          generator.setSourceContent(sourceFile, content);
        }
      });
      return generator;
    };
    SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
      var generated = util.getArg(aArgs, "generated");
      var original = util.getArg(aArgs, "original", null);
      var source = util.getArg(aArgs, "source", null);
      var name = util.getArg(aArgs, "name", null);
      if (!this._skipValidation) {
        this._validateMapping(generated, original, source, name);
      }
      if (source != null) {
        source = String(source);
        if (!this._sources.has(source)) {
          this._sources.add(source);
        }
      }
      if (name != null) {
        name = String(name);
        if (!this._names.has(name)) {
          this._names.add(name);
        }
      }
      this._mappings.add({
        generatedLine: generated.line,
        generatedColumn: generated.column,
        originalLine: original != null && original.line,
        originalColumn: original != null && original.column,
        source,
        name
      });
    };
    SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
      var source = aSourceFile;
      if (this._sourceRoot != null) {
        source = util.relative(this._sourceRoot, source);
      }
      if (aSourceContent != null) {
        if (!this._sourcesContents) {
          this._sourcesContents = /* @__PURE__ */ Object.create(null);
        }
        this._sourcesContents[util.toSetString(source)] = aSourceContent;
      } else if (this._sourcesContents) {
        delete this._sourcesContents[util.toSetString(source)];
        if (Object.keys(this._sourcesContents).length === 0) {
          this._sourcesContents = null;
        }
      }
    };
    SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
      var sourceFile = aSourceFile;
      if (aSourceFile == null) {
        if (aSourceMapConsumer.file == null) {
          throw new Error(
            `SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`
          );
        }
        sourceFile = aSourceMapConsumer.file;
      }
      var sourceRoot = this._sourceRoot;
      if (sourceRoot != null) {
        sourceFile = util.relative(sourceRoot, sourceFile);
      }
      var newSources = new ArraySet();
      var newNames = new ArraySet();
      this._mappings.unsortedForEach(function(mapping) {
        if (mapping.source === sourceFile && mapping.originalLine != null) {
          var original = aSourceMapConsumer.originalPositionFor({
            line: mapping.originalLine,
            column: mapping.originalColumn
          });
          if (original.source != null) {
            mapping.source = original.source;
            if (aSourceMapPath != null) {
              mapping.source = util.join(aSourceMapPath, mapping.source);
            }
            if (sourceRoot != null) {
              mapping.source = util.relative(sourceRoot, mapping.source);
            }
            mapping.originalLine = original.line;
            mapping.originalColumn = original.column;
            if (original.name != null) {
              mapping.name = original.name;
            }
          }
        }
        var source = mapping.source;
        if (source != null && !newSources.has(source)) {
          newSources.add(source);
        }
        var name = mapping.name;
        if (name != null && !newNames.has(name)) {
          newNames.add(name);
        }
      }, this);
      this._sources = newSources;
      this._names = newNames;
      aSourceMapConsumer.sources.forEach(function(sourceFile2) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile2);
        if (content != null) {
          if (aSourceMapPath != null) {
            sourceFile2 = util.join(aSourceMapPath, sourceFile2);
          }
          if (sourceRoot != null) {
            sourceFile2 = util.relative(sourceRoot, sourceFile2);
          }
          this.setSourceContent(sourceFile2, content);
        }
      }, this);
    };
    SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
      if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
        throw new Error(
          "original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values."
        );
      }
      if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
        return;
      } else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
        return;
      } else {
        throw new Error("Invalid mapping: " + JSON.stringify({
          generated: aGenerated,
          source: aSource,
          original: aOriginal,
          name: aName
        }));
      }
    };
    SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
      var previousGeneratedColumn = 0;
      var previousGeneratedLine = 1;
      var previousOriginalColumn = 0;
      var previousOriginalLine = 0;
      var previousName = 0;
      var previousSource = 0;
      var result = "";
      var next;
      var mapping;
      var nameIdx;
      var sourceIdx;
      var mappings = this._mappings.toArray();
      for (var i = 0, len = mappings.length; i < len; i++) {
        mapping = mappings[i];
        next = "";
        if (mapping.generatedLine !== previousGeneratedLine) {
          previousGeneratedColumn = 0;
          while (mapping.generatedLine !== previousGeneratedLine) {
            next += ";";
            previousGeneratedLine++;
          }
        } else {
          if (i > 0) {
            if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
              continue;
            }
            next += ",";
          }
        }
        next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
        previousGeneratedColumn = mapping.generatedColumn;
        if (mapping.source != null) {
          sourceIdx = this._sources.indexOf(mapping.source);
          next += base64VLQ.encode(sourceIdx - previousSource);
          previousSource = sourceIdx;
          next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
          previousOriginalLine = mapping.originalLine - 1;
          next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
          previousOriginalColumn = mapping.originalColumn;
          if (mapping.name != null) {
            nameIdx = this._names.indexOf(mapping.name);
            next += base64VLQ.encode(nameIdx - previousName);
            previousName = nameIdx;
          }
        }
        result += next;
      }
      return result;
    };
    SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
      return aSources.map(function(source) {
        if (!this._sourcesContents) {
          return null;
        }
        if (aSourceRoot != null) {
          source = util.relative(aSourceRoot, source);
        }
        var key = util.toSetString(source);
        return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
      }, this);
    };
    SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
      var map = {
        version: this._version,
        sources: this._sources.toArray(),
        names: this._names.toArray(),
        mappings: this._serializeMappings()
      };
      if (this._file != null) {
        map.file = this._file;
      }
      if (this._sourceRoot != null) {
        map.sourceRoot = this._sourceRoot;
      }
      if (this._sourcesContents) {
        map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
      }
      return map;
    };
    SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
      return JSON.stringify(this.toJSON());
    };
    exports2.SourceMapGenerator = SourceMapGenerator;
  }
});

// node_modules/source-map/lib/binary-search.js
var require_binary_search = __commonJS({
  "node_modules/source-map/lib/binary-search.js"(exports2) {
    "use strict";
    exports2.GREATEST_LOWER_BOUND = 1;
    exports2.LEAST_UPPER_BOUND = 2;
    function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
      var mid = Math.floor((aHigh - aLow) / 2) + aLow;
      var cmp = aCompare(aNeedle, aHaystack[mid], true);
      if (cmp === 0) {
        return mid;
      } else if (cmp > 0) {
        if (aHigh - mid > 1) {
          return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
        }
        if (aBias == exports2.LEAST_UPPER_BOUND) {
          return aHigh < aHaystack.length ? aHigh : -1;
        } else {
          return mid;
        }
      } else {
        if (mid - aLow > 1) {
          return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
        }
        if (aBias == exports2.LEAST_UPPER_BOUND) {
          return mid;
        } else {
          return aLow < 0 ? -1 : aLow;
        }
      }
    }
    exports2.search = function search(aNeedle, aHaystack, aCompare, aBias) {
      if (aHaystack.length === 0) {
        return -1;
      }
      var index = recursiveSearch(
        -1,
        aHaystack.length,
        aNeedle,
        aHaystack,
        aCompare,
        aBias || exports2.GREATEST_LOWER_BOUND
      );
      if (index < 0) {
        return -1;
      }
      while (index - 1 >= 0) {
        if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
          break;
        }
        --index;
      }
      return index;
    };
  }
});

// node_modules/source-map/lib/quick-sort.js
var require_quick_sort = __commonJS({
  "node_modules/source-map/lib/quick-sort.js"(exports2) {
    "use strict";
    function swap(ary, x, y) {
      var temp = ary[x];
      ary[x] = ary[y];
      ary[y] = temp;
    }
    function randomIntInRange(low, high) {
      return Math.round(low + Math.random() * (high - low));
    }
    function doQuickSort(ary, comparator, p, r) {
      if (p < r) {
        var pivotIndex = randomIntInRange(p, r);
        var i = p - 1;
        swap(ary, pivotIndex, r);
        var pivot = ary[r];
        for (var j = p; j < r; j++) {
          if (comparator(ary[j], pivot) <= 0) {
            i += 1;
            swap(ary, i, j);
          }
        }
        swap(ary, i + 1, j);
        var q = i + 1;
        doQuickSort(ary, comparator, p, q - 1);
        doQuickSort(ary, comparator, q + 1, r);
      }
    }
    exports2.quickSort = function(ary, comparator) {
      doQuickSort(ary, comparator, 0, ary.length - 1);
    };
  }
});

// node_modules/source-map/lib/source-map-consumer.js
var require_source_map_consumer = __commonJS({
  "node_modules/source-map/lib/source-map-consumer.js"(exports2) {
    "use strict";
    var util = require_util2();
    var binarySearch = require_binary_search();
    var ArraySet = require_array_set().ArraySet;
    var base64VLQ = require_base64_vlq();
    var quickSort = require_quick_sort().quickSort;
    function SourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = util.parseSourceMapInput(aSourceMap);
      }
      return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
    }
    SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
      return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
    };
    SourceMapConsumer.prototype._version = 3;
    SourceMapConsumer.prototype.__generatedMappings = null;
    Object.defineProperty(SourceMapConsumer.prototype, "_generatedMappings", {
      configurable: true,
      enumerable: true,
      get: function() {
        if (!this.__generatedMappings) {
          this._parseMappings(this._mappings, this.sourceRoot);
        }
        return this.__generatedMappings;
      }
    });
    SourceMapConsumer.prototype.__originalMappings = null;
    Object.defineProperty(SourceMapConsumer.prototype, "_originalMappings", {
      configurable: true,
      enumerable: true,
      get: function() {
        if (!this.__originalMappings) {
          this._parseMappings(this._mappings, this.sourceRoot);
        }
        return this.__originalMappings;
      }
    });
    SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
      var c = aStr.charAt(index);
      return c === ";" || c === ",";
    };
    SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      throw new Error("Subclasses must implement _parseMappings");
    };
    SourceMapConsumer.GENERATED_ORDER = 1;
    SourceMapConsumer.ORIGINAL_ORDER = 2;
    SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
    SourceMapConsumer.LEAST_UPPER_BOUND = 2;
    SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
      var context = aContext || null;
      var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
      var mappings;
      switch (order) {
        case SourceMapConsumer.GENERATED_ORDER:
          mappings = this._generatedMappings;
          break;
        case SourceMapConsumer.ORIGINAL_ORDER:
          mappings = this._originalMappings;
          break;
        default:
          throw new Error("Unknown order of iteration.");
      }
      var sourceRoot = this.sourceRoot;
      mappings.map(function(mapping) {
        var source = mapping.source === null ? null : this._sources.at(mapping.source);
        source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
        return {
          source,
          generatedLine: mapping.generatedLine,
          generatedColumn: mapping.generatedColumn,
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: mapping.name === null ? null : this._names.at(mapping.name)
        };
      }, this).forEach(aCallback, context);
    };
    SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
      var line = util.getArg(aArgs, "line");
      var needle = {
        source: util.getArg(aArgs, "source"),
        originalLine: line,
        originalColumn: util.getArg(aArgs, "column", 0)
      };
      needle.source = this._findSourceIndex(needle.source);
      if (needle.source < 0) {
        return [];
      }
      var mappings = [];
      var index = this._findMapping(
        needle,
        this._originalMappings,
        "originalLine",
        "originalColumn",
        util.compareByOriginalPositions,
        binarySearch.LEAST_UPPER_BOUND
      );
      if (index >= 0) {
        var mapping = this._originalMappings[index];
        if (aArgs.column === void 0) {
          var originalLine = mapping.originalLine;
          while (mapping && mapping.originalLine === originalLine) {
            mappings.push({
              line: util.getArg(mapping, "generatedLine", null),
              column: util.getArg(mapping, "generatedColumn", null),
              lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
            });
            mapping = this._originalMappings[++index];
          }
        } else {
          var originalColumn = mapping.originalColumn;
          while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
            mappings.push({
              line: util.getArg(mapping, "generatedLine", null),
              column: util.getArg(mapping, "generatedColumn", null),
              lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
            });
            mapping = this._originalMappings[++index];
          }
        }
      }
      return mappings;
    };
    exports2.SourceMapConsumer = SourceMapConsumer;
    function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = util.parseSourceMapInput(aSourceMap);
      }
      var version = util.getArg(sourceMap, "version");
      var sources = util.getArg(sourceMap, "sources");
      var names = util.getArg(sourceMap, "names", []);
      var sourceRoot = util.getArg(sourceMap, "sourceRoot", null);
      var sourcesContent = util.getArg(sourceMap, "sourcesContent", null);
      var mappings = util.getArg(sourceMap, "mappings");
      var file = util.getArg(sourceMap, "file", null);
      if (version != this._version) {
        throw new Error("Unsupported version: " + version);
      }
      if (sourceRoot) {
        sourceRoot = util.normalize(sourceRoot);
      }
      sources = sources.map(String).map(util.normalize).map(function(source) {
        return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;
      });
      this._names = ArraySet.fromArray(names.map(String), true);
      this._sources = ArraySet.fromArray(sources, true);
      this._absoluteSources = this._sources.toArray().map(function(s) {
        return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
      });
      this.sourceRoot = sourceRoot;
      this.sourcesContent = sourcesContent;
      this._mappings = mappings;
      this._sourceMapURL = aSourceMapURL;
      this.file = file;
    }
    BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
    BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
    BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
      var relativeSource = aSource;
      if (this.sourceRoot != null) {
        relativeSource = util.relative(this.sourceRoot, relativeSource);
      }
      if (this._sources.has(relativeSource)) {
        return this._sources.indexOf(relativeSource);
      }
      var i;
      for (i = 0; i < this._absoluteSources.length; ++i) {
        if (this._absoluteSources[i] == aSource) {
          return i;
        }
      }
      return -1;
    };
    BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
      var smc = Object.create(BasicSourceMapConsumer.prototype);
      var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
      var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
      smc.sourceRoot = aSourceMap._sourceRoot;
      smc.sourcesContent = aSourceMap._generateSourcesContent(
        smc._sources.toArray(),
        smc.sourceRoot
      );
      smc.file = aSourceMap._file;
      smc._sourceMapURL = aSourceMapURL;
      smc._absoluteSources = smc._sources.toArray().map(function(s) {
        return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
      });
      var generatedMappings = aSourceMap._mappings.toArray().slice();
      var destGeneratedMappings = smc.__generatedMappings = [];
      var destOriginalMappings = smc.__originalMappings = [];
      for (var i = 0, length = generatedMappings.length; i < length; i++) {
        var srcMapping = generatedMappings[i];
        var destMapping = new Mapping();
        destMapping.generatedLine = srcMapping.generatedLine;
        destMapping.generatedColumn = srcMapping.generatedColumn;
        if (srcMapping.source) {
          destMapping.source = sources.indexOf(srcMapping.source);
          destMapping.originalLine = srcMapping.originalLine;
          destMapping.originalColumn = srcMapping.originalColumn;
          if (srcMapping.name) {
            destMapping.name = names.indexOf(srcMapping.name);
          }
          destOriginalMappings.push(destMapping);
        }
        destGeneratedMappings.push(destMapping);
      }
      quickSort(smc.__originalMappings, util.compareByOriginalPositions);
      return smc;
    };
    BasicSourceMapConsumer.prototype._version = 3;
    Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", {
      get: function() {
        return this._absoluteSources.slice();
      }
    });
    function Mapping() {
      this.generatedLine = 0;
      this.generatedColumn = 0;
      this.source = null;
      this.originalLine = null;
      this.originalColumn = null;
      this.name = null;
    }
    BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      var generatedLine = 1;
      var previousGeneratedColumn = 0;
      var previousOriginalLine = 0;
      var previousOriginalColumn = 0;
      var previousSource = 0;
      var previousName = 0;
      var length = aStr.length;
      var index = 0;
      var cachedSegments = {};
      var temp = {};
      var originalMappings = [];
      var generatedMappings = [];
      var mapping, str, segment, end, value2;
      while (index < length) {
        if (aStr.charAt(index) === ";") {
          generatedLine++;
          index++;
          previousGeneratedColumn = 0;
        } else if (aStr.charAt(index) === ",") {
          index++;
        } else {
          mapping = new Mapping();
          mapping.generatedLine = generatedLine;
          for (end = index; end < length; end++) {
            if (this._charIsMappingSeparator(aStr, end)) {
              break;
            }
          }
          str = aStr.slice(index, end);
          segment = cachedSegments[str];
          if (segment) {
            index += str.length;
          } else {
            segment = [];
            while (index < end) {
              base64VLQ.decode(aStr, index, temp);
              value2 = temp.value;
              index = temp.rest;
              segment.push(value2);
            }
            if (segment.length === 2) {
              throw new Error("Found a source, but no line and column");
            }
            if (segment.length === 3) {
              throw new Error("Found a source and line, but no column");
            }
            cachedSegments[str] = segment;
          }
          mapping.generatedColumn = previousGeneratedColumn + segment[0];
          previousGeneratedColumn = mapping.generatedColumn;
          if (segment.length > 1) {
            mapping.source = previousSource + segment[1];
            previousSource += segment[1];
            mapping.originalLine = previousOriginalLine + segment[2];
            previousOriginalLine = mapping.originalLine;
            mapping.originalLine += 1;
            mapping.originalColumn = previousOriginalColumn + segment[3];
            previousOriginalColumn = mapping.originalColumn;
            if (segment.length > 4) {
              mapping.name = previousName + segment[4];
              previousName += segment[4];
            }
          }
          generatedMappings.push(mapping);
          if (typeof mapping.originalLine === "number") {
            originalMappings.push(mapping);
          }
        }
      }
      quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
      this.__generatedMappings = generatedMappings;
      quickSort(originalMappings, util.compareByOriginalPositions);
      this.__originalMappings = originalMappings;
    };
    BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
      if (aNeedle[aLineName] <= 0) {
        throw new TypeError("Line must be greater than or equal to 1, got " + aNeedle[aLineName]);
      }
      if (aNeedle[aColumnName] < 0) {
        throw new TypeError("Column must be greater than or equal to 0, got " + aNeedle[aColumnName]);
      }
      return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
    };
    BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
      for (var index = 0; index < this._generatedMappings.length; ++index) {
        var mapping = this._generatedMappings[index];
        if (index + 1 < this._generatedMappings.length) {
          var nextMapping = this._generatedMappings[index + 1];
          if (mapping.generatedLine === nextMapping.generatedLine) {
            mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
            continue;
          }
        }
        mapping.lastGeneratedColumn = Infinity;
      }
    };
    BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, "line"),
        generatedColumn: util.getArg(aArgs, "column")
      };
      var index = this._findMapping(
        needle,
        this._generatedMappings,
        "generatedLine",
        "generatedColumn",
        util.compareByGeneratedPositionsDeflated,
        util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND)
      );
      if (index >= 0) {
        var mapping = this._generatedMappings[index];
        if (mapping.generatedLine === needle.generatedLine) {
          var source = util.getArg(mapping, "source", null);
          if (source !== null) {
            source = this._sources.at(source);
            source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
          }
          var name = util.getArg(mapping, "name", null);
          if (name !== null) {
            name = this._names.at(name);
          }
          return {
            source,
            line: util.getArg(mapping, "originalLine", null),
            column: util.getArg(mapping, "originalColumn", null),
            name
          };
        }
      }
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    };
    BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
      if (!this.sourcesContent) {
        return false;
      }
      return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {
        return sc == null;
      });
    };
    BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      if (!this.sourcesContent) {
        return null;
      }
      var index = this._findSourceIndex(aSource);
      if (index >= 0) {
        return this.sourcesContent[index];
      }
      var relativeSource = aSource;
      if (this.sourceRoot != null) {
        relativeSource = util.relative(this.sourceRoot, relativeSource);
      }
      var url;
      if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {
        var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
        if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
          return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
        }
        if ((!url.path || url.path == "/") && this._sources.has("/" + relativeSource)) {
          return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
        }
      }
      if (nullOnMissing) {
        return null;
      } else {
        throw new Error('"' + relativeSource + '" is not in the SourceMap.');
      }
    };
    BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
      var source = util.getArg(aArgs, "source");
      source = this._findSourceIndex(source);
      if (source < 0) {
        return {
          line: null,
          column: null,
          lastColumn: null
        };
      }
      var needle = {
        source,
        originalLine: util.getArg(aArgs, "line"),
        originalColumn: util.getArg(aArgs, "column")
      };
      var index = this._findMapping(
        needle,
        this._originalMappings,
        "originalLine",
        "originalColumn",
        util.compareByOriginalPositions,
        util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND)
      );
      if (index >= 0) {
        var mapping = this._originalMappings[index];
        if (mapping.source === needle.source) {
          return {
            line: util.getArg(mapping, "generatedLine", null),
            column: util.getArg(mapping, "generatedColumn", null),
            lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
          };
        }
      }
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    };
    exports2.BasicSourceMapConsumer = BasicSourceMapConsumer;
    function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = util.parseSourceMapInput(aSourceMap);
      }
      var version = util.getArg(sourceMap, "version");
      var sections = util.getArg(sourceMap, "sections");
      if (version != this._version) {
        throw new Error("Unsupported version: " + version);
      }
      this._sources = new ArraySet();
      this._names = new ArraySet();
      var lastOffset = {
        line: -1,
        column: 0
      };
      this._sections = sections.map(function(s) {
        if (s.url) {
          throw new Error("Support for url field in sections not implemented.");
        }
        var offset = util.getArg(s, "offset");
        var offsetLine = util.getArg(offset, "line");
        var offsetColumn = util.getArg(offset, "column");
        if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
          throw new Error("Section offsets must be ordered and non-overlapping.");
        }
        lastOffset = offset;
        return {
          generatedOffset: {
            // The offset fields are 0-based, but we use 1-based indices when
            // encoding/decoding from VLQ.
            generatedLine: offsetLine + 1,
            generatedColumn: offsetColumn + 1
          },
          consumer: new SourceMapConsumer(util.getArg(s, "map"), aSourceMapURL)
        };
      });
    }
    IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
    IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
    IndexedSourceMapConsumer.prototype._version = 3;
    Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", {
      get: function() {
        var sources = [];
        for (var i = 0; i < this._sections.length; i++) {
          for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
            sources.push(this._sections[i].consumer.sources[j]);
          }
        }
        return sources;
      }
    });
    IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, "line"),
        generatedColumn: util.getArg(aArgs, "column")
      };
      var sectionIndex = binarySearch.search(
        needle,
        this._sections,
        function(needle2, section2) {
          var cmp = needle2.generatedLine - section2.generatedOffset.generatedLine;
          if (cmp) {
            return cmp;
          }
          return needle2.generatedColumn - section2.generatedOffset.generatedColumn;
        }
      );
      var section = this._sections[sectionIndex];
      if (!section) {
        return {
          source: null,
          line: null,
          column: null,
          name: null
        };
      }
      return section.consumer.originalPositionFor({
        line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
        column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
        bias: aArgs.bias
      });
    };
    IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
      return this._sections.every(function(s) {
        return s.consumer.hasContentsOfAllSources();
      });
    };
    IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        var content = section.consumer.sourceContentFor(aSource, true);
        if (content) {
          return content;
        }
      }
      if (nullOnMissing) {
        return null;
      } else {
        throw new Error('"' + aSource + '" is not in the SourceMap.');
      }
    };
    IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        if (section.consumer._findSourceIndex(util.getArg(aArgs, "source")) === -1) {
          continue;
        }
        var generatedPosition = section.consumer.generatedPositionFor(aArgs);
        if (generatedPosition) {
          var ret = {
            line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
            column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
          };
          return ret;
        }
      }
      return {
        line: null,
        column: null
      };
    };
    IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      this.__generatedMappings = [];
      this.__originalMappings = [];
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        var sectionMappings = section.consumer._generatedMappings;
        for (var j = 0; j < sectionMappings.length; j++) {
          var mapping = sectionMappings[j];
          var source = section.consumer._sources.at(mapping.source);
          source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
          this._sources.add(source);
          source = this._sources.indexOf(source);
          var name = null;
          if (mapping.name) {
            name = section.consumer._names.at(mapping.name);
            this._names.add(name);
            name = this._names.indexOf(name);
          }
          var adjustedMapping = {
            source,
            generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
            generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
            originalLine: mapping.originalLine,
            originalColumn: mapping.originalColumn,
            name
          };
          this.__generatedMappings.push(adjustedMapping);
          if (typeof adjustedMapping.originalLine === "number") {
            this.__originalMappings.push(adjustedMapping);
          }
        }
      }
      quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
      quickSort(this.__originalMappings, util.compareByOriginalPositions);
    };
    exports2.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
  }
});

// node_modules/source-map/lib/source-node.js
var require_source_node = __commonJS({
  "node_modules/source-map/lib/source-node.js"(exports2) {
    "use strict";
    var SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
    var util = require_util2();
    var REGEX_NEWLINE = /(\r?\n)/;
    var NEWLINE_CODE = 10;
    var isSourceNode = "$$$isSourceNode$$$";
    function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
      this.children = [];
      this.sourceContents = {};
      this.line = aLine == null ? null : aLine;
      this.column = aColumn == null ? null : aColumn;
      this.source = aSource == null ? null : aSource;
      this.name = aName == null ? null : aName;
      this[isSourceNode] = true;
      if (aChunks != null) this.add(aChunks);
    }
    SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
      var node = new SourceNode();
      var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
      var remainingLinesIndex = 0;
      var shiftNextLine = function() {
        var lineContents = getNextLine();
        var newLine = getNextLine() || "";
        return lineContents + newLine;
        function getNextLine() {
          return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : void 0;
        }
      };
      var lastGeneratedLine = 1, lastGeneratedColumn = 0;
      var lastMapping = null;
      aSourceMapConsumer.eachMapping(function(mapping) {
        if (lastMapping !== null) {
          if (lastGeneratedLine < mapping.generatedLine) {
            addMappingWithCode(lastMapping, shiftNextLine());
            lastGeneratedLine++;
            lastGeneratedColumn = 0;
          } else {
            var nextLine = remainingLines[remainingLinesIndex] || "";
            var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
            remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
            addMappingWithCode(lastMapping, code);
            lastMapping = mapping;
            return;
          }
        }
        while (lastGeneratedLine < mapping.generatedLine) {
          node.add(shiftNextLine());
          lastGeneratedLine++;
        }
        if (lastGeneratedColumn < mapping.generatedColumn) {
          var nextLine = remainingLines[remainingLinesIndex] || "";
          node.add(nextLine.substr(0, mapping.generatedColumn));
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
        }
        lastMapping = mapping;
      }, this);
      if (remainingLinesIndex < remainingLines.length) {
        if (lastMapping) {
          addMappingWithCode(lastMapping, shiftNextLine());
        }
        node.add(remainingLines.splice(remainingLinesIndex).join(""));
      }
      aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          if (aRelativePath != null) {
            sourceFile = util.join(aRelativePath, sourceFile);
          }
          node.setSourceContent(sourceFile, content);
        }
      });
      return node;
      function addMappingWithCode(mapping, code) {
        if (mapping === null || mapping.source === void 0) {
          node.add(code);
        } else {
          var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
          node.add(new SourceNode(
            mapping.originalLine,
            mapping.originalColumn,
            source,
            code,
            mapping.name
          ));
        }
      }
    };
    SourceNode.prototype.add = function SourceNode_add(aChunk) {
      if (Array.isArray(aChunk)) {
        aChunk.forEach(function(chunk) {
          this.add(chunk);
        }, this);
      } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
        if (aChunk) {
          this.children.push(aChunk);
        }
      } else {
        throw new TypeError(
          "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
        );
      }
      return this;
    };
    SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
      if (Array.isArray(aChunk)) {
        for (var i = aChunk.length - 1; i >= 0; i--) {
          this.prepend(aChunk[i]);
        }
      } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
        this.children.unshift(aChunk);
      } else {
        throw new TypeError(
          "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
        );
      }
      return this;
    };
    SourceNode.prototype.walk = function SourceNode_walk(aFn) {
      var chunk;
      for (var i = 0, len = this.children.length; i < len; i++) {
        chunk = this.children[i];
        if (chunk[isSourceNode]) {
          chunk.walk(aFn);
        } else {
          if (chunk !== "") {
            aFn(chunk, {
              source: this.source,
              line: this.line,
              column: this.column,
              name: this.name
            });
          }
        }
      }
    };
    SourceNode.prototype.join = function SourceNode_join(aSep) {
      var newChildren;
      var i;
      var len = this.children.length;
      if (len > 0) {
        newChildren = [];
        for (i = 0; i < len - 1; i++) {
          newChildren.push(this.children[i]);
          newChildren.push(aSep);
        }
        newChildren.push(this.children[i]);
        this.children = newChildren;
      }
      return this;
    };
    SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
      var lastChild = this.children[this.children.length - 1];
      if (lastChild[isSourceNode]) {
        lastChild.replaceRight(aPattern, aReplacement);
      } else if (typeof lastChild === "string") {
        this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
      } else {
        this.children.push("".replace(aPattern, aReplacement));
      }
      return this;
    };
    SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
      this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
    };
    SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
      for (var i = 0, len = this.children.length; i < len; i++) {
        if (this.children[i][isSourceNode]) {
          this.children[i].walkSourceContents(aFn);
        }
      }
      var sources = Object.keys(this.sourceContents);
      for (var i = 0, len = sources.length; i < len; i++) {
        aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
      }
    };
    SourceNode.prototype.toString = function SourceNode_toString() {
      var str = "";
      this.walk(function(chunk) {
        str += chunk;
      });
      return str;
    };
    SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
      var generated = {
        code: "",
        line: 1,
        column: 0
      };
      var map = new SourceMapGenerator(aArgs);
      var sourceMappingActive = false;
      var lastOriginalSource = null;
      var lastOriginalLine = null;
      var lastOriginalColumn = null;
      var lastOriginalName = null;
      this.walk(function(chunk, original) {
        generated.code += chunk;
        if (original.source !== null && original.line !== null && original.column !== null) {
          if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
            map.addMapping({
              source: original.source,
              original: {
                line: original.line,
                column: original.column
              },
              generated: {
                line: generated.line,
                column: generated.column
              },
              name: original.name
            });
          }
          lastOriginalSource = original.source;
          lastOriginalLine = original.line;
          lastOriginalColumn = original.column;
          lastOriginalName = original.name;
          sourceMappingActive = true;
        } else if (sourceMappingActive) {
          map.addMapping({
            generated: {
              line: generated.line,
              column: generated.column
            }
          });
          lastOriginalSource = null;
          sourceMappingActive = false;
        }
        for (var idx = 0, length = chunk.length; idx < length; idx++) {
          if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
            generated.line++;
            generated.column = 0;
            if (idx + 1 === length) {
              lastOriginalSource = null;
              sourceMappingActive = false;
            } else if (sourceMappingActive) {
              map.addMapping({
                source: original.source,
                original: {
                  line: original.line,
                  column: original.column
                },
                generated: {
                  line: generated.line,
                  column: generated.column
                },
                name: original.name
              });
            }
          } else {
            generated.column++;
          }
        }
      });
      this.walkSourceContents(function(sourceFile, sourceContent) {
        map.setSourceContent(sourceFile, sourceContent);
      });
      return { code: generated.code, map };
    };
    exports2.SourceNode = SourceNode;
  }
});

// node_modules/source-map/source-map.js
var require_source_map = __commonJS({
  "node_modules/source-map/source-map.js"(exports2) {
    "use strict";
    exports2.SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
    exports2.SourceMapConsumer = require_source_map_consumer().SourceMapConsumer;
    exports2.SourceNode = require_source_node().SourceNode;
  }
});

// node_modules/buffer-from/index.js
var require_buffer_from = __commonJS({
  "node_modules/buffer-from/index.js"(exports2, module2) {
    "use strict";
    var toString = Object.prototype.toString;
    var isModern = typeof Buffer !== "undefined" && typeof Buffer.alloc === "function" && typeof Buffer.allocUnsafe === "function" && typeof Buffer.from === "function";
    function isArrayBuffer(input) {
      return toString.call(input).slice(8, -1) === "ArrayBuffer";
    }
    function fromArrayBuffer(obj, byteOffset, length) {
      byteOffset >>>= 0;
      var maxLength = obj.byteLength - byteOffset;
      if (maxLength < 0) {
        throw new RangeError("'offset' is out of bounds");
      }
      if (length === void 0) {
        length = maxLength;
      } else {
        length >>>= 0;
        if (length > maxLength) {
          throw new RangeError("'length' is out of bounds");
        }
      }
      return isModern ? Buffer.from(obj.slice(byteOffset, byteOffset + length)) : new Buffer(new Uint8Array(obj.slice(byteOffset, byteOffset + length)));
    }
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer.isEncoding(encoding)) {
        throw new TypeError('"encoding" must be a valid string encoding');
      }
      return isModern ? Buffer.from(string, encoding) : new Buffer(string, encoding);
    }
    function bufferFrom(value2, encodingOrOffset, length) {
      if (typeof value2 === "number") {
        throw new TypeError('"value" argument must not be a number');
      }
      if (isArrayBuffer(value2)) {
        return fromArrayBuffer(value2, encodingOrOffset, length);
      }
      if (typeof value2 === "string") {
        return fromString(value2, encodingOrOffset);
      }
      return isModern ? Buffer.from(value2) : new Buffer(value2);
    }
    module2.exports = bufferFrom;
  }
});

// node_modules/source-map-support/source-map-support.js
var require_source_map_support = __commonJS({
  "node_modules/source-map-support/source-map-support.js"(exports2, module2) {
    "use strict";
    var SourceMapConsumer = require_source_map().SourceMapConsumer;
    var path = require("path");
    var fs;
    try {
      fs = require("fs");
      if (!fs.existsSync || !fs.readFileSync) {
        fs = null;
      }
    } catch (err) {
    }
    var bufferFrom = require_buffer_from();
    function dynamicRequire(mod, request) {
      return mod.require(request);
    }
    var errorFormatterInstalled = false;
    var uncaughtShimInstalled = false;
    var emptyCacheBetweenOperations = false;
    var environment = "auto";
    var fileContentsCache = {};
    var sourceMapCache = {};
    var reSourceMap = /^data:application\/json[^,]+base64,/;
    var retrieveFileHandlers = [];
    var retrieveMapHandlers = [];
    function isInBrowser() {
      if (environment === "browser")
        return true;
      if (environment === "node")
        return false;
      return typeof window !== "undefined" && typeof XMLHttpRequest === "function" && !(window.require && window.module && window.process && window.process.type === "renderer");
    }
    function hasGlobalProcessEventEmitter() {
      return typeof process === "object" && process !== null && typeof process.on === "function";
    }
    function globalProcessVersion() {
      if (typeof process === "object" && process !== null) {
        return process.version;
      } else {
        return "";
      }
    }
    function globalProcessStderr() {
      if (typeof process === "object" && process !== null) {
        return process.stderr;
      }
    }
    function globalProcessExit(code) {
      if (typeof process === "object" && process !== null && typeof process.exit === "function") {
        return process.exit(code);
      }
    }
    function handlerExec(list) {
      return function(arg) {
        for (var i = 0; i < list.length; i++) {
          var ret = list[i](arg);
          if (ret) {
            return ret;
          }
        }
        return null;
      };
    }
    var retrieveFile = handlerExec(retrieveFileHandlers);
    retrieveFileHandlers.push(function(path2) {
      path2 = path2.trim();
      if (/^file:/.test(path2)) {
        path2 = path2.replace(/file:\/\/\/(\w:)?/, function(protocol, drive) {
          return drive ? "" : (
            // file:///C:/dir/file -> C:/dir/file
            "/"
          );
        });
      }
      if (path2 in fileContentsCache) {
        return fileContentsCache[path2];
      }
      var contents = "";
      try {
        if (!fs) {
          var xhr = new XMLHttpRequest();
          xhr.open(
            "GET",
            path2,
            /** async */
            false
          );
          xhr.send(null);
          if (xhr.readyState === 4 && xhr.status === 200) {
            contents = xhr.responseText;
          }
        } else if (fs.existsSync(path2)) {
          contents = fs.readFileSync(path2, "utf8");
        }
      } catch (er) {
      }
      return fileContentsCache[path2] = contents;
    });
    function supportRelativeURL(file, url) {
      if (!file) return url;
      var dir = path.dirname(file);
      var match = /^\w+:\/\/[^\/]*/.exec(dir);
      var protocol = match ? match[0] : "";
      var startPath = dir.slice(protocol.length);
      if (protocol && /^\/\w\:/.test(startPath)) {
        protocol += "/";
        return protocol + path.resolve(dir.slice(protocol.length), url).replace(/\\/g, "/");
      }
      return protocol + path.resolve(dir.slice(protocol.length), url);
    }
    function retrieveSourceMapURL(source) {
      var fileData;
      if (isInBrowser()) {
        try {
          var xhr = new XMLHttpRequest();
          xhr.open("GET", source, false);
          xhr.send(null);
          fileData = xhr.readyState === 4 ? xhr.responseText : null;
          var sourceMapHeader = xhr.getResponseHeader("SourceMap") || xhr.getResponseHeader("X-SourceMap");
          if (sourceMapHeader) {
            return sourceMapHeader;
          }
        } catch (e) {
        }
      }
      fileData = retrieveFile(source);
      var re = /(?:\/\/[@#][\s]*sourceMappingURL=([^\s'"]+)[\s]*$)|(?:\/\*[@#][\s]*sourceMappingURL=([^\s*'"]+)[\s]*(?:\*\/)[\s]*$)/mg;
      var lastMatch, match;
      while (match = re.exec(fileData)) lastMatch = match;
      if (!lastMatch) return null;
      return lastMatch[1];
    }
    var retrieveSourceMap = handlerExec(retrieveMapHandlers);
    retrieveMapHandlers.push(function(source) {
      var sourceMappingURL = retrieveSourceMapURL(source);
      if (!sourceMappingURL) return null;
      var sourceMapData;
      if (reSourceMap.test(sourceMappingURL)) {
        var rawData = sourceMappingURL.slice(sourceMappingURL.indexOf(",") + 1);
        sourceMapData = bufferFrom(rawData, "base64").toString();
        sourceMappingURL = source;
      } else {
        sourceMappingURL = supportRelativeURL(source, sourceMappingURL);
        sourceMapData = retrieveFile(sourceMappingURL);
      }
      if (!sourceMapData) {
        return null;
      }
      return {
        url: sourceMappingURL,
        map: sourceMapData
      };
    });
    function mapSourcePosition(position) {
      var sourceMap = sourceMapCache[position.source];
      if (!sourceMap) {
        var urlAndMap = retrieveSourceMap(position.source);
        if (urlAndMap) {
          sourceMap = sourceMapCache[position.source] = {
            url: urlAndMap.url,
            map: new SourceMapConsumer(urlAndMap.map)
          };
          if (sourceMap.map.sourcesContent) {
            sourceMap.map.sources.forEach(function(source, i) {
              var contents = sourceMap.map.sourcesContent[i];
              if (contents) {
                var url = supportRelativeURL(sourceMap.url, source);
                fileContentsCache[url] = contents;
              }
            });
          }
        } else {
          sourceMap = sourceMapCache[position.source] = {
            url: null,
            map: null
          };
        }
      }
      if (sourceMap && sourceMap.map && typeof sourceMap.map.originalPositionFor === "function") {
        var originalPosition = sourceMap.map.originalPositionFor(position);
        if (originalPosition.source !== null) {
          originalPosition.source = supportRelativeURL(
            sourceMap.url,
            originalPosition.source
          );
          return originalPosition;
        }
      }
      return position;
    }
    function mapEvalOrigin(origin) {
      var match = /^eval at ([^(]+) \((.+):(\d+):(\d+)\)$/.exec(origin);
      if (match) {
        var position = mapSourcePosition({
          source: match[2],
          line: +match[3],
          column: match[4] - 1
        });
        return "eval at " + match[1] + " (" + position.source + ":" + position.line + ":" + (position.column + 1) + ")";
      }
      match = /^eval at ([^(]+) \((.+)\)$/.exec(origin);
      if (match) {
        return "eval at " + match[1] + " (" + mapEvalOrigin(match[2]) + ")";
      }
      return origin;
    }
    function CallSiteToString() {
      var fileName;
      var fileLocation = "";
      if (this.isNative()) {
        fileLocation = "native";
      } else {
        fileName = this.getScriptNameOrSourceURL();
        if (!fileName && this.isEval()) {
          fileLocation = this.getEvalOrigin();
          fileLocation += ", ";
        }
        if (fileName) {
          fileLocation += fileName;
        } else {
          fileLocation += "<anonymous>";
        }
        var lineNumber = this.getLineNumber();
        if (lineNumber != null) {
          fileLocation += ":" + lineNumber;
          var columnNumber = this.getColumnNumber();
          if (columnNumber) {
            fileLocation += ":" + columnNumber;
          }
        }
      }
      var line = "";
      var functionName = this.getFunctionName();
      var addSuffix = true;
      var isConstructor = this.isConstructor();
      var isMethodCall = !(this.isToplevel() || isConstructor);
      if (isMethodCall) {
        var typeName = this.getTypeName();
        if (typeName === "[object Object]") {
          typeName = "null";
        }
        var methodName = this.getMethodName();
        if (functionName) {
          if (typeName && functionName.indexOf(typeName) != 0) {
            line += typeName + ".";
          }
          line += functionName;
          if (methodName && functionName.indexOf("." + methodName) != functionName.length - methodName.length - 1) {
            line += " [as " + methodName + "]";
          }
        } else {
          line += typeName + "." + (methodName || "<anonymous>");
        }
      } else if (isConstructor) {
        line += "new " + (functionName || "<anonymous>");
      } else if (functionName) {
        line += functionName;
      } else {
        line += fileLocation;
        addSuffix = false;
      }
      if (addSuffix) {
        line += " (" + fileLocation + ")";
      }
      return line;
    }
    function cloneCallSite(frame) {
      var object = {};
      Object.getOwnPropertyNames(Object.getPrototypeOf(frame)).forEach(function(name) {
        object[name] = /^(?:is|get)/.test(name) ? function() {
          return frame[name].call(frame);
        } : frame[name];
      });
      object.toString = CallSiteToString;
      return object;
    }
    function wrapCallSite(frame, state) {
      if (state === void 0) {
        state = { nextPosition: null, curPosition: null };
      }
      if (frame.isNative()) {
        state.curPosition = null;
        return frame;
      }
      var source = frame.getFileName() || frame.getScriptNameOrSourceURL();
      if (source) {
        var line = frame.getLineNumber();
        var column = frame.getColumnNumber() - 1;
        var noHeader = /^v(10\.1[6-9]|10\.[2-9][0-9]|10\.[0-9]{3,}|1[2-9]\d*|[2-9]\d|\d{3,}|11\.11)/;
        var headerLength = noHeader.test(globalProcessVersion()) ? 0 : 62;
        if (line === 1 && column > headerLength && !isInBrowser() && !frame.isEval()) {
          column -= headerLength;
        }
        var position = mapSourcePosition({
          source,
          line,
          column
        });
        state.curPosition = position;
        frame = cloneCallSite(frame);
        var originalFunctionName = frame.getFunctionName;
        frame.getFunctionName = function() {
          if (state.nextPosition == null) {
            return originalFunctionName();
          }
          return state.nextPosition.name || originalFunctionName();
        };
        frame.getFileName = function() {
          return position.source;
        };
        frame.getLineNumber = function() {
          return position.line;
        };
        frame.getColumnNumber = function() {
          return position.column + 1;
        };
        frame.getScriptNameOrSourceURL = function() {
          return position.source;
        };
        return frame;
      }
      var origin = frame.isEval() && frame.getEvalOrigin();
      if (origin) {
        origin = mapEvalOrigin(origin);
        frame = cloneCallSite(frame);
        frame.getEvalOrigin = function() {
          return origin;
        };
        return frame;
      }
      return frame;
    }
    function prepareStackTrace(error, stack) {
      if (emptyCacheBetweenOperations) {
        fileContentsCache = {};
        sourceMapCache = {};
      }
      var name = error.name || "Error";
      var message = error.message || "";
      var errorString = name + ": " + message;
      var state = { nextPosition: null, curPosition: null };
      var processedStack = [];
      for (var i = stack.length - 1; i >= 0; i--) {
        processedStack.push("\n    at " + wrapCallSite(stack[i], state));
        state.nextPosition = state.curPosition;
      }
      state.curPosition = state.nextPosition = null;
      return errorString + processedStack.reverse().join("");
    }
    function getErrorSource(error) {
      var match = /\n    at [^(]+ \((.*):(\d+):(\d+)\)/.exec(error.stack);
      if (match) {
        var source = match[1];
        var line = +match[2];
        var column = +match[3];
        var contents = fileContentsCache[source];
        if (!contents && fs && fs.existsSync(source)) {
          try {
            contents = fs.readFileSync(source, "utf8");
          } catch (er) {
            contents = "";
          }
        }
        if (contents) {
          var code = contents.split(/(?:\r\n|\r|\n)/)[line - 1];
          if (code) {
            return source + ":" + line + "\n" + code + "\n" + new Array(column).join(" ") + "^";
          }
        }
      }
      return null;
    }
    function printErrorAndExit(error) {
      var source = getErrorSource(error);
      var stderr = globalProcessStderr();
      if (stderr && stderr._handle && stderr._handle.setBlocking) {
        stderr._handle.setBlocking(true);
      }
      if (source) {
        console.error();
        console.error(source);
      }
      console.error(error.stack);
      globalProcessExit(1);
    }
    function shimEmitUncaughtException() {
      var origEmit = process.emit;
      process.emit = function(type) {
        if (type === "uncaughtException") {
          var hasStack = arguments[1] && arguments[1].stack;
          var hasListeners = this.listeners(type).length > 0;
          if (hasStack && !hasListeners) {
            return printErrorAndExit(arguments[1]);
          }
        }
        return origEmit.apply(this, arguments);
      };
    }
    var originalRetrieveFileHandlers = retrieveFileHandlers.slice(0);
    var originalRetrieveMapHandlers = retrieveMapHandlers.slice(0);
    exports2.wrapCallSite = wrapCallSite;
    exports2.getErrorSource = getErrorSource;
    exports2.mapSourcePosition = mapSourcePosition;
    exports2.retrieveSourceMap = retrieveSourceMap;
    exports2.install = function(options) {
      options = options || {};
      if (options.environment) {
        environment = options.environment;
        if (["node", "browser", "auto"].indexOf(environment) === -1) {
          throw new Error("environment " + environment + " was unknown. Available options are {auto, browser, node}");
        }
      }
      if (options.retrieveFile) {
        if (options.overrideRetrieveFile) {
          retrieveFileHandlers.length = 0;
        }
        retrieveFileHandlers.unshift(options.retrieveFile);
      }
      if (options.retrieveSourceMap) {
        if (options.overrideRetrieveSourceMap) {
          retrieveMapHandlers.length = 0;
        }
        retrieveMapHandlers.unshift(options.retrieveSourceMap);
      }
      if (options.hookRequire && !isInBrowser()) {
        var Module = dynamicRequire(module2, "module");
        var $compile = Module.prototype._compile;
        if (!$compile.__sourceMapSupport) {
          Module.prototype._compile = function(content, filename) {
            fileContentsCache[filename] = content;
            sourceMapCache[filename] = void 0;
            return $compile.call(this, content, filename);
          };
          Module.prototype._compile.__sourceMapSupport = true;
        }
      }
      if (!emptyCacheBetweenOperations) {
        emptyCacheBetweenOperations = "emptyCacheBetweenOperations" in options ? options.emptyCacheBetweenOperations : false;
      }
      if (!errorFormatterInstalled) {
        errorFormatterInstalled = true;
        Error.prepareStackTrace = prepareStackTrace;
      }
      if (!uncaughtShimInstalled) {
        var installHandler = "handleUncaughtExceptions" in options ? options.handleUncaughtExceptions : true;
        try {
          var worker_threads = dynamicRequire(module2, "worker_threads");
          if (worker_threads.isMainThread === false) {
            installHandler = false;
          }
        } catch (e) {
        }
        if (installHandler && hasGlobalProcessEventEmitter()) {
          uncaughtShimInstalled = true;
          shimEmitUncaughtException();
        }
      }
    };
    exports2.resetRetrieveHandlers = function() {
      retrieveFileHandlers.length = 0;
      retrieveMapHandlers.length = 0;
      retrieveFileHandlers = originalRetrieveFileHandlers.slice(0);
      retrieveMapHandlers = originalRetrieveMapHandlers.slice(0);
      retrieveSourceMap = handlerExec(retrieveMapHandlers);
      retrieveFile = handlerExec(retrieveFileHandlers);
    };
  }
});

// node_modules/ava/lib/worker/line-numbers.js
var require_line_numbers = __commonJS({
  "node_modules/ava/lib/worker/line-numbers.js"(exports2, module2) {
    "use strict";
    function parse(file) {
      const fs = require("fs");
      const acorn = require_acorn();
      const walk = require_walk();
      const ast = acorn.parse(fs.readFileSync(file, "utf8"), {
        ecmaVersion: 11,
        locations: true
      });
      const locations = [];
      walk.simple(ast, {
        CallExpression(node) {
          locations.push(node.loc);
        }
      });
      locations.sort((a, b) => {
        if (a.start.line === b.start.line) {
          return a.start.column - b.start.column;
        }
        return a.start.line - b.start.line;
      });
      return locations;
    }
    function findTest(locations, declaration) {
      const spans = locations.filter((loc) => {
        if (loc.start.line > declaration.line || loc.end.line < declaration.line) {
          return false;
        }
        if (loc.start.line === declaration.line && loc.start.column > declaration.column) {
          return false;
        }
        if (loc.end.line === declaration.line && loc.end.column < declaration.column) {
          return false;
        }
        return true;
      });
      return spans.pop();
    }
    var range = (start, end) => new Array(end - start + 1).fill(start).map((element, index) => element + index);
    module2.exports = ({ file, lineNumbers = [] }) => {
      if (lineNumbers.length === 0) {
        return void 0;
      }
      const callsites = require_callsites();
      const sourceMapSupport = require_source_map_support();
      const locations = parse(file);
      const selected = new Set(lineNumbers);
      return () => {
        const callSite = callsites().find((callSite2) => callSite2.getFileName() === file);
        if (!callSite) {
          return false;
        }
        const sourceCallSite = sourceMapSupport.wrapCallSite(callSite);
        const start = {
          line: sourceCallSite.getLineNumber(),
          column: sourceCallSite.getColumnNumber() - 1
          // Use 0-indexed columns.
        };
        const test = findTest(locations, start);
        if (!test) {
          return false;
        }
        return range(test.start.line, test.end.line).some((line) => selected.has(line));
      };
    };
  }
});

// node_modules/ava/lib/worker/subprocess.js
var require_subprocess = __commonJS({
  "node_modules/ava/lib/worker/subprocess.js"(exports2, module2) {
    "use strict";
    var { pathToFileURL } = require("url");
    var currentlyUnhandled = require_currently_unhandled()();
    require_ensure_forked();
    var ipc = require_ipc();
    var supportsESM = async () => {
      try {
        await Promise.resolve().then(() => __toESM(require_javascript()));
        return true;
      } catch {
      }
      return false;
    };
    ipc.send({ type: "ready-for-options" });
    ipc.options.then(async (options) => {
      require_options().set(options);
      require_chalk().set(options.chalkOptions);
      if (options.chalkOptions.level > 0) {
        const { stdout, stderr } = process;
        global.console = Object.assign(global.console, new console.Console({ stdout, stderr, colorMode: true }));
      }
      const nowAndTimers = require_now_and_timers();
      const providerManager = require_provider_manager();
      const Runner = require_runner();
      const serializeError = require_serialize_error();
      const dependencyTracking = require_dependency_tracker();
      const lineNumberSelection = require_line_numbers();
      const sharedWorkerTeardowns = [];
      async function exit(code) {
        if (!process.exitCode) {
          process.exitCode = code;
        }
        dependencyTracking.flush();
        await ipc.flush();
        process.exit();
      }
      let checkSelectedByLineNumbers;
      try {
        checkSelectedByLineNumbers = lineNumberSelection({
          file: options.file,
          lineNumbers: options.lineNumbers
        });
      } catch (error) {
        ipc.send({ type: "line-number-selection-error", err: serializeError("Line number selection error", false, error, options.file) });
        checkSelectedByLineNumbers = () => false;
      }
      const runner = new Runner({
        checkSelectedByLineNumbers,
        experiments: options.experiments,
        failFast: options.failFast,
        failWithoutAssertions: options.failWithoutAssertions,
        file: options.file,
        match: options.match,
        projectDir: options.projectDir,
        recordNewSnapshots: options.recordNewSnapshots,
        runOnlyExclusive: options.runOnlyExclusive,
        serial: options.serial,
        snapshotDir: options.snapshotDir,
        updateSnapshots: options.updateSnapshots
      });
      ipc.peerFailed.then(() => {
        runner.interrupt();
      });
      const attributedRejections = /* @__PURE__ */ new Set();
      process.on("unhandledRejection", (reason, promise) => {
        if (runner.attributeLeakedError(reason)) {
          attributedRejections.add(promise);
        }
      });
      runner.on("dependency", dependencyTracking.track);
      runner.on("stateChange", (state) => ipc.send(state));
      runner.on("error", (error) => {
        ipc.send({ type: "internal-error", err: serializeError("Internal runner error", false, error, runner.file) });
        exit(1);
      });
      runner.on("finish", async () => {
        try {
          const { cannotSave, touchedFiles } = runner.saveSnapshotState();
          if (cannotSave) {
            ipc.send({ type: "snapshot-error" });
          } else if (touchedFiles) {
            ipc.send({ type: "touched-files", files: touchedFiles });
          }
        } catch (error) {
          ipc.send({ type: "internal-error", err: serializeError("Internal runner error", false, error, runner.file) });
          exit(1);
          return;
        }
        try {
          await Promise.all(sharedWorkerTeardowns.map((fn) => fn()));
        } catch (error) {
          ipc.send({ type: "uncaught-exception", err: serializeError("Shared worker teardown error", false, error, runner.file) });
          exit(1);
          return;
        }
        nowAndTimers.setImmediate(() => {
          currentlyUnhandled().filter((rejection) => !attributedRejections.has(rejection.promise)).forEach((rejection) => {
            ipc.send({ type: "unhandled-rejection", err: serializeError("Unhandled rejection", true, rejection.reason, runner.file) });
          });
          exit(0);
        });
      });
      process.on("uncaughtException", (error) => {
        if (runner.attributeLeakedError(error)) {
          return;
        }
        ipc.send({ type: "uncaught-exception", err: serializeError("Uncaught exception", true, error, runner.file) });
        exit(1);
      });
      let accessedRunner = false;
      exports2.getRunner = () => {
        accessedRunner = true;
        return runner;
      };
      exports2.registerSharedWorker = (filename, initialData, teardown) => {
        const { channel, forceUnref, ready } = ipc.registerSharedWorker(filename, initialData);
        runner.waitForReady.push(ready);
        sharedWorkerTeardowns.push(async () => {
          try {
            await teardown();
          } finally {
            forceUnref();
          }
        });
        return channel;
      };
      const testPath = options.file;
      const sourceMapSupport = require_source_map_support();
      sourceMapSupport.install({
        environment: "node",
        handleUncaughtExceptions: false
      });
      const extensionsToLoadAsModules = Object.entries(options.moduleTypes).filter(([, type]) => type === "module").map(([extension]) => extension);
      const { projectDir, providerStates = [] } = options;
      const providers = providerStates.map(({ type, state }) => {
        if (type === "babel") {
          const provider = providerManager.babel(projectDir).worker({ extensionsToLoadAsModules, state });
          runner.powerAssert = provider.powerAssert;
          return provider;
        }
        if (type === "typescript") {
          return providerManager.typescript(projectDir).worker({ extensionsToLoadAsModules, state });
        }
        return null;
      }).filter((provider) => provider !== null);
      let requireFn = require;
      let isESMSupported;
      const load = async (ref) => {
        for (const extension of extensionsToLoadAsModules) {
          if (ref.endsWith(`.${extension}`)) {
            if (typeof isESMSupported !== "boolean") {
              isESMSupported = await supportsESM();
            }
            if (isESMSupported) {
              return import(pathToFileURL(ref));
            }
            ipc.send({ type: "internal-error", err: serializeError("Internal runner error", false, new Error("ECMAScript Modules are not supported in this Node.js version.")) });
            exit(1);
            return;
          }
        }
        for (const provider of providers) {
          if (provider.canLoad(ref)) {
            return provider.load(ref, { requireFn });
          }
        }
        return requireFn(ref);
      };
      try {
        for await (const ref of options.require || []) {
          const mod = await load(ref);
          try {
            if (Reflect.has(mod, Symbol.for("esm:package"))) {
              requireFn = mod(module2);
            }
          } catch {
          }
        }
        dependencyTracking.install(testPath);
        if (options.debug && options.debug.port !== void 0 && options.debug.host !== void 0) {
          const inspector = require("inspector");
          if (!options.debug.active || inspector.url() === void 0) {
            inspector.open(options.debug.port, options.debug.host, true);
          }
          if (options.debug.break) {
            debugger;
          }
        }
        await load(testPath);
        if (accessedRunner) {
          ipc.unref();
        } else {
          ipc.send({ type: "missing-ava-import" });
          exit(1);
        }
      } catch (error) {
        ipc.send({ type: "uncaught-exception", err: serializeError("Uncaught exception", true, error, runner.file) });
        exit(1);
      }
    }).catch((error) => {
      setImmediate(() => {
        throw error;
      });
    });
  }
});

// node_modules/ava/lib/worker/main.js
var require_main = __commonJS({
  "node_modules/ava/lib/worker/main.js"(exports2, module2) {
    "use strict";
    var runner = require_subprocess().getRunner();
    var makeCjsExport = () => {
      function test(...args) {
        return runner.chain(...args);
      }
      return Object.assign(test, runner.chain);
    };
    module2.exports = Object.assign(makeCjsExport(), {
      __esModule: true,
      default: runner.chain
    });
  }
});

// node_modules/ava/index.js
var require_ava = __commonJS({
  "node_modules/ava/index.js"(exports2, module2) {
    "use strict";
    if (process.env.AVA_PATH && process.env.AVA_PATH !== __dirname) {
      module2.exports = require(process.env.AVA_PATH);
    } else {
      module2.exports = require_main();
    }
  }
});

// src/tests/bulk_test.spec.ts
var import_ava = __toESM(require_ava());

// src/openapi/api/apikeys-api.ts
var import_axios2 = __toESM(require("axios"));

// src/openapi/base.ts
var import_axios = __toESM(require("axios"));
var BASE_PATH = "http://localhost".replace(/\/+$/, "");
var BaseAPI = class {
  constructor(configuration, basePath = BASE_PATH, axios4 = import_axios.default) {
    this.basePath = basePath;
    this.axios = axios4;
    if (configuration) {
      this.configuration = configuration;
      this.basePath = configuration.basePath || this.basePath;
    }
  }
};
var RequiredError = class extends Error {
  constructor(field, msg) {
    super(msg);
    this.field = field;
    this.name = "RequiredError";
  }
};

// src/openapi/common.ts
var DUMMY_BASE_URL = "https://example.com";
var assertParamExists = function(functionName, paramName, paramValue) {
  if (paramValue === null || paramValue === void 0) {
    throw new RequiredError(
      paramName,
      `Required parameter ${paramName} was null or undefined when calling ${functionName}.`
    );
  }
};
var setBearerAuthToObject = async function(object, configuration) {
  if (configuration && configuration.accessToken) {
    const accessToken = typeof configuration.accessToken === "function" ? await configuration.accessToken() : await configuration.accessToken;
    object["Authorization"] = "Bearer " + accessToken;
  }
};
function setFlattenedQueryParams(urlSearchParams, parameter, key = "") {
  if (typeof parameter === "object") {
    if (Array.isArray(parameter)) {
      parameter.forEach((item) => setFlattenedQueryParams(urlSearchParams, item, key));
    } else {
      Object.keys(parameter).forEach(
        (currentKey) => setFlattenedQueryParams(
          urlSearchParams,
          parameter[currentKey],
          `${key}${key !== "" ? "." : ""}${currentKey}`
        )
      );
    }
  } else {
    if (urlSearchParams.has(key)) {
      urlSearchParams.append(key, parameter);
    } else {
      urlSearchParams.set(key, parameter);
    }
  }
}
var setSearchParams = function(url, ...objects) {
  const searchParams = new URLSearchParams(url.search);
  setFlattenedQueryParams(searchParams, objects);
  url.search = searchParams.toString();
};
var serializeDataIfNeeded = function(value2, requestOptions, configuration) {
  const nonString = typeof value2 !== "string";
  const needsSerialization = nonString && configuration && configuration.isJsonMime ? configuration.isJsonMime(requestOptions.headers["Content-Type"]) : nonString;
  return needsSerialization ? JSON.stringify(value2 !== void 0 ? value2 : {}) : value2 || "";
};
var toPathString = function(url) {
  return url.pathname + url.search + url.hash;
};
var createRequestFunction = function(axiosArgs, globalAxios39, BASE_PATH2, configuration) {
  return (axios4 = globalAxios39, basePath = BASE_PATH2) => {
    const axiosRequestArgs = {
      ...axiosArgs.options,
      url: ((configuration == null ? void 0 : configuration.basePath) || basePath) + axiosArgs.url
    };
    return axios4.request(axiosRequestArgs);
  };
};

// src/openapi/api/apikeys-api.ts
var APIKeysApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * Creates a new api_key under the active organization.
     * @summary Create Api Key
     * @param {APIKeyCreate} aPIKeyCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createApiKey: async (aPIKeyCreate, options = {}) => {
      assertParamExists("createApiKey", "aPIKeyCreate", aPIKeyCreate);
      const localVarPath = `/v2/api-key`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        aPIKeyCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes the api_key and all its related data.
     * @summary Delete Api Key
     * @param {string} apiKeyId The unique id of the API key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteApiKey: async (apiKeyId, options = {}) => {
      assertParamExists("deleteApiKey", "apiKeyId", apiKeyId);
      const localVarPath = `/v2/api-key/{api_key_id}`.replace(
        `{${"api_key_id"}}`,
        encodeURIComponent(String(apiKeyId))
      );
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Gets a single api_key matching the given api_key_id, if such api_key exists.
     * @summary Get Api Key
     * @param {string} apiKeyId The unique id of the API key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getApiKey: async (apiKeyId, options = {}) => {
      assertParamExists("getApiKey", "apiKeyId", apiKeyId);
      const localVarPath = `/v2/api-key/{api_key_id}`.replace(
        `{${"api_key_id"}}`,
        encodeURIComponent(String(apiKeyId))
      );
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Get Api Key Scope
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getApiKeyScope: async (options = {}) => {
      const localVarPath = `/v2/api-key/scope`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Get Environment Api Key
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEnvironmentApiKey: async (projId, envId, options = {}) => {
      assertParamExists("getEnvironmentApiKey", "projId", projId);
      assertParamExists("getEnvironmentApiKey", "envId", envId);
      const localVarPath = `/v2/api-key/{proj_id}/{env_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Lists all the api_keys under the active organization.
     * @summary List Api Keys
     * @param {MemberAccessObj} [objectType]
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listApiKeys: async (objectType, page, perPage, options = {}) => {
      const localVarPath = `/v2/api-key`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (objectType !== void 0) {
        localVarQueryParameter["object_type"] = objectType;
      }
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Rotates the API key of the PDP container with id `pdp_id`.  The rotation of the API key revokes the old API key and issues a new API key to the PDP.
     * @summary Rotate API Key
     * @param {string} apiKeyId The unique id of the API key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rotateApiKey: async (apiKeyId, options = {}) => {
      assertParamExists("rotateApiKey", "apiKeyId", apiKeyId);
      const localVarPath = `/v2/api-key/{api_key_id}/rotate-secret`.replace(
        `{${"api_key_id"}}`,
        encodeURIComponent(String(apiKeyId))
      );
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var APIKeysApiFp = function(configuration) {
  const localVarAxiosParamCreator = APIKeysApiAxiosParamCreator(configuration);
  return {
    /**
     * Creates a new api_key under the active organization.
     * @summary Create Api Key
     * @param {APIKeyCreate} aPIKeyCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createApiKey(aPIKeyCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createApiKey(aPIKeyCreate, options);
      return createRequestFunction(localVarAxiosArgs, import_axios2.default, BASE_PATH, configuration);
    },
    /**
     * Deletes the api_key and all its related data.
     * @summary Delete Api Key
     * @param {string} apiKeyId The unique id of the API key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteApiKey(apiKeyId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApiKey(apiKeyId, options);
      return createRequestFunction(localVarAxiosArgs, import_axios2.default, BASE_PATH, configuration);
    },
    /**
     * Gets a single api_key matching the given api_key_id, if such api_key exists.
     * @summary Get Api Key
     * @param {string} apiKeyId The unique id of the API key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getApiKey(apiKeyId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getApiKey(apiKeyId, options);
      return createRequestFunction(localVarAxiosArgs, import_axios2.default, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get Api Key Scope
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getApiKeyScope(options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getApiKeyScope(options);
      return createRequestFunction(localVarAxiosArgs, import_axios2.default, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get Environment Api Key
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEnvironmentApiKey(projId, envId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getEnvironmentApiKey(
        projId,
        envId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios2.default, BASE_PATH, configuration);
    },
    /**
     * Lists all the api_keys under the active organization.
     * @summary List Api Keys
     * @param {MemberAccessObj} [objectType]
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listApiKeys(objectType, page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listApiKeys(
        objectType,
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios2.default, BASE_PATH, configuration);
    },
    /**
     * Rotates the API key of the PDP container with id `pdp_id`.  The rotation of the API key revokes the old API key and issues a new API key to the PDP.
     * @summary Rotate API Key
     * @param {string} apiKeyId The unique id of the API key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async rotateApiKey(apiKeyId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.rotateApiKey(apiKeyId, options);
      return createRequestFunction(localVarAxiosArgs, import_axios2.default, BASE_PATH, configuration);
    }
  };
};
var APIKeysApi = class extends BaseAPI {
  /**
   * Creates a new api_key under the active organization.
   * @summary Create Api Key
   * @param {APIKeysApiCreateApiKeyRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIKeysApi
   */
  createApiKey(requestParameters, options) {
    return APIKeysApiFp(this.configuration).createApiKey(requestParameters.aPIKeyCreate, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Deletes the api_key and all its related data.
   * @summary Delete Api Key
   * @param {APIKeysApiDeleteApiKeyRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIKeysApi
   */
  deleteApiKey(requestParameters, options) {
    return APIKeysApiFp(this.configuration).deleteApiKey(requestParameters.apiKeyId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Gets a single api_key matching the given api_key_id, if such api_key exists.
   * @summary Get Api Key
   * @param {APIKeysApiGetApiKeyRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIKeysApi
   */
  getApiKey(requestParameters, options) {
    return APIKeysApiFp(this.configuration).getApiKey(requestParameters.apiKeyId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Get Api Key Scope
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIKeysApi
   */
  getApiKeyScope(options) {
    return APIKeysApiFp(this.configuration).getApiKeyScope(options).then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Get Environment Api Key
   * @param {APIKeysApiGetEnvironmentApiKeyRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIKeysApi
   */
  getEnvironmentApiKey(requestParameters, options) {
    return APIKeysApiFp(this.configuration).getEnvironmentApiKey(requestParameters.projId, requestParameters.envId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Lists all the api_keys under the active organization.
   * @summary List Api Keys
   * @param {APIKeysApiListApiKeysRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIKeysApi
   */
  listApiKeys(requestParameters = {}, options) {
    return APIKeysApiFp(this.configuration).listApiKeys(
      requestParameters.objectType,
      requestParameters.page,
      requestParameters.perPage,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Rotates the API key of the PDP container with id `pdp_id`.  The rotation of the API key revokes the old API key and issues a new API key to the PDP.
   * @summary Rotate API Key
   * @param {APIKeysApiRotateApiKeyRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIKeysApi
   */
  rotateApiKey(requestParameters, options) {
    return APIKeysApiFp(this.configuration).rotateApiKey(requestParameters.apiKeyId, options).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/audit-elements-data-api.ts
var import_axios3 = __toESM(require("axios"));

// src/openapi/api/audit-logs-api.ts
var import_axios4 = __toESM(require("axios"));

// src/openapi/api/authentication-api.ts
var import_axios5 = __toESM(require("axios"));
var AuthenticationApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * The dev-login endpoints allows a developer inside permit.io to log in with an email address.  THIS IS ONLY AVAILABLE IN DEV MODE.
     * @summary (DEV MODE) Login
     * @param {DevLogin} devLogin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    devLogin: async (devLogin, options = {}) => {
      assertParamExists("devLogin", "devLogin", devLogin);
      const localVarPath = `/v2/auth/devlogin`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        devLogin,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Elements Fe Login As
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {UserFELoginRequestInput} userFELoginRequestInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    elementsFeLoginAs: async (envId, userFELoginRequestInput, options = {}) => {
      assertParamExists("elementsFeLoginAs", "envId", envId);
      assertParamExists("elementsFeLoginAs", "userFELoginRequestInput", userFELoginRequestInput);
      const localVarPath = `/v2/auth/{env_id}/elements_fe_login_as`.replace(
        `{${"env_id"}}`,
        encodeURIComponent(String(envId))
      );
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userFELoginRequestInput,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Elements Login As
     * @param {UserLoginRequestInput} userLoginRequestInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    elementsLoginAs: async (userLoginRequestInput, options = {}) => {
      assertParamExists("elementsLoginAs", "userLoginRequestInput", userLoginRequestInput);
      const localVarPath = `/v2/auth/elements_login_as`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userLoginRequestInput,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * The login endpoint allows the frontend app to exchange a user JWT with a user session. The user session is stored on an httpOnly + secure cookie.
     * @summary Login
     * @param {string} [inviteCode] An optional invite code to an existing organization. If the invite code is provided and is valid, the member will gain access to that organization.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    login: async (inviteCode, options = {}) => {
      const localVarPath = `/v2/auth/login`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (inviteCode !== void 0) {
        localVarQueryParameter["invite_code"] = inviteCode;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * The login endpoint allows the frontend app to exchange a user JWT with a user session. The user session is stored on an httpOnly + secure cookie.
     * @summary Login Elements
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    loginElements: async (token, options = {}) => {
      assertParamExists("loginElements", "token", token);
      const localVarPath = `/v2/auth/login_elements`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      if (token !== void 0) {
        localVarQueryParameter["token"] = token;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * The logout endpoint deletes the session cookie of a logged in user and invalidates cached VCs.
     * @summary Logout Get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logoutGet: async (options = {}) => {
      const localVarPath = `/v2/auth/logout`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * The logout endpoint deletes the session cookie of a logged in user and invalidates cached VCs.
     * @summary Logout Post
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logoutPost: async (options = {}) => {
      const localVarPath = `/v2/auth/logout`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Me
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    me: async (options = {}) => {
      const localVarPath = `/v2/auth/me`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Allows the user to switch his active organization (manipulates the user\'s login session).  This route will return a new login cookie to the user.
     * @summary Switch Organization
     * @param {string} orgId the organization id the user wishes to switch to as the active org on the session
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    switchOrganization: async (orgId, options = {}) => {
      assertParamExists("switchOrganization", "orgId", orgId);
      const localVarPath = `/v2/auth/switch_org/{org_id}`.replace(
        `{${"org_id"}}`,
        encodeURIComponent(String(orgId))
      );
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var AuthenticationApiFp = function(configuration) {
  const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration);
  return {
    /**
     * The dev-login endpoints allows a developer inside permit.io to log in with an email address.  THIS IS ONLY AVAILABLE IN DEV MODE.
     * @summary (DEV MODE) Login
     * @param {DevLogin} devLogin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async devLogin(devLogin, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.devLogin(devLogin, options);
      return createRequestFunction(localVarAxiosArgs, import_axios5.default, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Elements Fe Login As
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {UserFELoginRequestInput} userFELoginRequestInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async elementsFeLoginAs(envId, userFELoginRequestInput, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.elementsFeLoginAs(
        envId,
        userFELoginRequestInput,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios5.default, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Elements Login As
     * @param {UserLoginRequestInput} userLoginRequestInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async elementsLoginAs(userLoginRequestInput, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.elementsLoginAs(
        userLoginRequestInput,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios5.default, BASE_PATH, configuration);
    },
    /**
     * The login endpoint allows the frontend app to exchange a user JWT with a user session. The user session is stored on an httpOnly + secure cookie.
     * @summary Login
     * @param {string} [inviteCode] An optional invite code to an existing organization. If the invite code is provided and is valid, the member will gain access to that organization.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async login(inviteCode, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.login(inviteCode, options);
      return createRequestFunction(localVarAxiosArgs, import_axios5.default, BASE_PATH, configuration);
    },
    /**
     * The login endpoint allows the frontend app to exchange a user JWT with a user session. The user session is stored on an httpOnly + secure cookie.
     * @summary Login Elements
     * @param {string} token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async loginElements(token, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.loginElements(token, options);
      return createRequestFunction(localVarAxiosArgs, import_axios5.default, BASE_PATH, configuration);
    },
    /**
     * The logout endpoint deletes the session cookie of a logged in user and invalidates cached VCs.
     * @summary Logout Get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async logoutGet(options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.logoutGet(options);
      return createRequestFunction(localVarAxiosArgs, import_axios5.default, BASE_PATH, configuration);
    },
    /**
     * The logout endpoint deletes the session cookie of a logged in user and invalidates cached VCs.
     * @summary Logout Post
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async logoutPost(options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.logoutPost(options);
      return createRequestFunction(localVarAxiosArgs, import_axios5.default, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Me
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async me(options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.me(options);
      return createRequestFunction(localVarAxiosArgs, import_axios5.default, BASE_PATH, configuration);
    },
    /**
     * Allows the user to switch his active organization (manipulates the user\'s login session).  This route will return a new login cookie to the user.
     * @summary Switch Organization
     * @param {string} orgId the organization id the user wishes to switch to as the active org on the session
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async switchOrganization(orgId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.switchOrganization(orgId, options);
      return createRequestFunction(localVarAxiosArgs, import_axios5.default, BASE_PATH, configuration);
    }
  };
};
var AuthenticationApi = class extends BaseAPI {
  /**
   * The dev-login endpoints allows a developer inside permit.io to log in with an email address.  THIS IS ONLY AVAILABLE IN DEV MODE.
   * @summary (DEV MODE) Login
   * @param {AuthenticationApiDevLoginRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationApi
   */
  devLogin(requestParameters, options) {
    return AuthenticationApiFp(this.configuration).devLogin(requestParameters.devLogin, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Elements Fe Login As
   * @param {AuthenticationApiElementsFeLoginAsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationApi
   */
  elementsFeLoginAs(requestParameters, options) {
    return AuthenticationApiFp(this.configuration).elementsFeLoginAs(
      requestParameters.envId,
      requestParameters.userFELoginRequestInput,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Elements Login As
   * @param {AuthenticationApiElementsLoginAsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationApi
   */
  elementsLoginAs(requestParameters, options) {
    return AuthenticationApiFp(this.configuration).elementsLoginAs(requestParameters.userLoginRequestInput, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * The login endpoint allows the frontend app to exchange a user JWT with a user session. The user session is stored on an httpOnly + secure cookie.
   * @summary Login
   * @param {AuthenticationApiLoginRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationApi
   */
  login(requestParameters = {}, options) {
    return AuthenticationApiFp(this.configuration).login(requestParameters.inviteCode, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * The login endpoint allows the frontend app to exchange a user JWT with a user session. The user session is stored on an httpOnly + secure cookie.
   * @summary Login Elements
   * @param {AuthenticationApiLoginElementsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationApi
   */
  loginElements(requestParameters, options) {
    return AuthenticationApiFp(this.configuration).loginElements(requestParameters.token, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * The logout endpoint deletes the session cookie of a logged in user and invalidates cached VCs.
   * @summary Logout Get
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationApi
   */
  logoutGet(options) {
    return AuthenticationApiFp(this.configuration).logoutGet(options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * The logout endpoint deletes the session cookie of a logged in user and invalidates cached VCs.
   * @summary Logout Post
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationApi
   */
  logoutPost(options) {
    return AuthenticationApiFp(this.configuration).logoutPost(options).then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Me
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationApi
   */
  me(options) {
    return AuthenticationApiFp(this.configuration).me(options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Allows the user to switch his active organization (manipulates the user\'s login session).  This route will return a new login cookie to the user.
   * @summary Switch Organization
   * @param {AuthenticationApiSwitchOrganizationRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationApi
   */
  switchOrganization(requestParameters, options) {
    return AuthenticationApiFp(this.configuration).switchOrganization(requestParameters.orgId, options).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/condition-set-rules-api.ts
var import_axios6 = __toESM(require("axios"));
var ConditionSetRulesApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * Grant permissions to a user set *on* a resource set.  If the permission is already granted, it is skipped.
     * @summary Assign Set Permissions
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ConditionSetRuleCreate} conditionSetRuleCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    assignSetPermissions: async (projId, envId, conditionSetRuleCreate, options = {}) => {
      assertParamExists("assignSetPermissions", "projId", projId);
      assertParamExists("assignSetPermissions", "envId", envId);
      assertParamExists("assignSetPermissions", "conditionSetRuleCreate", conditionSetRuleCreate);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/set_rules`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        conditionSetRuleCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Lists the condition set rules matching the filter. - If the `user_set` filter is present, will only return the permissions set of that user set. - If the `permission` filter is present, will only return the permissions sets that equals to the queried permission. - If the `resource_set` filter is present, will only return the permissions set of that resource set.
     * @summary List Set Permissions
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} [userSet] optional user set filter, will only return rules where the permission is granted to this user set
     * @param {string} [permission] optional permission filter, will only return condition set rules granting this permission
     * @param {string} [resourceSet] optional resource set filter, will only return rules where the permission is granted on this resource set
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listSetPermissions: async (projId, envId, userSet, permission, resourceSet, page, perPage, options = {}) => {
      assertParamExists("listSetPermissions", "projId", projId);
      assertParamExists("listSetPermissions", "envId", envId);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/set_rules`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (userSet !== void 0) {
        localVarQueryParameter["user_set"] = userSet;
      }
      if (permission !== void 0) {
        localVarQueryParameter["permission"] = permission;
      }
      if (resourceSet !== void 0) {
        localVarQueryParameter["resource_set"] = resourceSet;
      }
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Revokes permissions to a user set *on* a resource set.  If the permission is not granted, it is skipped.
     * @summary Unassign Set Permissions
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ConditionSetRuleRemove} conditionSetRuleRemove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unassignSetPermissions: async (projId, envId, conditionSetRuleRemove, options = {}) => {
      assertParamExists("unassignSetPermissions", "projId", projId);
      assertParamExists("unassignSetPermissions", "envId", envId);
      assertParamExists("unassignSetPermissions", "conditionSetRuleRemove", conditionSetRuleRemove);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/set_rules`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        conditionSetRuleRemove,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var ConditionSetRulesApiFp = function(configuration) {
  const localVarAxiosParamCreator = ConditionSetRulesApiAxiosParamCreator(configuration);
  return {
    /**
     * Grant permissions to a user set *on* a resource set.  If the permission is already granted, it is skipped.
     * @summary Assign Set Permissions
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ConditionSetRuleCreate} conditionSetRuleCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async assignSetPermissions(projId, envId, conditionSetRuleCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.assignSetPermissions(
        projId,
        envId,
        conditionSetRuleCreate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios6.default, BASE_PATH, configuration);
    },
    /**
     * Lists the condition set rules matching the filter. - If the `user_set` filter is present, will only return the permissions set of that user set. - If the `permission` filter is present, will only return the permissions sets that equals to the queried permission. - If the `resource_set` filter is present, will only return the permissions set of that resource set.
     * @summary List Set Permissions
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} [userSet] optional user set filter, will only return rules where the permission is granted to this user set
     * @param {string} [permission] optional permission filter, will only return condition set rules granting this permission
     * @param {string} [resourceSet] optional resource set filter, will only return rules where the permission is granted on this resource set
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listSetPermissions(projId, envId, userSet, permission, resourceSet, page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listSetPermissions(
        projId,
        envId,
        userSet,
        permission,
        resourceSet,
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios6.default, BASE_PATH, configuration);
    },
    /**
     * Revokes permissions to a user set *on* a resource set.  If the permission is not granted, it is skipped.
     * @summary Unassign Set Permissions
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ConditionSetRuleRemove} conditionSetRuleRemove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async unassignSetPermissions(projId, envId, conditionSetRuleRemove, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.unassignSetPermissions(
        projId,
        envId,
        conditionSetRuleRemove,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios6.default, BASE_PATH, configuration);
    }
  };
};
var ConditionSetRulesApi = class extends BaseAPI {
  /**
   * Grant permissions to a user set *on* a resource set.  If the permission is already granted, it is skipped.
   * @summary Assign Set Permissions
   * @param {ConditionSetRulesApiAssignSetPermissionsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConditionSetRulesApi
   */
  assignSetPermissions(requestParameters, options) {
    return ConditionSetRulesApiFp(this.configuration).assignSetPermissions(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.conditionSetRuleCreate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Lists the condition set rules matching the filter. - If the `user_set` filter is present, will only return the permissions set of that user set. - If the `permission` filter is present, will only return the permissions sets that equals to the queried permission. - If the `resource_set` filter is present, will only return the permissions set of that resource set.
   * @summary List Set Permissions
   * @param {ConditionSetRulesApiListSetPermissionsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConditionSetRulesApi
   */
  listSetPermissions(requestParameters, options) {
    return ConditionSetRulesApiFp(this.configuration).listSetPermissions(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.userSet,
      requestParameters.permission,
      requestParameters.resourceSet,
      requestParameters.page,
      requestParameters.perPage,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Revokes permissions to a user set *on* a resource set.  If the permission is not granted, it is skipped.
   * @summary Unassign Set Permissions
   * @param {ConditionSetRulesApiUnassignSetPermissionsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConditionSetRulesApi
   */
  unassignSetPermissions(requestParameters, options) {
    return ConditionSetRulesApiFp(this.configuration).unassignSetPermissions(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.conditionSetRuleRemove,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/condition-sets-api.ts
var import_axios7 = __toESM(require("axios"));
var ConditionSetsApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * Creates a new condition set (can be either a user set or a resource set).
     * @summary Create Condition Set
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ConditionSetCreate} conditionSetCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createConditionSet: async (projId, envId, conditionSetCreate, options = {}) => {
      assertParamExists("createConditionSet", "projId", projId);
      assertParamExists("createConditionSet", "envId", envId);
      assertParamExists("createConditionSet", "conditionSetCreate", conditionSetCreate);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/condition_sets`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        conditionSetCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes a condition set and all its related data. This includes any permissions granted to said condition set (i.e: any matching condition set rules).
     * @summary Delete Condition Set
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} conditionSetId Either the unique id of the condition set, or the URL-friendly key of the condition set (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteConditionSet: async (projId, envId, conditionSetId, options = {}) => {
      assertParamExists("deleteConditionSet", "projId", projId);
      assertParamExists("deleteConditionSet", "envId", envId);
      assertParamExists("deleteConditionSet", "conditionSetId", conditionSetId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/condition_sets/{condition_set_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"condition_set_id"}}`, encodeURIComponent(String(conditionSetId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Gets a single condition set, if such condition set exists.
     * @summary Get Condition Set
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} conditionSetId Either the unique id of the condition set, or the URL-friendly key of the condition set (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConditionSet: async (projId, envId, conditionSetId, options = {}) => {
      assertParamExists("getConditionSet", "projId", projId);
      assertParamExists("getConditionSet", "envId", envId);
      assertParamExists("getConditionSet", "conditionSetId", conditionSetId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/condition_sets/{condition_set_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"condition_set_id"}}`, encodeURIComponent(String(conditionSetId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Gets all ancestors (parent, parent of parent, and so on)
     * @summary Get Condition Set Ancestors
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} conditionSetId Either the unique id of the condition set, or the URL-friendly key of the condition set (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConditionSetAncestors: async (projId, envId, conditionSetId, page, perPage, options = {}) => {
      assertParamExists("getConditionSetAncestors", "projId", projId);
      assertParamExists("getConditionSetAncestors", "envId", envId);
      assertParamExists("getConditionSetAncestors", "conditionSetId", conditionSetId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/condition_sets/{condition_set_id}/ancestors`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"condition_set_id"}}`, encodeURIComponent(String(conditionSetId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Gets all descendants (children, children of children, and so on)
     * @summary Get Condition Set Descendants
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} conditionSetId Either the unique id of the condition set, or the URL-friendly key of the condition set (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConditionSetDescendants: async (projId, envId, conditionSetId, page, perPage, options = {}) => {
      assertParamExists("getConditionSetDescendants", "projId", projId);
      assertParamExists("getConditionSetDescendants", "envId", envId);
      assertParamExists("getConditionSetDescendants", "conditionSetId", conditionSetId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/condition_sets/{condition_set_id}/descendants`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"condition_set_id"}}`, encodeURIComponent(String(conditionSetId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Get Condition Set Possible Parents
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} conditionSetId Either the unique id of the condition set, or the URL-friendly key of the condition set (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConditionSetPossibleParents: async (projId, envId, conditionSetId, page, perPage, options = {}) => {
      assertParamExists("getConditionSetPossibleParents", "projId", projId);
      assertParamExists("getConditionSetPossibleParents", "envId", envId);
      assertParamExists("getConditionSetPossibleParents", "conditionSetId", conditionSetId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/condition_sets/{condition_set_id}/possible_parents`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"condition_set_id"}}`, encodeURIComponent(String(conditionSetId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Lists all condition sets matching a filter.
     * @summary List Condition Sets
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ConditionSetType} [type] if provided, will return only the condition sets of the specified type. e.g: only user sets.
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listConditionSets: async (projId, envId, type, page, perPage, options = {}) => {
      assertParamExists("listConditionSets", "projId", projId);
      assertParamExists("listConditionSets", "envId", envId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/condition_sets`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (type !== void 0) {
        localVarQueryParameter["type"] = type;
      }
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Partially updates a condition set. Fields that will be provided will be completely overwritten.
     * @summary Update Condition Set
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} conditionSetId Either the unique id of the condition set, or the URL-friendly key of the condition set (i.e: the \&quot;slug\&quot;).
     * @param {ConditionSetUpdate} conditionSetUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateConditionSet: async (projId, envId, conditionSetId, conditionSetUpdate, options = {}) => {
      assertParamExists("updateConditionSet", "projId", projId);
      assertParamExists("updateConditionSet", "envId", envId);
      assertParamExists("updateConditionSet", "conditionSetId", conditionSetId);
      assertParamExists("updateConditionSet", "conditionSetUpdate", conditionSetUpdate);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/condition_sets/{condition_set_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"condition_set_id"}}`, encodeURIComponent(String(conditionSetId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        conditionSetUpdate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var ConditionSetsApiFp = function(configuration) {
  const localVarAxiosParamCreator = ConditionSetsApiAxiosParamCreator(configuration);
  return {
    /**
     * Creates a new condition set (can be either a user set or a resource set).
     * @summary Create Condition Set
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ConditionSetCreate} conditionSetCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createConditionSet(projId, envId, conditionSetCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createConditionSet(
        projId,
        envId,
        conditionSetCreate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios7.default, BASE_PATH, configuration);
    },
    /**
     * Deletes a condition set and all its related data. This includes any permissions granted to said condition set (i.e: any matching condition set rules).
     * @summary Delete Condition Set
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} conditionSetId Either the unique id of the condition set, or the URL-friendly key of the condition set (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteConditionSet(projId, envId, conditionSetId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteConditionSet(
        projId,
        envId,
        conditionSetId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios7.default, BASE_PATH, configuration);
    },
    /**
     * Gets a single condition set, if such condition set exists.
     * @summary Get Condition Set
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} conditionSetId Either the unique id of the condition set, or the URL-friendly key of the condition set (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getConditionSet(projId, envId, conditionSetId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getConditionSet(
        projId,
        envId,
        conditionSetId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios7.default, BASE_PATH, configuration);
    },
    /**
     * Gets all ancestors (parent, parent of parent, and so on)
     * @summary Get Condition Set Ancestors
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} conditionSetId Either the unique id of the condition set, or the URL-friendly key of the condition set (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getConditionSetAncestors(projId, envId, conditionSetId, page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getConditionSetAncestors(
        projId,
        envId,
        conditionSetId,
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios7.default, BASE_PATH, configuration);
    },
    /**
     * Gets all descendants (children, children of children, and so on)
     * @summary Get Condition Set Descendants
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} conditionSetId Either the unique id of the condition set, or the URL-friendly key of the condition set (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getConditionSetDescendants(projId, envId, conditionSetId, page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getConditionSetDescendants(
        projId,
        envId,
        conditionSetId,
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios7.default, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get Condition Set Possible Parents
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} conditionSetId Either the unique id of the condition set, or the URL-friendly key of the condition set (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getConditionSetPossibleParents(projId, envId, conditionSetId, page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getConditionSetPossibleParents(
        projId,
        envId,
        conditionSetId,
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios7.default, BASE_PATH, configuration);
    },
    /**
     * Lists all condition sets matching a filter.
     * @summary List Condition Sets
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ConditionSetType} [type] if provided, will return only the condition sets of the specified type. e.g: only user sets.
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listConditionSets(projId, envId, type, page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listConditionSets(
        projId,
        envId,
        type,
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios7.default, BASE_PATH, configuration);
    },
    /**
     * Partially updates a condition set. Fields that will be provided will be completely overwritten.
     * @summary Update Condition Set
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} conditionSetId Either the unique id of the condition set, or the URL-friendly key of the condition set (i.e: the \&quot;slug\&quot;).
     * @param {ConditionSetUpdate} conditionSetUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateConditionSet(projId, envId, conditionSetId, conditionSetUpdate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateConditionSet(
        projId,
        envId,
        conditionSetId,
        conditionSetUpdate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios7.default, BASE_PATH, configuration);
    }
  };
};
var ConditionSetsApi = class extends BaseAPI {
  /**
   * Creates a new condition set (can be either a user set or a resource set).
   * @summary Create Condition Set
   * @param {ConditionSetsApiCreateConditionSetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConditionSetsApi
   */
  createConditionSet(requestParameters, options) {
    return ConditionSetsApiFp(this.configuration).createConditionSet(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.conditionSetCreate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Deletes a condition set and all its related data. This includes any permissions granted to said condition set (i.e: any matching condition set rules).
   * @summary Delete Condition Set
   * @param {ConditionSetsApiDeleteConditionSetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConditionSetsApi
   */
  deleteConditionSet(requestParameters, options) {
    return ConditionSetsApiFp(this.configuration).deleteConditionSet(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.conditionSetId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Gets a single condition set, if such condition set exists.
   * @summary Get Condition Set
   * @param {ConditionSetsApiGetConditionSetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConditionSetsApi
   */
  getConditionSet(requestParameters, options) {
    return ConditionSetsApiFp(this.configuration).getConditionSet(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.conditionSetId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Gets all ancestors (parent, parent of parent, and so on)
   * @summary Get Condition Set Ancestors
   * @param {ConditionSetsApiGetConditionSetAncestorsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConditionSetsApi
   */
  getConditionSetAncestors(requestParameters, options) {
    return ConditionSetsApiFp(this.configuration).getConditionSetAncestors(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.conditionSetId,
      requestParameters.page,
      requestParameters.perPage,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Gets all descendants (children, children of children, and so on)
   * @summary Get Condition Set Descendants
   * @param {ConditionSetsApiGetConditionSetDescendantsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConditionSetsApi
   */
  getConditionSetDescendants(requestParameters, options) {
    return ConditionSetsApiFp(this.configuration).getConditionSetDescendants(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.conditionSetId,
      requestParameters.page,
      requestParameters.perPage,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Get Condition Set Possible Parents
   * @param {ConditionSetsApiGetConditionSetPossibleParentsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConditionSetsApi
   */
  getConditionSetPossibleParents(requestParameters, options) {
    return ConditionSetsApiFp(this.configuration).getConditionSetPossibleParents(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.conditionSetId,
      requestParameters.page,
      requestParameters.perPage,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Lists all condition sets matching a filter.
   * @summary List Condition Sets
   * @param {ConditionSetsApiListConditionSetsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConditionSetsApi
   */
  listConditionSets(requestParameters, options) {
    return ConditionSetsApiFp(this.configuration).listConditionSets(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.type,
      requestParameters.page,
      requestParameters.perPage,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Partially updates a condition set. Fields that will be provided will be completely overwritten.
   * @summary Update Condition Set
   * @param {ConditionSetsApiUpdateConditionSetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConditionSetsApi
   */
  updateConditionSet(requestParameters, options) {
    return ConditionSetsApiFp(this.configuration).updateConditionSet(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.conditionSetId,
      requestParameters.conditionSetUpdate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/decision-logs-api.ts
var import_axios8 = __toESM(require("axios"));

// src/openapi/api/decision-logs-ingress-api.ts
var import_axios9 = __toESM(require("axios"));

// src/openapi/api/default-api.ts
var import_axios10 = __toESM(require("axios"));

// src/openapi/api/elements-configs-api.ts
var import_axios11 = __toESM(require("axios"));

// src/openapi/api/environments-api.ts
var import_axios12 = __toESM(require("axios"));
var EnvironmentsApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * Copy environment  This endpoint either duplicates an existing environment to a new environment in the same project, or copies from an existing environment to another existing environment.  The `scope` object controls which objects will be copied to the target environment.  To clone to a new environment, the user must have write permissions to the containing project. To clone into an existing environment, the user must have write permissions to the target environment.  Copying environments across projects or organizations is not allowed.
     * @summary Copy Environment
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {EnvironmentCopy} environmentCopy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    copyEnvironment: async (projId, envId, environmentCopy, options = {}) => {
      assertParamExists("copyEnvironment", "projId", projId);
      assertParamExists("copyEnvironment", "envId", envId);
      assertParamExists("copyEnvironment", "environmentCopy", environmentCopy);
      const localVarPath = `/v2/projects/{proj_id}/envs/{env_id}/copy`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        environmentCopy,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Creates a new environment under a given project.
     * @summary Create Environment
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {EnvironmentCreate} environmentCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createEnvironment: async (projId, environmentCreate, options = {}) => {
      assertParamExists("createEnvironment", "projId", projId);
      assertParamExists("createEnvironment", "environmentCreate", environmentCreate);
      const localVarPath = `/v2/projects/{proj_id}/envs`.replace(
        `{${"proj_id"}}`,
        encodeURIComponent(String(projId))
      );
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        environmentCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes an environment and all its related data.
     * @summary Delete Environment
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteEnvironment: async (projId, envId, options = {}) => {
      assertParamExists("deleteEnvironment", "projId", projId);
      assertParamExists("deleteEnvironment", "envId", envId);
      const localVarPath = `/v2/projects/{proj_id}/envs/{env_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Gets a single environment matching the given env_id, if such environment exists.
     * @summary Get Environment
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEnvironment: async (projId, envId, options = {}) => {
      assertParamExists("getEnvironment", "projId", projId);
      assertParamExists("getEnvironment", "envId", envId);
      const localVarPath = `/v2/projects/{proj_id}/envs/{env_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Lists all the environments under a given project.
     * @summary List Environments
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listEnvironments: async (projId, page, perPage, options = {}) => {
      assertParamExists("listEnvironments", "projId", projId);
      const localVarPath = `/v2/projects/{proj_id}/envs`.replace(
        `{${"proj_id"}}`,
        encodeURIComponent(String(projId))
      );
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Stats Environments
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    statsEnvironments: async (projId, envId, options = {}) => {
      assertParamExists("statsEnvironments", "projId", projId);
      assertParamExists("statsEnvironments", "envId", envId);
      const localVarPath = `/v2/projects/{proj_id}/envs/{env_id}/stats`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Updates the environment.
     * @summary Update Environment
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {EnvironmentUpdate} environmentUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateEnvironment: async (projId, envId, environmentUpdate, options = {}) => {
      assertParamExists("updateEnvironment", "projId", projId);
      assertParamExists("updateEnvironment", "envId", envId);
      assertParamExists("updateEnvironment", "environmentUpdate", environmentUpdate);
      const localVarPath = `/v2/projects/{proj_id}/envs/{env_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        environmentUpdate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var EnvironmentsApiFp = function(configuration) {
  const localVarAxiosParamCreator = EnvironmentsApiAxiosParamCreator(configuration);
  return {
    /**
     * Copy environment  This endpoint either duplicates an existing environment to a new environment in the same project, or copies from an existing environment to another existing environment.  The `scope` object controls which objects will be copied to the target environment.  To clone to a new environment, the user must have write permissions to the containing project. To clone into an existing environment, the user must have write permissions to the target environment.  Copying environments across projects or organizations is not allowed.
     * @summary Copy Environment
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {EnvironmentCopy} environmentCopy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async copyEnvironment(projId, envId, environmentCopy, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.copyEnvironment(
        projId,
        envId,
        environmentCopy,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios12.default, BASE_PATH, configuration);
    },
    /**
     * Creates a new environment under a given project.
     * @summary Create Environment
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {EnvironmentCreate} environmentCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createEnvironment(projId, environmentCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createEnvironment(
        projId,
        environmentCreate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios12.default, BASE_PATH, configuration);
    },
    /**
     * Deletes an environment and all its related data.
     * @summary Delete Environment
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteEnvironment(projId, envId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEnvironment(
        projId,
        envId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios12.default, BASE_PATH, configuration);
    },
    /**
     * Gets a single environment matching the given env_id, if such environment exists.
     * @summary Get Environment
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEnvironment(projId, envId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getEnvironment(
        projId,
        envId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios12.default, BASE_PATH, configuration);
    },
    /**
     * Lists all the environments under a given project.
     * @summary List Environments
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listEnvironments(projId, page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listEnvironments(
        projId,
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios12.default, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Stats Environments
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async statsEnvironments(projId, envId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.statsEnvironments(
        projId,
        envId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios12.default, BASE_PATH, configuration);
    },
    /**
     * Updates the environment.
     * @summary Update Environment
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {EnvironmentUpdate} environmentUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateEnvironment(projId, envId, environmentUpdate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateEnvironment(
        projId,
        envId,
        environmentUpdate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios12.default, BASE_PATH, configuration);
    }
  };
};
var EnvironmentsApi = class extends BaseAPI {
  /**
   * Copy environment  This endpoint either duplicates an existing environment to a new environment in the same project, or copies from an existing environment to another existing environment.  The `scope` object controls which objects will be copied to the target environment.  To clone to a new environment, the user must have write permissions to the containing project. To clone into an existing environment, the user must have write permissions to the target environment.  Copying environments across projects or organizations is not allowed.
   * @summary Copy Environment
   * @param {EnvironmentsApiCopyEnvironmentRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EnvironmentsApi
   */
  copyEnvironment(requestParameters, options) {
    return EnvironmentsApiFp(this.configuration).copyEnvironment(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.environmentCopy,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Creates a new environment under a given project.
   * @summary Create Environment
   * @param {EnvironmentsApiCreateEnvironmentRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EnvironmentsApi
   */
  createEnvironment(requestParameters, options) {
    return EnvironmentsApiFp(this.configuration).createEnvironment(requestParameters.projId, requestParameters.environmentCreate, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Deletes an environment and all its related data.
   * @summary Delete Environment
   * @param {EnvironmentsApiDeleteEnvironmentRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EnvironmentsApi
   */
  deleteEnvironment(requestParameters, options) {
    return EnvironmentsApiFp(this.configuration).deleteEnvironment(requestParameters.projId, requestParameters.envId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Gets a single environment matching the given env_id, if such environment exists.
   * @summary Get Environment
   * @param {EnvironmentsApiGetEnvironmentRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EnvironmentsApi
   */
  getEnvironment(requestParameters, options) {
    return EnvironmentsApiFp(this.configuration).getEnvironment(requestParameters.projId, requestParameters.envId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Lists all the environments under a given project.
   * @summary List Environments
   * @param {EnvironmentsApiListEnvironmentsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EnvironmentsApi
   */
  listEnvironments(requestParameters, options) {
    return EnvironmentsApiFp(this.configuration).listEnvironments(
      requestParameters.projId,
      requestParameters.page,
      requestParameters.perPage,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Stats Environments
   * @param {EnvironmentsApiStatsEnvironmentsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EnvironmentsApi
   */
  statsEnvironments(requestParameters, options) {
    return EnvironmentsApiFp(this.configuration).statsEnvironments(requestParameters.projId, requestParameters.envId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Updates the environment.
   * @summary Update Environment
   * @param {EnvironmentsApiUpdateEnvironmentRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EnvironmentsApi
   */
  updateEnvironment(requestParameters, options) {
    return EnvironmentsApiFp(this.configuration).updateEnvironment(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.environmentUpdate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/implicit-grants-api.ts
var import_axios13 = __toESM(require("axios"));
var ImplicitGrantsApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * Creates an implicit grant on a given role
     * @summary Create Implicit Grant
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {DerivedRoleRuleCreate} derivedRoleRuleCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createImplicitGrant: async (projId, envId, resourceId, roleId, derivedRoleRuleCreate, options = {}) => {
      assertParamExists("createImplicitGrant", "projId", projId);
      assertParamExists("createImplicitGrant", "envId", envId);
      assertParamExists("createImplicitGrant", "resourceId", resourceId);
      assertParamExists("createImplicitGrant", "roleId", roleId);
      assertParamExists("createImplicitGrant", "derivedRoleRuleCreate", derivedRoleRuleCreate);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/roles/{role_id}/implicit_grants`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId))).replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        derivedRoleRuleCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes an implicit grant on a given role
     * @summary Delete Implicit Grant
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {DerivedRoleRuleDelete} derivedRoleRuleDelete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteImplicitGrant: async (projId, envId, roleId, resourceId, derivedRoleRuleDelete, options = {}) => {
      assertParamExists("deleteImplicitGrant", "projId", projId);
      assertParamExists("deleteImplicitGrant", "envId", envId);
      assertParamExists("deleteImplicitGrant", "roleId", roleId);
      assertParamExists("deleteImplicitGrant", "resourceId", resourceId);
      assertParamExists("deleteImplicitGrant", "derivedRoleRuleDelete", derivedRoleRuleDelete);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/roles/{role_id}/implicit_grants`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"role_id"}}`, encodeURIComponent(String(roleId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        derivedRoleRuleDelete,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Update the `when` for implicit grants on a given role
     * @summary Update Implicit Grants Conditions
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {PermitBackendSchemasSchemaDerivedRoleDerivedRoleSettings} permitBackendSchemasSchemaDerivedRoleDerivedRoleSettings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateImplicitGrantsConditions: async (projId, envId, resourceId, roleId, permitBackendSchemasSchemaDerivedRoleDerivedRoleSettings, options = {}) => {
      assertParamExists("updateImplicitGrantsConditions", "projId", projId);
      assertParamExists("updateImplicitGrantsConditions", "envId", envId);
      assertParamExists("updateImplicitGrantsConditions", "resourceId", resourceId);
      assertParamExists("updateImplicitGrantsConditions", "roleId", roleId);
      assertParamExists(
        "updateImplicitGrantsConditions",
        "permitBackendSchemasSchemaDerivedRoleDerivedRoleSettings",
        permitBackendSchemasSchemaDerivedRoleDerivedRoleSettings
      );
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/roles/{role_id}/implicit_grants/conditions`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId))).replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        permitBackendSchemasSchemaDerivedRoleDerivedRoleSettings,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var ImplicitGrantsApiFp = function(configuration) {
  const localVarAxiosParamCreator = ImplicitGrantsApiAxiosParamCreator(configuration);
  return {
    /**
     * Creates an implicit grant on a given role
     * @summary Create Implicit Grant
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {DerivedRoleRuleCreate} derivedRoleRuleCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createImplicitGrant(projId, envId, resourceId, roleId, derivedRoleRuleCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createImplicitGrant(
        projId,
        envId,
        resourceId,
        roleId,
        derivedRoleRuleCreate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios13.default, BASE_PATH, configuration);
    },
    /**
     * Deletes an implicit grant on a given role
     * @summary Delete Implicit Grant
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {DerivedRoleRuleDelete} derivedRoleRuleDelete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteImplicitGrant(projId, envId, roleId, resourceId, derivedRoleRuleDelete, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteImplicitGrant(
        projId,
        envId,
        roleId,
        resourceId,
        derivedRoleRuleDelete,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios13.default, BASE_PATH, configuration);
    },
    /**
     * Update the `when` for implicit grants on a given role
     * @summary Update Implicit Grants Conditions
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {PermitBackendSchemasSchemaDerivedRoleDerivedRoleSettings} permitBackendSchemasSchemaDerivedRoleDerivedRoleSettings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateImplicitGrantsConditions(projId, envId, resourceId, roleId, permitBackendSchemasSchemaDerivedRoleDerivedRoleSettings, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateImplicitGrantsConditions(
        projId,
        envId,
        resourceId,
        roleId,
        permitBackendSchemasSchemaDerivedRoleDerivedRoleSettings,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios13.default, BASE_PATH, configuration);
    }
  };
};
var ImplicitGrantsApi = class extends BaseAPI {
  /**
   * Creates an implicit grant on a given role
   * @summary Create Implicit Grant
   * @param {ImplicitGrantsApiCreateImplicitGrantRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ImplicitGrantsApi
   */
  createImplicitGrant(requestParameters, options) {
    return ImplicitGrantsApiFp(this.configuration).createImplicitGrant(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.roleId,
      requestParameters.derivedRoleRuleCreate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Deletes an implicit grant on a given role
   * @summary Delete Implicit Grant
   * @param {ImplicitGrantsApiDeleteImplicitGrantRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ImplicitGrantsApi
   */
  deleteImplicitGrant(requestParameters, options) {
    return ImplicitGrantsApiFp(this.configuration).deleteImplicitGrant(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.roleId,
      requestParameters.resourceId,
      requestParameters.derivedRoleRuleDelete,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Update the `when` for implicit grants on a given role
   * @summary Update Implicit Grants Conditions
   * @param {ImplicitGrantsApiUpdateImplicitGrantsConditionsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ImplicitGrantsApi
   */
  updateImplicitGrantsConditions(requestParameters, options) {
    return ImplicitGrantsApiFp(this.configuration).updateImplicitGrantsConditions(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.roleId,
      requestParameters.permitBackendSchemasSchemaDerivedRoleDerivedRoleSettings,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/instructions-api.ts
var import_axios14 = __toESM(require("axios"));

// src/openapi/api/members-api.ts
var import_axios15 = __toESM(require("axios"));

// src/openapi/api/opaldata-api.ts
var import_axios16 = __toESM(require("axios"));

// src/openapi/api/organizations-api.ts
var import_axios17 = __toESM(require("axios"));

// src/openapi/api/policy-api.ts
var import_axios18 = __toESM(require("axios"));

// src/openapi/api/policy-decision-points-api.ts
var import_axios19 = __toESM(require("axios"));

// src/openapi/api/policy-git-repositories-api.ts
var import_axios20 = __toESM(require("axios"));

// src/openapi/api/projects-api.ts
var import_axios21 = __toESM(require("axios"));
var ProjectsApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * Creates a new project under the active organization.
     * @summary Create Project
     * @param {ProjectCreate} projectCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createProject: async (projectCreate, options = {}) => {
      assertParamExists("createProject", "projectCreate", projectCreate);
      const localVarPath = `/v2/projects`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        projectCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes the project and all its related data.
     * @summary Delete Project
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteProject: async (projId, options = {}) => {
      assertParamExists("deleteProject", "projId", projId);
      const localVarPath = `/v2/projects/{proj_id}`.replace(
        `{${"proj_id"}}`,
        encodeURIComponent(String(projId))
      );
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Gets a single project matching the given proj_id, if such project exists.
     * @summary Get Project
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProject: async (projId, options = {}) => {
      assertParamExists("getProject", "projId", projId);
      const localVarPath = `/v2/projects/{proj_id}`.replace(
        `{${"proj_id"}}`,
        encodeURIComponent(String(projId))
      );
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Lists all the projects under the active organization.
     * @summary List Projects
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listProjects: async (page, perPage, options = {}) => {
      const localVarPath = `/v2/projects`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Updates the project.
     * @summary Update Project
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {ProjectUpdate} projectUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProject: async (projId, projectUpdate, options = {}) => {
      assertParamExists("updateProject", "projId", projId);
      assertParamExists("updateProject", "projectUpdate", projectUpdate);
      const localVarPath = `/v2/projects/{proj_id}`.replace(
        `{${"proj_id"}}`,
        encodeURIComponent(String(projId))
      );
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        projectUpdate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var ProjectsApiFp = function(configuration) {
  const localVarAxiosParamCreator = ProjectsApiAxiosParamCreator(configuration);
  return {
    /**
     * Creates a new project under the active organization.
     * @summary Create Project
     * @param {ProjectCreate} projectCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createProject(projectCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createProject(
        projectCreate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios21.default, BASE_PATH, configuration);
    },
    /**
     * Deletes the project and all its related data.
     * @summary Delete Project
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteProject(projId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProject(projId, options);
      return createRequestFunction(localVarAxiosArgs, import_axios21.default, BASE_PATH, configuration);
    },
    /**
     * Gets a single project matching the given proj_id, if such project exists.
     * @summary Get Project
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getProject(projId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getProject(projId, options);
      return createRequestFunction(localVarAxiosArgs, import_axios21.default, BASE_PATH, configuration);
    },
    /**
     * Lists all the projects under the active organization.
     * @summary List Projects
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listProjects(page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listProjects(
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios21.default, BASE_PATH, configuration);
    },
    /**
     * Updates the project.
     * @summary Update Project
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {ProjectUpdate} projectUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateProject(projId, projectUpdate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateProject(
        projId,
        projectUpdate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios21.default, BASE_PATH, configuration);
    }
  };
};
var ProjectsApi = class extends BaseAPI {
  /**
   * Creates a new project under the active organization.
   * @summary Create Project
   * @param {ProjectsApiCreateProjectRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectsApi
   */
  createProject(requestParameters, options) {
    return ProjectsApiFp(this.configuration).createProject(requestParameters.projectCreate, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Deletes the project and all its related data.
   * @summary Delete Project
   * @param {ProjectsApiDeleteProjectRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectsApi
   */
  deleteProject(requestParameters, options) {
    return ProjectsApiFp(this.configuration).deleteProject(requestParameters.projId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Gets a single project matching the given proj_id, if such project exists.
   * @summary Get Project
   * @param {ProjectsApiGetProjectRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectsApi
   */
  getProject(requestParameters, options) {
    return ProjectsApiFp(this.configuration).getProject(requestParameters.projId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Lists all the projects under the active organization.
   * @summary List Projects
   * @param {ProjectsApiListProjectsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectsApi
   */
  listProjects(requestParameters = {}, options) {
    return ProjectsApiFp(this.configuration).listProjects(requestParameters.page, requestParameters.perPage, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Updates the project.
   * @summary Update Project
   * @param {ProjectsApiUpdateProjectRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectsApi
   */
  updateProject(requestParameters, options) {
    return ProjectsApiFp(this.configuration).updateProject(requestParameters.projId, requestParameters.projectUpdate, options).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/proxy-config-api.ts
var import_axios22 = __toESM(require("axios"));

// src/openapi/api/relationship-tuples-api.ts
var import_axios23 = __toESM(require("axios"));
var RelationshipTuplesApiAxiosParamCreator = function(configuration) {
  return {
    /**
     *
     * @summary Bulk create relationship tuples(EAP)
     * @param {any} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {any} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {RelationshipTupleCreateBulkOperation} relationshipTupleCreateBulkOperation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkCreateRelationshipTuples: async (projId, envId, relationshipTupleCreateBulkOperation, options = {}) => {
      assertParamExists("bulkCreateRelationshipTuples", "projId", projId);
      assertParamExists("bulkCreateRelationshipTuples", "envId", envId);
      assertParamExists(
        "bulkCreateRelationshipTuples",
        "relationshipTupleCreateBulkOperation",
        relationshipTupleCreateBulkOperation
      );
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/relationship_tuples/bulk`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        relationshipTupleCreateBulkOperation,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Bulk Delete Relationship Tuples
     * @param {any} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {any} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {RelationshipTupleDeleteBulkOperation} relationshipTupleDeleteBulkOperation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkDeleteRelationshipTuples: async (projId, envId, relationshipTupleDeleteBulkOperation, options = {}) => {
      assertParamExists("bulkDeleteRelationshipTuples", "projId", projId);
      assertParamExists("bulkDeleteRelationshipTuples", "envId", envId);
      assertParamExists(
        "bulkDeleteRelationshipTuples",
        "relationshipTupleDeleteBulkOperation",
        relationshipTupleDeleteBulkOperation
      );
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/relationship_tuples/bulk`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        relationshipTupleDeleteBulkOperation,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Create a relationship between two resource instances using a relation.
     * @summary Create Relationship Tuple
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {RelationshipTupleCreate} relationshipTupleCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRelationshipTuple: async (projId, envId, relationshipTupleCreate, options = {}) => {
      assertParamExists("createRelationshipTuple", "projId", projId);
      assertParamExists("createRelationshipTuple", "envId", envId);
      assertParamExists(
        "createRelationshipTuple",
        "relationshipTupleCreate",
        relationshipTupleCreate
      );
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/relationship_tuples`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        relationshipTupleCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Delete a relationship between two resource instances.
     * @summary Delete Relationship Tuple
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {RelationshipTupleDelete} relationshipTupleDelete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRelationshipTuple: async (projId, envId, relationshipTupleDelete, options = {}) => {
      assertParamExists("deleteRelationshipTuple", "projId", projId);
      assertParamExists("deleteRelationshipTuple", "envId", envId);
      assertParamExists(
        "deleteRelationshipTuple",
        "relationshipTupleDelete",
        relationshipTupleDelete
      );
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/relationship_tuples`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        relationshipTupleDelete,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Lists the relationship tuples defined within an environment.
     * @summary List Relationship Tuples
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {string} [tenant] The tenant key or id to filter by
     * @param {string} [subject] The subject to filter by, accepts either the resource instance id or resource_type:resource_instance
     * @param {string} [relation] The relation id or key to filter by
     * @param {string} [object] The object to filter by, accepts either the resource instance id or resource_type:resource_instance
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listRelationshipTuples: async (projId, envId, detailed, page, perPage, tenant, subject, relation, object, objectType, subjectType, options = {}) => {
      assertParamExists("listRelationshipTuples", "projId", projId);
      assertParamExists("listRelationshipTuples", "envId", envId);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/relationship_tuples`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (detailed !== void 0) {
        localVarQueryParameter["detailed"] = detailed;
      }
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      if (tenant !== void 0) {
        localVarQueryParameter["tenant"] = tenant;
      }
      if (subject !== void 0) {
        localVarQueryParameter["subject"] = subject;
      }
      if (relation !== void 0) {
        localVarQueryParameter["relation"] = relation;
      }
      if (object !== void 0) {
        localVarQueryParameter["object"] = object;
      }
      if (objectType !== void 0) {
        localVarQueryParameter["object_type"] = objectType;
      }
      if (subjectType !== void 0) {
        localVarQueryParameter["subject_type"] = subjectType;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var RelationshipTuplesApiFp = function(configuration) {
  const localVarAxiosParamCreator = RelationshipTuplesApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Bulk create relationship tuples(EAP)
     * @param {any} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {any} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {RelationshipTupleCreateBulkOperation} relationshipTupleCreateBulkOperation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bulkCreateRelationshipTuples(projId, envId, relationshipTupleCreateBulkOperation, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.bulkCreateRelationshipTuples(
        projId,
        envId,
        relationshipTupleCreateBulkOperation,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios23.default, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Bulk Delete Relationship Tuples
     * @param {any} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {any} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {RelationshipTupleDeleteBulkOperation} relationshipTupleDeleteBulkOperation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bulkDeleteRelationshipTuples(projId, envId, relationshipTupleDeleteBulkOperation, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.bulkDeleteRelationshipTuples(
        projId,
        envId,
        relationshipTupleDeleteBulkOperation,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios23.default, BASE_PATH, configuration);
    },
    /**
     * Create a relationship between two resource instances using a relation.
     * @summary Create Relationship Tuple
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {RelationshipTupleCreate} relationshipTupleCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createRelationshipTuple(projId, envId, relationshipTupleCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createRelationshipTuple(
        projId,
        envId,
        relationshipTupleCreate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios23.default, BASE_PATH, configuration);
    },
    /**
     * Delete a relationship between two resource instances.
     * @summary Delete Relationship Tuple
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {RelationshipTupleDelete} relationshipTupleDelete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteRelationshipTuple(projId, envId, relationshipTupleDelete, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRelationshipTuple(
        projId,
        envId,
        relationshipTupleDelete,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios23.default, BASE_PATH, configuration);
    },
    /**
     * Lists the relationship tuples defined within an environment.
     * @summary List Relationship Tuples
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {string} [tenant] The tenant key or id to filter by
     * @param {string} [subject] The subject to filter by, accepts either the resource instance id or resource_type:resource_instance
     * @param {string} [relation] The relation id or key to filter by
     * @param {string} [object] The object to filter by, accepts either the resource instance id or resource_type:resource_instance
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listRelationshipTuples(projId, envId, detailed, page, perPage, tenant, subject, relation, object, objectType, subjectType, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listRelationshipTuples(
        projId,
        envId,
        detailed,
        page,
        perPage,
        tenant,
        subject,
        relation,
        object,
        objectType,
        subjectType,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios23.default, BASE_PATH, configuration);
    }
  };
};
var RelationshipTuplesApi = class extends BaseAPI {
  /**
   *
   * @summary Bulk create relationship tuples(EAP)
   * @param {RelationshipTuplesApiBulkCreateRelationshipTuplesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RelationshipTuplesApi
   */
  async bulkCreateRelationshipTuples(requestParameters, options) {
    let request = await RelationshipTuplesApiFp(this.configuration).bulkCreateRelationshipTuples(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.relationshipTupleCreateBulkOperation,
      options
    );
    return request(this.axios, this.basePath);
  }
  /**
   *
   * @summary Bulk Delete Relationship Tuples
   * @param {RelationshipTuplesApiBulkDeleteRelationshipTuplesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RelationshipTuplesApi
   */
  async bulkDeleteRelationshipTuples(requestParameters, options) {
    let request = await RelationshipTuplesApiFp(this.configuration).bulkDeleteRelationshipTuples(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.relationshipTupleDeleteBulkOperation,
      options
    );
    return request(this.axios, this.basePath);
  }
  /**
   * Create a relationship between two resource instances using a relation.
   * @summary Create Relationship Tuple
   * @param {RelationshipTuplesApiCreateRelationshipTupleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RelationshipTuplesApi
   */
  createRelationshipTuple(requestParameters, options) {
    return RelationshipTuplesApiFp(this.configuration).createRelationshipTuple(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.relationshipTupleCreate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Delete a relationship between two resource instances.
   * @summary Delete Relationship Tuple
   * @param {RelationshipTuplesApiDeleteRelationshipTupleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RelationshipTuplesApi
   */
  deleteRelationshipTuple(requestParameters, options) {
    return RelationshipTuplesApiFp(this.configuration).deleteRelationshipTuple(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.relationshipTupleDelete,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Lists the relationship tuples defined within an environment.
   * @summary List Relationship Tuples
   * @param {RelationshipTuplesApiListRelationshipTuplesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RelationshipTuplesApi
   */
  listRelationshipTuples(requestParameters, options) {
    return RelationshipTuplesApiFp(this.configuration).listRelationshipTuples(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.detailed,
      requestParameters.page,
      requestParameters.perPage,
      requestParameters.tenant,
      requestParameters.subject,
      requestParameters.relation,
      requestParameters.object,
      requestParameters.objectType,
      requestParameters.subjectType,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/resource-action-groups-api.ts
var import_axios24 = __toESM(require("axios"));
var ResourceActionGroupsApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * Creates a new action group that can affect the resource.
     * @summary Create Resource Action Group
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {ResourceActionGroupCreate} resourceActionGroupCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createResourceActionGroup: async (projId, envId, resourceId, resourceActionGroupCreate, options = {}) => {
      assertParamExists("createResourceActionGroup", "projId", projId);
      assertParamExists("createResourceActionGroup", "envId", envId);
      assertParamExists("createResourceActionGroup", "resourceId", resourceId);
      assertParamExists(
        "createResourceActionGroup",
        "resourceActionGroupCreate",
        resourceActionGroupCreate
      );
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/action_groups`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        resourceActionGroupCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes the action and all its related data. This includes any permissions granted to perform the action.
     * @summary Delete Resource Action Group
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} actionGroupId Either the unique id of the action group, or the URL-friendly key of the action group (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteResourceActionGroup: async (projId, envId, resourceId, actionGroupId, options = {}) => {
      assertParamExists("deleteResourceActionGroup", "projId", projId);
      assertParamExists("deleteResourceActionGroup", "envId", envId);
      assertParamExists("deleteResourceActionGroup", "resourceId", resourceId);
      assertParamExists("deleteResourceActionGroup", "actionGroupId", actionGroupId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/action_groups/{action_group_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId))).replace(`{${"action_group_id"}}`, encodeURIComponent(String(actionGroupId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Gets a single action group defined on the resource, if such action exists.
     * @summary Get Resource Action Group
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} actionGroupId Either the unique id of the action group, or the URL-friendly key of the action group (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getResourceActionGroup: async (projId, envId, resourceId, actionGroupId, options = {}) => {
      assertParamExists("getResourceActionGroup", "projId", projId);
      assertParamExists("getResourceActionGroup", "envId", envId);
      assertParamExists("getResourceActionGroup", "resourceId", resourceId);
      assertParamExists("getResourceActionGroup", "actionGroupId", actionGroupId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/action_groups/{action_group_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId))).replace(`{${"action_group_id"}}`, encodeURIComponent(String(actionGroupId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Lists all the action groups defined on the resource.
     * @summary List Resource Action Groups
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listResourceActionGroups: async (projId, envId, resourceId, page, perPage, options = {}) => {
      assertParamExists("listResourceActionGroups", "projId", projId);
      assertParamExists("listResourceActionGroups", "envId", envId);
      assertParamExists("listResourceActionGroups", "resourceId", resourceId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/action_groups`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Partially updates the action defined on a resource. Fields that will be provided will be completely overwritten.
     * @summary Update Resource Action Group
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} actionGroupId Either the unique id of the action group, or the URL-friendly key of the action group (i.e: the \&quot;slug\&quot;).
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ResourceActionGroupUpdate} resourceActionGroupUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateResourceActionGroup: async (resourceId, actionGroupId, projId, envId, resourceActionGroupUpdate, options = {}) => {
      assertParamExists("updateResourceActionGroup", "resourceId", resourceId);
      assertParamExists("updateResourceActionGroup", "actionGroupId", actionGroupId);
      assertParamExists("updateResourceActionGroup", "projId", projId);
      assertParamExists("updateResourceActionGroup", "envId", envId);
      assertParamExists(
        "updateResourceActionGroup",
        "resourceActionGroupUpdate",
        resourceActionGroupUpdate
      );
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/action_groups/{action_group_id}`.replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId))).replace(`{${"action_group_id"}}`, encodeURIComponent(String(actionGroupId))).replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        resourceActionGroupUpdate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var ResourceActionGroupsApiFp = function(configuration) {
  const localVarAxiosParamCreator = ResourceActionGroupsApiAxiosParamCreator(configuration);
  return {
    /**
     * Creates a new action group that can affect the resource.
     * @summary Create Resource Action Group
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {ResourceActionGroupCreate} resourceActionGroupCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createResourceActionGroup(projId, envId, resourceId, resourceActionGroupCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createResourceActionGroup(
        projId,
        envId,
        resourceId,
        resourceActionGroupCreate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios24.default, BASE_PATH, configuration);
    },
    /**
     * Deletes the action and all its related data. This includes any permissions granted to perform the action.
     * @summary Delete Resource Action Group
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} actionGroupId Either the unique id of the action group, or the URL-friendly key of the action group (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteResourceActionGroup(projId, envId, resourceId, actionGroupId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteResourceActionGroup(
        projId,
        envId,
        resourceId,
        actionGroupId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios24.default, BASE_PATH, configuration);
    },
    /**
     * Gets a single action group defined on the resource, if such action exists.
     * @summary Get Resource Action Group
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} actionGroupId Either the unique id of the action group, or the URL-friendly key of the action group (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getResourceActionGroup(projId, envId, resourceId, actionGroupId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getResourceActionGroup(
        projId,
        envId,
        resourceId,
        actionGroupId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios24.default, BASE_PATH, configuration);
    },
    /**
     * Lists all the action groups defined on the resource.
     * @summary List Resource Action Groups
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listResourceActionGroups(projId, envId, resourceId, page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listResourceActionGroups(
        projId,
        envId,
        resourceId,
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios24.default, BASE_PATH, configuration);
    },
    /**
     * Partially updates the action defined on a resource. Fields that will be provided will be completely overwritten.
     * @summary Update Resource Action Group
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} actionGroupId Either the unique id of the action group, or the URL-friendly key of the action group (i.e: the \&quot;slug\&quot;).
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ResourceActionGroupUpdate} resourceActionGroupUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateResourceActionGroup(resourceId, actionGroupId, projId, envId, resourceActionGroupUpdate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateResourceActionGroup(
        resourceId,
        actionGroupId,
        projId,
        envId,
        resourceActionGroupUpdate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios24.default, BASE_PATH, configuration);
    }
  };
};
var ResourceActionGroupsApi = class extends BaseAPI {
  /**
   * Creates a new action group that can affect the resource.
   * @summary Create Resource Action Group
   * @param {ResourceActionGroupsApiCreateResourceActionGroupRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceActionGroupsApi
   */
  createResourceActionGroup(requestParameters, options) {
    return ResourceActionGroupsApiFp(this.configuration).createResourceActionGroup(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.resourceActionGroupCreate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Deletes the action and all its related data. This includes any permissions granted to perform the action.
   * @summary Delete Resource Action Group
   * @param {ResourceActionGroupsApiDeleteResourceActionGroupRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceActionGroupsApi
   */
  deleteResourceActionGroup(requestParameters, options) {
    return ResourceActionGroupsApiFp(this.configuration).deleteResourceActionGroup(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.actionGroupId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Gets a single action group defined on the resource, if such action exists.
   * @summary Get Resource Action Group
   * @param {ResourceActionGroupsApiGetResourceActionGroupRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceActionGroupsApi
   */
  getResourceActionGroup(requestParameters, options) {
    return ResourceActionGroupsApiFp(this.configuration).getResourceActionGroup(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.actionGroupId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Lists all the action groups defined on the resource.
   * @summary List Resource Action Groups
   * @param {ResourceActionGroupsApiListResourceActionGroupsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceActionGroupsApi
   */
  listResourceActionGroups(requestParameters, options) {
    return ResourceActionGroupsApiFp(this.configuration).listResourceActionGroups(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.page,
      requestParameters.perPage,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Partially updates the action defined on a resource. Fields that will be provided will be completely overwritten.
   * @summary Update Resource Action Group
   * @param {ResourceActionGroupsApiUpdateResourceActionGroupRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceActionGroupsApi
   */
  updateResourceActionGroup(requestParameters, options) {
    return ResourceActionGroupsApiFp(this.configuration).updateResourceActionGroup(
      requestParameters.resourceId,
      requestParameters.actionGroupId,
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceActionGroupUpdate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/resource-actions-api.ts
var import_axios25 = __toESM(require("axios"));
var ResourceActionsApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * Creates a new action that can affect the resource.
     * @summary Create Resource Action
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {ResourceActionCreate} resourceActionCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createResourceAction: async (projId, envId, resourceId, resourceActionCreate, options = {}) => {
      assertParamExists("createResourceAction", "projId", projId);
      assertParamExists("createResourceAction", "envId", envId);
      assertParamExists("createResourceAction", "resourceId", resourceId);
      assertParamExists("createResourceAction", "resourceActionCreate", resourceActionCreate);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/actions`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        resourceActionCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes the action and all its related data. This includes any permissions granted to perform the action.
     * @summary Delete Resource Action
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} actionId Either the unique id of the action, or the URL-friendly key of the action (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteResourceAction: async (projId, envId, resourceId, actionId, options = {}) => {
      assertParamExists("deleteResourceAction", "projId", projId);
      assertParamExists("deleteResourceAction", "envId", envId);
      assertParamExists("deleteResourceAction", "resourceId", resourceId);
      assertParamExists("deleteResourceAction", "actionId", actionId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/actions/{action_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId))).replace(`{${"action_id"}}`, encodeURIComponent(String(actionId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Gets a single action defined on the resource, if such action exists.
     * @summary Get Resource Action
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} actionId Either the unique id of the action, or the URL-friendly key of the action (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getResourceAction: async (projId, envId, resourceId, actionId, options = {}) => {
      assertParamExists("getResourceAction", "projId", projId);
      assertParamExists("getResourceAction", "envId", envId);
      assertParamExists("getResourceAction", "resourceId", resourceId);
      assertParamExists("getResourceAction", "actionId", actionId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/actions/{action_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId))).replace(`{${"action_id"}}`, encodeURIComponent(String(actionId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Lists all the actions defined on the resource.
     * @summary List Resource Actions
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listResourceActions: async (projId, envId, resourceId, page, perPage, options = {}) => {
      assertParamExists("listResourceActions", "projId", projId);
      assertParamExists("listResourceActions", "envId", envId);
      assertParamExists("listResourceActions", "resourceId", resourceId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/actions`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Partially updates the action defined on a resource. Fields that will be provided will be completely overwritten.
     * @summary Update Resource Action
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} actionId Either the unique id of the action, or the URL-friendly key of the action (i.e: the \&quot;slug\&quot;).
     * @param {ResourceActionUpdate} resourceActionUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateResourceAction: async (projId, envId, resourceId, actionId, resourceActionUpdate, options = {}) => {
      assertParamExists("updateResourceAction", "projId", projId);
      assertParamExists("updateResourceAction", "envId", envId);
      assertParamExists("updateResourceAction", "resourceId", resourceId);
      assertParamExists("updateResourceAction", "actionId", actionId);
      assertParamExists("updateResourceAction", "resourceActionUpdate", resourceActionUpdate);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/actions/{action_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId))).replace(`{${"action_id"}}`, encodeURIComponent(String(actionId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        resourceActionUpdate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var ResourceActionsApiFp = function(configuration) {
  const localVarAxiosParamCreator = ResourceActionsApiAxiosParamCreator(configuration);
  return {
    /**
     * Creates a new action that can affect the resource.
     * @summary Create Resource Action
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {ResourceActionCreate} resourceActionCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createResourceAction(projId, envId, resourceId, resourceActionCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createResourceAction(
        projId,
        envId,
        resourceId,
        resourceActionCreate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios25.default, BASE_PATH, configuration);
    },
    /**
     * Deletes the action and all its related data. This includes any permissions granted to perform the action.
     * @summary Delete Resource Action
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} actionId Either the unique id of the action, or the URL-friendly key of the action (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteResourceAction(projId, envId, resourceId, actionId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteResourceAction(
        projId,
        envId,
        resourceId,
        actionId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios25.default, BASE_PATH, configuration);
    },
    /**
     * Gets a single action defined on the resource, if such action exists.
     * @summary Get Resource Action
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} actionId Either the unique id of the action, or the URL-friendly key of the action (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getResourceAction(projId, envId, resourceId, actionId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getResourceAction(
        projId,
        envId,
        resourceId,
        actionId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios25.default, BASE_PATH, configuration);
    },
    /**
     * Lists all the actions defined on the resource.
     * @summary List Resource Actions
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listResourceActions(projId, envId, resourceId, page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listResourceActions(
        projId,
        envId,
        resourceId,
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios25.default, BASE_PATH, configuration);
    },
    /**
     * Partially updates the action defined on a resource. Fields that will be provided will be completely overwritten.
     * @summary Update Resource Action
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} actionId Either the unique id of the action, or the URL-friendly key of the action (i.e: the \&quot;slug\&quot;).
     * @param {ResourceActionUpdate} resourceActionUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateResourceAction(projId, envId, resourceId, actionId, resourceActionUpdate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateResourceAction(
        projId,
        envId,
        resourceId,
        actionId,
        resourceActionUpdate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios25.default, BASE_PATH, configuration);
    }
  };
};
var ResourceActionsApi = class extends BaseAPI {
  /**
   * Creates a new action that can affect the resource.
   * @summary Create Resource Action
   * @param {ResourceActionsApiCreateResourceActionRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceActionsApi
   */
  createResourceAction(requestParameters, options) {
    return ResourceActionsApiFp(this.configuration).createResourceAction(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.resourceActionCreate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Deletes the action and all its related data. This includes any permissions granted to perform the action.
   * @summary Delete Resource Action
   * @param {ResourceActionsApiDeleteResourceActionRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceActionsApi
   */
  deleteResourceAction(requestParameters, options) {
    return ResourceActionsApiFp(this.configuration).deleteResourceAction(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.actionId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Gets a single action defined on the resource, if such action exists.
   * @summary Get Resource Action
   * @param {ResourceActionsApiGetResourceActionRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceActionsApi
   */
  getResourceAction(requestParameters, options) {
    return ResourceActionsApiFp(this.configuration).getResourceAction(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.actionId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Lists all the actions defined on the resource.
   * @summary List Resource Actions
   * @param {ResourceActionsApiListResourceActionsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceActionsApi
   */
  listResourceActions(requestParameters, options) {
    return ResourceActionsApiFp(this.configuration).listResourceActions(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.page,
      requestParameters.perPage,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Partially updates the action defined on a resource. Fields that will be provided will be completely overwritten.
   * @summary Update Resource Action
   * @param {ResourceActionsApiUpdateResourceActionRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceActionsApi
   */
  updateResourceAction(requestParameters, options) {
    return ResourceActionsApiFp(this.configuration).updateResourceAction(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.actionId,
      requestParameters.resourceActionUpdate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/resource-attributes-api.ts
var import_axios26 = __toESM(require("axios"));
var ResourceAttributesApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * Creates a new attribute as part of the resource definition.
     * @summary Create Resource Attribute
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {ResourceAttributeCreate} resourceAttributeCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createResourceAttribute: async (projId, envId, resourceId, resourceAttributeCreate, options = {}) => {
      assertParamExists("createResourceAttribute", "projId", projId);
      assertParamExists("createResourceAttribute", "envId", envId);
      assertParamExists("createResourceAttribute", "resourceId", resourceId);
      assertParamExists(
        "createResourceAttribute",
        "resourceAttributeCreate",
        resourceAttributeCreate
      );
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/attributes`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        resourceAttributeCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes the attribute and all its related data.  Note: If the attribute is used by policies, removing it will cause the attribute to evaluate as `undefined`.
     * @summary Delete Resource Attribute
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} attributeId Either the unique id of the attribute, or the URL-friendly key of the attribute (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteResourceAttribute: async (projId, envId, resourceId, attributeId, page, perPage, options = {}) => {
      assertParamExists("deleteResourceAttribute", "projId", projId);
      assertParamExists("deleteResourceAttribute", "envId", envId);
      assertParamExists("deleteResourceAttribute", "resourceId", resourceId);
      assertParamExists("deleteResourceAttribute", "attributeId", attributeId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/attributes/{attribute_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId))).replace(`{${"attribute_id"}}`, encodeURIComponent(String(attributeId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Gets a single attribute defined on the resource, if such attribute exists.
     * @summary Get Resource Attribute
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} attributeId Either the unique id of the attribute, or the URL-friendly key of the attribute (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getResourceAttribute: async (projId, envId, resourceId, attributeId, options = {}) => {
      assertParamExists("getResourceAttribute", "projId", projId);
      assertParamExists("getResourceAttribute", "envId", envId);
      assertParamExists("getResourceAttribute", "resourceId", resourceId);
      assertParamExists("getResourceAttribute", "attributeId", attributeId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/attributes/{attribute_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId))).replace(`{${"attribute_id"}}`, encodeURIComponent(String(attributeId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Lists all the attributes defined on the resource.
     * @summary List Resource Attributes
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listResourceAttributes: async (projId, envId, resourceId, page, perPage, options = {}) => {
      assertParamExists("listResourceAttributes", "projId", projId);
      assertParamExists("listResourceAttributes", "envId", envId);
      assertParamExists("listResourceAttributes", "resourceId", resourceId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/attributes`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Partially updates the attribute defined on a resource. Fields that will be provided will be completely overwritten.
     * @summary Update Resource Attribute
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} attributeId Either the unique id of the attribute, or the URL-friendly key of the attribute (i.e: the \&quot;slug\&quot;).
     * @param {ResourceAttributeUpdate} resourceAttributeUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateResourceAttribute: async (projId, envId, resourceId, attributeId, resourceAttributeUpdate, options = {}) => {
      assertParamExists("updateResourceAttribute", "projId", projId);
      assertParamExists("updateResourceAttribute", "envId", envId);
      assertParamExists("updateResourceAttribute", "resourceId", resourceId);
      assertParamExists("updateResourceAttribute", "attributeId", attributeId);
      assertParamExists(
        "updateResourceAttribute",
        "resourceAttributeUpdate",
        resourceAttributeUpdate
      );
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/attributes/{attribute_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId))).replace(`{${"attribute_id"}}`, encodeURIComponent(String(attributeId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        resourceAttributeUpdate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var ResourceAttributesApiFp = function(configuration) {
  const localVarAxiosParamCreator = ResourceAttributesApiAxiosParamCreator(configuration);
  return {
    /**
     * Creates a new attribute as part of the resource definition.
     * @summary Create Resource Attribute
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {ResourceAttributeCreate} resourceAttributeCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createResourceAttribute(projId, envId, resourceId, resourceAttributeCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createResourceAttribute(
        projId,
        envId,
        resourceId,
        resourceAttributeCreate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios26.default, BASE_PATH, configuration);
    },
    /**
     * Deletes the attribute and all its related data.  Note: If the attribute is used by policies, removing it will cause the attribute to evaluate as `undefined`.
     * @summary Delete Resource Attribute
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} attributeId Either the unique id of the attribute, or the URL-friendly key of the attribute (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteResourceAttribute(projId, envId, resourceId, attributeId, page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteResourceAttribute(
        projId,
        envId,
        resourceId,
        attributeId,
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios26.default, BASE_PATH, configuration);
    },
    /**
     * Gets a single attribute defined on the resource, if such attribute exists.
     * @summary Get Resource Attribute
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} attributeId Either the unique id of the attribute, or the URL-friendly key of the attribute (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getResourceAttribute(projId, envId, resourceId, attributeId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getResourceAttribute(
        projId,
        envId,
        resourceId,
        attributeId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios26.default, BASE_PATH, configuration);
    },
    /**
     * Lists all the attributes defined on the resource.
     * @summary List Resource Attributes
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listResourceAttributes(projId, envId, resourceId, page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listResourceAttributes(
        projId,
        envId,
        resourceId,
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios26.default, BASE_PATH, configuration);
    },
    /**
     * Partially updates the attribute defined on a resource. Fields that will be provided will be completely overwritten.
     * @summary Update Resource Attribute
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} attributeId Either the unique id of the attribute, or the URL-friendly key of the attribute (i.e: the \&quot;slug\&quot;).
     * @param {ResourceAttributeUpdate} resourceAttributeUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateResourceAttribute(projId, envId, resourceId, attributeId, resourceAttributeUpdate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateResourceAttribute(
        projId,
        envId,
        resourceId,
        attributeId,
        resourceAttributeUpdate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios26.default, BASE_PATH, configuration);
    }
  };
};
var ResourceAttributesApi = class extends BaseAPI {
  /**
   * Creates a new attribute as part of the resource definition.
   * @summary Create Resource Attribute
   * @param {ResourceAttributesApiCreateResourceAttributeRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceAttributesApi
   */
  createResourceAttribute(requestParameters, options) {
    return ResourceAttributesApiFp(this.configuration).createResourceAttribute(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.resourceAttributeCreate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Deletes the attribute and all its related data.  Note: If the attribute is used by policies, removing it will cause the attribute to evaluate as `undefined`.
   * @summary Delete Resource Attribute
   * @param {ResourceAttributesApiDeleteResourceAttributeRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceAttributesApi
   */
  deleteResourceAttribute(requestParameters, options) {
    return ResourceAttributesApiFp(this.configuration).deleteResourceAttribute(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.attributeId,
      requestParameters.page,
      requestParameters.perPage,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Gets a single attribute defined on the resource, if such attribute exists.
   * @summary Get Resource Attribute
   * @param {ResourceAttributesApiGetResourceAttributeRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceAttributesApi
   */
  getResourceAttribute(requestParameters, options) {
    return ResourceAttributesApiFp(this.configuration).getResourceAttribute(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.attributeId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Lists all the attributes defined on the resource.
   * @summary List Resource Attributes
   * @param {ResourceAttributesApiListResourceAttributesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceAttributesApi
   */
  listResourceAttributes(requestParameters, options) {
    return ResourceAttributesApiFp(this.configuration).listResourceAttributes(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.page,
      requestParameters.perPage,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Partially updates the attribute defined on a resource. Fields that will be provided will be completely overwritten.
   * @summary Update Resource Attribute
   * @param {ResourceAttributesApiUpdateResourceAttributeRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceAttributesApi
   */
  updateResourceAttribute(requestParameters, options) {
    return ResourceAttributesApiFp(this.configuration).updateResourceAttribute(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.attributeId,
      requestParameters.resourceAttributeUpdate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/resource-instances-api.ts
var import_axios27 = __toESM(require("axios"));
var ResourceInstancesApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * Creates a new instance inside the Permit.io system.  If the instance is already created: will return 200 instead of 201, and will return the existing instance object in the response body.
     * @summary Create Resource Instance
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ResourceInstanceCreate} resourceInstanceCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createResourceInstance: async (projId, envId, resourceInstanceCreate, options = {}) => {
      assertParamExists("createResourceInstance", "projId", projId);
      assertParamExists("createResourceInstance", "envId", envId);
      assertParamExists("createResourceInstance", "resourceInstanceCreate", resourceInstanceCreate);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/resource_instances`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        resourceInstanceCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes the instance and all its related data.
     * @summary Delete Resource Instance
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} instanceId Either the unique id of the resource instance, or the URL-friendly key of the resource instance (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteResourceInstance: async (projId, envId, instanceId, options = {}) => {
      assertParamExists("deleteResourceInstance", "projId", projId);
      assertParamExists("deleteResourceInstance", "envId", envId);
      assertParamExists("deleteResourceInstance", "instanceId", instanceId);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/resource_instances/{instance_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"instance_id"}}`, encodeURIComponent(String(instanceId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Gets a instance, if such instance exists. Otherwise returns 404.
     * @summary Get Resource Instance
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} instanceId Either the unique id of the resource instance, or the URL-friendly key of the resource instance (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getResourceInstance: async (projId, envId, instanceId, options = {}) => {
      assertParamExists("getResourceInstance", "projId", projId);
      assertParamExists("getResourceInstance", "envId", envId);
      assertParamExists("getResourceInstance", "instanceId", instanceId);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/resource_instances/{instance_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"instance_id"}}`, encodeURIComponent(String(instanceId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Lists all the resource instances defined within an environment.
     * @summary List Resource Instances
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} [tenant] The tenant key or id to filter by
     * @param {string} [resource] The resource key or id to filter by
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listResourceInstances: async (projId, envId, tenant, resource, page, perPage, options = {}) => {
      assertParamExists("listResourceInstances", "projId", projId);
      assertParamExists("listResourceInstances", "envId", envId);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/resource_instances`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (tenant !== void 0) {
        localVarQueryParameter["tenant"] = tenant;
      }
      if (resource !== void 0) {
        localVarQueryParameter["resource"] = resource;
      }
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Partially updates the instance definition. Fields that will be provided will be completely overwritten.
     * @summary Update Resource Instance
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} instanceId Either the unique id of the resource instance, or the URL-friendly key of the resource instance (i.e: the \&quot;slug\&quot;).
     * @param {ResourceInstanceUpdate} resourceInstanceUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateResourceInstance: async (projId, envId, instanceId, resourceInstanceUpdate, options = {}) => {
      assertParamExists("updateResourceInstance", "projId", projId);
      assertParamExists("updateResourceInstance", "envId", envId);
      assertParamExists("updateResourceInstance", "instanceId", instanceId);
      assertParamExists("updateResourceInstance", "resourceInstanceUpdate", resourceInstanceUpdate);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/resource_instances/{instance_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"instance_id"}}`, encodeURIComponent(String(instanceId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        resourceInstanceUpdate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var ResourceInstancesApiFp = function(configuration) {
  const localVarAxiosParamCreator = ResourceInstancesApiAxiosParamCreator(configuration);
  return {
    /**
     * Creates a new instance inside the Permit.io system.  If the instance is already created: will return 200 instead of 201, and will return the existing instance object in the response body.
     * @summary Create Resource Instance
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ResourceInstanceCreate} resourceInstanceCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createResourceInstance(projId, envId, resourceInstanceCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createResourceInstance(
        projId,
        envId,
        resourceInstanceCreate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios27.default, BASE_PATH, configuration);
    },
    /**
     * Deletes the instance and all its related data.
     * @summary Delete Resource Instance
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} instanceId Either the unique id of the resource instance, or the URL-friendly key of the resource instance (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteResourceInstance(projId, envId, instanceId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteResourceInstance(
        projId,
        envId,
        instanceId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios27.default, BASE_PATH, configuration);
    },
    /**
     * Gets a instance, if such instance exists. Otherwise returns 404.
     * @summary Get Resource Instance
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} instanceId Either the unique id of the resource instance, or the URL-friendly key of the resource instance (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getResourceInstance(projId, envId, instanceId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getResourceInstance(
        projId,
        envId,
        instanceId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios27.default, BASE_PATH, configuration);
    },
    /**
     * Lists all the resource instances defined within an environment.
     * @summary List Resource Instances
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} [tenant] The tenant key or id to filter by
     * @param {string} [resource] The resource key or id to filter by
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listResourceInstances(projId, envId, tenant, resource, page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listResourceInstances(
        projId,
        envId,
        tenant,
        resource,
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios27.default, BASE_PATH, configuration);
    },
    /**
     * Partially updates the instance definition. Fields that will be provided will be completely overwritten.
     * @summary Update Resource Instance
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} instanceId Either the unique id of the resource instance, or the URL-friendly key of the resource instance (i.e: the \&quot;slug\&quot;).
     * @param {ResourceInstanceUpdate} resourceInstanceUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateResourceInstance(projId, envId, instanceId, resourceInstanceUpdate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateResourceInstance(
        projId,
        envId,
        instanceId,
        resourceInstanceUpdate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios27.default, BASE_PATH, configuration);
    }
  };
};
var ResourceInstancesApi = class extends BaseAPI {
  /**
   * Creates a new instance inside the Permit.io system.  If the instance is already created: will return 200 instead of 201, and will return the existing instance object in the response body.
   * @summary Create Resource Instance
   * @param {ResourceInstancesApiCreateResourceInstanceRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceInstancesApi
   */
  createResourceInstance(requestParameters, options) {
    return ResourceInstancesApiFp(this.configuration).createResourceInstance(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceInstanceCreate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Deletes the instance and all its related data.
   * @summary Delete Resource Instance
   * @param {ResourceInstancesApiDeleteResourceInstanceRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceInstancesApi
   */
  deleteResourceInstance(requestParameters, options) {
    return ResourceInstancesApiFp(this.configuration).deleteResourceInstance(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.instanceId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Gets a instance, if such instance exists. Otherwise returns 404.
   * @summary Get Resource Instance
   * @param {ResourceInstancesApiGetResourceInstanceRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceInstancesApi
   */
  getResourceInstance(requestParameters, options) {
    return ResourceInstancesApiFp(this.configuration).getResourceInstance(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.instanceId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Lists all the resource instances defined within an environment.
   * @summary List Resource Instances
   * @param {ResourceInstancesApiListResourceInstancesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceInstancesApi
   */
  listResourceInstances(requestParameters, options) {
    return ResourceInstancesApiFp(this.configuration).listResourceInstances(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.tenant,
      requestParameters.resource,
      requestParameters.page,
      requestParameters.perPage,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Partially updates the instance definition. Fields that will be provided will be completely overwritten.
   * @summary Update Resource Instance
   * @param {ResourceInstancesApiUpdateResourceInstanceRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceInstancesApi
   */
  updateResourceInstance(requestParameters, options) {
    return ResourceInstancesApiFp(this.configuration).updateResourceInstance(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.instanceId,
      requestParameters.resourceInstanceUpdate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/resource-relations-api.ts
var import_axios28 = __toESM(require("axios"));
var ResourceRelationsApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * Creates a resource relation to another resource
     * @summary Create Resource Relation
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {RelationCreate} relationCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createResourceRelation: async (projId, envId, resourceId, relationCreate, options = {}) => {
      assertParamExists("createResourceRelation", "projId", projId);
      assertParamExists("createResourceRelation", "envId", envId);
      assertParamExists("createResourceRelation", "resourceId", resourceId);
      assertParamExists("createResourceRelation", "relationCreate", relationCreate);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/relations`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        relationCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes a resource relation
     * @summary Delete Resource Relation
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} relationId Either the unique id of the relation, or the URL-friendly key of the relation (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteResourceRelation: async (projId, envId, resourceId, relationId, options = {}) => {
      assertParamExists("deleteResourceRelation", "projId", projId);
      assertParamExists("deleteResourceRelation", "envId", envId);
      assertParamExists("deleteResourceRelation", "resourceId", resourceId);
      assertParamExists("deleteResourceRelation", "relationId", relationId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/relations/{relation_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId))).replace(`{${"relation_id"}}`, encodeURIComponent(String(relationId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Get a resource relation
     * @summary Get Resource Relation
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} relationId Either the unique id of the relation, or the URL-friendly key of the relation (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getResourceRelation: async (projId, envId, resourceId, relationId, options = {}) => {
      assertParamExists("getResourceRelation", "projId", projId);
      assertParamExists("getResourceRelation", "envId", envId);
      assertParamExists("getResourceRelation", "resourceId", resourceId);
      assertParamExists("getResourceRelation", "relationId", relationId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/relations/{relation_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId))).replace(`{${"relation_id"}}`, encodeURIComponent(String(relationId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Creates a resource relation to another resource
     * @summary List Resource Relations
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listResourceRelations: async (projId, envId, resourceId, page, perPage, options = {}) => {
      assertParamExists("listResourceRelations", "projId", projId);
      assertParamExists("listResourceRelations", "envId", envId);
      assertParamExists("listResourceRelations", "resourceId", resourceId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/relations`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var ResourceRelationsApiFp = function(configuration) {
  const localVarAxiosParamCreator = ResourceRelationsApiAxiosParamCreator(configuration);
  return {
    /**
     * Creates a resource relation to another resource
     * @summary Create Resource Relation
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {RelationCreate} relationCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createResourceRelation(projId, envId, resourceId, relationCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createResourceRelation(
        projId,
        envId,
        resourceId,
        relationCreate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios28.default, BASE_PATH, configuration);
    },
    /**
     * Deletes a resource relation
     * @summary Delete Resource Relation
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} relationId Either the unique id of the relation, or the URL-friendly key of the relation (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteResourceRelation(projId, envId, resourceId, relationId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteResourceRelation(
        projId,
        envId,
        resourceId,
        relationId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios28.default, BASE_PATH, configuration);
    },
    /**
     * Get a resource relation
     * @summary Get Resource Relation
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} relationId Either the unique id of the relation, or the URL-friendly key of the relation (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getResourceRelation(projId, envId, resourceId, relationId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getResourceRelation(
        projId,
        envId,
        resourceId,
        relationId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios28.default, BASE_PATH, configuration);
    },
    /**
     * Creates a resource relation to another resource
     * @summary List Resource Relations
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listResourceRelations(projId, envId, resourceId, page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listResourceRelations(
        projId,
        envId,
        resourceId,
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios28.default, BASE_PATH, configuration);
    }
  };
};
var ResourceRelationsApi = class extends BaseAPI {
  /**
   * Creates a resource relation to another resource
   * @summary Create Resource Relation
   * @param {ResourceRelationsApiCreateResourceRelationRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceRelationsApi
   */
  createResourceRelation(requestParameters, options) {
    return ResourceRelationsApiFp(this.configuration).createResourceRelation(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.relationCreate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Deletes a resource relation
   * @summary Delete Resource Relation
   * @param {ResourceRelationsApiDeleteResourceRelationRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceRelationsApi
   */
  deleteResourceRelation(requestParameters, options) {
    return ResourceRelationsApiFp(this.configuration).deleteResourceRelation(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.relationId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Get a resource relation
   * @summary Get Resource Relation
   * @param {ResourceRelationsApiGetResourceRelationRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceRelationsApi
   */
  getResourceRelation(requestParameters, options) {
    return ResourceRelationsApiFp(this.configuration).getResourceRelation(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.relationId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Creates a resource relation to another resource
   * @summary List Resource Relations
   * @param {ResourceRelationsApiListResourceRelationsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceRelationsApi
   */
  listResourceRelations(requestParameters, options) {
    return ResourceRelationsApiFp(this.configuration).listResourceRelations(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.page,
      requestParameters.perPage,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/resource-roles-api.ts
var import_axios29 = __toESM(require("axios"));
var ResourceRolesApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * Assign permissions to role.  If some of the permissions specified are already assigned, will skip them.
     * @summary Assign Permissions to Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {AddRolePermissions} addRolePermissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    assignPermissionsToResourceRole: async (projId, envId, resourceId, roleId, addRolePermissions, options = {}) => {
      assertParamExists("assignPermissionsToResourceRole", "projId", projId);
      assertParamExists("assignPermissionsToResourceRole", "envId", envId);
      assertParamExists("assignPermissionsToResourceRole", "resourceId", resourceId);
      assertParamExists("assignPermissionsToResourceRole", "roleId", roleId);
      assertParamExists(
        "assignPermissionsToResourceRole",
        "addRolePermissions",
        addRolePermissions
      );
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/roles/{role_id}/permissions`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId))).replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        addRolePermissions,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Creates a new role associated with the resource.
     * @summary Create Resource Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {ResourceRoleCreate} resourceRoleCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createResourceRole: async (projId, envId, resourceId, resourceRoleCreate, options = {}) => {
      assertParamExists("createResourceRole", "projId", projId);
      assertParamExists("createResourceRole", "envId", envId);
      assertParamExists("createResourceRole", "resourceId", resourceId);
      assertParamExists("createResourceRole", "resourceRoleCreate", resourceRoleCreate);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/roles`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        resourceRoleCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes the role and all its related data. This includes any permissions granted to said role.
     * @summary Delete Resource Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteResourceRole: async (projId, envId, resourceId, roleId, options = {}) => {
      assertParamExists("deleteResourceRole", "projId", projId);
      assertParamExists("deleteResourceRole", "envId", envId);
      assertParamExists("deleteResourceRole", "resourceId", resourceId);
      assertParamExists("deleteResourceRole", "roleId", roleId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/roles/{role_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId))).replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Gets a single role defined on the resource, if such role exists.
     * @summary Get Resource Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getResourceRole: async (projId, envId, resourceId, roleId, options = {}) => {
      assertParamExists("getResourceRole", "projId", projId);
      assertParamExists("getResourceRole", "envId", envId);
      assertParamExists("getResourceRole", "resourceId", resourceId);
      assertParamExists("getResourceRole", "roleId", roleId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/roles/{role_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId))).replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Lists all the roles defined on the resource.
     * @summary List Resource Roles
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listResourceRoles: async (projId, envId, resourceId, page, perPage, options = {}) => {
      assertParamExists("listResourceRoles", "projId", projId);
      assertParamExists("listResourceRoles", "envId", envId);
      assertParamExists("listResourceRoles", "resourceId", resourceId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/roles`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Remove permissions from role.  If some of the permissions specified are already unassigned, will skip them.
     * @summary Remove Permissions from Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {RemoveRolePermissions} removeRolePermissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removePermissionsFromResourceRole: async (projId, envId, resourceId, roleId, removeRolePermissions, options = {}) => {
      assertParamExists("removePermissionsFromResourceRole", "projId", projId);
      assertParamExists("removePermissionsFromResourceRole", "envId", envId);
      assertParamExists("removePermissionsFromResourceRole", "resourceId", resourceId);
      assertParamExists("removePermissionsFromResourceRole", "roleId", roleId);
      assertParamExists(
        "removePermissionsFromResourceRole",
        "removeRolePermissions",
        removeRolePermissions
      );
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/roles/{role_id}/permissions`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId))).replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        removeRolePermissions,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Partially updates the role defined on a resource. Fields that will be provided will be completely overwritten.
     * @summary Update Resource Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {ResourceRoleUpdate} resourceRoleUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateResourceRole: async (projId, envId, resourceId, roleId, resourceRoleUpdate, options = {}) => {
      assertParamExists("updateResourceRole", "projId", projId);
      assertParamExists("updateResourceRole", "envId", envId);
      assertParamExists("updateResourceRole", "resourceId", resourceId);
      assertParamExists("updateResourceRole", "roleId", roleId);
      assertParamExists("updateResourceRole", "resourceRoleUpdate", resourceRoleUpdate);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/roles/{role_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId))).replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        resourceRoleUpdate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var ResourceRolesApiFp = function(configuration) {
  const localVarAxiosParamCreator = ResourceRolesApiAxiosParamCreator(configuration);
  return {
    /**
     * Assign permissions to role.  If some of the permissions specified are already assigned, will skip them.
     * @summary Assign Permissions to Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {AddRolePermissions} addRolePermissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async assignPermissionsToResourceRole(projId, envId, resourceId, roleId, addRolePermissions, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.assignPermissionsToResourceRole(
        projId,
        envId,
        resourceId,
        roleId,
        addRolePermissions,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios29.default, BASE_PATH, configuration);
    },
    /**
     * Creates a new role associated with the resource.
     * @summary Create Resource Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {ResourceRoleCreate} resourceRoleCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createResourceRole(projId, envId, resourceId, resourceRoleCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createResourceRole(
        projId,
        envId,
        resourceId,
        resourceRoleCreate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios29.default, BASE_PATH, configuration);
    },
    /**
     * Deletes the role and all its related data. This includes any permissions granted to said role.
     * @summary Delete Resource Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteResourceRole(projId, envId, resourceId, roleId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteResourceRole(
        projId,
        envId,
        resourceId,
        roleId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios29.default, BASE_PATH, configuration);
    },
    /**
     * Gets a single role defined on the resource, if such role exists.
     * @summary Get Resource Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getResourceRole(projId, envId, resourceId, roleId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getResourceRole(
        projId,
        envId,
        resourceId,
        roleId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios29.default, BASE_PATH, configuration);
    },
    /**
     * Lists all the roles defined on the resource.
     * @summary List Resource Roles
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listResourceRoles(projId, envId, resourceId, page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listResourceRoles(
        projId,
        envId,
        resourceId,
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios29.default, BASE_PATH, configuration);
    },
    /**
     * Remove permissions from role.  If some of the permissions specified are already unassigned, will skip them.
     * @summary Remove Permissions from Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {RemoveRolePermissions} removeRolePermissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removePermissionsFromResourceRole(projId, envId, resourceId, roleId, removeRolePermissions, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.removePermissionsFromResourceRole(
        projId,
        envId,
        resourceId,
        roleId,
        removeRolePermissions,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios29.default, BASE_PATH, configuration);
    },
    /**
     * Partially updates the role defined on a resource. Fields that will be provided will be completely overwritten.
     * @summary Update Resource Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {ResourceRoleUpdate} resourceRoleUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateResourceRole(projId, envId, resourceId, roleId, resourceRoleUpdate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateResourceRole(
        projId,
        envId,
        resourceId,
        roleId,
        resourceRoleUpdate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios29.default, BASE_PATH, configuration);
    }
  };
};
var ResourceRolesApi = class extends BaseAPI {
  /**
   * Assign permissions to role.  If some of the permissions specified are already assigned, will skip them.
   * @summary Assign Permissions to Role
   * @param {ResourceRolesApiAssignPermissionsToResourceRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceRolesApi
   */
  assignPermissionsToResourceRole(requestParameters, options) {
    return ResourceRolesApiFp(this.configuration).assignPermissionsToResourceRole(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.roleId,
      requestParameters.addRolePermissions,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Creates a new role associated with the resource.
   * @summary Create Resource Role
   * @param {ResourceRolesApiCreateResourceRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceRolesApi
   */
  createResourceRole(requestParameters, options) {
    return ResourceRolesApiFp(this.configuration).createResourceRole(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.resourceRoleCreate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Deletes the role and all its related data. This includes any permissions granted to said role.
   * @summary Delete Resource Role
   * @param {ResourceRolesApiDeleteResourceRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceRolesApi
   */
  deleteResourceRole(requestParameters, options) {
    return ResourceRolesApiFp(this.configuration).deleteResourceRole(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.roleId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Gets a single role defined on the resource, if such role exists.
   * @summary Get Resource Role
   * @param {ResourceRolesApiGetResourceRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceRolesApi
   */
  getResourceRole(requestParameters, options) {
    return ResourceRolesApiFp(this.configuration).getResourceRole(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.roleId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Lists all the roles defined on the resource.
   * @summary List Resource Roles
   * @param {ResourceRolesApiListResourceRolesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceRolesApi
   */
  listResourceRoles(requestParameters, options) {
    return ResourceRolesApiFp(this.configuration).listResourceRoles(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.page,
      requestParameters.perPage,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Remove permissions from role.  If some of the permissions specified are already unassigned, will skip them.
   * @summary Remove Permissions from Role
   * @param {ResourceRolesApiRemovePermissionsFromResourceRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceRolesApi
   */
  removePermissionsFromResourceRole(requestParameters, options) {
    return ResourceRolesApiFp(this.configuration).removePermissionsFromResourceRole(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.roleId,
      requestParameters.removeRolePermissions,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Partially updates the role defined on a resource. Fields that will be provided will be completely overwritten.
   * @summary Update Resource Role
   * @param {ResourceRolesApiUpdateResourceRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceRolesApi
   */
  updateResourceRole(requestParameters, options) {
    return ResourceRolesApiFp(this.configuration).updateResourceRole(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.roleId,
      requestParameters.resourceRoleUpdate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/resources-api.ts
var import_axios30 = __toESM(require("axios"));
var ResourcesApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * Creates a new resource (a type of object you may protect with permissions).
     * @summary Create Resource
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ResourceCreate} resourceCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createResource: async (projId, envId, resourceCreate, options = {}) => {
      assertParamExists("createResource", "projId", projId);
      assertParamExists("createResource", "envId", envId);
      assertParamExists("createResource", "resourceCreate", resourceCreate);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        resourceCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes the resource and all its related data.
     * @summary Delete Resource
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteResource: async (projId, envId, resourceId, options = {}) => {
      assertParamExists("deleteResource", "projId", projId);
      assertParamExists("deleteResource", "envId", envId);
      assertParamExists("deleteResource", "resourceId", resourceId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Gets a single resource, if such resource exists.
     * @summary Get Resource
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getResource: async (projId, envId, resourceId, options = {}) => {
      assertParamExists("getResource", "projId", projId);
      assertParamExists("getResource", "envId", envId);
      assertParamExists("getResource", "resourceId", resourceId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Lists all the resources defined in your schema.
     * @summary List Resources
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {boolean} [includeBuiltIn] Whether to include or exclude built-in resources, default is False
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {includeTotalCount} [includeTotalCount] Include the total count of resources in the response, default is False
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listResources: async (projId, envId, includeBuiltIn, page, perPage, includeTotalCount, options = {}) => {
      assertParamExists("listResources", "projId", projId);
      assertParamExists("listResources", "envId", envId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (includeBuiltIn !== void 0) {
        localVarQueryParameter["include_built_in"] = includeBuiltIn;
      }
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      if (includeTotalCount !== void 0) {
        localVarQueryParameter["include_total_count"] = includeTotalCount;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Completely replaces the resource definition.  - If the resource key is changed, all role and permissions assignments for the the resource will be revoked. - If the resource key is unchanged, but some actions are removed or renamed from the resource definition, role and permissions assignments for these actions will be revoked.  TODO: we need to decide if we are auto-revoking, or if we are rejecting the PUT completely while there are permissions that can be affected.
     * @summary Replace Resource
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {ResourceReplace} resourceReplace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    replaceResource: async (projId, envId, resourceId, resourceReplace, options = {}) => {
      assertParamExists("replaceResource", "projId", projId);
      assertParamExists("replaceResource", "envId", envId);
      assertParamExists("replaceResource", "resourceId", resourceId);
      assertParamExists("replaceResource", "resourceReplace", resourceReplace);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        resourceReplace,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Partially updates the resource definition. Fields that will be provided will be completely overwritten.
     * @summary Update Resource
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {ResourceUpdate} resourceUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateResource: async (projId, envId, resourceId, resourceUpdate, options = {}) => {
      assertParamExists("updateResource", "projId", projId);
      assertParamExists("updateResource", "envId", envId);
      assertParamExists("updateResource", "resourceId", resourceId);
      assertParamExists("updateResource", "resourceUpdate", resourceUpdate);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        resourceUpdate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var ResourcesApiFp = function(configuration) {
  const localVarAxiosParamCreator = ResourcesApiAxiosParamCreator(configuration);
  return {
    /**
     * Creates a new resource (a type of object you may protect with permissions).
     * @summary Create Resource
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ResourceCreate} resourceCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createResource(projId, envId, resourceCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createResource(
        projId,
        envId,
        resourceCreate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios30.default, BASE_PATH, configuration);
    },
    /**
     * Deletes the resource and all its related data.
     * @summary Delete Resource
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteResource(projId, envId, resourceId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteResource(
        projId,
        envId,
        resourceId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios30.default, BASE_PATH, configuration);
    },
    /**
     * Gets a single resource, if such resource exists.
     * @summary Get Resource
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getResource(projId, envId, resourceId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getResource(
        projId,
        envId,
        resourceId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios30.default, BASE_PATH, configuration);
    },
    /**
     * Lists all the resources defined in your schema.
     * @summary List Resources
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {boolean} [includeBuiltIn] Whether to include or exclude built-in resources, default is False
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {includeTotalCount} [includeTotalCount] Include the total count of resources in the response, default is False
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listResources(projId, envId, includeBuiltIn, page, perPage, includeTotalCount, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listResources(
        projId,
        envId,
        includeBuiltIn,
        page,
        perPage,
        includeTotalCount,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios30.default, BASE_PATH, configuration);
    },
    /**
     * Completely replaces the resource definition.  - If the resource key is changed, all role and permissions assignments for the the resource will be revoked. - If the resource key is unchanged, but some actions are removed or renamed from the resource definition, role and permissions assignments for these actions will be revoked.  TODO: we need to decide if we are auto-revoking, or if we are rejecting the PUT completely while there are permissions that can be affected.
     * @summary Replace Resource
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {ResourceReplace} resourceReplace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async replaceResource(projId, envId, resourceId, resourceReplace, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.replaceResource(
        projId,
        envId,
        resourceId,
        resourceReplace,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios30.default, BASE_PATH, configuration);
    },
    /**
     * Partially updates the resource definition. Fields that will be provided will be completely overwritten.
     * @summary Update Resource
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {ResourceUpdate} resourceUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateResource(projId, envId, resourceId, resourceUpdate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateResource(
        projId,
        envId,
        resourceId,
        resourceUpdate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios30.default, BASE_PATH, configuration);
    }
  };
};
var ResourcesApi = class extends BaseAPI {
  /**
   * Creates a new resource (a type of object you may protect with permissions).
   * @summary Create Resource
   * @param {ResourcesApiCreateResourceRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  createResource(requestParameters, options) {
    return ResourcesApiFp(this.configuration).createResource(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceCreate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Deletes the resource and all its related data.
   * @summary Delete Resource
   * @param {ResourcesApiDeleteResourceRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  deleteResource(requestParameters, options) {
    return ResourcesApiFp(this.configuration).deleteResource(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Gets a single resource, if such resource exists.
   * @summary Get Resource
   * @param {ResourcesApiGetResourceRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  getResource(requestParameters, options) {
    return ResourcesApiFp(this.configuration).getResource(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Lists all the resources defined in your schema.
   * @summary List Resources
   * @param {ResourcesApiListResourcesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  listResources(requestParameters, options) {
    return ResourcesApiFp(this.configuration).listResources(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.includeBuiltIn,
      requestParameters.page,
      requestParameters.perPage,
      requestParameters.includeTotalCount,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Completely replaces the resource definition.  - If the resource key is changed, all role and permissions assignments for the the resource will be revoked. - If the resource key is unchanged, but some actions are removed or renamed from the resource definition, role and permissions assignments for these actions will be revoked.  TODO: we need to decide if we are auto-revoking, or if we are rejecting the PUT completely while there are permissions that can be affected.
   * @summary Replace Resource
   * @param {ResourcesApiReplaceResourceRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  replaceResource(requestParameters, options) {
    return ResourcesApiFp(this.configuration).replaceResource(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.resourceReplace,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Partially updates the resource definition. Fields that will be provided will be completely overwritten.
   * @summary Update Resource
   * @param {ResourcesApiUpdateResourceRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  updateResource(requestParameters, options) {
    return ResourcesApiFp(this.configuration).updateResource(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.resourceUpdate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/role-assignments-api.ts
var import_axios31 = __toESM(require("axios"));
var RoleAssignmentsApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * Assigns a role to a user within a tenant.  The tenant defines the scope of the assignment. In other words, the role is effective only within the tenant.
     * @summary Assign Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {RoleAssignmentCreate} roleAssignmentCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    assignRole: async (projId, envId, roleAssignmentCreate, options = {}) => {
      assertParamExists("assignRole", "projId", projId);
      assertParamExists("assignRole", "envId", envId);
      assertParamExists("assignRole", "roleAssignmentCreate", roleAssignmentCreate);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/role_assignments`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        roleAssignmentCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Bulk Assign Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {Array<RoleAssignmentCreate>} roleAssignmentCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkAssignRole: async (projId, envId, roleAssignmentCreate, options = {}) => {
      assertParamExists("bulkAssignRole", "projId", projId);
      assertParamExists("bulkAssignRole", "envId", envId);
      assertParamExists("bulkAssignRole", "roleAssignmentCreate", roleAssignmentCreate);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/role_assignments/bulk`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        roleAssignmentCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Bulk Unassign Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {Array<RoleAssignmentRemove>} roleAssignmentRemove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkUnassignRole: async (projId, envId, roleAssignmentRemove, options = {}) => {
      assertParamExists("bulkUnassignRole", "projId", projId);
      assertParamExists("bulkUnassignRole", "envId", envId);
      assertParamExists("bulkUnassignRole", "roleAssignmentRemove", roleAssignmentRemove);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/role_assignments/bulk`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        roleAssignmentRemove,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Lists the role assignments defined within an environment.  - If the `user` filter is present, will only return the role assignments of that user (supports multiple). - If the `tenant` filter is present, will only return the role assignments in that tenant (supports multiple). - If the `role` filter is present, will only return role assignments that are granting that role (supports multiple). - If the `resource` filter is present, will only return role assignments for resource instances of that resource type. - If the `resource_instance` filter is present, will only return role assignments for that resource instance.  Providing both `tenant` and `resource_instance` filters will only return role assignments if the resource instance is in that tenant. If multiple tenants are received, the last tenant will be compared with the resource instance.
     * @summary List Role Assignments
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} [user] optional user(s) filter, will only return role assignments granted to this user(s).
     * @param {string} [role] optional role(s) filter, will only return role assignments granting this role(s).
     * @param {string} [tenant] optional tenant(s) filter, will only return role assignments granted in that tenant(s).
     * @param {string} [resource] optional resource **type** filter, will only return role assignments granted on that resource type.
     * @param {string} [resourceInstance] optional resource instance filter, will only return role assignments granted on that resource instance.
     * @param {boolean} [detailed] Whether to return full details about the user, tenant and role
     * @param {boolean} [includeTotalCount] If true, returns the list of role assignments and the total count.
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listRoleAssignments: async (projId, envId, user, role, tenant, resource, resourceInstance, detailed, includeTotalCount, page, perPage, options = {}) => {
      assertParamExists("listRoleAssignments", "projId", projId);
      assertParamExists("listRoleAssignments", "envId", envId);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/role_assignments`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (user !== void 0) {
        localVarQueryParameter["user"] = user;
      }
      if (role !== void 0) {
        localVarQueryParameter["role"] = role;
      }
      if (tenant !== void 0) {
        localVarQueryParameter["tenant"] = tenant;
      }
      if (resource !== void 0) {
        localVarQueryParameter["resource"] = resource;
      }
      if (resourceInstance !== void 0) {
        localVarQueryParameter["resource_instance"] = resourceInstance;
      }
      if (detailed !== void 0) {
        localVarQueryParameter["detailed"] = detailed;
      }
      if (includeTotalCount !== void 0) {
        localVarQueryParameter["include_total_count"] = includeTotalCount;
      }
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Unassigns a user role within a tenant.  The tenant defines the scope of the assignment. In other words, the role is effective only within the tenant.  If the role is not actually assigned, will return 404.
     * @summary Unassign Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {RoleAssignmentRemove} roleAssignmentRemove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unassignRole: async (projId, envId, roleAssignmentRemove, options = {}) => {
      assertParamExists("unassignRole", "projId", projId);
      assertParamExists("unassignRole", "envId", envId);
      assertParamExists("unassignRole", "roleAssignmentRemove", roleAssignmentRemove);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/role_assignments`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        roleAssignmentRemove,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var RoleAssignmentsApiFp = function(configuration) {
  const localVarAxiosParamCreator = RoleAssignmentsApiAxiosParamCreator(configuration);
  return {
    /**
     * Assigns a role to a user within a tenant.  The tenant defines the scope of the assignment. In other words, the role is effective only within the tenant.
     * @summary Assign Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {RoleAssignmentCreate} roleAssignmentCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async assignRole(projId, envId, roleAssignmentCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.assignRole(
        projId,
        envId,
        roleAssignmentCreate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios31.default, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Bulk Assign Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {Array<RoleAssignmentCreate>} roleAssignmentCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bulkAssignRole(projId, envId, roleAssignmentCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.bulkAssignRole(
        projId,
        envId,
        roleAssignmentCreate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios31.default, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Bulk Unassign Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {Array<RoleAssignmentRemove>} roleAssignmentRemove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bulkUnassignRole(projId, envId, roleAssignmentRemove, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.bulkUnassignRole(
        projId,
        envId,
        roleAssignmentRemove,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios31.default, BASE_PATH, configuration);
    },
    /**
     * Lists the role assignments defined within an environment.  - If the `user` filter is present, will only return the role assignments of that user (supports multiple). - If the `tenant` filter is present, will only return the role assignments in that tenant (supports multiple). - If the `role` filter is present, will only return role assignments that are granting that role (supports multiple). - If the `resource` filter is present, will only return role assignments for resource instances of that resource type. - If the `resource_instance` filter is present, will only return role assignments for that resource instance.  Providing both `tenant` and `resource_instance` filters will only return role assignments if the resource instance is in that tenant. If multiple tenants are received, the last tenant will be compared with the resource instance.
     * @summary List Role Assignments
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} [user] optional user(s) filter, will only return role assignments granted to this user(s).
     * @param {string} [role] optional role(s) filter, will only return role assignments granting this role(s).
     * @param {string} [tenant] optional tenant(s) filter, will only return role assignments granted in that tenant(s).
     * @param {string} [resource] optional resource **type** filter, will only return role assignments granted on that resource type.
     * @param {string} [resourceInstance] optional resource instance filter, will only return role assignments granted on that resource instance.
     * @param {boolean} [detailed] Whether to return full details about the user, tenant and role
     * @param {boolean} [includeTotalCount] If true, returns the list of role assignments and the total count.
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listRoleAssignments(projId, envId, user, role, tenant, resource, resourceInstance, detailed, includeTotalCount, page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listRoleAssignments(
        projId,
        envId,
        user,
        role,
        tenant,
        resource,
        resourceInstance,
        detailed,
        includeTotalCount,
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios31.default, BASE_PATH, configuration);
    },
    /**
     * Unassigns a user role within a tenant.  The tenant defines the scope of the assignment. In other words, the role is effective only within the tenant.  If the role is not actually assigned, will return 404.
     * @summary Unassign Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {RoleAssignmentRemove} roleAssignmentRemove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async unassignRole(projId, envId, roleAssignmentRemove, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.unassignRole(
        projId,
        envId,
        roleAssignmentRemove,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios31.default, BASE_PATH, configuration);
    }
  };
};
var RoleAssignmentsApi = class extends BaseAPI {
  /**
   * Assigns a role to a user within a tenant.  The tenant defines the scope of the assignment. In other words, the role is effective only within the tenant.
   * @summary Assign Role
   * @param {RoleAssignmentsApiAssignRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RoleAssignmentsApi
   */
  assignRole(requestParameters, options) {
    return RoleAssignmentsApiFp(this.configuration).assignRole(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.roleAssignmentCreate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Bulk Assign Role
   * @param {RoleAssignmentsApiBulkAssignRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RoleAssignmentsApi
   */
  bulkAssignRole(requestParameters, options) {
    return RoleAssignmentsApiFp(this.configuration).bulkAssignRole(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.roleAssignmentCreate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Bulk Unassign Role
   * @param {RoleAssignmentsApiBulkUnassignRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RoleAssignmentsApi
   */
  bulkUnassignRole(requestParameters, options) {
    return RoleAssignmentsApiFp(this.configuration).bulkUnassignRole(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.roleAssignmentRemove,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Lists the role assignments defined within an environment.  - If the `user` filter is present, will only return the role assignments of that user (supports multiple). - If the `tenant` filter is present, will only return the role assignments in that tenant (supports multiple). - If the `role` filter is present, will only return role assignments that are granting that role (supports multiple). - If the `resource` filter is present, will only return role assignments for resource instances of that resource type. - If the `resource_instance` filter is present, will only return role assignments for that resource instance.  Providing both `tenant` and `resource_instance` filters will only return role assignments if the resource instance is in that tenant. If multiple tenants are received, the last tenant will be compared with the resource instance.
   * @summary List Role Assignments
   * @param {RoleAssignmentsApiListRoleAssignmentsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RoleAssignmentsApi
   */
  listRoleAssignments(requestParameters, options) {
    return RoleAssignmentsApiFp(this.configuration).listRoleAssignments(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.user,
      requestParameters.role,
      requestParameters.tenant,
      requestParameters.resource,
      requestParameters.resourceInstance,
      requestParameters.detailed,
      requestParameters.includeTotalCount,
      requestParameters.page,
      requestParameters.perPage,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Unassigns a user role within a tenant.  The tenant defines the scope of the assignment. In other words, the role is effective only within the tenant.  If the role is not actually assigned, will return 404.
   * @summary Unassign Role
   * @param {RoleAssignmentsApiUnassignRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RoleAssignmentsApi
   */
  unassignRole(requestParameters, options) {
    return RoleAssignmentsApiFp(this.configuration).unassignRole(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.roleAssignmentRemove,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/roles-api.ts
var import_axios32 = __toESM(require("axios"));
var RolesApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * This endpoint is part of the role hierarchy feature.  Makes role with id `role_id` extend the role with id `parent_role_id`. In other words, `role_id` will automatically be assigned any permissions that are granted to `parent_role_id`.  We can say the `role_id` **extends** `parent_role_id` or **inherits** from `parent_role_id`.  If `role_id` is already an ancestor of `parent_role_id`, the request will fail with HTTP 400 to prevent a cycle in the role hierarchy.
     * @summary Add Parent Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {string} parentRoleId Either the unique id of the parent role, or the URL-friendly key of the parent role (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addParentRole: async (projId, envId, roleId, parentRoleId, options = {}) => {
      assertParamExists("addParentRole", "projId", projId);
      assertParamExists("addParentRole", "envId", envId);
      assertParamExists("addParentRole", "roleId", roleId);
      assertParamExists("addParentRole", "parentRoleId", parentRoleId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/roles/{role_id}/parents/{parent_role_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"role_id"}}`, encodeURIComponent(String(roleId))).replace(`{${"parent_role_id"}}`, encodeURIComponent(String(parentRoleId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Assign permissions to role.  If some of the permissions specified are already assigned, will skip them.
     * @summary Assign Permissions To Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {AddRolePermissions} addRolePermissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    assignPermissionsToRole: async (projId, envId, roleId, addRolePermissions, options = {}) => {
      assertParamExists("assignPermissionsToRole", "projId", projId);
      assertParamExists("assignPermissionsToRole", "envId", envId);
      assertParamExists("assignPermissionsToRole", "roleId", roleId);
      assertParamExists("assignPermissionsToRole", "addRolePermissions", addRolePermissions);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/roles/{role_id}/permissions`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        addRolePermissions,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Creates a new tenant role.
     * @summary Create Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {RoleCreate} roleCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRole: async (projId, envId, roleCreate, options = {}) => {
      assertParamExists("createRole", "projId", projId);
      assertParamExists("createRole", "envId", envId);
      assertParamExists("createRole", "roleCreate", roleCreate);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/roles`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        roleCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes a tenant role and all its related data. This includes any permissions granted to said role.
     * @summary Delete Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRole: async (projId, envId, roleId, options = {}) => {
      assertParamExists("deleteRole", "projId", projId);
      assertParamExists("deleteRole", "envId", envId);
      assertParamExists("deleteRole", "roleId", roleId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/roles/{role_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Gets a single tenant role, if such role exists.
     * @summary Get Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRole: async (projId, envId, roleId, options = {}) => {
      assertParamExists("getRole", "projId", projId);
      assertParamExists("getRole", "envId", envId);
      assertParamExists("getRole", "roleId", roleId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/roles/{role_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Lists all tenant roles.
     * @summary List Roles
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {boolean} [includeTotalCount] Include total count in response (default to false)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listRoles: async (projId, envId, page, perPage, includeTotalCount, options = {}) => {
      assertParamExists("listRoles", "projId", projId);
      assertParamExists("listRoles", "envId", envId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/roles`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      if (includeTotalCount !== void 0) {
        localVarQueryParameter["include_total_count"] = includeTotalCount;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * This endpoint is part of the role hierarchy feature.  Removes `parent_role_id` from the list of parent roles of role with id `role_id`. In other words, `role_id` will no longer be automatically assigned permissions that are granted to `parent_role_id`.  We can say the `role_id` **not longer extends** `parent_role_id` or **no longer inherits** from `parent_role_id`.
     * @summary Remove Parent Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {string} parentRoleId Either the unique id of the parent role, or the URL-friendly key of the parent role (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeParentRole: async (projId, envId, roleId, parentRoleId, options = {}) => {
      assertParamExists("removeParentRole", "projId", projId);
      assertParamExists("removeParentRole", "envId", envId);
      assertParamExists("removeParentRole", "roleId", roleId);
      assertParamExists("removeParentRole", "parentRoleId", parentRoleId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/roles/{role_id}/parents/{parent_role_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"role_id"}}`, encodeURIComponent(String(roleId))).replace(`{${"parent_role_id"}}`, encodeURIComponent(String(parentRoleId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Remove permissions from role.  If some of the permissions specified are already unassigned, will skip them.
     * @summary Remove Permissions From Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {RemoveRolePermissions} removeRolePermissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removePermissionsFromRole: async (projId, envId, roleId, removeRolePermissions, options = {}) => {
      assertParamExists("removePermissionsFromRole", "projId", projId);
      assertParamExists("removePermissionsFromRole", "envId", envId);
      assertParamExists("removePermissionsFromRole", "roleId", roleId);
      assertParamExists(
        "removePermissionsFromRole",
        "removeRolePermissions",
        removeRolePermissions
      );
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/roles/{role_id}/permissions`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        removeRolePermissions,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Partially updates a tenant role. Fields that will be provided will be completely overwritten.
     * @summary Update Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {RoleUpdate} roleUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRole: async (projId, envId, roleId, roleUpdate, options = {}) => {
      assertParamExists("updateRole", "projId", projId);
      assertParamExists("updateRole", "envId", envId);
      assertParamExists("updateRole", "roleId", roleId);
      assertParamExists("updateRole", "roleUpdate", roleUpdate);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/roles/{role_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        roleUpdate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var RolesApiFp = function(configuration) {
  const localVarAxiosParamCreator = RolesApiAxiosParamCreator(configuration);
  return {
    /**
     * This endpoint is part of the role hierarchy feature.  Makes role with id `role_id` extend the role with id `parent_role_id`. In other words, `role_id` will automatically be assigned any permissions that are granted to `parent_role_id`.  We can say the `role_id` **extends** `parent_role_id` or **inherits** from `parent_role_id`.  If `role_id` is already an ancestor of `parent_role_id`, the request will fail with HTTP 400 to prevent a cycle in the role hierarchy.
     * @summary Add Parent Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {string} parentRoleId Either the unique id of the parent role, or the URL-friendly key of the parent role (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addParentRole(projId, envId, roleId, parentRoleId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addParentRole(
        projId,
        envId,
        roleId,
        parentRoleId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios32.default, BASE_PATH, configuration);
    },
    /**
     * Assign permissions to role.  If some of the permissions specified are already assigned, will skip them.
     * @summary Assign Permissions To Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {AddRolePermissions} addRolePermissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async assignPermissionsToRole(projId, envId, roleId, addRolePermissions, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.assignPermissionsToRole(
        projId,
        envId,
        roleId,
        addRolePermissions,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios32.default, BASE_PATH, configuration);
    },
    /**
     * Creates a new tenant role.
     * @summary Create Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {RoleCreate} roleCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createRole(projId, envId, roleCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createRole(
        projId,
        envId,
        roleCreate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios32.default, BASE_PATH, configuration);
    },
    /**
     * Deletes a tenant role and all its related data. This includes any permissions granted to said role.
     * @summary Delete Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteRole(projId, envId, roleId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRole(
        projId,
        envId,
        roleId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios32.default, BASE_PATH, configuration);
    },
    /**
     * Gets a single tenant role, if such role exists.
     * @summary Get Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRole(projId, envId, roleId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getRole(
        projId,
        envId,
        roleId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios32.default, BASE_PATH, configuration);
    },
    /**
     * Lists all tenant roles.
     * @summary List Roles
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {boolean} [includeTotalCount] Include total count in response (default to false)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listRoles(projId, envId, page, perPage, includeTotalCount, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listRoles(
        projId,
        envId,
        page,
        perPage,
        includeTotalCount,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios32.default, BASE_PATH, configuration);
    },
    /**
     * This endpoint is part of the role hierarchy feature.  Removes `parent_role_id` from the list of parent roles of role with id `role_id`. In other words, `role_id` will no longer be automatically assigned permissions that are granted to `parent_role_id`.  We can say the `role_id` **not longer extends** `parent_role_id` or **no longer inherits** from `parent_role_id`.
     * @summary Remove Parent Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {string} parentRoleId Either the unique id of the parent role, or the URL-friendly key of the parent role (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removeParentRole(projId, envId, roleId, parentRoleId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.removeParentRole(
        projId,
        envId,
        roleId,
        parentRoleId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios32.default, BASE_PATH, configuration);
    },
    /**
     * Remove permissions from role.  If some of the permissions specified are already unassigned, will skip them.
     * @summary Remove Permissions From Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {RemoveRolePermissions} removeRolePermissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removePermissionsFromRole(projId, envId, roleId, removeRolePermissions, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.removePermissionsFromRole(
        projId,
        envId,
        roleId,
        removeRolePermissions,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios32.default, BASE_PATH, configuration);
    },
    /**
     * Partially updates a tenant role. Fields that will be provided will be completely overwritten.
     * @summary Update Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {RoleUpdate} roleUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateRole(projId, envId, roleId, roleUpdate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateRole(
        projId,
        envId,
        roleId,
        roleUpdate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios32.default, BASE_PATH, configuration);
    }
  };
};
var RolesApi = class extends BaseAPI {
  /**
   * This endpoint is part of the role hierarchy feature.  Makes role with id `role_id` extend the role with id `parent_role_id`. In other words, `role_id` will automatically be assigned any permissions that are granted to `parent_role_id`.  We can say the `role_id` **extends** `parent_role_id` or **inherits** from `parent_role_id`.  If `role_id` is already an ancestor of `parent_role_id`, the request will fail with HTTP 400 to prevent a cycle in the role hierarchy.
   * @summary Add Parent Role
   * @param {RolesApiAddParentRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RolesApi
   */
  addParentRole(requestParameters, options) {
    return RolesApiFp(this.configuration).addParentRole(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.roleId,
      requestParameters.parentRoleId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Assign permissions to role.  If some of the permissions specified are already assigned, will skip them.
   * @summary Assign Permissions To Role
   * @param {RolesApiAssignPermissionsToRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RolesApi
   */
  assignPermissionsToRole(requestParameters, options) {
    return RolesApiFp(this.configuration).assignPermissionsToRole(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.roleId,
      requestParameters.addRolePermissions,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Creates a new tenant role.
   * @summary Create Role
   * @param {RolesApiCreateRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RolesApi
   */
  createRole(requestParameters, options) {
    return RolesApiFp(this.configuration).createRole(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.roleCreate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Deletes a tenant role and all its related data. This includes any permissions granted to said role.
   * @summary Delete Role
   * @param {RolesApiDeleteRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RolesApi
   */
  deleteRole(requestParameters, options) {
    return RolesApiFp(this.configuration).deleteRole(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.roleId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Gets a single tenant role, if such role exists.
   * @summary Get Role
   * @param {RolesApiGetRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RolesApi
   */
  getRole(requestParameters, options) {
    return RolesApiFp(this.configuration).getRole(requestParameters.projId, requestParameters.envId, requestParameters.roleId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Lists all tenant roles.
   * @summary List Roles
   * @param {RolesApiListRolesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RolesApi
   */
  listRoles(requestParameters, options) {
    return RolesApiFp(this.configuration).listRoles(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.page,
      requestParameters.perPage,
      requestParameters.includeTotalCount,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * This endpoint is part of the role hierarchy feature.  Removes `parent_role_id` from the list of parent roles of role with id `role_id`. In other words, `role_id` will no longer be automatically assigned permissions that are granted to `parent_role_id`.  We can say the `role_id` **not longer extends** `parent_role_id` or **no longer inherits** from `parent_role_id`.
   * @summary Remove Parent Role
   * @param {RolesApiRemoveParentRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RolesApi
   */
  removeParentRole(requestParameters, options) {
    return RolesApiFp(this.configuration).removeParentRole(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.roleId,
      requestParameters.parentRoleId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Remove permissions from role.  If some of the permissions specified are already unassigned, will skip them.
   * @summary Remove Permissions From Role
   * @param {RolesApiRemovePermissionsFromRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RolesApi
   */
  removePermissionsFromRole(requestParameters, options) {
    return RolesApiFp(this.configuration).removePermissionsFromRole(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.roleId,
      requestParameters.removeRolePermissions,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Partially updates a tenant role. Fields that will be provided will be completely overwritten.
   * @summary Update Role
   * @param {RolesApiUpdateRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RolesApi
   */
  updateRole(requestParameters, options) {
    return RolesApiFp(this.configuration).updateRole(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.roleId,
      requestParameters.roleUpdate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/tenants-api.ts
var import_axios33 = __toESM(require("axios"));
var TenantsApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * Creates a new tenant inside the Permit.io system.  If the tenant is already created: will return 200 instead of 201, and will return the existing tenant object in the response body.
     * @summary Create Tenant
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {TenantCreate} tenantCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTenant: async (projId, envId, tenantCreate, options = {}) => {
      assertParamExists("createTenant", "projId", projId);
      assertParamExists("createTenant", "envId", envId);
      assertParamExists("createTenant", "tenantCreate", tenantCreate);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/tenants`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        tenantCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes the tenant and all its related data.
     * @summary Delete Tenant
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} tenantId Either the unique id of the tenant, or the URL-friendly key of the tenant (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTenant: async (projId, envId, tenantId, options = {}) => {
      assertParamExists("deleteTenant", "projId", projId);
      assertParamExists("deleteTenant", "envId", envId);
      assertParamExists("deleteTenant", "tenantId", tenantId);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/tenants/{tenant_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"tenant_id"}}`, encodeURIComponent(String(tenantId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes a user under a tenant.
     * @summary Delete Tenant User
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} tenantId Either the unique id of the tenant, or the URL-friendly key of the tenant (i.e: the \&quot;slug\&quot;).
     * @param {string} userId Either the unique id of the user, or the URL-friendly key of the user (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTenantUser: async (projId, envId, tenantId, userId, options = {}) => {
      assertParamExists("deleteTenantUser", "projId", projId);
      assertParamExists("deleteTenantUser", "envId", envId);
      assertParamExists("deleteTenantUser", "tenantId", tenantId);
      assertParamExists("deleteTenantUser", "userId", userId);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/tenants/{tenant_id}/users/{user_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"tenant_id"}}`, encodeURIComponent(String(tenantId))).replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Gets a tenant, if such tenant exists. Otherwise returns 404.
     * @summary Get Tenant
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} tenantId Either the unique id of the tenant, or the URL-friendly key of the tenant (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTenant: async (projId, envId, tenantId, options = {}) => {
      assertParamExists("getTenant", "projId", projId);
      assertParamExists("getTenant", "envId", envId);
      assertParamExists("getTenant", "tenantId", tenantId);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/tenants/{tenant_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"tenant_id"}}`, encodeURIComponent(String(tenantId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary List Tenant Users
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} tenantId Either the unique id of the tenant, or the URL-friendly key of the tenant (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} [search] Text search for the email field
     * @param {string} [role] Match users with a specific role
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTenantUsers: async (projId, tenantId, envId, search, role, page, perPage, options = {}) => {
      assertParamExists("listTenantUsers", "projId", projId);
      assertParamExists("listTenantUsers", "tenantId", tenantId);
      assertParamExists("listTenantUsers", "envId", envId);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/tenants/{tenant_id}/users`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"tenant_id"}}`, encodeURIComponent(String(tenantId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (search !== void 0) {
        localVarQueryParameter["search"] = search;
      }
      if (role !== void 0) {
        localVarQueryParameter["role"] = role;
      }
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Lists all the tenants defined within an environment.
     * @summary List Tenants
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} [search] Text search for the tenant name or key
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTenants: async (projId, envId, search, page, perPage, options = {}) => {
      assertParamExists("listTenants", "projId", projId);
      assertParamExists("listTenants", "envId", envId);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/tenants`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (search !== void 0) {
        localVarQueryParameter["search"] = search;
      }
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Partially updates the tenant definition. Fields that will be provided will be completely overwritten.
     * @summary Update Tenant
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} tenantId Either the unique id of the tenant, or the URL-friendly key of the tenant (i.e: the \&quot;slug\&quot;).
     * @param {TenantUpdate} tenantUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateTenant: async (projId, envId, tenantId, tenantUpdate, options = {}) => {
      assertParamExists("updateTenant", "projId", projId);
      assertParamExists("updateTenant", "envId", envId);
      assertParamExists("updateTenant", "tenantId", tenantId);
      assertParamExists("updateTenant", "tenantUpdate", tenantUpdate);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/tenants/{tenant_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"tenant_id"}}`, encodeURIComponent(String(tenantId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        tenantUpdate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var TenantsApiFp = function(configuration) {
  const localVarAxiosParamCreator = TenantsApiAxiosParamCreator(configuration);
  return {
    /**
     * Creates a new tenant inside the Permit.io system.  If the tenant is already created: will return 200 instead of 201, and will return the existing tenant object in the response body.
     * @summary Create Tenant
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {TenantCreate} tenantCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createTenant(projId, envId, tenantCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createTenant(
        projId,
        envId,
        tenantCreate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios33.default, BASE_PATH, configuration);
    },
    /**
     * Deletes the tenant and all its related data.
     * @summary Delete Tenant
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} tenantId Either the unique id of the tenant, or the URL-friendly key of the tenant (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteTenant(projId, envId, tenantId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTenant(
        projId,
        envId,
        tenantId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios33.default, BASE_PATH, configuration);
    },
    /**
     * Deletes a user under a tenant.
     * @summary Delete Tenant User
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} tenantId Either the unique id of the tenant, or the URL-friendly key of the tenant (i.e: the \&quot;slug\&quot;).
     * @param {string} userId Either the unique id of the user, or the URL-friendly key of the user (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteTenantUser(projId, envId, tenantId, userId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTenantUser(
        projId,
        envId,
        tenantId,
        userId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios33.default, BASE_PATH, configuration);
    },
    /**
     * Gets a tenant, if such tenant exists. Otherwise returns 404.
     * @summary Get Tenant
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} tenantId Either the unique id of the tenant, or the URL-friendly key of the tenant (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTenant(projId, envId, tenantId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getTenant(
        projId,
        envId,
        tenantId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios33.default, BASE_PATH, configuration);
    },
    /**
     *
     * @summary List Tenant Users
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} tenantId Either the unique id of the tenant, or the URL-friendly key of the tenant (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} [search] Text search for the email field
     * @param {string} [role] Match users with a specific role
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listTenantUsers(projId, tenantId, envId, search, role, page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listTenantUsers(
        projId,
        tenantId,
        envId,
        search,
        role,
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios33.default, BASE_PATH, configuration);
    },
    /**
     * Lists all the tenants defined within an environment.
     * @summary List Tenants
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} [search] Text search for the tenant name or key
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listTenants(projId, envId, search, page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listTenants(
        projId,
        envId,
        search,
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios33.default, BASE_PATH, configuration);
    },
    /**
     * Partially updates the tenant definition. Fields that will be provided will be completely overwritten.
     * @summary Update Tenant
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} tenantId Either the unique id of the tenant, or the URL-friendly key of the tenant (i.e: the \&quot;slug\&quot;).
     * @param {TenantUpdate} tenantUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateTenant(projId, envId, tenantId, tenantUpdate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateTenant(
        projId,
        envId,
        tenantId,
        tenantUpdate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios33.default, BASE_PATH, configuration);
    }
  };
};
var TenantsApi = class extends BaseAPI {
  /**
   * Creates a new tenant inside the Permit.io system.  If the tenant is already created: will return 200 instead of 201, and will return the existing tenant object in the response body.
   * @summary Create Tenant
   * @param {TenantsApiCreateTenantRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TenantsApi
   */
  createTenant(requestParameters, options) {
    return TenantsApiFp(this.configuration).createTenant(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.tenantCreate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Deletes the tenant and all its related data.
   * @summary Delete Tenant
   * @param {TenantsApiDeleteTenantRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TenantsApi
   */
  deleteTenant(requestParameters, options) {
    return TenantsApiFp(this.configuration).deleteTenant(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.tenantId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Deletes a user under a tenant.
   * @summary Delete Tenant User
   * @param {TenantsApiDeleteTenantUserRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TenantsApi
   */
  deleteTenantUser(requestParameters, options) {
    return TenantsApiFp(this.configuration).deleteTenantUser(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.tenantId,
      requestParameters.userId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Gets a tenant, if such tenant exists. Otherwise returns 404.
   * @summary Get Tenant
   * @param {TenantsApiGetTenantRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TenantsApi
   */
  getTenant(requestParameters, options) {
    return TenantsApiFp(this.configuration).getTenant(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.tenantId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary List Tenant Users
   * @param {TenantsApiListTenantUsersRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TenantsApi
   */
  listTenantUsers(requestParameters, options) {
    return TenantsApiFp(this.configuration).listTenantUsers(
      requestParameters.projId,
      requestParameters.tenantId,
      requestParameters.envId,
      requestParameters.search,
      requestParameters.role,
      requestParameters.page,
      requestParameters.perPage,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Lists all the tenants defined within an environment.
   * @summary List Tenants
   * @param {TenantsApiListTenantsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TenantsApi
   */
  listTenants(requestParameters, options) {
    return TenantsApiFp(this.configuration).listTenants(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.search,
      requestParameters.page,
      requestParameters.perPage,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Partially updates the tenant definition. Fields that will be provided will be completely overwritten.
   * @summary Update Tenant
   * @param {TenantsApiUpdateTenantRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TenantsApi
   */
  updateTenant(requestParameters, options) {
    return TenantsApiFp(this.configuration).updateTenant(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.tenantId,
      requestParameters.tenantUpdate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/user-attributes-api.ts
var import_axios34 = __toESM(require("axios"));

// src/openapi/api/users-api.ts
var import_axios35 = __toESM(require("axios"));
var UsersApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * Assigns a role to the user within the tenant.  The tenant defines the scope of the assignment. In other words, the role is effective only within the tenant.
     * @summary Assign Role To User
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} userId Either the unique id of the user, or the URL-friendly key of the user (i.e: the \&quot;slug\&quot;).
     * @param {UserRoleCreate} userRoleCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    assignRoleToUser: async (projId, envId, userId, userRoleCreate, options = {}) => {
      assertParamExists("assignRoleToUser", "projId", projId);
      assertParamExists("assignRoleToUser", "envId", envId);
      assertParamExists("assignRoleToUser", "userId", userId);
      assertParamExists("assignRoleToUser", "userRoleCreate", userRoleCreate);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/users/{user_id}/roles`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userRoleCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Creates a new user inside the Permit.io system, from that point forward you may run permission checks on that user.  If the user is already created: will return 200 instead of 201, and will return the existing user object in the response body.
     * @summary Create User
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {UserCreate} userCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUser: async (projId, envId, userCreate, options = {}) => {
      assertParamExists("createUser", "projId", projId);
      assertParamExists("createUser", "envId", envId);
      assertParamExists("createUser", "userCreate", userCreate);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/users`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes the user and all its related data.
     * @summary Delete User
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} userId Either the unique id of the user, or the URL-friendly key of the user (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser: async (projId, envId, userId, options = {}) => {
      assertParamExists("deleteUser", "projId", projId);
      assertParamExists("deleteUser", "envId", envId);
      assertParamExists("deleteUser", "userId", userId);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/users/{user_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Gets a user, if such user exists. Otherwise returns 404.
     * @summary Get User
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} userId Either the unique id of the user, or the URL-friendly key of the user (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUser: async (projId, envId, userId, options = {}) => {
      assertParamExists("getUser", "projId", projId);
      assertParamExists("getUser", "envId", envId);
      assertParamExists("getUser", "userId", userId);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/users/{user_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Lists all the users defined within an environment.
     * @summary List Users
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} [search] Text search for the email field
     * @param {string} [role] Match users with a specific role
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listUsers: async (projId, envId, search, role, page, perPage, options = {}) => {
      assertParamExists("listUsers", "projId", projId);
      assertParamExists("listUsers", "envId", envId);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/users`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (search !== void 0) {
        localVarQueryParameter["search"] = search;
      }
      if (role !== void 0) {
        localVarQueryParameter["role"] = role;
      }
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Replace User
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} userId Either the unique id of the user, or the URL-friendly key of the user (i.e: the \&quot;slug\&quot;).
     * @param {UserCreate} userCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    replaceUser: async (projId, envId, userId, userCreate, options = {}) => {
      assertParamExists("replaceUser", "projId", projId);
      assertParamExists("replaceUser", "envId", envId);
      assertParamExists("replaceUser", "userId", userId);
      assertParamExists("replaceUser", "userCreate", userCreate);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/users/{user_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Unassigns the role from the user within the tenant.  The tenant defines the scope of the assignment. In other words, the role is effective only within the tenant.  If the role is not actually assigned, will return 404.
     * @summary Unassign Role From User
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} userId Either the unique id of the user, or the URL-friendly key of the user (i.e: the \&quot;slug\&quot;).
     * @param {UserRoleRemove} userRoleRemove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unassignRoleFromUser: async (projId, envId, userId, userRoleRemove, options = {}) => {
      assertParamExists("unassignRoleFromUser", "projId", projId);
      assertParamExists("unassignRoleFromUser", "envId", envId);
      assertParamExists("unassignRoleFromUser", "userId", userId);
      assertParamExists("unassignRoleFromUser", "userRoleRemove", userRoleRemove);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/users/{user_id}/roles`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userRoleRemove,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Partially updates the user definition. Fields that will be provided will be completely overwritten.
     * @summary Update User
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} userId Either the unique id of the user, or the URL-friendly key of the user (i.e: the \&quot;slug\&quot;).
     * @param {UserUpdate} userUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUser: async (projId, envId, userId, userUpdate, options = {}) => {
      assertParamExists("updateUser", "projId", projId);
      assertParamExists("updateUser", "envId", envId);
      assertParamExists("updateUser", "userId", userId);
      assertParamExists("updateUser", "userUpdate", userUpdate);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/users/{user_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userUpdate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var UsersApiFp = function(configuration) {
  const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration);
  return {
    /**
     * Assigns a role to the user within the tenant.  The tenant defines the scope of the assignment. In other words, the role is effective only within the tenant.
     * @summary Assign Role To User
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} userId Either the unique id of the user, or the URL-friendly key of the user (i.e: the \&quot;slug\&quot;).
     * @param {UserRoleCreate} userRoleCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async assignRoleToUser(projId, envId, userId, userRoleCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.assignRoleToUser(
        projId,
        envId,
        userId,
        userRoleCreate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios35.default, BASE_PATH, configuration);
    },
    /**
     * Creates a new user inside the Permit.io system, from that point forward you may run permission checks on that user.  If the user is already created: will return 200 instead of 201, and will return the existing user object in the response body.
     * @summary Create User
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {UserCreate} userCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createUser(projId, envId, userCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(
        projId,
        envId,
        userCreate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios35.default, BASE_PATH, configuration);
    },
    /**
     * Deletes the user and all its related data.
     * @summary Delete User
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} userId Either the unique id of the user, or the URL-friendly key of the user (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteUser(projId, envId, userId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(
        projId,
        envId,
        userId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios35.default, BASE_PATH, configuration);
    },
    /**
     * Gets a user, if such user exists. Otherwise returns 404.
     * @summary Get User
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} userId Either the unique id of the user, or the URL-friendly key of the user (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUser(projId, envId, userId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(
        projId,
        envId,
        userId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios35.default, BASE_PATH, configuration);
    },
    /**
     * Lists all the users defined within an environment.
     * @summary List Users
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} [search] Text search for the email field
     * @param {string} [role] Match users with a specific role
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listUsers(projId, envId, search, role, page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listUsers(
        projId,
        envId,
        search,
        role,
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios35.default, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Replace User
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} userId Either the unique id of the user, or the URL-friendly key of the user (i.e: the \&quot;slug\&quot;).
     * @param {UserCreate} userCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async replaceUser(projId, envId, userId, userCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.replaceUser(
        projId,
        envId,
        userId,
        userCreate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios35.default, BASE_PATH, configuration);
    },
    /**
     * Unassigns the role from the user within the tenant.  The tenant defines the scope of the assignment. In other words, the role is effective only within the tenant.  If the role is not actually assigned, will return 404.
     * @summary Unassign Role From User
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} userId Either the unique id of the user, or the URL-friendly key of the user (i.e: the \&quot;slug\&quot;).
     * @param {UserRoleRemove} userRoleRemove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async unassignRoleFromUser(projId, envId, userId, userRoleRemove, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.unassignRoleFromUser(
        projId,
        envId,
        userId,
        userRoleRemove,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios35.default, BASE_PATH, configuration);
    },
    /**
     * Partially updates the user definition. Fields that will be provided will be completely overwritten.
     * @summary Update User
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} userId Either the unique id of the user, or the URL-friendly key of the user (i.e: the \&quot;slug\&quot;).
     * @param {UserUpdate} userUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateUser(projId, envId, userId, userUpdate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(
        projId,
        envId,
        userId,
        userUpdate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios35.default, BASE_PATH, configuration);
    }
  };
};
var UsersApi = class extends BaseAPI {
  /**
   * Assigns a role to the user within the tenant.  The tenant defines the scope of the assignment. In other words, the role is effective only within the tenant.
   * @summary Assign Role To User
   * @param {UsersApiAssignRoleToUserRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  assignRoleToUser(requestParameters, options) {
    return UsersApiFp(this.configuration).assignRoleToUser(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.userId,
      requestParameters.userRoleCreate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Creates a new user inside the Permit.io system, from that point forward you may run permission checks on that user.  If the user is already created: will return 200 instead of 201, and will return the existing user object in the response body.
   * @summary Create User
   * @param {UsersApiCreateUserRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  createUser(requestParameters, options) {
    return UsersApiFp(this.configuration).createUser(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.userCreate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Deletes the user and all its related data.
   * @summary Delete User
   * @param {UsersApiDeleteUserRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  deleteUser(requestParameters, options) {
    return UsersApiFp(this.configuration).deleteUser(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.userId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Gets a user, if such user exists. Otherwise returns 404.
   * @summary Get User
   * @param {UsersApiGetUserRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  getUser(requestParameters, options) {
    return UsersApiFp(this.configuration).getUser(requestParameters.projId, requestParameters.envId, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Lists all the users defined within an environment.
   * @summary List Users
   * @param {UsersApiListUsersRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  listUsers(requestParameters, options) {
    return UsersApiFp(this.configuration).listUsers(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.search,
      requestParameters.role,
      requestParameters.page,
      requestParameters.perPage,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Replace User
   * @param {UsersApiReplaceUserRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  replaceUser(requestParameters, options) {
    return UsersApiFp(this.configuration).replaceUser(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.userId,
      requestParameters.userCreate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Unassigns the role from the user within the tenant.  The tenant defines the scope of the assignment. In other words, the role is effective only within the tenant.  If the role is not actually assigned, will return 404.
   * @summary Unassign Role From User
   * @param {UsersApiUnassignRoleFromUserRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  unassignRoleFromUser(requestParameters, options) {
    return UsersApiFp(this.configuration).unassignRoleFromUser(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.userId,
      requestParameters.userRoleRemove,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Partially updates the user definition. Fields that will be provided will be completely overwritten.
   * @summary Update User
   * @param {UsersApiUpdateUserRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  updateUser(requestParameters, options) {
    return UsersApiFp(this.configuration).updateUser(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.userId,
      requestParameters.userUpdate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/users-elements-data-api.ts
var import_axios36 = __toESM(require("axios"));

// src/openapi/configuration.ts
var Configuration = class {
  constructor(param = {}) {
    this.apiKey = param.apiKey;
    this.username = param.username;
    this.password = param.password;
    this.accessToken = param.accessToken;
    this.basePath = param.basePath;
    this.baseOptions = param.baseOptions;
    this.formDataCtor = param.formDataCtor;
  }
  /**
   * Check if the given MIME is a JSON MIME.
   * JSON MIME examples:
   *   application/json
   *   application/json; charset=UTF8
   *   APPLICATION/JSON
   *   application/vnd.company+json
   * @param mime - MIME (Multipurpose Internet Mail Extensions)
   * @return True if the given MIME is JSON, false otherwise.
   */
  isJsonMime(mime) {
    const jsonMime = new RegExp(
      "^(application/json|[^;/ 	]+/[^;/ 	]+[+]json)[ 	]*(;.*)?$",
      "i"
    );
    return mime !== null && (jsonMime.test(mime) || mime.toLowerCase() === "application/json-patch+json");
  }
};

// src/api/base.ts
var import_axios37 = __toESM(require("axios"));

// src/api/context.ts
var API_ACCESS_LEVELS = [
  "ORGANIZATION_LEVEL_API_KEY" /* ORGANIZATION_LEVEL_API_KEY */,
  "PROJECT_LEVEL_API_KEY" /* PROJECT_LEVEL_API_KEY */,
  "ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */
];
var ApiContextLevel = /* @__PURE__ */ ((ApiContextLevel2) => {
  ApiContextLevel2[ApiContextLevel2["WAIT_FOR_INIT"] = 0] = "WAIT_FOR_INIT";
  ApiContextLevel2[ApiContextLevel2["ORGANIZATION"] = 1] = "ORGANIZATION";
  ApiContextLevel2[ApiContextLevel2["PROJECT"] = 2] = "PROJECT";
  ApiContextLevel2[ApiContextLevel2["ENVIRONMENT"] = 3] = "ENVIRONMENT";
  return ApiContextLevel2;
})(ApiContextLevel || {});
var PermitContextError = class extends Error {
  constructor(message) {
    super(message);
  }
};
var PermitContextChangeError = class extends Error {
  constructor(message) {
    super(message);
  }
};
var ApiContext = class {
  constructor() {
    this._level = "WAIT_FOR_INIT" /* WAIT_FOR_INIT */;
    this._permittedOrganization = null;
    this._permittedProject = null;
    this._permittedEnvironment = null;
    this._contextLevel = 0 /* WAIT_FOR_INIT */;
    this._organization = null;
    this._project = null;
    this._environment = null;
  }
  /**
   * Do not call this method directly!
   */
  _saveApiKeyAccessibleScope(org, project, environment) {
    this._permittedOrganization = org;
    if (project && environment) {
      this._permittedProject = project;
      this._permittedEnvironment = environment;
      this._level = "ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */;
    } else if (project) {
      this._permittedProject = project;
      this._permittedEnvironment = null;
      this._level = "PROJECT_LEVEL_API_KEY" /* PROJECT_LEVEL_API_KEY */;
    } else {
      this._permittedProject = null;
      this._permittedEnvironment = null;
      this._level = "ORGANIZATION_LEVEL_API_KEY" /* ORGANIZATION_LEVEL_API_KEY */;
    }
  }
  /**
   * Get the current API key access level.
   */
  get permittedAccessLevel() {
    return this._level;
  }
  /**
   * Get the current API key level.
   * @deprecated replaced with permit.config.apiContext.permittedAccessLevel
   */
  get level() {
    return this._level;
  }
  /**
   * Get the current SDK context level.
   */
  get contextLevel() {
    return this._contextLevel;
  }
  /**
   * Get the current organization in the context.
   */
  get organization() {
    return this._organization;
  }
  /**
   * Get the current project in the context.
   */
  get project() {
    return this._project;
  }
  /**
   * Get the current environment in the context.
   */
  get environment() {
    return this._environment;
  }
  verifyCanAccessOrg(org) {
    if (org !== this._permittedOrganization) {
      throw new PermitContextChangeError(
        `You cannot set an SDK context with org '${org}' due to insufficient API Key permissions`
      );
    }
  }
  verifyCanAccessProject(org, project) {
    this.verifyCanAccessOrg(org);
    if (this._permittedProject !== null && project !== this._permittedProject) {
      throw new PermitContextChangeError(
        `You cannot set an SDK context with project '${project}' due to insufficient API Key permissions`
      );
    }
  }
  verifyCanAccessEnvironment(org, project, environment) {
    this.verifyCanAccessProject(org, project);
    if (this._permittedEnvironment !== null && environment !== this._permittedEnvironment) {
      throw new PermitContextChangeError(
        `You cannot set an SDK context with environment '${environment}' due to insufficient API Key permissions`
      );
    }
  }
  /**
   * Set the context to organization level.
   * @param org The organization key.
   */
  setOrganizationLevelContext(org) {
    this.verifyCanAccessOrg(org);
    this._contextLevel = 1 /* ORGANIZATION */;
    this._organization = org;
    this._project = null;
    this._environment = null;
  }
  /**
   * Set the context to project level.
   * @param org The organization key.
   * @param project The project key.
   */
  setProjectLevelContext(org, project) {
    this.verifyCanAccessProject(org, project);
    this._contextLevel = 2 /* PROJECT */;
    this._organization = org;
    this._project = project;
    this._environment = null;
  }
  /**
   * Set the context to environment level.
   * @param org The organization key.
   * @param project The project key.
   * @param environment The environment key.
   */
  setEnvironmentLevelContext(org, project, environment) {
    this.verifyCanAccessEnvironment(org, project, environment);
    this._contextLevel = 3 /* ENVIRONMENT */;
    this._organization = org;
    this._project = project;
    this._environment = environment;
  }
  /**
   * Get the API project and environment parameters from an environment-level context.
   * @returns An object containing the project and environment IDs.
   * @throws {@link PermitContextError} If the API context is not set to environment level or the project or environment is null.
   */
  get environmentContext() {
    if (this._contextLevel !== 3 /* ENVIRONMENT */ || this._project === null || this._environment === null) {
      throw new PermitContextError(
        `You cannot get environment context, current api context is: ${ApiContextLevel[this._contextLevel]}`
      );
    }
    return {
      projId: this._project,
      envId: this._environment
    };
  }
};

// src/api/base.ts
var PermitApiError = class extends Error {
  constructor(message, originalError) {
    super(message);
    this.originalError = originalError;
  }
  get formattedAxiosError() {
    var _a;
    return {
      code: this.originalError.code,
      message: this.message,
      error: (_a = this.originalError.response) == null ? void 0 : _a.data,
      status: this.originalError.status
    };
  }
  get request() {
    return this.originalError.request;
  }
  get response() {
    return this.originalError.response;
  }
};
var BasePermitApi = class {
  constructor(config, logger) {
    this.config = config;
    this.logger = logger;
    const version = process.env.npm_package_version ?? "unknown";
    this.openapiClientConfig = new Configuration({
      basePath: `${this.config.apiUrl}`,
      accessToken: this.config.token,
      baseOptions: {
        headers: {
          "X-Permit-SDK-Version": `node:${version}`
        }
      }
    });
    this.scopeApi = new APIKeysApi(this.openapiClientConfig, BASE_PATH, this.config.axiosInstance);
  }
  /**
   * Sets the API context and permitted access level based on the API key scope.
   */
  async setContextFromApiKey() {
    var _a, _b;
    try {
      this.logger.debug("Fetching api key scope");
      const response = await this.scopeApi.getApiKeyScope();
      if (response.data.organization_id !== void 0 && response.data.organization_id !== null) {
        this.config.apiContext._saveApiKeyAccessibleScope(
          response.data.organization_id,
          response.data.project_id,
          response.data.environment_id
        );
        if (response.data.project_id !== void 0 && response.data.project_id !== null) {
          if (response.data.environment_id !== void 0 && response.data.environment_id !== null) {
            this.logger.debug(`setting: environment-level api context`);
            this.config.apiContext.setEnvironmentLevelContext(
              response.data.organization_id,
              response.data.project_id,
              response.data.environment_id
            );
            return;
          }
          this.logger.debug(`setting: project-level api context`);
          this.config.apiContext.setProjectLevelContext(
            response.data.organization_id,
            response.data.project_id
          );
          return;
        }
        this.logger.debug(`setting: organization-level api context`);
        this.config.apiContext.setOrganizationLevelContext(response.data.organization_id);
        return;
      }
      throw new PermitContextError("could not set api context level");
    } catch (err) {
      if (import_axios37.default.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.getApiKeyScope(), err: ${JSON.stringify(
            (_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data
          )}`
        );
      }
      throw new PermitContextError(
        "could not fetch the api key scope in order to set the api context level"
      );
    }
  }
  /**
   * Ensure that the API Key has the necessary permissions to successfully call the API endpoint.
   * Note that this check is not foolproof, and the API may still throw 401.
   * @param requiredAccessLevel The required API Key Access level for the endpoint.
   * @throws PermitContextError If the currently set API key access level does not match the required access level.
   */
  async ensureAccessLevel(requiredAccessLevel) {
    if (this.config.apiContext.contextLevel === 0 /* WAIT_FOR_INIT */ || this.config.apiContext.permittedAccessLevel === "WAIT_FOR_INIT" /* WAIT_FOR_INIT */) {
      await this.setContextFromApiKey();
    }
    if (requiredAccessLevel !== this.config.apiContext.permittedAccessLevel) {
      if (API_ACCESS_LEVELS.indexOf(requiredAccessLevel) < API_ACCESS_LEVELS.indexOf(this.config.apiContext.permittedAccessLevel)) {
        throw new PermitContextError(
          `You're trying to use an SDK method that requires an API Key with access level: ${requiredAccessLevel}, however the SDK is running with an API key with level ${this.config.apiContext.permittedAccessLevel}.`
        );
      }
    }
  }
  /**
   * Ensure that the API context matches the required endpoint context.
   * @param requiredContext The required API context level for the endpoint.
   * @throws PermitContextError If the currently set API context level does not match the required context level.
   */
  async ensureContext(requiredContext) {
    if (this.config.apiContext.contextLevel === 0 /* WAIT_FOR_INIT */ || this.config.apiContext.permittedAccessLevel === "WAIT_FOR_INIT" /* WAIT_FOR_INIT */) {
      await this.setContextFromApiKey();
    }
    if (this.config.apiContext.contextLevel < requiredContext || this.config.apiContext.contextLevel === 0 /* WAIT_FOR_INIT */) {
      throw new PermitContextError(
        `You're trying to use an SDK method that requires an API context of ${ApiContextLevel[requiredContext]}, however the SDK is running in a less specific context level: ${ApiContextLevel[this.config.apiContext.contextLevel]}.`
      );
    }
  }
  handleApiError(err) {
    var _a, _b, _c;
    if (import_axios37.default.isAxiosError(err)) {
      const logMessage = `Got error status code: ${(_a = err.response) == null ? void 0 : _a.status}, err: ${JSON.stringify(
        (_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data
      )}`;
      const apiMessage = (_c = err.response) == null ? void 0 : _c.data.message;
      this.logger.error(logMessage);
      throw new PermitApiError(apiMessage, err);
    } else {
      throw err;
    }
  }
};
var BaseFactsPermitAPI = class extends BasePermitApi {
  constructor(config, logger) {
    super(config, logger);
    this.config = config;
    this.logger = logger;
    if (config.proxyFactsViaPdp) {
      this.openapiClientConfig = new Configuration({
        basePath: `${this.config.pdp}`,
        accessToken: this.config.token,
        baseOptions: {
          headers: {
            ...this.openapiClientConfig.baseOptions.headers,
            ...this.config.factsSyncTimeout !== null && {
              "X-Wait-Timeout": this.config.factsSyncTimeout.toString()
            },
            ...this.config.factsSyncTimeoutPolicy && {
              "X-Timeout-Policy": this.config.factsSyncTimeoutPolicy
            }
          }
        }
      });
    }
  }
  clone() {
    return new this.constructor(this.config, this.logger);
  }
  waitForSync(timeout, policy) {
    if (this.config.proxyFactsViaPdp) {
      const clone = this.clone();
      clone.openapiClientConfig.baseOptions.headers["X-Wait-Timeout"] = timeout === null ? "" : timeout.toString();
      const timeoutPolicy = policy || this.config.factsSyncTimeoutPolicy;
      if (timeoutPolicy) {
        clone.openapiClientConfig.baseOptions.headers["X-Timeout-Policy"] = timeoutPolicy;
      }
      return clone;
    } else {
      this.logger.warn(
        "Attempted to wait for sync, but 'proxyFactsViaPdp' is not enabled. Ignoring."
      );
      return this;
    }
  }
};

// src/api/condition-set-rules.ts
var ConditionSetRulesApi2 = class extends BasePermitApi {
  /**
   * Creates an instance of the ConditionSetRulesApi.
   * @param config - The configuration object for the Permit SDK.
   * @param logger - The logger instance for logging.
   */
  constructor(config, logger) {
    super(config, logger);
    this.setRules = new ConditionSetRulesApi(
      this.openapiClientConfig,
      BASE_PATH,
      this.config.axiosInstance
    );
  }
  /**
   * Retrieves a list of condition set rules based on the specified parameters.
   *
   * @param params - parameters for filtering and pagination, @see {@link IListConditionSetRules}
   * @returns A promise that resolves to an array of condition set rules.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async list(params) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    const { userSetKey, permissionKey, resourceSetKey, page = 1, perPage = 100 } = params;
    try {
      return (await this.setRules.listSetPermissions({
        ...this.config.apiContext.environmentContext,
        userSet: userSetKey,
        permission: permissionKey,
        resourceSet: resourceSetKey,
        page,
        perPage
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Creates a new condition set rule.
   *
   * @param rule - The condition set rule to create.
   * @returns A promise that resolves to the created condition set rule.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async create(rule) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.setRules.assignSetPermissions({
        ...this.config.apiContext.environmentContext,
        conditionSetRuleCreate: rule
      })).data[0];
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Deletes a condition set rule.
   *
   * @param rule - The condition set rule to delete.
   * @returns A promise that resolves when the condition set rule is deleted.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async delete(rule) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.setRules.unassignSetPermissions({
        ...this.config.apiContext.environmentContext,
        conditionSetRuleRemove: rule
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
};

// src/api/condition-sets.ts
var ConditionSetsApi2 = class extends BasePermitApi {
  /**
   * Creates an instance of the ConditionSetsApi.
   * @param config - The configuration object for the Permit SDK.
   * @param logger - The logger instance for logging.
   */
  constructor(config, logger) {
    super(config, logger);
    this.conditionSets = new ConditionSetsApi(
      this.openapiClientConfig,
      BASE_PATH,
      this.config.axiosInstance
    );
  }
  /**
   * Retrieves a list of condition sets.
   *
   * @param pagination The pagination options, @see {@link IPagination}
   * @returns A promise that resolves to an array of condition sets.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async list(pagination) {
    const { page = 1, perPage = 100 } = pagination ?? {};
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.conditionSets.listConditionSets({
        ...this.config.apiContext.environmentContext,
        page,
        perPage
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Retrieves a condition set by its key.
   *
   * @param conditionSetKey The key of the condition set.
   * @returns A promise that resolves to the condition set.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async get(conditionSetKey) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.conditionSets.getConditionSet({
        ...this.config.apiContext.environmentContext,
        conditionSetId: conditionSetKey
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Retrieves a condition set by its key.
   * Alias for the {@link get} method.
   *
   * @param conditionSetKey The key of the condition set.
   * @returns A promise that resolves to the condition set.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async getByKey(conditionSetKey) {
    return await this.get(conditionSetKey);
  }
  /**
   * Retrieves a condition set by its ID.
   * Alias for the {@link get} method.
   *
   * @param conditionSetId The ID of the condition set.
   * @returns A promise that resolves to the condition set.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async getById(conditionSetId) {
    return await this.get(conditionSetId);
  }
  /**
   * Creates a new condition set.
   *
   * @param conditionSetData The data for the new condition set.
   * @returns A promise that resolves to the created condition set.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async create(conditionSetData) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.conditionSets.createConditionSet({
        ...this.config.apiContext.environmentContext,
        conditionSetCreate: conditionSetData
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Updates a condition set.
   *
   * @param conditionSetKey The key of the condition set.
   * @param conditionSetData The updated data for the condition set.
   * @returns A promise that resolves to the updated condition set.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async update(conditionSetKey, conditionSetData) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.conditionSets.updateConditionSet({
        ...this.config.apiContext.environmentContext,
        conditionSetId: conditionSetKey,
        conditionSetUpdate: conditionSetData
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Deletes a condition set.
   *
   * @param conditionSetKey The key of the condition set to delete.
   * @returns A promise that resolves when the condition set is deleted.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async delete(conditionSetKey) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      await this.conditionSets.deleteConditionSet({
        ...this.config.apiContext.environmentContext,
        conditionSetId: conditionSetKey
      });
    } catch (err) {
      this.handleApiError(err);
    }
  }
};

// src/api/deprecated.ts
var import_axios38 = __toESM(require("axios"));
var DeprecatedApiClient = class extends BasePermitApi {
  /**
   * Creates an instance of DeprecatedApiClient.
   * @param config - The configuration object for the Permit SDK.
   * @param logger - The logger object for logging.
   */
  constructor(config, logger) {
    super(config, logger);
    this._users = new UsersApi(this.openapiClientConfig, BASE_PATH, this.config.axiosInstance);
    this._tenants = new TenantsApi(this.openapiClientConfig, BASE_PATH, this.config.axiosInstance);
    this._roles = new RolesApi(this.openapiClientConfig, BASE_PATH, this.config.axiosInstance);
    this._conditionSets = new ConditionSetsApi(
      this.openapiClientConfig,
      BASE_PATH,
      this.config.axiosInstance
    );
    this._conditionSetRules = new ConditionSetRulesApi(
      this.openapiClientConfig,
      BASE_PATH,
      this.config.axiosInstance
    );
    this._roleAssignments = new RoleAssignmentsApi(
      this.openapiClientConfig,
      BASE_PATH,
      this.config.axiosInstance
    );
    this._resources = new ResourcesApi(
      this.openapiClientConfig,
      BASE_PATH,
      this.config.axiosInstance
    );
  }
  /**
   * Retrieves a list of users.
   * @returns A promise that resolves to an array of UserRead objects representing the users.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.users.list()
   */
  async listUsers() {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._users.listUsers({
        ...this.config.apiContext.environmentContext
      });
      this.logger.debug(`[${response.status}] permit.api.listUsers()`);
      return response.data.data;
    } catch (err) {
      if (import_axios38.default.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.getUser(), err: ${JSON.stringify(
            (_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data
          )}`
        );
      }
      throw err;
    }
  }
  /**
   * Retrieves a list of roles.
   * @returns A promise that resolves to an array of RoleRead objects representing the roles.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.roles.list()
   */
  async listRoles() {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._roles.listRoles({
        ...this.config.apiContext.environmentContext
      });
      this.logger.debug(`[${response.status}] permit.api.listRoles()`);
      return response.data;
    } catch (err) {
      if (import_axios38.default.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.listRoles(), err: ${JSON.stringify(
            (_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data
          )}`
        );
      }
      throw err;
    }
  }
  /**
   * Retrieves a list of condition sets.
   * @param type - The type of the condition set, either `userset` or `resourceset`.
   * @param page - The page number.
   * @param perPage - The number of items per page.
   * @returns A promise that resolves to an array of ConditionSetRead objects representing the condition sets.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.conditionSets.list()
   */
  async listConditionSets(type, page, perPage) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._conditionSets.listConditionSets({
        ...this.config.apiContext.environmentContext,
        type,
        page,
        perPage
      });
      this.logger.debug(`[${response.status}] permit.api.listRoles()`);
      return response.data;
    } catch (err) {
      if (import_axios38.default.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.listRoles(), err: ${JSON.stringify(
            (_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data
          )}`
        );
      }
      throw err;
    }
  }
  /**
   * Retrieves a list of condition set rules.
   * @param page - The page number.
   * @param perPage - The number of items per page.
   * @returns A promise that resolves to an array of ConditionSetRuleRead objects representing the condition set rules.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.conditionSetRules.list()
   */
  async listConditionSetsRules(page, perPage) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._conditionSetRules.listSetPermissions({
        ...this.config.apiContext.environmentContext,
        page,
        perPage
      });
      this.logger.debug(`[${response.status}] permit.api.listRoles()`);
      return response.data;
    } catch (err) {
      if (import_axios38.default.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.listRoles(), err: ${JSON.stringify(
            (_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data
          )}`
        );
      }
      throw err;
    }
  }
  /**
   * Retrieves a user by ID or key
   * @param userId - The ID or the key of the user.
   * @returns A promise that resolves to a UserRead object representing the user.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.users.get()
   */
  async getUser(userId) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._users.getUser({
        ...this.config.apiContext.environmentContext,
        userId
      });
      this.logger.debug(`[${response.status}] permit.api.getUser(${userId})`);
      return response.data;
    } catch (err) {
      if (import_axios38.default.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.getUser(${userId}), err: ${JSON.stringify(
            (_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data
          )}`
        );
      }
      throw err;
    }
  }
  /**
   * Retrieves a tenant by ID or key.
   * @param tenantId - The ID or the key of the tenant.
   * @returns A promise that resolves to a TenantRead object representing the tenant.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.tenants.get()
   */
  async getTenant(tenantId) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._tenants.getTenant({
        ...this.config.apiContext.environmentContext,
        tenantId
      });
      this.logger.debug(`[${response.status}] permit.api.getTenant(${tenantId})`);
      return response.data;
    } catch (err) {
      if (import_axios38.default.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.getTenant(${tenantId}), err: ${JSON.stringify(
            (_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data
          )}`
        );
      }
      throw err;
    }
  }
  /**
   * Retrieves a list of tenants.
   * @param page - The page number.
   * @returns A promise that resolves to an array of TenantRead objects representing the tenants.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.tenants.list()
   */
  async listTenants(page) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._tenants.listTenants({
        ...this.config.apiContext.environmentContext,
        page
      });
      this.logger.debug(`[${response.status}] permit.api.listTenants(${page ?? ""})`);
      return response.data;
    } catch (err) {
      if (import_axios38.default.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.listTenants(${page ?? ""}), err: ${JSON.stringify(
            (_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data
          )}`
        );
      }
      throw err;
    }
  }
  /**
   * Retrieves a role by ID or key.
   * @param roleId - The ID or the key of the role.
   * @returns A promise that resolves to a RoleRead object representing the role.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.roles.get()
   */
  async getRole(roleId) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._roles.getRole({
        ...this.config.apiContext.environmentContext,
        roleId
      });
      this.logger.debug(`[${response.status}] permit.api.getRole(${roleId})`);
      return response.data;
    } catch (err) {
      if (import_axios38.default.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.getRole(${roleId}), err: ${JSON.stringify(
            (_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data
          )}`
        );
      }
      throw err;
    }
  }
  /**
   * Retrieves the assigned roles for a user (either in a single tenant or in all tenants).
   * @param user - The ID or key of the user.
   * @param tenant - The ID or key of the tenant, optional. If provided, only roles assigned within this tenant will be returned.
   * @returns A promise that resolves to an array of RoleAssignmentRead objects representing the assigned roles.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.users.getAssignedRoles()
   */
  async getAssignedRoles(user, tenant) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._roleAssignments.listRoleAssignments({
        ...this.config.apiContext.environmentContext,
        user,
        tenant
      });
      this.logger.debug(
        `[${response.status}] permit.api.getAssignedRoles(${user}, ${tenant ?? "all tenants"})`
      );
      return response.data;
    } catch (err) {
      if (import_axios38.default.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.getAssignedRoles(${user}, ${tenant ?? "all tenants"}), err: ${JSON.stringify((_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data)}`
        );
      }
      throw err;
    }
  }
  /**
   * Creates a new resource.
   * @param resource - The resource to create.
   * @returns A promise that resolves to a ResourceRead object representing the created resource.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.resources.create()
   */
  async createResource(resource) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._resources.createResource({
        ...this.config.apiContext.environmentContext,
        resourceCreate: resource
      });
      this.logger.debug(
        `[${response.status}] permit.api.createResource(${JSON.stringify(resource)})`
      );
      return response.data;
    } catch (err) {
      if (import_axios38.default.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.createResource(${JSON.stringify(
            resource
          )}), err: ${JSON.stringify((_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data)}`
        );
      }
      throw err;
    }
  }
  /**
   * Updates an existing resource.
   * @param resourceId - The ID or key of the resource to update.
   * @param resource - The updated resource data.
   * @returns A promise that resolves to a ResourceRead object representing the updated resource.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.resources.update()
   */
  async updateResource(resourceId, resource) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._resources.updateResource({
        ...this.config.apiContext.environmentContext,
        resourceId,
        resourceUpdate: resource
      });
      this.logger.debug(
        `[${response.status}] permit.api.updateResource(${resourceId}, ${JSON.stringify(
          resource
        )})`
      );
      return response.data;
    } catch (err) {
      if (import_axios38.default.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.updateResource(${resourceId}, ${JSON.stringify(
            resource
          )}), err: ${JSON.stringify((_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data)}`
        );
      }
      throw err;
    }
  }
  /**
   * Deletes a resource.
   * @param resourceId - The ID or key of the resource to delete.
   * @returns A promise that resolves when the resource is deleted.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.resources.delete()
   */
  async deleteResource(resourceId) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._resources.deleteResource({
        ...this.config.apiContext.environmentContext,
        resourceId
      });
      this.logger.debug(`[${response.status}] permit.api.deleteResource(${resourceId})`);
      return response;
    } catch (err) {
      if (import_axios38.default.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.deleteResource(${resourceId}), err: ${JSON.stringify((_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data)}`
        );
      }
      throw err;
    }
  }
  /**
   * Creates a new user.
   * @param user - The user to create.
   * @returns A promise that resolves to a UserRead object representing the created user.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.users.create()
   */
  async createUser(user) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._users.createUser({
        ...this.config.apiContext.environmentContext,
        userCreate: user
      });
      this.logger.debug(`[${response.status}] permit.api.createUser(${JSON.stringify(user)})`);
      return response.data;
    } catch (err) {
      if (import_axios38.default.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.createUser(${JSON.stringify(
            user
          )}), err: ${JSON.stringify((_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data)}`
        );
      }
      throw err;
    }
  }
  /**
   * Creates or Updates in place a user.
   * @param user - The user to create or update.
   * @returns A promise that resolves to a UserRead object representing the synced user.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.users.sync()
   */
  async syncUser(user) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._users.replaceUser({
        ...this.config.apiContext.environmentContext,
        userId: user.key,
        userCreate: user
      });
      this.logger.debug(`[${response.status}] permit.api.syncUser(${JSON.stringify(user)})`);
      return response.data;
    } catch (err) {
      if (import_axios38.default.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.syncUser(${JSON.stringify(
            user
          )}), err: ${JSON.stringify((_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data)}`
        );
      }
      throw err;
    }
  }
  /**
   * Updates an existing user.
   * @param userId - The ID or key of the user to update.
   * @param user - The updated user data.
   * @returns A promise that resolves to a UserRead object representing the updated user.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.users.update()
   */
  async updateUser(userId, user) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._users.updateUser({
        ...this.config.apiContext.environmentContext,
        userId,
        userUpdate: user
      });
      this.logger.debug(`[${response.status}] permit.api.updateUser(${JSON.stringify(user)})`);
      return response.data;
    } catch (err) {
      if (import_axios38.default.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.updateUser(${JSON.stringify(
            user
          )}), err: ${JSON.stringify((_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data)}`
        );
      }
      throw err;
    }
  }
  /**
   * Deletes a user.
   * @param userId - The ID or key of the user to delete.
   * @returns A promise that resolves when the user is deleted.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.users.delete()
   */
  async deleteUser(userId) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._users.deleteUser({
        ...this.config.apiContext.environmentContext,
        userId
        // user id or key
      });
      this.logger.debug(`[${response.status}] permit.api.deleteUser(${userId})`);
      return response;
    } catch (err) {
      if (import_axios38.default.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.deleteUser(${userId}), err: ${JSON.stringify(
            (_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data
          )}`
        );
      }
      throw err;
    }
  }
  /**
   * Creates a new tenant.
   * @param tenant - The tenant to create.
   * @returns A promise that resolves to a TenantRead object representing the created tenant.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.tenants.create()
   */
  async createTenant(tenant) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._tenants.createTenant({
        ...this.config.apiContext.environmentContext,
        tenantCreate: tenant
      });
      this.logger.debug(`[${response.status}] permit.api.createTenant(${JSON.stringify(tenant)})`);
      return response.data;
    } catch (err) {
      if (import_axios38.default.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.createTenant(${JSON.stringify(
            tenant
          )}), err: ${JSON.stringify((_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data)}`
        );
      }
      throw err;
    }
  }
  /**
   * Updates an existing tenant.
   * @param tenantId - The ID or key of the tenant to update.
   * @param tenant - The updated tenant data.
   * @returns A promise that resolves to a TenantRead object representing the updated tenant.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.tenants.update()
   */
  async updateTenant(tenantId, tenant) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._tenants.updateTenant({
        ...this.config.apiContext.environmentContext,
        tenantId,
        tenantUpdate: tenant
      });
      this.logger.debug(
        `[${response.status}] permit.api.updateTenant(${tenantId}, ${JSON.stringify(tenant)})`
      );
      return response.data;
    } catch (err) {
      if (import_axios38.default.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.updateTenant(${tenantId}, ${JSON.stringify(
            tenant
          )}), err: ${JSON.stringify((_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data)}`
        );
      }
      throw err;
    }
  }
  /**
   * Deletes a tenant.
   * @param tenantId - The ID or key of the tenant to delete.
   * @returns A promise that resolves when the tenant is deleted.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.tenants.delete()
   */
  async deleteTenant(tenantId) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._tenants.deleteTenant({
        ...this.config.apiContext.environmentContext,
        tenantId
      });
      this.logger.debug(`[${response.status}] permit.api.deleteTenant(${tenantId})`);
      return response;
    } catch (err) {
      if (import_axios38.default.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.deleteTenant(${tenantId}), err: ${JSON.stringify(
            (_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data
          )}`
        );
      }
      throw err;
    }
  }
  /**
   * Creates a new role.
   * @param role - The role to create.
   * @returns A promise that resolves to a RoleRead object representing the created role.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.roles.create()
   */
  async createRole(role) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._roles.createRole({
        ...this.config.apiContext.environmentContext,
        roleCreate: role
      });
      this.logger.debug(`[${response.status}] permit.api.createRole(${JSON.stringify(role)})`);
      return response.data;
    } catch (err) {
      if (import_axios38.default.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.createRole(${JSON.stringify(
            role
          )}), err: ${JSON.stringify((_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data)}`
        );
      }
      throw err;
    }
  }
  /**
   * Updates an existing role.
   * @param roleId - The ID or key of the role to update.
   * @param role - The updated role data.
   * @returns A promise that resolves to a RoleRead object representing the updated role.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.roles.update()
   */
  async updateRole(roleId, role) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._roles.updateRole({
        ...this.config.apiContext.environmentContext,
        roleId,
        roleUpdate: role
      });
      this.logger.debug(
        `[${response.status}] permit.api.updateRole(${roleId}, ${JSON.stringify(role)})`
      );
      return response.data;
    } catch (err) {
      if (import_axios38.default.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.updateRole(${roleId}, ${JSON.stringify(
            role
          )}), err: ${JSON.stringify((_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data)}`
        );
      }
      throw err;
    }
  }
  /**
   * Deletes a role.
   * @param roleId - The ID or key of the role to delete.
   * @returns A promise that resolves when the role is deleted.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.roles.delete()
   */
  async deleteRole(roleId) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._roles.deleteRole({
        ...this.config.apiContext.environmentContext,
        roleId
      });
      this.logger.debug(`[${response.status}] permit.api.deleteRole(${roleId})`);
      return response;
    } catch (err) {
      if (import_axios38.default.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.deleteRole(${roleId}), err: ${JSON.stringify(
            (_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data
          )}`
        );
      }
      throw err;
    }
  }
  /**
   * Assigns a role to a user.
   * @param assignedRole - The role assignment data.
   * @returns A promise that resolves to a RoleAssignmentRead object representing the assigned role.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.users.assignRole()
   */
  async assignRole(assignedRole) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._roleAssignments.assignRole({
        ...this.config.apiContext.environmentContext,
        roleAssignmentCreate: assignedRole
      });
      this.logger.debug(
        `[${response.status}] permit.api.assignRole(${JSON.stringify(assignedRole)})`
      );
      return response.data;
    } catch (err) {
      if (import_axios38.default.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.assignRole(${JSON.stringify(
            assignedRole
          )}), err: ${JSON.stringify((_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data)}`
        );
      }
      throw err;
    }
  }
  /**
   * Unassigns a role from a user.
   * @param removedRole - The role unassignment data.
   * @returns A promise that resolves when the role is unassigned.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.users.unassignRole()
   */
  async unassignRole(removedRole) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._roleAssignments.unassignRole({
        ...this.config.apiContext.environmentContext,
        roleAssignmentRemove: removedRole
      });
      this.logger.debug(
        `[${response.status}] permit.api.unassignRole(${JSON.stringify(removedRole)})`
      );
      return response;
    } catch (err) {
      if (import_axios38.default.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.unassignRole(${JSON.stringify(
            removedRole
          )}), err: ${JSON.stringify((_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data)}`
        );
      }
      throw err;
    }
  }
  /**
   * Creates a new condition set.
   * @param conditionSet - The condition set to create.
   * @returns A promise that resolves to a ConditionSetRead object representing the created condition set.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.conditionSets.create()
   */
  async createConditionSet(conditionSet) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._conditionSets.createConditionSet({
        ...this.config.apiContext.environmentContext,
        conditionSetCreate: conditionSet
      });
      this.logger.debug(
        `[${response.status}] permit.api.createConditionSet(${JSON.stringify(conditionSet)})`
      );
      return response.data;
    } catch (err) {
      if (import_axios38.default.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.createConditionSet(${JSON.stringify(
            conditionSet
          )}), err: ${JSON.stringify((_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data)}`
        );
      }
      throw err;
    }
  }
  /**
   * Updates an existing condition set.
   * @param conditionSetId - The ID or key of the condition set to update.
   * @param conditionSet - The updated condition set data.
   * @returns A promise that resolves to a ConditionSetRead object representing the updated condition set.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.conditionSets.update()
   */
  async updateConditionSet(conditionSetId, conditionSet) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._conditionSets.updateConditionSet({
        ...this.config.apiContext.environmentContext,
        conditionSetId,
        conditionSetUpdate: conditionSet
      });
      this.logger.debug(
        `[${response.status}] permit.api.updateConditionSet(${conditionSetId}, ${JSON.stringify(
          conditionSet
        )})`
      );
      return response.data;
    } catch (err) {
      if (import_axios38.default.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.updateConditionSet(${conditionSetId}, ${JSON.stringify(
            conditionSet
          )}), err: ${JSON.stringify((_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data)}`
        );
      }
      throw err;
    }
  }
  /**
   * Deletes a condition set.
   * @param conditionSetId - The ID or key of the condition set to delete.
   * @returns A promise that resolves when the condition set is deleted.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.conditionSets.delete()
   */
  async deleteConditionSet(conditionSetId) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._conditionSets.deleteConditionSet({
        ...this.config.apiContext.environmentContext,
        conditionSetId
      });
      this.logger.debug(`[${response.status}] permit.api.deleteConditionSet(${conditionSetId})`);
      return response;
    } catch (err) {
      if (import_axios38.default.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.deleteConditionSet(${conditionSetId}), err: ${JSON.stringify(
            (_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data
          )}`
        );
      }
      throw err;
    }
  }
  /**
   * Creates a condition set rule (i.e: grants permission to a userset to act on a resourceset).
   * @param conditionSetRule - The condition set rule data.
   * @returns A promise that resolves to a ConditionSetRuleRead object representing the assigned condition set rule.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.conditionSetRules.create()
   */
  async assignConditionSetRule(conditionSetRule) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._conditionSetRules.assignSetPermissions({
        ...this.config.apiContext.environmentContext,
        conditionSetRuleCreate: conditionSetRule
      });
      this.logger.debug(
        `[${response.status}] permit.api.createConditionSetRule(${JSON.stringify(
          conditionSetRule
        )})`
      );
      return response.data;
    } catch (err) {
      if (import_axios38.default.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.createConditionSetRule(${JSON.stringify(
            conditionSetRule
          )}), err: ${JSON.stringify((_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data)}`
        );
      }
      throw err;
    }
  }
  /**
   * Removes a condition set rule (i.e: unassigns permission from a userset to act on a resourceset).
   * @param conditionSetRuleId - The ID or key of the condition set rule to remove.
   * @returns A promise that resolves when the condition set rule is deleted.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.conditionSetRules.delete()
   */
  async unassignConditionSetRule(conditionSetRule) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._conditionSetRules.unassignSetPermissions({
        ...this.config.apiContext.environmentContext,
        conditionSetRuleRemove: conditionSetRule
      });
      this.logger.debug(
        `[${response.status}] permit.api.deleteConditionSetRule(${JSON.stringify(
          conditionSetRule
        )})`
      );
      return response;
    } catch (err) {
      if (import_axios38.default.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.deleteConditionSetRule(${JSON.stringify(
            conditionSetRule
          )}), err: ${JSON.stringify((_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data)}`
        );
      }
      throw err;
    }
  }
  getMethods() {
    return {
      listUsers: this.listUsers.bind(this),
      listRoles: this.listRoles.bind(this),
      listConditionSets: this.listConditionSets.bind(this),
      listConditionSetsRules: this.listConditionSetsRules.bind(this),
      updateUser: this.updateUser.bind(this),
      getUser: this.getUser.bind(this),
      getTenant: this.getTenant.bind(this),
      getRole: this.getRole.bind(this),
      getAssignedRoles: this.getAssignedRoles.bind(this),
      createResource: this.createResource.bind(this),
      updateResource: this.updateResource.bind(this),
      deleteResource: this.deleteResource.bind(this),
      createUser: this.createUser.bind(this),
      syncUser: this.syncUser.bind(this),
      deleteUser: this.deleteUser.bind(this),
      createTenant: this.createTenant.bind(this),
      updateTenant: this.updateTenant.bind(this),
      deleteTenant: this.deleteTenant.bind(this),
      listTenants: this.listTenants.bind(this),
      createRole: this.createRole.bind(this),
      updateRole: this.updateRole.bind(this),
      deleteRole: this.deleteRole.bind(this),
      assignRole: this.assignRole.bind(this),
      unassignRole: this.unassignRole.bind(this),
      createConditionSet: this.createConditionSet.bind(this),
      updateConditionSet: this.updateConditionSet.bind(this),
      deleteConditionSet: this.deleteConditionSet.bind(this),
      assignConditionSetRule: this.assignConditionSetRule.bind(this),
      unassignConditionSetRule: this.unassignConditionSetRule.bind(this)
    };
  }
};

// src/api/environments.ts
var EnvironmentsApi2 = class extends BasePermitApi {
  /**
   * Creates an instance of the EnvironmentsApi.
   * @param config - The configuration object for the Permit SDK.
   * @param logger - The logger instance for logging.
   */
  constructor(config, logger) {
    super(config, logger);
    this.environments = new EnvironmentsApi(
      this.openapiClientConfig,
      BASE_PATH,
      this.config.axiosInstance
    );
    this.apiKeys = new APIKeysApi(
      this.openapiClientConfig,
      BASE_PATH,
      this.config.axiosInstance
    );
  }
  /**
   * Retrieves a list of environments.
   *
   * @param params - the filters and pagination options, @see {@link IListEnvironments}
   * @returns A promise that resolves to an array of EnvironmentRead objects representing the listed environments.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async list(params) {
    const { projectKey, page = 1, perPage = 100 } = params;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(1 /* ORGANIZATION */);
    try {
      return (await this.environments.listEnvironments({
        projId: projectKey,
        page,
        perPage
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Gets an environment by project key and environment key.
   *
   * @param projectKey - The project key.
   * @param environmentKey - The environment key.
   * @returns A promise that resolves to an EnvironmentRead object representing the retrieved environment.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async get(projectKey, environmentKey) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(1 /* ORGANIZATION */);
    try {
      return (await this.environments.getEnvironment({
        projId: projectKey,
        envId: environmentKey
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Gets an environment by project key and environment key.
   * Alias for the {@link get} method.
   *
   * @param projectKey - The project key.
   * @param environmentKey - The environment key.
   * @returns A promise that resolves to an EnvironmentRead object representing the retrieved environment.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async getByKey(projectKey, environmentKey) {
    return await this.get(projectKey, environmentKey);
  }
  /**
   * Gets an environment by project ID and environment ID.
   * Alias for the {@link get} method.
   *
   * @param projectId - The project ID.
   * @param environmentId - The environment ID.
   * @returns A promise that resolves to an EnvironmentRead object representing the retrieved environment.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async getById(projectId, environmentId) {
    return await this.get(projectId, environmentId);
  }
  /**
   * Retrieves statistics and metadata for an environment.
   *
   * @param projectKey - The project key.
   * @param environmentKey - The environment key.
   * @returns A promise that resolves to an EnvironmentStats object representing the statistics data.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async getStats(projectKey, environmentKey) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(1 /* ORGANIZATION */);
    try {
      return (await this.environments.statsEnvironments({
        projId: projectKey,
        envId: environmentKey
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Retrieves the API key that grants access for an environment (and only the requested environment).
   * Must be requested with an organization-level api key.
   *
   * @param projectKey - The project key.
   * @param environmentKey - The environment key.
   * @returns A promise that resolves to an APIKeyRead object containing the API key and its metadata.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async getApiKey(projectKey, environmentKey) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(1 /* ORGANIZATION */);
    try {
      return (await this.apiKeys.getEnvironmentApiKey({
        projId: projectKey,
        envId: environmentKey
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Creates a new environment.
   *
   * @param projectKey - The project key.
   * @param environmentData - The data for creating the environment.
   * @returns A promise that resolves to an EnvironmentRead object representing the created environment.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async create(projectKey, environmentData) {
    await this.ensureAccessLevel("PROJECT_LEVEL_API_KEY" /* PROJECT_LEVEL_API_KEY */);
    await this.ensureContext(1 /* ORGANIZATION */);
    try {
      return (await this.environments.createEnvironment({
        projId: projectKey,
        environmentCreate: environmentData
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Updates an existing environment.
   *
   * @param projectKey - The project key.
   * @param environmentKey - The environment key.
   * @param environmentData - The data for updating the environment.
   * @returns A promise that resolves to an EnvironmentRead object representing the updated environment.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async update(projectKey, environmentKey, environmentData) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(1 /* ORGANIZATION */);
    try {
      return (await this.environments.updateEnvironment({
        projId: projectKey,
        envId: environmentKey,
        environmentUpdate: environmentData
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Clones data (creates a copy) from a source specified environment into a different target
   * environment in the same project. The target environment can be a new environment or an existing
   * environment. For existing environments, the user must specify a conflict strategy - meaning what
   * the system should do in case a copied object conflicts with an existing object (with the same key)
   * in the target environment. The system can overwrite all the conflicting objects, or fail (and
   * cancel the copy) when encountering the first conflict.
   *
   * @param projectKey - The project key.
   * @param environmentKey - The environment key.
   * @param copyParams - The parameters for copying the environment.
   * @returns A promise that resolves to an EnvironmentRead object representing the copied environment.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async copy(projectKey, environmentKey, copyParams) {
    await this.ensureAccessLevel("PROJECT_LEVEL_API_KEY" /* PROJECT_LEVEL_API_KEY */);
    await this.ensureContext(1 /* ORGANIZATION */);
    try {
      return (await this.environments.copyEnvironment({
        projId: projectKey,
        envId: environmentKey,
        environmentCopy: copyParams
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Deletes an environment.
   *
   * @param projectKey - The project key.
   * @param environmentKey - The environment key.
   * @returns A promise that resolves when the environment is successfully deleted.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async delete(projectKey, environmentKey) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(1 /* ORGANIZATION */);
    try {
      await this.environments.deleteEnvironment({
        projId: projectKey,
        envId: environmentKey
      });
    } catch (err) {
      this.handleApiError(err);
    }
  }
};

// src/api/projects.ts
var ProjectsApi2 = class extends BasePermitApi {
  /**
   * Creates an instance of the ProjectsApi.
   * @param config - The configuration object for the Permit SDK.
   * @param logger - The logger instance for logging.
   */
  constructor(config, logger) {
    super(config, logger);
    this.projects = new ProjectsApi(
      this.openapiClientConfig,
      BASE_PATH,
      this.config.axiosInstance
    );
  }
  /**
   * Retrieves a list of projects.
   *
   * @param pagination The pagination options, @see {@link IPagination}
   * @returns A promise that resolves to an array of projects.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async list(pagination) {
    const { page = 1, perPage = 100 } = pagination ?? {};
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(1 /* ORGANIZATION */);
    try {
      return (await this.projects.listProjects({
        page,
        perPage
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Retrieves a project by its key.
   *
   * @param projectKey The key of the project.
   * @returns A promise that resolves to the project.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async get(projectKey) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(1 /* ORGANIZATION */);
    try {
      return (await this.projects.getProject({
        projId: projectKey
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Retrieves a project by its key.
   * Alias for the {@link get} method.
   *
   * @param projectKey The key of the project.
   * @returns A promise that resolves to the project.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async getByKey(projectKey) {
    return await this.get(projectKey);
  }
  /**
   * Retrieves a project by its ID.
   * Alias for the {@link get} method.
   *
   * @param projectId The ID of the project.
   * @returns A promise that resolves to the project.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async getById(projectId) {
    return await this.get(projectId);
  }
  /**
   * Creates a new project.
   *
   * @param projectData The data for the new project.
   * @returns A promise that resolves to the created project.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async create(projectData) {
    await this.ensureAccessLevel("ORGANIZATION_LEVEL_API_KEY" /* ORGANIZATION_LEVEL_API_KEY */);
    await this.ensureContext(1 /* ORGANIZATION */);
    try {
      return (await this.projects.createProject({
        projectCreate: projectData
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Updates a project.
   *
   * @param projectKey The key of the project.
   * @param projectData The updated data for the project.
   * @returns A promise that resolves to the updated project.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async update(projectKey, projectData) {
    await this.ensureAccessLevel("PROJECT_LEVEL_API_KEY" /* PROJECT_LEVEL_API_KEY */);
    await this.ensureContext(1 /* ORGANIZATION */);
    try {
      return (await this.projects.updateProject({
        projId: projectKey,
        projectUpdate: projectData
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Deletes a project.
   *
   * @param projectKey The key of the project to delete.
   * @returns A promise that resolves when the project is deleted.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async delete(projectKey) {
    await this.ensureAccessLevel("PROJECT_LEVEL_API_KEY" /* PROJECT_LEVEL_API_KEY */);
    await this.ensureContext(1 /* ORGANIZATION */);
    try {
      await this.projects.deleteProject({
        projId: projectKey
      });
    } catch (err) {
      this.handleApiError(err);
    }
  }
};

// src/api/relationship-tuples.ts
var RelationshipTuplesApi2 = class extends BaseFactsPermitAPI {
  /**
   * Creates an instance of the RelationshipTuplesApi.
   * @param config - The configuration object for the Permit SDK.
   * @param logger - The logger instance for logging.
   */
  constructor(config, logger) {
    super(config, logger);
    this.relationshipTuples = new RelationshipTuplesApi(
      this.openapiClientConfig,
      BASE_PATH,
      this.config.axiosInstance
    );
  }
  /**
   * Retrieves a list of role createments based on the specified filters.
   *
   * @param params - The filters and pagination options for listing role createments.
   * @returns A promise that resolves with an array of role createments.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async list(params) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.relationshipTuples.listRelationshipTuples({
        ...params,
        ...this.config.apiContext.environmentContext
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Creates a new relationship tuple, that states that a relationship (of type: relation)
   * exists between two resource instances: the subject and the object.
   *
   * @param tuple - The tuple to create
   * @returns A promise that resolves to the created relationship tuple.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async create(tuple) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.relationshipTuples.createRelationshipTuple({
        ...this.config.apiContext.environmentContext,
        relationshipTupleCreate: tuple
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Removes a relationship tuple.
   *
   * @param tuple - The tuple to delete
   * @returns A promise that resolves when the tuple is successfully deleted.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async delete(tuple) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.relationshipTuples.deleteRelationshipTuple({
        ...this.config.apiContext.environmentContext,
        relationshipTupleDelete: tuple
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Creates a new relationship tuple, that states that a relationship (of type: relation)
   * exists between two resource instances: the subject and the object.
   *
   * @returns A promise that resolves to the created relationship tuple.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @param tuples
   */
  async bulkRelationshipTuples(tuples) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.relationshipTuples.bulkCreateRelationshipTuples({
        ...this.config.apiContext.environmentContext,
        relationshipTupleCreateBulkOperation: {
          operations: tuples
        }
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Deletes multiple relationship tuples at once using the provided tuple data.
   * Each tuple object is of type RelationshipTupleDelete and is essentially a tuple of (subject, relation, object).
   *
   * @param tuples - he relationship tuples to delete.
   * @returns A promise that resolves with the bulk un relationship tuples report.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async bulkUnRelationshipTuples(tuples) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.relationshipTuples.bulkDeleteRelationshipTuples({
        ...this.config.apiContext.environmentContext,
        relationshipTupleDeleteBulkOperation: {
          idents: tuples
        }
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
};

// src/api/resource-action-groups.ts
var ResourceActionGroupsApi2 = class extends BasePermitApi {
  /**
   * Creates an instance of the ResourceActionGroupsApi.
   * @param config - The configuration object for the Permit SDK.
   * @param logger - The logger instance for logging.
   */
  constructor(config, logger) {
    super(config, logger);
    this.groupsApi = new ResourceActionGroupsApi(
      this.openapiClientConfig,
      BASE_PATH,
      this.config.axiosInstance
    );
  }
  /**
   * Retrieves a list of all action groups that are defined for a given resource.
   * @param params - pagination and filtering params, @see {@link IListActionGroups}
   * @returns A promise that resolves to an array of ResourceActionGroupRead objects representing the action groups.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async list(params) {
    const { resourceKey, page = 1, perPage = 100 } = params;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.groupsApi.listResourceActionGroups({
        ...this.config.apiContext.environmentContext,
        resourceId: resourceKey,
        page,
        perPage
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Retrieves an action group based on the resource key and the group key.
   *
   * @param resourceKey - The resource key.
   * @param groupKey - The group key.
   * @returns A promise that resolves to a ResourceActionGroupRead object representing the action group.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async get(resourceKey, groupKey) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.groupsApi.getResourceActionGroup({
        ...this.config.apiContext.environmentContext,
        resourceId: resourceKey,
        actionGroupId: groupKey
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Retrieves an action group based on the resource key and the group key.
   * Alias for the {@link get} method.
   *
   * @param resourceKey - The resource key.
   * @param groupKey - The group key.
   * @returns A promise that resolves to a ResourceActionGroupRead object representing the action group.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async getByKey(resourceKey, groupKey) {
    return await this.get(resourceKey, groupKey);
  }
  /**
   * Retrieves an action group based on the resource ID and the group ID.
   * Alias for the {@link get} method.
   *
   * @param resourceId - The resource ID.
   * @param groupId - The group ID.
   * @returns A promise that resolves to a ResourceActionGroupRead object representing the action group.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async getById(resourceId, groupId) {
    return await this.get(resourceId, groupId);
  }
  /**
   * Creates a new action group.
   * @param resourceKey - The resource key.
   * @param groupData - The action group data.
   * @returns A promise that resolves to a ResourceActionGroupRead object representing the created action group.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async create(resourceKey, groupData) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.groupsApi.createResourceActionGroup({
        ...this.config.apiContext.environmentContext,
        resourceId: resourceKey,
        resourceActionGroupCreate: groupData
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Updates an action group.
   * @param resourceKey - The resource key.
   * @param groupKey - The group key.
   * @param groupData - The action group data.
   * @returns A promise that resolves to a ResourceActionGroupRead object representing the updated action group.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async update(resourceKey, groupKey, groupData) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.groupsApi.updateResourceActionGroup({
        ...this.config.apiContext.environmentContext,
        resourceId: resourceKey,
        actionGroupId: groupKey,
        resourceActionGroupUpdate: groupData
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Deletes a action group based on the resource key and group key.
   * @param resourceKey - The resource key.
   * @param groupKey - The group key.
   * @returns A promise that resolves when the action group is successfully deleted.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async delete(resourceKey, groupKey) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      await this.groupsApi.deleteResourceActionGroup({
        ...this.config.apiContext.environmentContext,
        resourceId: resourceKey,
        actionGroupId: groupKey
      });
    } catch (err) {
      this.handleApiError(err);
    }
  }
};

// src/api/resource-actions.ts
var ResourceActionsApi2 = class extends BasePermitApi {
  /**
   * Creates an instance of the ResourceActionsApi.
   * @param config - The configuration object for the Permit SDK.
   * @param logger - The logger instance for logging.
   */
  constructor(config, logger) {
    super(config, logger);
    this.actionsApi = new ResourceActionsApi(
      this.openapiClientConfig,
      BASE_PATH,
      this.config.axiosInstance
    );
  }
  /**
   * Retrieves a list of all actions that are defined for a given resource.
   * @param params - pagination and filtering params, @see {@link IListActions}
   * @returns A promise that resolves to an array of ResourceActionRead objects representing the actions.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async list(params) {
    const { resourceKey, page = 1, perPage = 100 } = params;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.actionsApi.listResourceActions({
        ...this.config.apiContext.environmentContext,
        resourceId: resourceKey,
        page,
        perPage
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Retrieves an action based on the resource key and the action key.
   *
   * @param resourceKey - The resource key.
   * @param actionKey - The action key.
   * @returns A promise that resolves to a ResourceActionRead object representing the action.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async get(resourceKey, actionKey) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.actionsApi.getResourceAction({
        ...this.config.apiContext.environmentContext,
        resourceId: resourceKey,
        actionId: actionKey
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Retrieves an action based on the resource key and the action key.
   * Alias for the {@link get} method.
   *
   * @param resourceKey - The resource key.
   * @param actionKey - The action key.
   * @returns A promise that resolves to a ResourceActionRead object representing the action.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async getByKey(resourceKey, actionKey) {
    return await this.get(resourceKey, actionKey);
  }
  /**
   * Retrieves an action based on the resource ID and the action ID.
   * Alias for the {@link get} method.
   *
   * @param resourceId - The resource ID.
   * @param actionId - The action ID.
   * @returns A promise that resolves to a ResourceActionRead object representing the action.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async getById(resourceId, actionId) {
    return await this.get(resourceId, actionId);
  }
  /**
   * Creates a new action.
   *
   * @param resourceKey - The resource key.
   * @param actionData - The action data.
   * @returns A promise that resolves to a ResourceActionRead object representing the created action.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async create(resourceKey, actionData) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.actionsApi.createResourceAction({
        ...this.config.apiContext.environmentContext,
        resourceId: resourceKey,
        resourceActionCreate: actionData
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Updates an existing action.
   *
   * @param resourceKey - The resource key.
   * @param actionKey - The key of the action to modify.
   * @param actionData - The data for updating the action.
   * @returns A promise that resolves to a ResourceActionRead object representing the updated action.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async update(resourceKey, actionKey, actionData) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.actionsApi.updateResourceAction({
        ...this.config.apiContext.environmentContext,
        resourceId: resourceKey,
        actionId: actionKey,
        resourceActionUpdate: actionData
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Deletes a action based on the resource key and action key.
   * @param resourceKey - The resource key.
   * @param actionKey - The action key.
   * @returns A promise that resolves when the action is successfully deleted.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async delete(resourceKey, actionKey) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      await this.actionsApi.deleteResourceAction({
        ...this.config.apiContext.environmentContext,
        resourceId: resourceKey,
        actionId: actionKey
      });
    } catch (err) {
      this.handleApiError(err);
    }
  }
};

// src/api/resource-attributes.ts
var ResourceAttributesApi2 = class extends BasePermitApi {
  /**
   * Creates an instance of the ResourceAttributesApi.
   * @param config - The configuration object for the Permit SDK.
   * @param logger - The logger instance for logging.
   */
  constructor(config, logger) {
    super(config, logger);
    this.attributesApi = new ResourceAttributesApi(
      this.openapiClientConfig,
      BASE_PATH,
      this.config.axiosInstance
    );
  }
  /**
   * Retrieves a list of all attributes that are defined for a given resource.
   * @param params - pagination and filtering params, @see {@link IListAttributes}
   * @returns A promise that resolves to an array of ResourceAttributeRead objects representing the attributes.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async list(params) {
    const { resourceKey, page = 1, perPage = 100 } = params;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.attributesApi.listResourceAttributes({
        ...this.config.apiContext.environmentContext,
        resourceId: resourceKey,
        page,
        perPage
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Retrieves an attribute based on the resource key and the attribute key.
   *
   * @param resourceKey - The resource key.
   * @param attributeKey - The attribute key.
   * @returns A promise that resolves to a ResourceAttributeRead object representing the attribute.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async get(resourceKey, attributeKey) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.attributesApi.getResourceAttribute({
        ...this.config.apiContext.environmentContext,
        resourceId: resourceKey,
        attributeId: attributeKey
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Retrieves an attribute based on the resource key and the attribute key.
   * Alias for the {@link get} method.
   *
   * @param resourceKey - The resource key.
   * @param attributeKey - The attribute key.
   * @returns A promise that resolves to a ResourceAttributeRead object representing the attribute.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async getByKey(resourceKey, attributeKey) {
    return await this.get(resourceKey, attributeKey);
  }
  /**
   * Retrieves an attribute based on the resource ID and the attribute ID.
   * Alias for the {@link get} method.
   *
   * @param resourceId - The resource ID.
   * @param attributeId - The attribute ID.
   * @returns A promise that resolves to a ResourceAttributeRead object representing the attribute.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async getById(resourceId, attributeId) {
    return await this.get(resourceId, attributeId);
  }
  /**
   * Creates a new attribute.
   *
   * @param resourceKey - The resource key.
   * @param attributeData - The attribute data.
   * @returns A promise that resolves to a ResourceAttributeRead object representing the created attribute.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async create(resourceKey, attributeData) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.attributesApi.createResourceAttribute({
        ...this.config.apiContext.environmentContext,
        resourceId: resourceKey,
        resourceAttributeCreate: attributeData
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Updates an existing attribute.
   *
   * @param resourceKey - The resource key.
   * @param attributeKey - The key of the attribute to modify.
   * @param attributeData - The data for updating the attribute.
   * @returns A promise that resolves to a ResourceAttributeRead object representing the updated attribute.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async update(resourceKey, attributeKey, attributeData) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.attributesApi.updateResourceAttribute({
        ...this.config.apiContext.environmentContext,
        resourceId: resourceKey,
        attributeId: attributeKey,
        resourceAttributeUpdate: attributeData
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Deletes a attribute based on the resource key and attribute key.
   * @param resourceKey - The resource key.
   * @param attributeKey - The attribute key.
   * @returns A promise that resolves when the attribute is successfully deleted.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async delete(resourceKey, attributeKey) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      await this.attributesApi.deleteResourceAttribute({
        ...this.config.apiContext.environmentContext,
        resourceId: resourceKey,
        attributeId: attributeKey
      });
    } catch (err) {
      this.handleApiError(err);
    }
  }
};

// src/api/resource-instances.ts
var ResourceInstancesApi2 = class extends BaseFactsPermitAPI {
  /**
   * Creates an instance of the ResourceInstancesApi.
   * @param config - The configuration object for the Permit SDK.
   * @param logger - The logger instance for logging.
   */
  constructor(config, logger) {
    super(config, logger);
    this.instances = new ResourceInstancesApi(
      this.openapiClientConfig,
      BASE_PATH,
      this.config.axiosInstance
    );
  }
  /**
   * Retrieves a list of resource instances.
   *
   * @param params Filtering and pagination options, @see {@link IListResourceInstanceParams}
   * @returns A promise that resolves to an array of resource instances.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async list(params) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.instances.listResourceInstances({
        ...params,
        ...this.config.apiContext.environmentContext
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Retrieves a instance by its key.
   *
   * @param instanceKey The key of the resource instance.
   * @returns A promise that resolves to the resource instance.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async get(instanceKey) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.instances.getResourceInstance({
        ...this.config.apiContext.environmentContext,
        instanceId: instanceKey
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Retrieves a instance by its key.
   * Alias for the {@link get} method.
   *
   * @param instanceKey The key of the resource instance.
   * @returns A promise that resolves to the resource instance.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async getByKey(instanceKey) {
    return await this.get(instanceKey);
  }
  /**
   * Retrieves a instance by its ID.
   * Alias for the {@link get} method.
   *
   * @param instanceId The ID of the resource instance.
   * @returns A promise that resolves to the resource instance.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async getById(instanceId) {
    return await this.get(instanceId);
  }
  /**
   * Creates a new instance.
   *
   * @param instanceData The data for the new instance.
   * @returns A promise that resolves to the created instance.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async create(instanceData) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.instances.createResourceInstance({
        ...this.config.apiContext.environmentContext,
        resourceInstanceCreate: instanceData
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Updates a instance.
   *
   * @param instanceKey The key of the resource instance.
   * @param instanceData The updated data for the resource instance.
   * @returns A promise that resolves to the updated instance.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async update(instanceKey, instanceData) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.instances.updateResourceInstance({
        ...this.config.apiContext.environmentContext,
        instanceId: instanceKey,
        resourceInstanceUpdate: instanceData
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Deletes a instance.
   *
   * @param instanceKey The key of the resource instance to delete.
   * @returns A promise that resolves when the resource instance is deleted.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async delete(instanceKey) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      await this.instances.deleteResourceInstance({
        ...this.config.apiContext.environmentContext,
        instanceId: instanceKey
      });
    } catch (err) {
      this.handleApiError(err);
    }
  }
};

// src/api/resource-relations.ts
var ResourceRelationsApi2 = class extends BasePermitApi {
  /**
   * Creates an instance of the ResourceRelationsApi.
   * @param config - The configuration object for the Permit SDK.
   * @param logger - The logger instance for logging.
   */
  constructor(config, logger) {
    super(config, logger);
    this.relationsApi = new ResourceRelationsApi(
      this.openapiClientConfig,
      BASE_PATH,
      this.config.axiosInstance
    );
  }
  /**
   * Retrieves a list of all resource relations that are defined for a given resource.
   * @param params - pagination and filtering params, @see {@link IListRelations}
   * @returns A promise that resolves to an array of RelationRead objects representing the relations.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async list(params) {
    const { resourceKey, page = 1, perPage = 100 } = params;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.relationsApi.listResourceRelations({
        ...this.config.apiContext.environmentContext,
        resourceId: resourceKey,
        page,
        perPage
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Retrieves a resource relation based on the resource key and the relation key.
   *
   * @param resourceKey - The resource key.
   * @param relationKey - The relation key.
   * @returns A promise that resolves to a RelationRead object representing the relation.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async get(resourceKey, relationKey) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.relationsApi.getResourceRelation({
        ...this.config.apiContext.environmentContext,
        resourceId: resourceKey,
        relationId: relationKey
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Retrieves an relation based on the resource key and the relation key.
   * Alias for the {@link get} method.
   *
   * @param resourceKey - The resource key.
   * @param relationKey - The relation key.
   * @returns A promise that resolves to a RelationRead object representing the relation.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async getByKey(resourceKey, relationKey) {
    return await this.get(resourceKey, relationKey);
  }
  /**
   * Retrieves an relation based on the resource ID and the relation ID.
   * Alias for the {@link get} method.
   *
   * @param resourceId - The resource ID.
   * @param relationId - The relation ID.
   * @returns A promise that resolves to a RelationRead object representing the relation.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async getById(resourceId, relationId) {
    return await this.get(resourceId, relationId);
  }
  /**
   * Creates a new resource relation.
   *
   * @param resourceKey - The resource key.
   * @param RelationData - The relation data.
   * @returns A promise that resolves to a RelationRead object representing the created relation.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async create(resourceKey, RelationData) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.relationsApi.createResourceRelation({
        ...this.config.apiContext.environmentContext,
        resourceId: resourceKey,
        relationCreate: RelationData
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Deletes a relation based on the resource key and relation key.
   * @param resourceKey - The resource key.
   * @param relationKey - The relation key.
   * @returns A promise that resolves when the relation is successfully deleted.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async delete(resourceKey, relationKey) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      await this.relationsApi.deleteResourceRelation({
        ...this.config.apiContext.environmentContext,
        resourceId: resourceKey,
        relationId: relationKey
      });
    } catch (err) {
      this.handleApiError(err);
    }
  }
};

// src/api/resource-roles.ts
var ResourceRolesApi2 = class extends BasePermitApi {
  /**
   * Creates an instance of the ResourceRolesApi.
   * @param config - The configuration object for the Permit SDK.
   * @param logger - The logger instance for logging.
   */
  constructor(config, logger) {
    super(config, logger);
    this.resourceRoles = new ResourceRolesApi(
      this.openapiClientConfig,
      BASE_PATH,
      this.config.axiosInstance
    );
    this.roleDerivations = new ImplicitGrantsApi(
      this.openapiClientConfig,
      BASE_PATH,
      this.config.axiosInstance
    );
  }
  /**
   * Retrieves a list of resource roles.
   *
   * @param params - pagination and filtering params, @see {@link IListResourceRoles}
   * @returns A promise that resolves to an array of roles.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async list(params) {
    const { resourceKey, page = 1, perPage = 100 } = params;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.resourceRoles.listResourceRoles({
        ...this.config.apiContext.environmentContext,
        page,
        perPage,
        resourceId: resourceKey
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Retrieves a resource role by its key.
   *
   * @param resourceKey The key of the resource.
   * @param roleKey The key of the role.
   * @returns A promise that resolves to the role.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async get(resourceKey, roleKey) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.resourceRoles.getResourceRole({
        ...this.config.apiContext.environmentContext,
        resourceId: resourceKey,
        roleId: roleKey
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Retrieves a resource role by its key.
   * Alias for the {@link get} method.
   *
   * @param resourceKey The key of the resource.
   * @param roleKey The key of the role.
   * @returns A promise that resolves to the role.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async getByKey(resourceKey, roleKey) {
    return await this.get(resourceKey, roleKey);
  }
  /**
   * Retrieves a resource role by its ID.
   * Alias for the {@link get} method.
   *
   * @param resourceId The ID of the resource.
   * @param roleId The ID of the role.
   * @returns A promise that resolves to the role.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async getById(resourceId, roleId) {
    return await this.get(resourceId, roleId);
  }
  /**
   * Creates a new role.
   *
   * @param resourceKey The key of the resource.
   * @param roleData The data for the new role.
   * @returns A promise that resolves to the created role.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async create(resourceKey, roleData) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.resourceRoles.createResourceRole({
        ...this.config.apiContext.environmentContext,
        resourceId: resourceKey,
        resourceRoleCreate: roleData
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Updates a resource role.
   *
   * @param resourceKey The key of the resource.
   * @param roleKey The key of the role.
   * @param roleData The updated data for the role.
   * @returns A promise that resolves to the updated role.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async update(resourceKey, roleKey, roleData) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.resourceRoles.updateResourceRole({
        ...this.config.apiContext.environmentContext,
        resourceId: resourceKey,
        roleId: roleKey,
        resourceRoleUpdate: roleData
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Deletes a resource role.
   *
   * @param resourceKey The key of the resource.
   * @param roleKey The key of the role to delete.
   * @returns A promise that resolves when the role is deleted.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async delete(resourceKey, roleKey) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      await this.resourceRoles.deleteResourceRole({
        ...this.config.apiContext.environmentContext,
        resourceId: resourceKey,
        roleId: roleKey
      });
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Assigns permissions to a resource role.
   *
   * @param resourceKey The key of the resource.
   * @param roleKey - The key of the role.
   * @param permissions - An array of permission keys (<resourceKey:actionKey>) to be assigned to the role.
   * @returns A promise that resolves to a ResourceRoleRead object representing the updated role.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async assignPermissions(resourceKey, roleKey, permissions) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.resourceRoles.assignPermissionsToResourceRole({
        ...this.config.apiContext.environmentContext,
        resourceId: resourceKey,
        roleId: roleKey,
        addRolePermissions: {
          permissions
        }
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Removes permissions from a resource role.
   *
   * @param resourceKey The key of the resource.
   * @param roleKey - The key of the role.
   * @param permissions - An array of permission keys (<resourceKey:actionKey>) to be removed from the role.
   * @returns A promise that resolves to a ResourceRoleRead object representing the updated role.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async removePermissions(resourceKey, roleKey, permissions) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.resourceRoles.removePermissionsFromResourceRole({
        ...this.config.apiContext.environmentContext,
        resourceId: resourceKey,
        roleId: roleKey,
        removeRolePermissions: {
          permissions
        }
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Create a conditional derivation from another role.
   * The derivation states that users with some other role on a related object will implicitly also be granted this role.
   *
   * @param resourceKey - The key of the resource the role belongs to.
   * @param roleKey - The key of the role.
   * @param derivationRule - A rule when to derived this role from another related role.
   * @returns A DerivedRoleRuleRead object representing the newly created role derivation.
   * @throws PermitApiError - If the API returns an error HTTP status code.
   * @throws PermitContextError - If the configured ApiContext does not match the required endpoint context.
   */
  async createRoleDerivation(resourceKey, roleKey, derivationRule) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.roleDerivations.createImplicitGrant({
        ...this.config.apiContext.environmentContext,
        resourceId: resourceKey,
        roleId: roleKey,
        derivedRoleRuleCreate: derivationRule
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Delete a role derivation.
   *
   * @param resourceKey - The key of the resource the role belongs to.
   * @param roleKey - The key of the role.
   * @param derivationRule - The details of the derivation rule to delete.
   * @throws PermitApiError - If the API returns an error HTTP status code.
   * @throws PermitContextError - If the configured ApiContext does not match the required endpoint context.
   */
  async deleteRoleDerivation(resourceKey, roleKey, derivationRule) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.roleDerivations.deleteImplicitGrant({
        ...this.config.apiContext.environmentContext,
        resourceId: resourceKey,
        roleId: roleKey,
        derivedRoleRuleDelete: derivationRule
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Update the optional (ABAC) conditions when to derive this role from other roles.
   *
   * @param resourceKey - The key of the resource the role belongs to.
   * @param roleKey - The key of the role.
   * @param conditions - The conditions object.
   * @returns The updated PermitBackendSchemasSchemaDerivedRoleDerivedRoleSettings.
   * @throws PermitApiError - If the API returns an error HTTP status code.
   * @throws PermitContextError - If the configured ApiContext does not match the required endpoint context.
   */
  async updateRoleDerivationConditions(resourceKey, roleKey, conditions) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.roleDerivations.updateImplicitGrantsConditions({
        ...this.config.apiContext.environmentContext,
        resourceId: resourceKey,
        roleId: roleKey,
        permitBackendSchemasSchemaDerivedRoleDerivedRoleSettings: conditions
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
};

// src/api/resources.ts
var ResourcesApi2 = class extends BasePermitApi {
  /**
   * Creates an instance of the ResourcesApi.
   * @param config - The configuration object for the Permit SDK.
   * @param logger - The logger instance for logging.
   */
  constructor(config, logger) {
    super(config, logger);
    this.resources = new ResourcesApi(
      this.openapiClientConfig,
      BASE_PATH,
      this.config.axiosInstance
    );
  }
  async list(pagination) {
    const { page = 1, perPage = 100, includeTotalCount } = pagination ?? {};
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.resources.listResources({
        ...this.config.apiContext.environmentContext,
        page,
        perPage,
        includeTotalCount
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Retrieves a resource by its key.
   *
   * @param resourceKey The key of the resource.
   * @returns A promise that resolves to the resource.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async get(resourceKey) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.resources.getResource({
        ...this.config.apiContext.environmentContext,
        resourceId: resourceKey
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Retrieves a resource by its key.
   * Alias for the {@link get} method.
   *
   * @param resourceKey The key of the resource.
   * @returns A promise that resolves to the resource.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async getByKey(resourceKey) {
    return await this.get(resourceKey);
  }
  /**
   * Retrieves a resource by its ID.
   * Alias for the {@link get} method.
   *
   * @param resourceId The ID of the resource.
   * @returns A promise that resolves to the resource.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async getById(resourceId) {
    return await this.get(resourceId);
  }
  /**
   * Creates a new resource.
   *
   * @param resourceData The data for the new resource.
   * @returns A promise that resolves to the created resource.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async create(resourceData) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.resources.createResource({
        ...this.config.apiContext.environmentContext,
        resourceCreate: resourceData
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Creates a resource if such a resource does not exists, otherwise completely replaces the resource configuration.
   *
   * @param resourceKey The key of the resource.
   * @param resourceData The updated data for the resource.
   * @returns A promise that resolves to the updated resource.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async replace(resourceKey, resourceData) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.resources.replaceResource({
        ...this.config.apiContext.environmentContext,
        resourceId: resourceKey,
        resourceReplace: resourceData
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Updates a resource.
   *
   * @param resourceKey The key of the resource.
   * @param resourceData The updated data for the resource.
   * @returns A promise that resolves to the updated resource.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async update(resourceKey, resourceData) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.resources.updateResource({
        ...this.config.apiContext.environmentContext,
        resourceId: resourceKey,
        resourceUpdate: resourceData
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Deletes a resource.
   *
   * @param resourceKey The key of the resource to delete.
   * @returns A promise that resolves when the resource is deleted.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async delete(resourceKey) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      await this.resources.deleteResource({
        ...this.config.apiContext.environmentContext,
        resourceId: resourceKey
      });
    } catch (err) {
      this.handleApiError(err);
    }
  }
};

// src/api/role-assignments.ts
var RoleAssignmentsApi2 = class extends BaseFactsPermitAPI {
  /**
   * Creates an instance of the RoleAssignmentsApi.
   * @param config - The configuration object for the Permit SDK.
   * @param logger - The logger instance for logging.
   */
  constructor(config, logger) {
    super(config, logger);
    this.roleAssignments = new RoleAssignmentsApi(
      this.openapiClientConfig,
      BASE_PATH,
      this.config.axiosInstance
    );
  }
  async list(params) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    const {
      user,
      tenant,
      role,
      resourceInstance,
      page = 1,
      perPage = 100,
      detailed,
      includeTotalCount
    } = params;
    try {
      return (await this.roleAssignments.listRoleAssignments({
        ...this.config.apiContext.environmentContext,
        user,
        tenant,
        role,
        resourceInstance,
        detailed,
        page,
        perPage,
        includeTotalCount
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Assigns a role to a user in the scope of a given tenant.
   *
   * @param assignment - The role assignment details.
   * @returns A promise that resolves with the assigned role.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async assign(assignment) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.roleAssignments.assignRole({
        ...this.config.apiContext.environmentContext,
        roleAssignmentCreate: assignment
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Unassigns a role from a user in the scope of a given tenant.
   *
   * @param unassignment - The role unassignment details.
   * @returns A promise that resolves when the role is successfully unassigned.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async unassign(unassignment) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.roleAssignments.unassignRole({
        ...this.config.apiContext.environmentContext,
        roleAssignmentRemove: unassignment
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Assigns multiple roles in bulk using the provided role assignments data.
   * Each role assignment is a tuple of (user, role, tenant).
   *
   * @param assignments - The role assignments to be performed in bulk.
   * @returns A promise that resolves with the bulk assignment report.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async bulkAssign(assignments) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.roleAssignments.bulkAssignRole({
        ...this.config.apiContext.environmentContext,
        roleAssignmentCreate: assignments
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Removes multiple role assignments in bulk using the provided unassignment data.
   * Each role to unassign is a tuple of (user, role, tenant).
   *
   * @param unassignments - The role unassignments to be performed in bulk.
   * @returns A promise that resolves with the bulk unassignment report.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async bulkUnassign(unassignments) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.roleAssignments.bulkUnassignRole({
        ...this.config.apiContext.environmentContext,
        roleAssignmentRemove: unassignments
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
};

// src/api/roles.ts
var RolesApi2 = class extends BasePermitApi {
  /**
   * Creates an instance of the RolesApi.
   * @param config - The configuration object for the Permit SDK.
   * @param logger - The logger instance for logging.
   */
  constructor(config, logger) {
    super(config, logger);
    this.roles = new RolesApi(
      this.openapiClientConfig,
      BASE_PATH,
      this.config.axiosInstance
    );
  }
  async list(pagination) {
    const { page = 1, perPage = 100, includeTotalCount } = pagination ?? {};
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.roles.listRoles({
        ...this.config.apiContext.environmentContext,
        page,
        perPage,
        includeTotalCount
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Retrieves a role by its key.
   *
   * @param roleKey The key of the role.
   * @returns A promise that resolves to the role.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async get(roleKey) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.roles.getRole({
        ...this.config.apiContext.environmentContext,
        roleId: roleKey
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Retrieves a role by its key.
   * Alias for the {@link get} method.
   *
   * @param roleKey The key of the role.
   * @returns A promise that resolves to the role.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async getByKey(roleKey) {
    return await this.get(roleKey);
  }
  /**
   * Retrieves a role by its ID.
   * Alias for the {@link get} method.
   *
   * @param roleId The ID of the role.
   * @returns A promise that resolves to the role.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async getById(roleId) {
    return await this.get(roleId);
  }
  /**
   * Creates a new role.
   *
   * @param roleData The data for the new role.
   * @returns A promise that resolves to the created role.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async create(roleData) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.roles.createRole({
        ...this.config.apiContext.environmentContext,
        roleCreate: roleData
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Updates a role.
   *
   * @param roleKey The key of the role.
   * @param roleData The updated data for the role.
   * @returns A promise that resolves to the updated role.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async update(roleKey, roleData) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.roles.updateRole({
        ...this.config.apiContext.environmentContext,
        roleId: roleKey,
        roleUpdate: roleData
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Deletes a role.
   *
   * @param roleKey The key of the role to delete.
   * @returns A promise that resolves when the role is deleted.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async delete(roleKey) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      await this.roles.deleteRole({
        ...this.config.apiContext.environmentContext,
        roleId: roleKey
      });
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Assigns permissions to a role.
   * @param roleKey - The key of the role.
   * @param permissions - An array of permission keys (<resourceKey:actionKey>) to be assigned to the role.
   * @returns A promise that resolves to a RoleRead object representing the updated role.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async assignPermissions(roleKey, permissions) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.roles.assignPermissionsToRole({
        ...this.config.apiContext.environmentContext,
        roleId: roleKey,
        addRolePermissions: {
          permissions
        }
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Removes permissions from a role.
   * @param roleKey - The key of the role.
   * @param permissions - An array of permission keys (<resourceKey:actionKey>) to be removed from the role.
   * @returns A promise that resolves to a RoleRead object representing the updated role.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async removePermissions(roleKey, permissions) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.roles.removePermissionsFromRole({
        ...this.config.apiContext.environmentContext,
        roleId: roleKey,
        removeRolePermissions: {
          permissions
        }
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
};

// src/api/tenants.ts
var TenantsApi2 = class extends BaseFactsPermitAPI {
  /**
   * Creates an instance of the TenantsApi.
   * @param config - The configuration object for the Permit SDK.
   * @param logger - The logger instance for logging.
   */
  constructor(config, logger) {
    super(config, logger);
    this.tenants = new TenantsApi(
      this.openapiClientConfig,
      BASE_PATH,
      this.config.axiosInstance
    );
  }
  /**
   * Retrieves a list of tenants.
   *
   * @param params Filtering and pagination options, @see {@link IListTenantsParams}
   * @returns A promise that resolves to an array of tenants.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async list(params) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.tenants.listTenants({
        ...params,
        ...this.config.apiContext.environmentContext
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Retrieves a list of users for a given tenant.
   *
   * @param tenantKey - The key of the tenant for which to list users.
   * @param params - pagination and filtering params.
   * @returns A promise that resolves to a PaginatedResultUserRead object containing the list of tenant users.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async listTenantUsers({
    tenantKey,
    ...params
  }) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.tenants.listTenantUsers({
        ...params,
        ...this.config.apiContext.environmentContext,
        tenantId: tenantKey
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Retrieves a tenant by its key.
   *
   * @param tenantKey The key of the tenant.
   * @returns A promise that resolves to the tenant.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async get(tenantKey) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.tenants.getTenant({
        ...this.config.apiContext.environmentContext,
        tenantId: tenantKey
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Retrieves a tenant by its key.
   * Alias for the {@link get} method.
   *
   * @param tenantKey The key of the tenant.
   * @returns A promise that resolves to the tenant.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async getByKey(tenantKey) {
    return await this.get(tenantKey);
  }
  /**
   * Retrieves a tenant by its ID.
   * Alias for the {@link get} method.
   *
   * @param tenantId The ID of the tenant.
   * @returns A promise that resolves to the tenant.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async getById(tenantId) {
    return await this.get(tenantId);
  }
  /**
   * Creates a new tenant.
   *
   * @param tenantData The data for the new tenant.
   * @returns A promise that resolves to the created tenant.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async create(tenantData) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.tenants.createTenant({
        ...this.config.apiContext.environmentContext,
        tenantCreate: tenantData
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Updates a tenant.
   *
   * @param tenantKey The key of the tenant.
   * @param tenantData The updated data for the tenant.
   * @returns A promise that resolves to the updated tenant.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async update(tenantKey, tenantData) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.tenants.updateTenant({
        ...this.config.apiContext.environmentContext,
        tenantId: tenantKey,
        tenantUpdate: tenantData
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Deletes a tenant.
   *
   * @param tenantKey The key of the tenant to delete.
   * @returns A promise that resolves when the tenant is deleted.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async delete(tenantKey) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      await this.tenants.deleteTenant({
        ...this.config.apiContext.environmentContext,
        tenantId: tenantKey
      });
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Deletes a user from a given tenant (also removes all roles granted to the user in that tenant).
   *
   * @param tenantKey - The key of the tenant from which the user will be deleted.
   * @param userKey - The key of the user to be deleted.
   * @returns A promise that resolves when the user is successfully deleted.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async deleteTenantUser(tenantKey, userKey) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      await this.tenants.deleteTenantUser({
        ...this.config.apiContext.environmentContext,
        tenantId: tenantKey,
        userId: userKey
      });
    } catch (err) {
      this.handleApiError(err);
    }
  }
};

// src/openapi/api/bulk-operations-api.ts
var import_axios39 = __toESM(require("axios"));
var BulkOperationsApiAxiosParamCreator = function(configuration) {
  return {
    /**
     *
     * @summary Bulk Create Tenants
     * @param {any} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {any} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {any} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkCreateTenants: async (projId, envId, requestBody, options = {}) => {
      assertParamExists("bulkCreateTenants", "projId", projId);
      assertParamExists("bulkCreateTenants", "envId", envId);
      assertParamExists("bulkCreateTenants", "requestBody", requestBody);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/bulk/tenants`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBody,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Bulk Create Users
     * @param {any} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {any} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param userCreateBulkOperation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkCreateUsers: async (projId, envId, userCreateBulkOperation, options = {}) => {
      assertParamExists("bulkCreateUsers", "projId", projId);
      assertParamExists("bulkCreateUsers", "envId", envId);
      assertParamExists("bulkCreateUsers", "requestBody", userCreateBulkOperation);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/bulk/users`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userCreateBulkOperation,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes many Resource Instances.
     * @summary Bulk Delete Resource Instances
     * @param {any} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {any} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ResourceInstanceDeleteBulkOperation} resourceInstanceDeleteBulkOperation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkDeleteResourceInstances: async (projId, envId, resourceInstanceDeleteBulkOperation, options = {}) => {
      assertParamExists("bulkDeleteResourceInstances", "projId", projId);
      assertParamExists("bulkDeleteResourceInstances", "envId", envId);
      assertParamExists(
        "bulkDeleteResourceInstances",
        "resourceInstanceDeleteBulkOperation",
        resourceInstanceDeleteBulkOperation
      );
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/bulk/resource_instances`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        resourceInstanceDeleteBulkOperation,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Bulk Delete Tenants
     * @param {any} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {any} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {any} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkDeleteTenants: async (projId, envId, requestBody, options = {}) => {
      assertParamExists("bulkDeleteTenants", "projId", projId);
      assertParamExists("bulkDeleteTenants", "envId", envId);
      assertParamExists("bulkDeleteTenants", "requestBody", requestBody);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/bulk/tenants`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBody,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Bulk Delete Users
     * @param {any} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {any} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param userDeleteBulkOperation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkDeleteUsers: async (projId, envId, userDeleteBulkOperation, options = {}) => {
      assertParamExists("bulkDeleteUsers", "projId", projId);
      assertParamExists("bulkDeleteUsers", "envId", envId);
      assertParamExists("bulkDeleteUsers", "requestBody", userDeleteBulkOperation);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/bulk/users`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userDeleteBulkOperation,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Creates or replaces Resource Instances. If a resource instance with `key` and `resource` already exists, it will be replaced.
     * @summary Bulk Replace Resource Instances
     * @param {any} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {any} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ResourceInstanceCreateBulkOperation} resourceInstanceCreateBulkOperation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkReplaceResourceInstances: async (projId, envId, resourceInstanceCreateBulkOperation, options = {}) => {
      assertParamExists("bulkReplaceResourceInstances", "projId", projId);
      assertParamExists("bulkReplaceResourceInstances", "envId", envId);
      assertParamExists(
        "bulkReplaceResourceInstances",
        "resourceInstanceCreateBulkOperation",
        resourceInstanceCreateBulkOperation
      );
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/bulk/resource_instances`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        resourceInstanceCreateBulkOperation,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Bulk Replace Users
     * @param {any} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {any} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param userReplaceBulkOperation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkReplaceUsers: async (projId, envId, userReplaceBulkOperation, options = {}) => {
      assertParamExists("bulkReplaceUsers", "projId", projId);
      assertParamExists("bulkReplaceUsers", "envId", envId);
      assertParamExists("bulkReplaceUsers", "requestBody", userReplaceBulkOperation);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/bulk/users`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userReplaceBulkOperation,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var BulkOperationsApiFp = function(configuration) {
  const localVarAxiosParamCreator = BulkOperationsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Bulk Create Tenants
     * @param {any} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {any} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {{ [key: string]: any; }} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bulkCreateTenants(projId, envId, requestBody, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.bulkCreateTenants(
        projId,
        envId,
        requestBody,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios39.default, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Bulk Create Users
     * @param {any} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {any} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param userCreateBulkOperation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bulkCreateUsers(projId, envId, userCreateBulkOperation, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.bulkCreateUsers(
        projId,
        envId,
        userCreateBulkOperation,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios39.default, BASE_PATH, configuration);
    },
    /**
     * Deletes many Resource Instances.
     * @summary Bulk Delete Resource Instances
     * @param {any} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {any} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ResourceInstanceDeleteBulkOperation} resourceInstanceDeleteBulkOperation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bulkDeleteResourceInstances(projId, envId, resourceInstanceDeleteBulkOperation, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.bulkDeleteResourceInstances(
        projId,
        envId,
        resourceInstanceDeleteBulkOperation,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios39.default, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Bulk Delete Tenants
     * @param {any} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {any} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {{ [key: string]: any; }} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bulkDeleteTenants(projId, envId, requestBody, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.bulkDeleteTenants(
        projId,
        envId,
        requestBody,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios39.default, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Bulk Delete Users
     * @param {any} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {any} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param userDeleteBulkOperation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bulkDeleteUsers(projId, envId, userDeleteBulkOperation, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.bulkDeleteUsers(
        projId,
        envId,
        userDeleteBulkOperation,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios39.default, BASE_PATH, configuration);
    },
    /**
     * Creates or replaces Resource Instances. If a resource instance with `key` and `resource` already exists, it will be replaced.
     * @summary Bulk Replace Resource Instances
     * @param {any} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {any} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ResourceInstanceCreateBulkOperation} resourceInstanceCreateBulkOperation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bulkReplaceResourceInstances(projId, envId, resourceInstanceCreateBulkOperation, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.bulkReplaceResourceInstances(
        projId,
        envId,
        resourceInstanceCreateBulkOperation,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios39.default, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Bulk Replace Users
     * @param {any} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {any} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param userReplaceBulkOperation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bulkReplaceUsers(projId, envId, userReplaceBulkOperation, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.bulkReplaceUsers(
        projId,
        envId,
        userReplaceBulkOperation,
        options
      );
      return createRequestFunction(localVarAxiosArgs, import_axios39.default, BASE_PATH, configuration);
    }
  };
};
var BulkOperationsApi = class extends BaseAPI {
  /**
   *
   * @summary Bulk Create Tenants
   * @param {BulkOpertionsApiBulkCreateTenantsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BulkOperationsApi
   */
  bulkCreateTenants(requestParameters, options) {
    return BulkOperationsApiFp(this.configuration).bulkCreateTenants(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.requestBody,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Bulk Create Users
   * @param {BulkOperationsApiBulkCreateUsersRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BulkOperationsApi
   */
  bulkCreateUsers(requestParameters, options) {
    return BulkOperationsApiFp(this.configuration).bulkCreateUsers(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.userCreateBulkOperations,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Deletes many Resource Instances.
   * @summary Bulk Delete Resource Instances
   * @param {BulkOperationsApiBulkDeleteResourceInstancesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BulkOperationsApi
   */
  bulkDeleteResourceInstances(requestParameters, options) {
    return BulkOperationsApiFp(this.configuration).bulkDeleteResourceInstances(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceInstanceDeleteBulkOperation,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Bulk Delete Tenants
   * @param {BulkOperationsApiBulkDeleteTenantsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BulkOperationsApi
   */
  bulkDeleteTenants(requestParameters, options) {
    return BulkOperationsApiFp(this.configuration).bulkDeleteTenants(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.requestBody,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Bulk Delete Users
   * @param {BulkOperationsApiBulkDeleteUsersRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BulkOperationsApi
   */
  async bulkDeleteUsers(requestParameters, options) {
    let request = await BulkOperationsApiFp(this.configuration).bulkDeleteUsers(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.userDeleteBulkOperation,
      options
    );
    return request(this.axios, this.basePath);
  }
  /**
   * Creates or replaces Resource Instances. If a resource instance with `key` and `resource` already exists, it will be replaced.
   * @summary Bulk Replace Resource Instances
   * @param {BulkOperationsApiBulkReplaceResourceInstancesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BulkOperationsApi
   */
  bulkReplaceResourceInstances(requestParameters, options) {
    return BulkOperationsApiFp(this.configuration).bulkReplaceResourceInstances(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceInstanceCreateBulkOperation,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Bulk Replace Users
   * @param {BulkOperationsApiBulkReplaceUsersRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BulkOperationsApi
   */
  bulkReplaceUsers(requestParameters, options) {
    return BulkOperationsApiFp(this.configuration).bulkReplaceUsers(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.userReplaceBulkOperation,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
};

// src/api/users.ts
var UsersApi2 = class extends BaseFactsPermitAPI {
  /**
   * Creates an instance of the UsersApi.
   * @param config - The configuration object for the Permit SDK.
   * @param logger - The logger instance for logging.
   */
  constructor(config, logger) {
    super(config, logger);
    this.users = new UsersApi(
      this.openapiClientConfig,
      BASE_PATH,
      this.config.axiosInstance
    );
    this.roleAssignments = new RoleAssignmentsApi(
      this.openapiClientConfig,
      BASE_PATH,
      this.config.axiosInstance
    );
    this.bulkOperationsApi = new BulkOperationsApi(
      this.openapiClientConfig,
      BASE_PATH,
      this.config.axiosInstance
    );
  }
  /**
   * Retrieves a list of users.
   *
   * @param params Filtering and pagination options, @see {@link IUsersListParams}
   * @returns A promise that resolves to a PaginatedResultUserRead object containing the list of users.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async list(params) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.users.listUsers({
        ...params,
        ...this.config.apiContext.environmentContext
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Retrieves a user by its key.
   *
   * @param userKey The key of the user.
   * @returns A promise that resolves to the user.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async get(userKey) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.users.getUser({
        ...this.config.apiContext.environmentContext,
        userId: userKey
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Retrieves a user by its key.
   * Alias for the {@link get} method.
   *
   * @param userKey The key of the user.
   * @returns A promise that resolves to the user.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async getByKey(userKey) {
    return await this.get(userKey);
  }
  /**
   * Retrieves a user by its ID.
   * Alias for the {@link get} method.
   *
   * @param userId The ID of the user.
   * @returns A promise that resolves to the user.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async getById(userId) {
    return await this.get(userId);
  }
  /**
   * Creates a new user.
   *
   * @param userData The data for the new user.
   * @returns A promise that resolves to the created user.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async create(userData) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.users.createUser({
        ...this.config.apiContext.environmentContext,
        userCreate: userData
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Updates a user.
   *
   * @param userKey The key of the user.
   * @param userData The updated data for the user.
   * @returns A promise that resolves to the updated user.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async update(userKey, userData) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.users.updateUser({
        ...this.config.apiContext.environmentContext,
        userId: userKey,
        userUpdate: userData
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Synchronizes user data by creating or updating a user.
   *
   * @param userData - The data of the user to be synchronized.
   * @returns A promise that resolves with the result of the user creation or update operation.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async sync(userData) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this.users.replaceUser({
        ...this.config.apiContext.environmentContext,
        userId: userData.key,
        userCreate: userData
      });
      return {
        user: response.data,
        created: response.status === 201
      };
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Deletes a user.
   *
   * @param userKey The key of the user to delete.
   * @returns A promise that resolves when the user is deleted.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async delete(userKey) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      await this.users.deleteUser({
        ...this.config.apiContext.environmentContext,
        userId: userKey
      });
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Assigns a role to a user in the scope of a given tenant.
   *
   * @param assignment - The role assignment details.
   * @returns A promise that resolves with the assigned role.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async assignRole(assignment) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.roleAssignments.assignRole({
        ...this.config.apiContext.environmentContext,
        roleAssignmentCreate: assignment
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Unassigns a role from a user in the scope of a given tenant.
   *
   * @param unassignment - The role unassignment details.
   * @returns A promise that resolves when the role is successfully unassigned from the user.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async unassignRole(unassignment) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.roleAssignments.unassignRole({
        ...this.config.apiContext.environmentContext,
        roleAssignmentRemove: unassignment
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Creates users in bulk.
   *
   * @param users The array of users to create.
   * @returns A promise that resolves to the bulk creation result.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async bulkUserCreate(users) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.bulkOperationsApi.bulkCreateUsers({
        ...this.config.apiContext.environmentContext,
        userCreateBulkOperations: {
          operations: users
        }
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Deletes users in bulk.
   *
   * @param userKeys The array of user keys to delete.
   * @returns A promise that resolves to the bulk deletion result.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async bulkUserDelete(userKeys) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.bulkOperationsApi.bulkDeleteUsers({
        ...this.config.apiContext.environmentContext,
        userDeleteBulkOperation: {
          idents: userKeys
        }
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Replaces users in bulk.
   *
   * If a user exists, it will be replaced. Otherwise, it will be created.
   *
   * @param users The array of users to replace.
   * @returns A promise that resolves to the bulk replacement result.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async bulkUserReplace(users) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.bulkOperationsApi.bulkReplaceUsers({
        ...this.config.apiContext.environmentContext,
        userReplaceBulkOperation: {
          operations: users
        }
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  async getAssignedRoles({
    user,
    tenant,
    page = 1,
    perPage = 100,
    detailed = false,
    includeTotalCount = false
  }) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.roleAssignments.listRoleAssignments({
        ...this.config.apiContext.environmentContext,
        user,
        tenant,
        page,
        perPage,
        detailed,
        includeTotalCount
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
};

// src/api/api-client.ts
var ApiClient = class extends DeprecatedApiClient {
  /**
   * Constructs a new instance of the ApiClient class with the specified configuration and logger.
   *
   * @param config - The configuration for the Permit API client.
   * @param logger - The logger instance.
   */
  constructor(config, logger) {
    super(config, logger);
    this.conditionSetRules = new ConditionSetRulesApi2(config, logger);
    this.conditionSets = new ConditionSetsApi2(config, logger);
    this.projects = new ProjectsApi2(config, logger);
    this.environments = new EnvironmentsApi2(config, logger);
    this.actionGroups = new ResourceActionGroupsApi2(config, logger);
    this.resourceActions = new ResourceActionsApi2(config, logger);
    this.resourceAttributes = new ResourceAttributesApi2(config, logger);
    this.resourceRoles = new ResourceRolesApi2(config, logger);
    this.resourceRelations = new ResourceRelationsApi2(config, logger);
    this.resourceInstances = new ResourceInstancesApi2(config, logger);
    this.resources = new ResourcesApi2(config, logger);
    this.roleAssignments = new RoleAssignmentsApi2(config, logger);
    this.roles = new RolesApi2(config, logger);
    this.relationshipTuples = new RelationshipTuplesApi2(config, logger);
    this.tenants = new TenantsApi2(config, logger);
    this.users = new UsersApi2(config, logger);
  }
};

// src/api/elements.ts
var ElementsClient = class extends BasePermitApi {
  /**
   * Creates an instance of the ElementsClient.
   * @param config - The configuration object for the Permit SDK.
   * @param logger - The logger instance for logging.
   */
  constructor(config, logger) {
    super(config, logger);
    this.authApi = new AuthenticationApi(
      this.openapiClientConfig,
      BASE_PATH,
      this.config.axiosInstance
    );
  }
  /**
   * Logs in as a user in the context of a specific tenant.
   * @param loginData - The login data containing the user key and tenant key.
   * @returns The embedded login authentication session data.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async loginAs({
    userId,
    tenantId
  }) {
    try {
      const response = await this.authApi.elementsLoginAs({
        userLoginRequestInput: {
          user_id: userId,
          tenant_id: tenantId
        }
      });
      return {
        ...response.data,
        content: { url: response.data.redirect_url }
      };
    } catch (err) {
      this.handleApiError(err);
    }
  }
};

// src/config.ts
var import_axios40 = __toESM(require("axios"));
var import_lodash = __toESM(require("lodash"));
var ConfigFactory = class _ConfigFactory {
  /**
   * @returns the default SDK configuration
   */
  static defaults() {
    return {
      token: import_lodash.default.get(process.env, "PERMIT_API_KEY", ""),
      pdp: import_lodash.default.get(process.env, "PERMIT_PDP_URL", "http://localhost:7766"),
      apiUrl: import_lodash.default.get(process.env, "PERMIT_API_URL", "https://api.permit.io"),
      log: {
        // log level, default is warn (warnings and errors)
        level: import_lodash.default.get(process.env, "PERMIT_LOG_LEVEL", "warn"),
        // Label added to logs
        label: import_lodash.default.get(process.env, "PERMIT_LOG_LABEL", "Permit.io"),
        // When logging - dump full data to console as JSON
        json: JSON.parse(import_lodash.default.get(process.env, "PERMIT_LOG_JSON", "false"))
      },
      multiTenancy: {
        defaultTenant: "default",
        useDefaultTenantIfEmpty: true
      },
      timeout: void 0,
      throwOnError: true,
      apiContext: new ApiContext(),
      axiosInstance: import_axios40.default.create(),
      proxyFactsViaPdp: false,
      factsSyncTimeout: null,
      factsSyncTimeoutPolicy: null
    };
  }
  /**
   * Builds the Permit SDK configuration from the values provided by the SDK user
   * and from the default SDK configuration when no specific values are set.
   *
   * @param options - a partial configuration
   * @returns the SDK configuration (for unset values returns the default config)
   */
  static build(options) {
    const config = import_lodash.default.merge(import_lodash.default.assign({}, _ConfigFactory.defaults()), options);
    return config;
  }
};

// src/enforcement/enforcer.ts
var import_axios41 = __toESM(require("axios"));
var import_url_parse = __toESM(require("url-parse"));

// src/utils/context.ts
var ContextStore = class {
  constructor() {
    this.baseContext = {};
    // cross-query context (global context)
    this.transforms = [];
  }
  /**
   * add context to the base context
   */
  add(context) {
    this.baseContext = Object.assign(this.baseContext, context);
  }
  registerTransform(transform) {
    this.transforms.push(transform);
  }
  /**
   * merges the global context (this.context) with the context
   * provided for this specific query (context). the specific
   * context overrides the base (global) context.
   */
  getDerivedContext(context) {
    return Object.assign({}, this.baseContext, context);
  }
  transform(initialContext) {
    let context = { ...initialContext };
    for (const transform of this.transforms) {
      context = transform(context);
    }
    return context;
  }
};

// src/utils/http-logger.ts
var AxiosLoggingInterceptor = class {
  static setupInterceptor(axiosInstance, logger) {
    axiosInstance.interceptors.request.use(
      function(request) {
        var _a;
        request.headers = request.headers || {};
        logger.debug(`Sending HTTP request: ${(_a = request == null ? void 0 : request.method) == null ? void 0 : _a.toUpperCase()} ${request == null ? void 0 : request.url}`);
        return request;
      },
      function(error) {
        return Promise.reject(error);
      }
    );
    axiosInstance.interceptors.response.use(
      function(response) {
        var _a, _b, _c;
        logger.debug(
          `Received HTTP response: ${(_b = (_a = response == null ? void 0 : response.config) == null ? void 0 : _a.method) == null ? void 0 : _b.toUpperCase()} ${(_c = response == null ? void 0 : response.config) == null ? void 0 : _c.url}, status: ${response == null ? void 0 : response.status}`
        );
        return response;
      },
      function(error) {
        return Promise.reject(error);
      }
    );
  }
};

// src/enforcement/interfaces.ts
function isOpaGetUserPermissionsResult(obj) {
  return "result" in obj;
}

// src/enforcement/enforcer.ts
var RESOURCE_DELIMITER = ":";
function isString(x) {
  return typeof x === "string";
}
var PermitError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "PermitError";
  }
};
var PermitConnectionError = class extends PermitError {
  constructor(message) {
    super(message);
    this.name = "PermitConnectionError";
  }
};
var PermitPDPStatusError = class extends PermitError {
  constructor(message) {
    super(message);
    this.name = "PermitPDPStatusError";
  }
};
var Enforcer = class _Enforcer {
  /**
   * Creates an instance of the Enforcer class.
   * @param config - The configuration object for the Permit SDK.
   * @param logger - The logger instance for logging.
   */
  constructor(config, logger) {
    this.config = config;
    this.logger = logger;
    const opaBaseUrl = new import_url_parse.default(this.config.pdp);
    opaBaseUrl.set("port", "8181");
    opaBaseUrl.set("pathname", `${opaBaseUrl.pathname}v1/data/permit/`);
    const version = process.env.npm_package_version ?? "unknown";
    if (config.axiosInstance) {
      this.client = config.axiosInstance;
      this.client.defaults.baseURL = `${this.config.pdp}/`;
      this.client.defaults.headers.common["X-Permit-SDK-Version"] = `node:${version}`;
    } else {
      this.client = import_axios41.default.create({
        baseURL: `${this.config.pdp}/`,
        headers: {
          "X-Permit-SDK-Version": `node:${version}`
        }
      });
    }
    if (config.opaAxiosInstance) {
      this.opaClient = config.opaAxiosInstance;
      this.opaClient.defaults.baseURL = opaBaseUrl.toString();
      this.opaClient.defaults.headers.common["X-Permit-SDK-Version"] = `node:${version}`;
    } else {
      this.opaClient = import_axios41.default.create({
        baseURL: opaBaseUrl.toString(),
        headers: {
          "X-Permit-SDK-Version": `node:${version}`
        }
      });
    }
    this.logger = logger;
    AxiosLoggingInterceptor.setupInterceptor(this.client, this.logger);
    this.contextStore = new ContextStore();
  }
  async getUserPermissions(user, tenants, resources, resource_types, config = {}) {
    return await this.getUserPermissionsWithExceptions(
      user,
      tenants,
      resources,
      resource_types,
      config
    ).catch((err) => {
      const shouldThrow = config.throwOnError === void 0 ? this.config.throwOnError : config.throwOnError;
      if (shouldThrow) {
        throw err;
      } else {
        this.logger.error(err);
        return {};
      }
    });
  }
  async getUserPermissionsWithExceptions(user, tenants, resources, resource_types, config = {}) {
    const checkTimeout = config.timeout || this.config.timeout;
    const input = {
      user: isString(user) ? { key: user } : user,
      tenants,
      resources,
      resource_types
    };
    return await this.client.post("user-permissions", input, {
      headers: {
        Authorization: `Bearer ${this.config.token}`
      },
      timeout: checkTimeout
    }).then((response) => {
      if (response.status !== 200) {
        throw new PermitPDPStatusError(`Permit.getUserPermissions() got an unexpected status code: ${response.status}, please check your SDK init and make sure the PDP sidecar is configured correctly. 
            Read more about setting up the PDP at https://docs.permit.io`);
      }
      const permissions = (isOpaGetUserPermissionsResult(response.data) ? response.data.result.permissions : response.data) || {};
      this.logger.info(
        `permit.getUserPermissions(${_Enforcer.userRepr(input.user)}) = ${JSON.stringify(
          permissions
        )}`
      );
      return permissions;
    }).catch((error) => {
      var _a, _b;
      const errorMessage = `Error in permit.getUserPermissions(${_Enforcer.userRepr(input.user)})`;
      if (import_axios41.default.isAxiosError(error)) {
        const errorStatusCode = ((_a = error.response) == null ? void 0 : _a.status.toString()) || "";
        const errorDetails = ((_b = error == null ? void 0 : error.response) == null ? void 0 : _b.data) ? JSON.stringify(error.response.data) : error.message;
        this.logger.error(`[${errorStatusCode}] ${errorMessage}, err: ${errorDetails}`);
      } else {
        this.logger.error(`${errorMessage}
${error}`);
      }
      throw new PermitConnectionError(`Permit SDK got error: 
 ${error.message} 

          and cannot connect to the PDP, please check your configuration and make sure the
          PDP is running at ${this.config.pdp} and accepting requests. 

          Read more about setting up the PDP at https://docs.permit.io`);
    });
  }
  async bulkCheck(checks, context = {}, config = {}) {
    return await this.bulkCheckWithExceptions(checks, context, config).catch((err) => {
      const shouldThrow = config.throwOnError === void 0 ? this.config.throwOnError : config.throwOnError;
      if (shouldThrow) {
        throw err;
      } else {
        this.logger.error(err);
        return [];
      }
    });
  }
  buildCheckInput(user, action, resource, context = {}) {
    const normalizedUser = isString(user) ? { key: user } : user;
    const resourceObj = isString(resource) ? _Enforcer.resourceFromString(resource) : resource;
    const normalizedResource = this.normalizeResource(resourceObj);
    const queryContext = this.contextStore.getDerivedContext(context);
    return {
      user: normalizedUser,
      action,
      resource: normalizedResource,
      context: queryContext
    };
  }
  checkInputRepr(checkInput) {
    return `${_Enforcer.userRepr(checkInput.user)}, ${checkInput.action}, ${_Enforcer.resourceRepr(
      checkInput.resource
    )}`;
  }
  async bulkCheckWithExceptions(checks, context = {}, config = {}) {
    const checkTimeout = config.timeout || this.config.timeout;
    const inputs = [];
    checks.forEach((check) => {
      const input = this.buildCheckInput(check.user, check.action, check.resource, context);
      inputs.push(input);
    });
    return await this.client.post("allowed/bulk", inputs, {
      headers: {
        Authorization: `Bearer ${this.config.token}`
      },
      timeout: checkTimeout
    }).then((response) => {
      if (response.status !== 200) {
        throw new PermitPDPStatusError(`Permit.bulkCheck() got an unexpected status code: ${response.status}, please check your SDK init and make sure the PDP sidecar is configured correctly. 
            Read more about setting up the PDP at https://docs.permit.io`);
      }
      const decisions = (("allow" in response.data ? response.data.allow : response.data.result.allow) || []).map((decision) => decision.allow || false);
      this.logger.info(
        `permit.bulkCheck(${inputs.map((input) => this.checkInputRepr(input))}) = ${decisions}`
      );
      return decisions;
    }).catch((error) => {
      var _a, _b;
      const errorMessage = `Error in permit.bulkCheck(${inputs.map(
        (input) => this.checkInputRepr(input)
      )})`;
      if (import_axios41.default.isAxiosError(error)) {
        const errorStatusCode = ((_a = error.response) == null ? void 0 : _a.status.toString()) || "";
        const errorDetails = ((_b = error == null ? void 0 : error.response) == null ? void 0 : _b.data) ? JSON.stringify(error.response.data) : error.message;
        this.logger.error(`[${errorStatusCode}] ${errorMessage}, err: ${errorDetails}`);
      } else {
        this.logger.error(`${errorMessage}
${error}`);
      }
      throw new PermitConnectionError(`Permit SDK got error: 
 ${error.message} 

          and cannot connect to the PDP, please check your configuration and make sure the
          PDP is running at ${this.config.pdp} and accepting requests. 

          Read more about setting up the PDP at https://docs.permit.io`);
    });
  }
  async checkAllTenants(user, action, resource, context = {}, sdk = "node") {
    try {
      const response = await this.client.post("/allowed/all-tenants", {
        headers: {
          Authorization: `Bearer ${this.config.token}`,
          "X-Permit-Sdk-Language": sdk
        },
        params: {
          user,
          action,
          resource,
          context
        }
      });
      return response.data.allowedTenants.map((item) => item.tenant);
    } catch (error) {
      this.logger.error("Error fetching all tenants:", error);
      throw error;
    }
  }
  async check(user, action, resource, context = {}, config = {}) {
    return await this.checkWithExceptions(user, action, resource, context, config).catch((err) => {
      const shouldThrow = config.throwOnError === void 0 ? this.config.throwOnError : config.throwOnError;
      if (shouldThrow) {
        throw err;
      } else {
        this.logger.error(err);
        return false;
      }
    });
  }
  //check
  async checkWithExceptions(user, action, resource, context = {}, config = {}) {
    let input = this.buildCheckInput(user, action, resource, context);
    const client = (config == null ? void 0 : config.useOpa) ? this.opaClient : this.client;
    const path = (config == null ? void 0 : config.useOpa) ? "root" : "allowed";
    if (config == null ? void 0 : config.useOpa) {
      input = { input };
    }
    const checkTimeout = config.timeout || this.config.timeout;
    return await client.post(path, input, {
      headers: {
        Authorization: `Bearer ${this.config.token}`
      },
      timeout: checkTimeout
    }).then((response) => {
      if (response.status !== 200) {
        throw new PermitPDPStatusError(`Permit.check() got an unexpected status code: ${response.status}, please check your SDK init and make sure the PDP sidecar is configured correctly. 
            Read more about setting up the PDP at https://docs.permit.io`);
      }
      const decision = ("allow" in response.data ? response.data.allow : response.data.result.allow) || false;
      this.logger.info(
        `permit.check(${this.checkInputRepr(input.input || input)}) = ${decision}`
      );
      return decision;
    }).catch((error) => {
      var _a, _b;
      const errorMessage = `Error in permit.check(${this.checkInputRepr(
        input.input || input
      )})`;
      if (import_axios41.default.isAxiosError(error)) {
        const errorStatusCode = ((_a = error.response) == null ? void 0 : _a.status.toString()) || "";
        const errorDetails = ((_b = error == null ? void 0 : error.response) == null ? void 0 : _b.data) ? JSON.stringify(error.response.data) : error.message;
        this.logger.error(`[${errorStatusCode}] ${errorMessage}, err: ${errorDetails}`);
      } else {
        this.logger.error(`${errorMessage}
${error}`);
      }
      throw new PermitConnectionError(`Permit SDK got error: 
 ${error.message} 

          and cannot connect to the PDP, please check your configuration and make sure the PDP is running at ${this.config.pdp} and accepting requests. 

          Read more about setting up the PDP at https://docs.permit.io`);
    });
  }
  // TODO: remove this eventually, once we decide on finalized structure of AuthzQuery
  normalizeResource(resource) {
    const normalizedResource = Object.assign({}, resource);
    if (!normalizedResource.tenant && this.config.multiTenancy.useDefaultTenantIfEmpty) {
      normalizedResource.tenant = this.config.multiTenancy.defaultTenant;
    }
    return normalizedResource;
  }
  static userRepr(user) {
    if (user.attributes || user.email) {
      return JSON.stringify(user);
    }
    return user.key;
  }
  static resourceRepr(resource) {
    if (resource.attributes && resource.attributes.length > 0) {
      return JSON.stringify(resource);
    }
    let resourceRepr = "";
    if (resource.tenant) {
      resourceRepr += `${resource.tenant}/`;
    }
    resourceRepr += `${resource.type}:${resource.key ?? "*"}`;
    return resourceRepr;
  }
  static resourceFromString(resource) {
    const parts = resource.split(RESOURCE_DELIMITER);
    if (parts.length < 1 || parts.length > 2) {
      throw Error(`permit.check() got invalid resource string: '${resource}'`);
    }
    return {
      type: parts[0],
      key: parts.length > 1 ? parts[1] : void 0
    };
  }
  getMethods() {
    return {
      check: this.check.bind(this),
      bulkCheck: this.bulkCheck.bind(this),
      getUserPermissions: this.getUserPermissions.bind(this),
      checkAllTenants: this.checkAllTenants.bind(this)
    };
  }
};

// src/logger.ts
var import_pino = __toESM(require("pino"));
var LoggerFactory = class {
  static createLogger(config) {
    return (0, import_pino.default)({
      level: config.log.level,
      prettyPrint: config.log.json ? { levelFirst: true } : false,
      base: { label: config.log.label },
      timestamp: import_pino.default.stdTimeFunctions.isoTime
    });
  }
};

// src/index.ts
var Permit = class {
  /**
   * Constructs a new instance of the {@link Permit} class with the specified configuration.
   *
   * @param config - The configuration for the Permit SDK.
   */
  constructor(config) {
    this.config = ConfigFactory.build(config);
    this.logger = LoggerFactory.createLogger(this.config);
    AxiosLoggingInterceptor.setupInterceptor(this.config.axiosInstance, this.logger);
    this.api = new ApiClient(this.config, this.logger);
    this.enforcer = new Enforcer(this.config, this.logger);
    this.elements = new ElementsClient(this.config, this.logger);
    this.logger.debug(
      `Permit.io SDK initialized with config:
${JSON.stringify(this.config, void 0, 2)}`
    );
  }
  /**
   * Checks if a `user` is authorized to perform an `action` on a `resource` within the specified context.
   *
   * @param user     - The user object representing the user.
   * @param action   - The action to be performed on the resource.
   * @param resource - The resource object representing the resource.
   * @param context  - The context object representing the context in which the action is performed.
   * @returns `true` if the user is authorized, `false` otherwise.
   * @throws {@link PermitConnectionError} if an error occurs while sending the authorization request to the PDP.
   * @throws {@link PermitPDPStatusError} if received a response with unexpected status code from the PDP.
   */
  async check(user, action, resource, context, config) {
    return await this.enforcer.check(user, action, resource, context, config);
  }
  /**
   * Checks multiple requests within the specified context.
   *
   * @param checks   - The check requests.
   * @param context  - The context object representing the context in which the action is performed.
   * @returns array containing `true` if the user is authorized, `false` otherwise for each check request.
   * @throws {@link PermitConnectionError} if an error occurs while sending the authorization request to the PDP.
   * @throws {@link PermitPDPStatusError} if received a response with unexpected status code from the PDP.
   */
  async bulkCheck(checks, context, config) {
    return await this.enforcer.bulkCheck(checks, context, config);
  }
  /**
   * Get all tenants available in the system.
   * @returns An array of TenantDetails representing all tenants.
   */
  /**
   * Get all tenants available in the system.
   * @returns An array of TenantDetails representing all tenants.
   */
  async checkAllTenants(user, action, resource, context, sdk) {
    try {
      return await this.enforcer.checkAllTenants(user, action, resource, context, sdk);
    } catch (error) {
      this.logger.error("Error fetching all tenants:", error);
      throw error;
    }
  }
  /**
   * Get all permissions for the specified user.
   *
   * @param user     - The user object representing the user.
   * @param tenants  - The list of tenants to filter the permissions on ( given by roles ).
   * @param resources - The list of resources to filter the permissions on ( given by resource roles ).
   * @param resource_types - The list of resource types to filter the permissions on ( given by resource roles ).
   * @returns object with key as the resource identifier and value as the resource details and permissions.
   * @throws {@link PermitConnectionError} if an error occurs while sending the authorization request to the PDP.
   * @throws {@link PermitPDPStatusError} if received a response with unexpected status code from the PDP.
   */
  async getUserPermissions(user, tenants, resources, resource_types, config) {
    return await this.enforcer.getUserPermissions(user, tenants, resources, resource_types, config);
  }
};

// src/tests/fixtures.ts
var provideTestExecutionContext = (t) => {
  const defaultPDPAddress = process.env.CLOUD_PDP === "true" ? "https://cloudpdp.api.permit.io" : "http://localhost:7766";
  const defaultApiAddress = process.env.API_TIER === "prod" ? "https://api.permit.io" : "http://localhost:8000";
  const token = process.env.PDP_API_KEY || "";
  const pdpAddress = process.env.PDP_URL || defaultPDPAddress;
  const apiUrl = process.env.PDP_CONTROL_PLANE || defaultApiAddress;
  if (!token) {
    t.fail("PDP_API_KEY is not configured, test cannot run!");
  }
  t.context.permit = new Permit({
    token,
    pdp: pdpAddress,
    apiUrl,
    log: {
      level: "debug"
    }
  });
  t.context.logger = LoggerFactory.createLogger(t.context.permit.config);
};

// src/tests/bulk_test.spec.ts
var test_relationship_tuples = import_ava.default;
test_relationship_tuples.before(provideTestExecutionContext);
test_relationship_tuples("Bulk relationship tuples test", async (t) => {
  const permit = t.context.permit;
  const logger = t.context.logger;
  try {
    const tuples = [
      {
        subject: "folders:pdf",
        relation: "parent",
        object: "docs:tasks",
        tenant: "default"
      },
      {
        subject: "folders:png",
        relation: "parent",
        object: "docs:files",
        tenant: "default"
      }
    ];
    logger.info("Tuples: " + JSON.stringify(tuples));
    await permit.api.relationshipTuples.bulkRelationshipTuples(tuples);
  } catch (error) {
    logger.error(`Got error: ${error}`);
    t.fail(`Got error: ${error}`);
  }
});
var test_bulk_add_users = import_ava.default;
test_bulk_add_users.before(provideTestExecutionContext);
test_bulk_add_users("Bulk users test", async (t) => {
  const permit = t.context.permit;
  const logger = t.context.logger;
  try {
    const users = [
      {
        key: "user_maya_test_1"
      },
      {
        key: "user_maya_test_2"
      }
    ];
    logger.info("users: " + JSON.stringify(users));
    await permit.api.users.bulkUserCreate(users);
  } catch (error) {
    logger.error(`Got error: ${error}`);
    t.fail(`Got error: ${error}`);
  }
});
var test_bulk_replace_users = import_ava.default;
test_bulk_replace_users.before(provideTestExecutionContext);
test_bulk_replace_users("Bulk users replace test", async (t) => {
  const permit = t.context.permit;
  const logger = t.context.logger;
  try {
    const users = [
      {
        key: "user_maya_test_1",
        first_name: "1"
      },
      {
        key: "user_maya_test_2",
        first_name: "2"
      }
    ];
    logger.info("users: " + JSON.stringify(users));
    await permit.api.users.bulkUserReplace(users);
  } catch (error) {
    logger.error(`Got error: ${error}`);
    t.fail(`Got error: ${error}`);
  }
});
var test_bulk_delete_users = import_ava.default;
test_bulk_delete_users.before(provideTestExecutionContext);
test_bulk_delete_users("Bulk users delete test", async (t) => {
  const permit = t.context.permit;
  const logger = t.context.logger;
  try {
    const users = [
      {
        key: "user_maya_1"
      },
      {
        key: "user_maya_2"
      }
    ];
    logger.info("users: " + JSON.stringify(users));
    await permit.api.users.bulkUserCreate(users);
    const users_key = ["user_maya_1", "user_maya_2"];
    logger.info("users: " + JSON.stringify(users_key));
    await permit.api.users.bulkUserDelete(users_key);
  } catch (error) {
    logger.error(`Got error: ${error}`);
    t.fail(`Got error: ${error}`);
  }
});
/*! Bundled license information:

is-extglob/index.js:
  (*!
   * is-extglob <https://github.com/jonschlinkert/is-extglob>
   *
   * Copyright (c) 2014-2016, Jon Schlinkert.
   * Licensed under the MIT License.
   *)

is-glob/index.js:
  (*!
   * is-glob <https://github.com/jonschlinkert/is-glob>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   *)

is-number/index.js:
  (*!
   * is-number <https://github.com/jonschlinkert/is-number>
   *
   * Copyright (c) 2014-present, Jon Schlinkert.
   * Released under the MIT License.
   *)

to-regex-range/index.js:
  (*!
   * to-regex-range <https://github.com/micromatch/to-regex-range>
   *
   * Copyright (c) 2015-present, Jon Schlinkert.
   * Released under the MIT License.
   *)

fill-range/index.js:
  (*!
   * fill-range <https://github.com/jonschlinkert/fill-range>
   *
   * Copyright (c) 2014-present, Jon Schlinkert.
   * Licensed under the MIT License.
   *)

queue-microtask/index.js:
  (*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

run-parallel/index.js:
  (*! run-parallel. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

imurmurhash/imurmurhash.js:
  (**
   * @preserve
   * JS Implementation of incremental MurmurHash3 (r150) (as of May 10, 2013)
   *
   * @author <a href="mailto:jensyt@gmail.com">Jens Taylor</a>
   * @see http://github.com/homebrewing/brauhaus-diff
   * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
   * @see http://github.com/garycourt/murmurhash-js
   * @author <a href="mailto:aappleby@gmail.com">Austin Appleby</a>
   * @see http://sites.google.com/site/murmurhash/
   *)
*/
//# sourceMappingURL=bulk_test.spec.js.map