import { AxiosError, AxiosResponse } from 'axios';
import { Logger } from 'pino';
import { FactsSyncTimeoutPolicy, IPermitConfig } from '../config';
import { Configuration } from '../openapi';
import { ApiContextLevel, ApiKeyLevel } from './context';
interface FormattedAxiosError<T> {
    code?: string;
    message: string;
    error?: T;
    status?: number;
}
export declare class PermitApiError<T> extends Error {
    originalError: AxiosError<T>;
    constructor(message: string, originalError: AxiosError<T>);
    get formattedAxiosError(): FormattedAxiosError<T>;
    get request(): any;
    get response(): AxiosResponse<T> | undefined;
}
export interface IPagination {
    /**
     * the page number to fetch (default: 1)
     */
    page?: number;
    /**
     * how many items to fetch per page (default: 100)
     */
    perPage?: number;
}
export interface IBasePaginationExtended {
    /**
     * the page number to fetch (default: 1)
     */
    page?: number;
    /**
     * how many items to fetch per page (default: 100)
     */
    perPage?: number;
    /**
     * the total number of items
     */
    includeTotalCount?: boolean;
}
type IPaginationForceIncludeTotal = IBasePaginationExtended & {
    includeTotalCount: true;
};
export type IPaginationExtended = IBasePaginationExtended | IPaginationForceIncludeTotal;
export type ReturnPaginationType<T extends IPaginationExtended, Y, Z> = T extends IPaginationForceIncludeTotal ? Y : Z;
export declare abstract class BasePermitApi {
    protected config: IPermitConfig;
    protected logger: Logger;
    protected openapiClientConfig: Configuration;
    private scopeApi;
    constructor(config: IPermitConfig, logger: Logger);
    /**
     * Sets the API context and permitted access level based on the API key scope.
     */
    private setContextFromApiKey;
    /**
     * Ensure that the API Key has the necessary permissions to successfully call the API endpoint.
     * Note that this check is not foolproof, and the API may still throw 401.
     * @param requiredAccessLevel The required API Key Access level for the endpoint.
     * @throws PermitContextError If the currently set API key access level does not match the required access level.
     */
    ensureAccessLevel(requiredAccessLevel: ApiKeyLevel): Promise<void>;
    /**
     * Ensure that the API context matches the required endpoint context.
     * @param requiredContext The required API context level for the endpoint.
     * @throws PermitContextError If the currently set API context level does not match the required context level.
     */
    ensureContext(requiredContext: ApiContextLevel): Promise<void>;
    protected handleApiError(err: unknown): never;
}
export interface IWaitForSync {
    /**
     * Wait for the facts to be synchronized with the PDP. Available only when `proxyFactsViaPdp` is set to `true`.
     * @param timeout - The maximum number of seconds to wait for the synchronization to complete.
     * Set to null to wait indefinitely.
     * @param policy - Controls what happens when the timeout is reached during synchronization.
     * - 'ignore': Respond immediately when data update did not apply within the timeout period
     * - 'fail': Respond with 424 status code when data update did not apply within the timeout period
     */
    waitForSync(timeout: number | null, policy?: FactsSyncTimeoutPolicy): this;
}
export declare abstract class BaseFactsPermitAPI extends BasePermitApi implements IWaitForSync {
    protected config: IPermitConfig;
    protected logger: Logger;
    constructor(config: IPermitConfig, logger: Logger);
    protected clone(): this;
    waitForSync(timeout: number | null, policy?: FactsSyncTimeoutPolicy): this;
}
export {};
