// src/openapi/api/apikeys-api.ts
import globalAxios2 from "axios";

// src/openapi/base.ts
import globalAxios from "axios";
var BASE_PATH = "http://localhost".replace(/\/+$/, "");
var BaseAPI = class {
  constructor(configuration, basePath = BASE_PATH, axios2 = globalAxios) {
    this.basePath = basePath;
    this.axios = axios2;
    if (configuration) {
      this.configuration = configuration;
      this.basePath = configuration.basePath || this.basePath;
    }
  }
};
var RequiredError = class extends Error {
  constructor(field, msg) {
    super(msg);
    this.field = field;
    this.name = "RequiredError";
  }
};

// src/openapi/common.ts
var DUMMY_BASE_URL = "https://example.com";
var assertParamExists = function(functionName, paramName, paramValue) {
  if (paramValue === null || paramValue === void 0) {
    throw new RequiredError(
      paramName,
      `Required parameter ${paramName} was null or undefined when calling ${functionName}.`
    );
  }
};
var setBearerAuthToObject = async function(object, configuration) {
  if (configuration && configuration.accessToken) {
    const accessToken = typeof configuration.accessToken === "function" ? await configuration.accessToken() : await configuration.accessToken;
    object["Authorization"] = "Bearer " + accessToken;
  }
};
function setFlattenedQueryParams(urlSearchParams, parameter, key = "") {
  if (typeof parameter === "object") {
    if (Array.isArray(parameter)) {
      parameter.forEach((item) => setFlattenedQueryParams(urlSearchParams, item, key));
    } else {
      Object.keys(parameter).forEach(
        (currentKey) => setFlattenedQueryParams(
          urlSearchParams,
          parameter[currentKey],
          `${key}${key !== "" ? "." : ""}${currentKey}`
        )
      );
    }
  } else {
    if (urlSearchParams.has(key)) {
      urlSearchParams.append(key, parameter);
    } else {
      urlSearchParams.set(key, parameter);
    }
  }
}
var setSearchParams = function(url, ...objects) {
  const searchParams = new URLSearchParams(url.search);
  setFlattenedQueryParams(searchParams, objects);
  url.search = searchParams.toString();
};
var serializeDataIfNeeded = function(value, requestOptions, configuration) {
  const nonString = typeof value !== "string";
  const needsSerialization = nonString && configuration && configuration.isJsonMime ? configuration.isJsonMime(requestOptions.headers["Content-Type"]) : nonString;
  return needsSerialization ? JSON.stringify(value !== void 0 ? value : {}) : value || "";
};
var toPathString = function(url) {
  return url.pathname + url.search + url.hash;
};
var createRequestFunction = function(axiosArgs, globalAxios37, BASE_PATH2, configuration) {
  return (axios2 = globalAxios37, basePath = BASE_PATH2) => {
    const axiosRequestArgs = {
      ...axiosArgs.options,
      url: ((configuration == null ? void 0 : configuration.basePath) || basePath) + axiosArgs.url
    };
    return axios2.request(axiosRequestArgs);
  };
};

// src/openapi/api/apikeys-api.ts
var APIKeysApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * Creates a new api_key under the active organization.
     * @summary Create Api Key
     * @param {APIKeyCreate} aPIKeyCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createApiKey: async (aPIKeyCreate, options = {}) => {
      assertParamExists("createApiKey", "aPIKeyCreate", aPIKeyCreate);
      const localVarPath = `/v2/api-key`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        aPIKeyCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes the api_key and all its related data.
     * @summary Delete Api Key
     * @param {string} apiKeyId The unique id of the API key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteApiKey: async (apiKeyId, options = {}) => {
      assertParamExists("deleteApiKey", "apiKeyId", apiKeyId);
      const localVarPath = `/v2/api-key/{api_key_id}`.replace(
        `{${"api_key_id"}}`,
        encodeURIComponent(String(apiKeyId))
      );
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Gets a single api_key matching the given api_key_id, if such api_key exists.
     * @summary Get Api Key
     * @param {string} apiKeyId The unique id of the API key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getApiKey: async (apiKeyId, options = {}) => {
      assertParamExists("getApiKey", "apiKeyId", apiKeyId);
      const localVarPath = `/v2/api-key/{api_key_id}`.replace(
        `{${"api_key_id"}}`,
        encodeURIComponent(String(apiKeyId))
      );
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Get Api Key Scope
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getApiKeyScope: async (options = {}) => {
      const localVarPath = `/v2/api-key/scope`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Get Environment Api Key
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEnvironmentApiKey: async (projId, envId, options = {}) => {
      assertParamExists("getEnvironmentApiKey", "projId", projId);
      assertParamExists("getEnvironmentApiKey", "envId", envId);
      const localVarPath = `/v2/api-key/{proj_id}/{env_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Lists all the api_keys under the active organization.
     * @summary List Api Keys
     * @param {MemberAccessObj} [objectType]
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listApiKeys: async (objectType, page, perPage, options = {}) => {
      const localVarPath = `/v2/api-key`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (objectType !== void 0) {
        localVarQueryParameter["object_type"] = objectType;
      }
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Rotates the API key of the PDP container with id `pdp_id`.  The rotation of the API key revokes the old API key and issues a new API key to the PDP.
     * @summary Rotate API Key
     * @param {string} apiKeyId The unique id of the API key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rotateApiKey: async (apiKeyId, options = {}) => {
      assertParamExists("rotateApiKey", "apiKeyId", apiKeyId);
      const localVarPath = `/v2/api-key/{api_key_id}/rotate-secret`.replace(
        `{${"api_key_id"}}`,
        encodeURIComponent(String(apiKeyId))
      );
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var APIKeysApiFp = function(configuration) {
  const localVarAxiosParamCreator = APIKeysApiAxiosParamCreator(configuration);
  return {
    /**
     * Creates a new api_key under the active organization.
     * @summary Create Api Key
     * @param {APIKeyCreate} aPIKeyCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createApiKey(aPIKeyCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createApiKey(aPIKeyCreate, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * Deletes the api_key and all its related data.
     * @summary Delete Api Key
     * @param {string} apiKeyId The unique id of the API key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteApiKey(apiKeyId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApiKey(apiKeyId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * Gets a single api_key matching the given api_key_id, if such api_key exists.
     * @summary Get Api Key
     * @param {string} apiKeyId The unique id of the API key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getApiKey(apiKeyId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getApiKey(apiKeyId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get Api Key Scope
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getApiKeyScope(options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getApiKeyScope(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get Environment Api Key
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEnvironmentApiKey(projId, envId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getEnvironmentApiKey(
        projId,
        envId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * Lists all the api_keys under the active organization.
     * @summary List Api Keys
     * @param {MemberAccessObj} [objectType]
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listApiKeys(objectType, page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listApiKeys(
        objectType,
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * Rotates the API key of the PDP container with id `pdp_id`.  The rotation of the API key revokes the old API key and issues a new API key to the PDP.
     * @summary Rotate API Key
     * @param {string} apiKeyId The unique id of the API key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async rotateApiKey(apiKeyId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.rotateApiKey(apiKeyId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    }
  };
};
var APIKeysApi = class extends BaseAPI {
  /**
   * Creates a new api_key under the active organization.
   * @summary Create Api Key
   * @param {APIKeysApiCreateApiKeyRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIKeysApi
   */
  createApiKey(requestParameters, options) {
    return APIKeysApiFp(this.configuration).createApiKey(requestParameters.aPIKeyCreate, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Deletes the api_key and all its related data.
   * @summary Delete Api Key
   * @param {APIKeysApiDeleteApiKeyRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIKeysApi
   */
  deleteApiKey(requestParameters, options) {
    return APIKeysApiFp(this.configuration).deleteApiKey(requestParameters.apiKeyId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Gets a single api_key matching the given api_key_id, if such api_key exists.
   * @summary Get Api Key
   * @param {APIKeysApiGetApiKeyRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIKeysApi
   */
  getApiKey(requestParameters, options) {
    return APIKeysApiFp(this.configuration).getApiKey(requestParameters.apiKeyId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Get Api Key Scope
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIKeysApi
   */
  getApiKeyScope(options) {
    return APIKeysApiFp(this.configuration).getApiKeyScope(options).then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Get Environment Api Key
   * @param {APIKeysApiGetEnvironmentApiKeyRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIKeysApi
   */
  getEnvironmentApiKey(requestParameters, options) {
    return APIKeysApiFp(this.configuration).getEnvironmentApiKey(requestParameters.projId, requestParameters.envId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Lists all the api_keys under the active organization.
   * @summary List Api Keys
   * @param {APIKeysApiListApiKeysRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIKeysApi
   */
  listApiKeys(requestParameters = {}, options) {
    return APIKeysApiFp(this.configuration).listApiKeys(
      requestParameters.objectType,
      requestParameters.page,
      requestParameters.perPage,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Rotates the API key of the PDP container with id `pdp_id`.  The rotation of the API key revokes the old API key and issues a new API key to the PDP.
   * @summary Rotate API Key
   * @param {APIKeysApiRotateApiKeyRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIKeysApi
   */
  rotateApiKey(requestParameters, options) {
    return APIKeysApiFp(this.configuration).rotateApiKey(requestParameters.apiKeyId, options).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/audit-elements-data-api.ts
import globalAxios3 from "axios";

// src/openapi/api/audit-logs-api.ts
import globalAxios4 from "axios";

// src/openapi/api/authentication-api.ts
import globalAxios5 from "axios";

// src/openapi/api/condition-set-rules-api.ts
import globalAxios6 from "axios";

// src/openapi/api/condition-sets-api.ts
import globalAxios7 from "axios";

// src/openapi/api/decision-logs-api.ts
import globalAxios8 from "axios";

// src/openapi/api/decision-logs-ingress-api.ts
import globalAxios9 from "axios";

// src/openapi/api/default-api.ts
import globalAxios10 from "axios";

// src/openapi/api/elements-configs-api.ts
import globalAxios11 from "axios";

// src/openapi/api/environments-api.ts
import globalAxios12 from "axios";

// src/openapi/api/implicit-grants-api.ts
import globalAxios13 from "axios";
var ImplicitGrantsApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * Creates an implicit grant on a given role
     * @summary Create Implicit Grant
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {DerivedRoleRuleCreate} derivedRoleRuleCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createImplicitGrant: async (projId, envId, resourceId, roleId, derivedRoleRuleCreate, options = {}) => {
      assertParamExists("createImplicitGrant", "projId", projId);
      assertParamExists("createImplicitGrant", "envId", envId);
      assertParamExists("createImplicitGrant", "resourceId", resourceId);
      assertParamExists("createImplicitGrant", "roleId", roleId);
      assertParamExists("createImplicitGrant", "derivedRoleRuleCreate", derivedRoleRuleCreate);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/roles/{role_id}/implicit_grants`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId))).replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        derivedRoleRuleCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes an implicit grant on a given role
     * @summary Delete Implicit Grant
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {DerivedRoleRuleDelete} derivedRoleRuleDelete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteImplicitGrant: async (projId, envId, roleId, resourceId, derivedRoleRuleDelete, options = {}) => {
      assertParamExists("deleteImplicitGrant", "projId", projId);
      assertParamExists("deleteImplicitGrant", "envId", envId);
      assertParamExists("deleteImplicitGrant", "roleId", roleId);
      assertParamExists("deleteImplicitGrant", "resourceId", resourceId);
      assertParamExists("deleteImplicitGrant", "derivedRoleRuleDelete", derivedRoleRuleDelete);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/roles/{role_id}/implicit_grants`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"role_id"}}`, encodeURIComponent(String(roleId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        derivedRoleRuleDelete,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Update the `when` for implicit grants on a given role
     * @summary Update Implicit Grants Conditions
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {PermitBackendSchemasSchemaDerivedRoleDerivedRoleSettings} permitBackendSchemasSchemaDerivedRoleDerivedRoleSettings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateImplicitGrantsConditions: async (projId, envId, resourceId, roleId, permitBackendSchemasSchemaDerivedRoleDerivedRoleSettings, options = {}) => {
      assertParamExists("updateImplicitGrantsConditions", "projId", projId);
      assertParamExists("updateImplicitGrantsConditions", "envId", envId);
      assertParamExists("updateImplicitGrantsConditions", "resourceId", resourceId);
      assertParamExists("updateImplicitGrantsConditions", "roleId", roleId);
      assertParamExists(
        "updateImplicitGrantsConditions",
        "permitBackendSchemasSchemaDerivedRoleDerivedRoleSettings",
        permitBackendSchemasSchemaDerivedRoleDerivedRoleSettings
      );
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/roles/{role_id}/implicit_grants/conditions`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId))).replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        permitBackendSchemasSchemaDerivedRoleDerivedRoleSettings,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var ImplicitGrantsApiFp = function(configuration) {
  const localVarAxiosParamCreator = ImplicitGrantsApiAxiosParamCreator(configuration);
  return {
    /**
     * Creates an implicit grant on a given role
     * @summary Create Implicit Grant
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {DerivedRoleRuleCreate} derivedRoleRuleCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createImplicitGrant(projId, envId, resourceId, roleId, derivedRoleRuleCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createImplicitGrant(
        projId,
        envId,
        resourceId,
        roleId,
        derivedRoleRuleCreate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios13, BASE_PATH, configuration);
    },
    /**
     * Deletes an implicit grant on a given role
     * @summary Delete Implicit Grant
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {DerivedRoleRuleDelete} derivedRoleRuleDelete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteImplicitGrant(projId, envId, roleId, resourceId, derivedRoleRuleDelete, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteImplicitGrant(
        projId,
        envId,
        roleId,
        resourceId,
        derivedRoleRuleDelete,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios13, BASE_PATH, configuration);
    },
    /**
     * Update the `when` for implicit grants on a given role
     * @summary Update Implicit Grants Conditions
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {PermitBackendSchemasSchemaDerivedRoleDerivedRoleSettings} permitBackendSchemasSchemaDerivedRoleDerivedRoleSettings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateImplicitGrantsConditions(projId, envId, resourceId, roleId, permitBackendSchemasSchemaDerivedRoleDerivedRoleSettings, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateImplicitGrantsConditions(
        projId,
        envId,
        resourceId,
        roleId,
        permitBackendSchemasSchemaDerivedRoleDerivedRoleSettings,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios13, BASE_PATH, configuration);
    }
  };
};
var ImplicitGrantsApi = class extends BaseAPI {
  /**
   * Creates an implicit grant on a given role
   * @summary Create Implicit Grant
   * @param {ImplicitGrantsApiCreateImplicitGrantRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ImplicitGrantsApi
   */
  createImplicitGrant(requestParameters, options) {
    return ImplicitGrantsApiFp(this.configuration).createImplicitGrant(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.roleId,
      requestParameters.derivedRoleRuleCreate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Deletes an implicit grant on a given role
   * @summary Delete Implicit Grant
   * @param {ImplicitGrantsApiDeleteImplicitGrantRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ImplicitGrantsApi
   */
  deleteImplicitGrant(requestParameters, options) {
    return ImplicitGrantsApiFp(this.configuration).deleteImplicitGrant(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.roleId,
      requestParameters.resourceId,
      requestParameters.derivedRoleRuleDelete,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Update the `when` for implicit grants on a given role
   * @summary Update Implicit Grants Conditions
   * @param {ImplicitGrantsApiUpdateImplicitGrantsConditionsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ImplicitGrantsApi
   */
  updateImplicitGrantsConditions(requestParameters, options) {
    return ImplicitGrantsApiFp(this.configuration).updateImplicitGrantsConditions(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.roleId,
      requestParameters.permitBackendSchemasSchemaDerivedRoleDerivedRoleSettings,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/instructions-api.ts
import globalAxios14 from "axios";

// src/openapi/api/members-api.ts
import globalAxios15 from "axios";

// src/openapi/api/opaldata-api.ts
import globalAxios16 from "axios";

// src/openapi/api/organizations-api.ts
import globalAxios17 from "axios";

// src/openapi/api/policy-api.ts
import globalAxios18 from "axios";

// src/openapi/api/policy-decision-points-api.ts
import globalAxios19 from "axios";

// src/openapi/api/policy-git-repositories-api.ts
import globalAxios20 from "axios";

// src/openapi/api/projects-api.ts
import globalAxios21 from "axios";

// src/openapi/api/proxy-config-api.ts
import globalAxios22 from "axios";

// src/openapi/api/relationship-tuples-api.ts
import globalAxios23 from "axios";

// src/openapi/api/resource-action-groups-api.ts
import globalAxios24 from "axios";

// src/openapi/api/resource-actions-api.ts
import globalAxios25 from "axios";

// src/openapi/api/resource-attributes-api.ts
import globalAxios26 from "axios";

// src/openapi/api/resource-instances-api.ts
import globalAxios27 from "axios";

// src/openapi/api/resource-relations-api.ts
import globalAxios28 from "axios";

// src/openapi/api/resource-roles-api.ts
import globalAxios29 from "axios";
var ResourceRolesApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * Assign permissions to role.  If some of the permissions specified are already assigned, will skip them.
     * @summary Assign Permissions to Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {AddRolePermissions} addRolePermissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    assignPermissionsToResourceRole: async (projId, envId, resourceId, roleId, addRolePermissions, options = {}) => {
      assertParamExists("assignPermissionsToResourceRole", "projId", projId);
      assertParamExists("assignPermissionsToResourceRole", "envId", envId);
      assertParamExists("assignPermissionsToResourceRole", "resourceId", resourceId);
      assertParamExists("assignPermissionsToResourceRole", "roleId", roleId);
      assertParamExists(
        "assignPermissionsToResourceRole",
        "addRolePermissions",
        addRolePermissions
      );
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/roles/{role_id}/permissions`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId))).replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        addRolePermissions,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Creates a new role associated with the resource.
     * @summary Create Resource Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {ResourceRoleCreate} resourceRoleCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createResourceRole: async (projId, envId, resourceId, resourceRoleCreate, options = {}) => {
      assertParamExists("createResourceRole", "projId", projId);
      assertParamExists("createResourceRole", "envId", envId);
      assertParamExists("createResourceRole", "resourceId", resourceId);
      assertParamExists("createResourceRole", "resourceRoleCreate", resourceRoleCreate);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/roles`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        resourceRoleCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes the role and all its related data. This includes any permissions granted to said role.
     * @summary Delete Resource Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteResourceRole: async (projId, envId, resourceId, roleId, options = {}) => {
      assertParamExists("deleteResourceRole", "projId", projId);
      assertParamExists("deleteResourceRole", "envId", envId);
      assertParamExists("deleteResourceRole", "resourceId", resourceId);
      assertParamExists("deleteResourceRole", "roleId", roleId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/roles/{role_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId))).replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Gets a single role defined on the resource, if such role exists.
     * @summary Get Resource Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getResourceRole: async (projId, envId, resourceId, roleId, options = {}) => {
      assertParamExists("getResourceRole", "projId", projId);
      assertParamExists("getResourceRole", "envId", envId);
      assertParamExists("getResourceRole", "resourceId", resourceId);
      assertParamExists("getResourceRole", "roleId", roleId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/roles/{role_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId))).replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Lists all the roles defined on the resource.
     * @summary List Resource Roles
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listResourceRoles: async (projId, envId, resourceId, page, perPage, options = {}) => {
      assertParamExists("listResourceRoles", "projId", projId);
      assertParamExists("listResourceRoles", "envId", envId);
      assertParamExists("listResourceRoles", "resourceId", resourceId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/roles`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Remove permissions from role.  If some of the permissions specified are already unassigned, will skip them.
     * @summary Remove Permissions from Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {RemoveRolePermissions} removeRolePermissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removePermissionsFromResourceRole: async (projId, envId, resourceId, roleId, removeRolePermissions, options = {}) => {
      assertParamExists("removePermissionsFromResourceRole", "projId", projId);
      assertParamExists("removePermissionsFromResourceRole", "envId", envId);
      assertParamExists("removePermissionsFromResourceRole", "resourceId", resourceId);
      assertParamExists("removePermissionsFromResourceRole", "roleId", roleId);
      assertParamExists(
        "removePermissionsFromResourceRole",
        "removeRolePermissions",
        removeRolePermissions
      );
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/roles/{role_id}/permissions`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId))).replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        removeRolePermissions,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Partially updates the role defined on a resource. Fields that will be provided will be completely overwritten.
     * @summary Update Resource Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {ResourceRoleUpdate} resourceRoleUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateResourceRole: async (projId, envId, resourceId, roleId, resourceRoleUpdate, options = {}) => {
      assertParamExists("updateResourceRole", "projId", projId);
      assertParamExists("updateResourceRole", "envId", envId);
      assertParamExists("updateResourceRole", "resourceId", resourceId);
      assertParamExists("updateResourceRole", "roleId", roleId);
      assertParamExists("updateResourceRole", "resourceRoleUpdate", resourceRoleUpdate);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}/roles/{role_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId))).replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        resourceRoleUpdate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var ResourceRolesApiFp = function(configuration) {
  const localVarAxiosParamCreator = ResourceRolesApiAxiosParamCreator(configuration);
  return {
    /**
     * Assign permissions to role.  If some of the permissions specified are already assigned, will skip them.
     * @summary Assign Permissions to Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {AddRolePermissions} addRolePermissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async assignPermissionsToResourceRole(projId, envId, resourceId, roleId, addRolePermissions, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.assignPermissionsToResourceRole(
        projId,
        envId,
        resourceId,
        roleId,
        addRolePermissions,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios29, BASE_PATH, configuration);
    },
    /**
     * Creates a new role associated with the resource.
     * @summary Create Resource Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {ResourceRoleCreate} resourceRoleCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createResourceRole(projId, envId, resourceId, resourceRoleCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createResourceRole(
        projId,
        envId,
        resourceId,
        resourceRoleCreate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios29, BASE_PATH, configuration);
    },
    /**
     * Deletes the role and all its related data. This includes any permissions granted to said role.
     * @summary Delete Resource Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteResourceRole(projId, envId, resourceId, roleId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteResourceRole(
        projId,
        envId,
        resourceId,
        roleId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios29, BASE_PATH, configuration);
    },
    /**
     * Gets a single role defined on the resource, if such role exists.
     * @summary Get Resource Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getResourceRole(projId, envId, resourceId, roleId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getResourceRole(
        projId,
        envId,
        resourceId,
        roleId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios29, BASE_PATH, configuration);
    },
    /**
     * Lists all the roles defined on the resource.
     * @summary List Resource Roles
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listResourceRoles(projId, envId, resourceId, page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listResourceRoles(
        projId,
        envId,
        resourceId,
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios29, BASE_PATH, configuration);
    },
    /**
     * Remove permissions from role.  If some of the permissions specified are already unassigned, will skip them.
     * @summary Remove Permissions from Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {RemoveRolePermissions} removeRolePermissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removePermissionsFromResourceRole(projId, envId, resourceId, roleId, removeRolePermissions, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.removePermissionsFromResourceRole(
        projId,
        envId,
        resourceId,
        roleId,
        removeRolePermissions,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios29, BASE_PATH, configuration);
    },
    /**
     * Partially updates the role defined on a resource. Fields that will be provided will be completely overwritten.
     * @summary Update Resource Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {ResourceRoleUpdate} resourceRoleUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateResourceRole(projId, envId, resourceId, roleId, resourceRoleUpdate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateResourceRole(
        projId,
        envId,
        resourceId,
        roleId,
        resourceRoleUpdate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios29, BASE_PATH, configuration);
    }
  };
};
var ResourceRolesApi = class extends BaseAPI {
  /**
   * Assign permissions to role.  If some of the permissions specified are already assigned, will skip them.
   * @summary Assign Permissions to Role
   * @param {ResourceRolesApiAssignPermissionsToResourceRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceRolesApi
   */
  assignPermissionsToResourceRole(requestParameters, options) {
    return ResourceRolesApiFp(this.configuration).assignPermissionsToResourceRole(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.roleId,
      requestParameters.addRolePermissions,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Creates a new role associated with the resource.
   * @summary Create Resource Role
   * @param {ResourceRolesApiCreateResourceRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceRolesApi
   */
  createResourceRole(requestParameters, options) {
    return ResourceRolesApiFp(this.configuration).createResourceRole(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.resourceRoleCreate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Deletes the role and all its related data. This includes any permissions granted to said role.
   * @summary Delete Resource Role
   * @param {ResourceRolesApiDeleteResourceRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceRolesApi
   */
  deleteResourceRole(requestParameters, options) {
    return ResourceRolesApiFp(this.configuration).deleteResourceRole(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.roleId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Gets a single role defined on the resource, if such role exists.
   * @summary Get Resource Role
   * @param {ResourceRolesApiGetResourceRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceRolesApi
   */
  getResourceRole(requestParameters, options) {
    return ResourceRolesApiFp(this.configuration).getResourceRole(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.roleId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Lists all the roles defined on the resource.
   * @summary List Resource Roles
   * @param {ResourceRolesApiListResourceRolesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceRolesApi
   */
  listResourceRoles(requestParameters, options) {
    return ResourceRolesApiFp(this.configuration).listResourceRoles(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.page,
      requestParameters.perPage,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Remove permissions from role.  If some of the permissions specified are already unassigned, will skip them.
   * @summary Remove Permissions from Role
   * @param {ResourceRolesApiRemovePermissionsFromResourceRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceRolesApi
   */
  removePermissionsFromResourceRole(requestParameters, options) {
    return ResourceRolesApiFp(this.configuration).removePermissionsFromResourceRole(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.roleId,
      requestParameters.removeRolePermissions,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Partially updates the role defined on a resource. Fields that will be provided will be completely overwritten.
   * @summary Update Resource Role
   * @param {ResourceRolesApiUpdateResourceRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceRolesApi
   */
  updateResourceRole(requestParameters, options) {
    return ResourceRolesApiFp(this.configuration).updateResourceRole(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.roleId,
      requestParameters.resourceRoleUpdate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/resources-api.ts
import globalAxios30 from "axios";

// src/openapi/api/role-assignments-api.ts
import globalAxios31 from "axios";

// src/openapi/api/roles-api.ts
import globalAxios32 from "axios";

// src/openapi/api/tenants-api.ts
import globalAxios33 from "axios";

// src/openapi/api/user-attributes-api.ts
import globalAxios34 from "axios";

// src/openapi/api/users-api.ts
import globalAxios35 from "axios";

// src/openapi/api/users-elements-data-api.ts
import globalAxios36 from "axios";

// src/openapi/configuration.ts
var Configuration = class {
  constructor(param = {}) {
    this.apiKey = param.apiKey;
    this.username = param.username;
    this.password = param.password;
    this.accessToken = param.accessToken;
    this.basePath = param.basePath;
    this.baseOptions = param.baseOptions;
    this.formDataCtor = param.formDataCtor;
  }
  /**
   * Check if the given MIME is a JSON MIME.
   * JSON MIME examples:
   *   application/json
   *   application/json; charset=UTF8
   *   APPLICATION/JSON
   *   application/vnd.company+json
   * @param mime - MIME (Multipurpose Internet Mail Extensions)
   * @return True if the given MIME is JSON, false otherwise.
   */
  isJsonMime(mime) {
    const jsonMime = new RegExp(
      "^(application/json|[^;/ 	]+/[^;/ 	]+[+]json)[ 	]*(;.*)?$",
      "i"
    );
    return mime !== null && (jsonMime.test(mime) || mime.toLowerCase() === "application/json-patch+json");
  }
};

// src/api/base.ts
import axios from "axios";

// src/api/context.ts
var API_ACCESS_LEVELS = [
  "ORGANIZATION_LEVEL_API_KEY" /* ORGANIZATION_LEVEL_API_KEY */,
  "PROJECT_LEVEL_API_KEY" /* PROJECT_LEVEL_API_KEY */,
  "ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */
];
var ApiContextLevel = /* @__PURE__ */ ((ApiContextLevel2) => {
  ApiContextLevel2[ApiContextLevel2["WAIT_FOR_INIT"] = 0] = "WAIT_FOR_INIT";
  ApiContextLevel2[ApiContextLevel2["ORGANIZATION"] = 1] = "ORGANIZATION";
  ApiContextLevel2[ApiContextLevel2["PROJECT"] = 2] = "PROJECT";
  ApiContextLevel2[ApiContextLevel2["ENVIRONMENT"] = 3] = "ENVIRONMENT";
  return ApiContextLevel2;
})(ApiContextLevel || {});
var PermitContextError = class extends Error {
  constructor(message) {
    super(message);
  }
};

// src/api/base.ts
var PermitApiError = class extends Error {
  constructor(message, originalError) {
    super(message);
    this.originalError = originalError;
  }
  get formattedAxiosError() {
    var _a;
    return {
      code: this.originalError.code,
      message: this.message,
      error: (_a = this.originalError.response) == null ? void 0 : _a.data,
      status: this.originalError.status
    };
  }
  get request() {
    return this.originalError.request;
  }
  get response() {
    return this.originalError.response;
  }
};
var BasePermitApi = class {
  constructor(config, logger) {
    this.config = config;
    this.logger = logger;
    const version = process.env.npm_package_version ?? "unknown";
    this.openapiClientConfig = new Configuration({
      basePath: `${this.config.apiUrl}`,
      accessToken: this.config.token,
      baseOptions: {
        headers: {
          "X-Permit-SDK-Version": `node:${version}`
        }
      }
    });
    this.scopeApi = new APIKeysApi(this.openapiClientConfig, BASE_PATH, this.config.axiosInstance);
  }
  /**
   * Sets the API context and permitted access level based on the API key scope.
   */
  async setContextFromApiKey() {
    var _a, _b;
    try {
      this.logger.debug("Fetching api key scope");
      const response = await this.scopeApi.getApiKeyScope();
      if (response.data.organization_id !== void 0 && response.data.organization_id !== null) {
        this.config.apiContext._saveApiKeyAccessibleScope(
          response.data.organization_id,
          response.data.project_id,
          response.data.environment_id
        );
        if (response.data.project_id !== void 0 && response.data.project_id !== null) {
          if (response.data.environment_id !== void 0 && response.data.environment_id !== null) {
            this.logger.debug(`setting: environment-level api context`);
            this.config.apiContext.setEnvironmentLevelContext(
              response.data.organization_id,
              response.data.project_id,
              response.data.environment_id
            );
            return;
          }
          this.logger.debug(`setting: project-level api context`);
          this.config.apiContext.setProjectLevelContext(
            response.data.organization_id,
            response.data.project_id
          );
          return;
        }
        this.logger.debug(`setting: organization-level api context`);
        this.config.apiContext.setOrganizationLevelContext(response.data.organization_id);
        return;
      }
      throw new PermitContextError("could not set api context level");
    } catch (err) {
      if (axios.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.getApiKeyScope(), err: ${JSON.stringify(
            (_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data
          )}`
        );
      }
      throw new PermitContextError(
        "could not fetch the api key scope in order to set the api context level"
      );
    }
  }
  /**
   * Ensure that the API Key has the necessary permissions to successfully call the API endpoint.
   * Note that this check is not foolproof, and the API may still throw 401.
   * @param requiredAccessLevel The required API Key Access level for the endpoint.
   * @throws PermitContextError If the currently set API key access level does not match the required access level.
   */
  async ensureAccessLevel(requiredAccessLevel) {
    if (this.config.apiContext.contextLevel === 0 /* WAIT_FOR_INIT */ || this.config.apiContext.permittedAccessLevel === "WAIT_FOR_INIT" /* WAIT_FOR_INIT */) {
      await this.setContextFromApiKey();
    }
    if (requiredAccessLevel !== this.config.apiContext.permittedAccessLevel) {
      if (API_ACCESS_LEVELS.indexOf(requiredAccessLevel) < API_ACCESS_LEVELS.indexOf(this.config.apiContext.permittedAccessLevel)) {
        throw new PermitContextError(
          `You're trying to use an SDK method that requires an API Key with access level: ${requiredAccessLevel}, however the SDK is running with an API key with level ${this.config.apiContext.permittedAccessLevel}.`
        );
      }
    }
  }
  /**
   * Ensure that the API context matches the required endpoint context.
   * @param requiredContext The required API context level for the endpoint.
   * @throws PermitContextError If the currently set API context level does not match the required context level.
   */
  async ensureContext(requiredContext) {
    if (this.config.apiContext.contextLevel === 0 /* WAIT_FOR_INIT */ || this.config.apiContext.permittedAccessLevel === "WAIT_FOR_INIT" /* WAIT_FOR_INIT */) {
      await this.setContextFromApiKey();
    }
    if (this.config.apiContext.contextLevel < requiredContext || this.config.apiContext.contextLevel === 0 /* WAIT_FOR_INIT */) {
      throw new PermitContextError(
        `You're trying to use an SDK method that requires an API context of ${ApiContextLevel[requiredContext]}, however the SDK is running in a less specific context level: ${ApiContextLevel[this.config.apiContext.contextLevel]}.`
      );
    }
  }
  handleApiError(err) {
    var _a, _b, _c;
    if (axios.isAxiosError(err)) {
      const logMessage = `Got error status code: ${(_a = err.response) == null ? void 0 : _a.status}, err: ${JSON.stringify(
        (_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data
      )}`;
      const apiMessage = (_c = err.response) == null ? void 0 : _c.data.message;
      this.logger.error(logMessage);
      throw new PermitApiError(apiMessage, err);
    } else {
      throw err;
    }
  }
};

// src/api/resource-roles.ts
var ResourceRolesApi2 = class extends BasePermitApi {
  /**
   * Creates an instance of the ResourceRolesApi.
   * @param config - The configuration object for the Permit SDK.
   * @param logger - The logger instance for logging.
   */
  constructor(config, logger) {
    super(config, logger);
    this.resourceRoles = new ResourceRolesApi(
      this.openapiClientConfig,
      BASE_PATH,
      this.config.axiosInstance
    );
    this.roleDerivations = new ImplicitGrantsApi(
      this.openapiClientConfig,
      BASE_PATH,
      this.config.axiosInstance
    );
  }
  /**
   * Retrieves a list of resource roles.
   *
   * @param params - pagination and filtering params, @see {@link IListResourceRoles}
   * @returns A promise that resolves to an array of roles.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async list(params) {
    const { resourceKey, page = 1, perPage = 100 } = params;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.resourceRoles.listResourceRoles({
        ...this.config.apiContext.environmentContext,
        page,
        perPage,
        resourceId: resourceKey
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Retrieves a resource role by its key.
   *
   * @param resourceKey The key of the resource.
   * @param roleKey The key of the role.
   * @returns A promise that resolves to the role.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async get(resourceKey, roleKey) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.resourceRoles.getResourceRole({
        ...this.config.apiContext.environmentContext,
        resourceId: resourceKey,
        roleId: roleKey
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Retrieves a resource role by its key.
   * Alias for the {@link get} method.
   *
   * @param resourceKey The key of the resource.
   * @param roleKey The key of the role.
   * @returns A promise that resolves to the role.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async getByKey(resourceKey, roleKey) {
    return await this.get(resourceKey, roleKey);
  }
  /**
   * Retrieves a resource role by its ID.
   * Alias for the {@link get} method.
   *
   * @param resourceId The ID of the resource.
   * @param roleId The ID of the role.
   * @returns A promise that resolves to the role.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async getById(resourceId, roleId) {
    return await this.get(resourceId, roleId);
  }
  /**
   * Creates a new role.
   *
   * @param resourceKey The key of the resource.
   * @param roleData The data for the new role.
   * @returns A promise that resolves to the created role.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async create(resourceKey, roleData) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.resourceRoles.createResourceRole({
        ...this.config.apiContext.environmentContext,
        resourceId: resourceKey,
        resourceRoleCreate: roleData
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Updates a resource role.
   *
   * @param resourceKey The key of the resource.
   * @param roleKey The key of the role.
   * @param roleData The updated data for the role.
   * @returns A promise that resolves to the updated role.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async update(resourceKey, roleKey, roleData) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.resourceRoles.updateResourceRole({
        ...this.config.apiContext.environmentContext,
        resourceId: resourceKey,
        roleId: roleKey,
        resourceRoleUpdate: roleData
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Deletes a resource role.
   *
   * @param resourceKey The key of the resource.
   * @param roleKey The key of the role to delete.
   * @returns A promise that resolves when the role is deleted.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async delete(resourceKey, roleKey) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      await this.resourceRoles.deleteResourceRole({
        ...this.config.apiContext.environmentContext,
        resourceId: resourceKey,
        roleId: roleKey
      });
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Assigns permissions to a resource role.
   *
   * @param resourceKey The key of the resource.
   * @param roleKey - The key of the role.
   * @param permissions - An array of permission keys (<resourceKey:actionKey>) to be assigned to the role.
   * @returns A promise that resolves to a ResourceRoleRead object representing the updated role.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async assignPermissions(resourceKey, roleKey, permissions) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.resourceRoles.assignPermissionsToResourceRole({
        ...this.config.apiContext.environmentContext,
        resourceId: resourceKey,
        roleId: roleKey,
        addRolePermissions: {
          permissions
        }
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Removes permissions from a resource role.
   *
   * @param resourceKey The key of the resource.
   * @param roleKey - The key of the role.
   * @param permissions - An array of permission keys (<resourceKey:actionKey>) to be removed from the role.
   * @returns A promise that resolves to a ResourceRoleRead object representing the updated role.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   */
  async removePermissions(resourceKey, roleKey, permissions) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.resourceRoles.removePermissionsFromResourceRole({
        ...this.config.apiContext.environmentContext,
        resourceId: resourceKey,
        roleId: roleKey,
        removeRolePermissions: {
          permissions
        }
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Create a conditional derivation from another role.
   * The derivation states that users with some other role on a related object will implicitly also be granted this role.
   *
   * @param resourceKey - The key of the resource the role belongs to.
   * @param roleKey - The key of the role.
   * @param derivationRule - A rule when to derived this role from another related role.
   * @returns A DerivedRoleRuleRead object representing the newly created role derivation.
   * @throws PermitApiError - If the API returns an error HTTP status code.
   * @throws PermitContextError - If the configured ApiContext does not match the required endpoint context.
   */
  async createRoleDerivation(resourceKey, roleKey, derivationRule) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.roleDerivations.createImplicitGrant({
        ...this.config.apiContext.environmentContext,
        resourceId: resourceKey,
        roleId: roleKey,
        derivedRoleRuleCreate: derivationRule
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Delete a role derivation.
   *
   * @param resourceKey - The key of the resource the role belongs to.
   * @param roleKey - The key of the role.
   * @param derivationRule - The details of the derivation rule to delete.
   * @throws PermitApiError - If the API returns an error HTTP status code.
   * @throws PermitContextError - If the configured ApiContext does not match the required endpoint context.
   */
  async deleteRoleDerivation(resourceKey, roleKey, derivationRule) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.roleDerivations.deleteImplicitGrant({
        ...this.config.apiContext.environmentContext,
        resourceId: resourceKey,
        roleId: roleKey,
        derivedRoleRuleDelete: derivationRule
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
  /**
   * Update the optional (ABAC) conditions when to derive this role from other roles.
   *
   * @param resourceKey - The key of the resource the role belongs to.
   * @param roleKey - The key of the role.
   * @param conditions - The conditions object.
   * @returns The updated PermitBackendSchemasSchemaDerivedRoleDerivedRoleSettings.
   * @throws PermitApiError - If the API returns an error HTTP status code.
   * @throws PermitContextError - If the configured ApiContext does not match the required endpoint context.
   */
  async updateRoleDerivationConditions(resourceKey, roleKey, conditions) {
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      return (await this.roleDerivations.updateImplicitGrantsConditions({
        ...this.config.apiContext.environmentContext,
        resourceId: resourceKey,
        roleId: roleKey,
        permitBackendSchemasSchemaDerivedRoleDerivedRoleSettings: conditions
      })).data;
    } catch (err) {
      this.handleApiError(err);
    }
  }
};
export {
  ResourceRolesApi2 as ResourceRolesApi
};
//# sourceMappingURL=resource-roles.mjs.map