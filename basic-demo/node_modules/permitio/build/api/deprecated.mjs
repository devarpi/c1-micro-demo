// src/api/deprecated.ts
import axios2 from "axios";

// src/openapi/api/apikeys-api.ts
import globalAxios2 from "axios";

// src/openapi/base.ts
import globalAxios from "axios";
var BASE_PATH = "http://localhost".replace(/\/+$/, "");
var BaseAPI = class {
  constructor(configuration, basePath = BASE_PATH, axios3 = globalAxios) {
    this.basePath = basePath;
    this.axios = axios3;
    if (configuration) {
      this.configuration = configuration;
      this.basePath = configuration.basePath || this.basePath;
    }
  }
};
var RequiredError = class extends Error {
  constructor(field, msg) {
    super(msg);
    this.field = field;
    this.name = "RequiredError";
  }
};

// src/openapi/common.ts
var DUMMY_BASE_URL = "https://example.com";
var assertParamExists = function(functionName, paramName, paramValue) {
  if (paramValue === null || paramValue === void 0) {
    throw new RequiredError(
      paramName,
      `Required parameter ${paramName} was null or undefined when calling ${functionName}.`
    );
  }
};
var setBearerAuthToObject = async function(object, configuration) {
  if (configuration && configuration.accessToken) {
    const accessToken = typeof configuration.accessToken === "function" ? await configuration.accessToken() : await configuration.accessToken;
    object["Authorization"] = "Bearer " + accessToken;
  }
};
function setFlattenedQueryParams(urlSearchParams, parameter, key = "") {
  if (typeof parameter === "object") {
    if (Array.isArray(parameter)) {
      parameter.forEach((item) => setFlattenedQueryParams(urlSearchParams, item, key));
    } else {
      Object.keys(parameter).forEach(
        (currentKey) => setFlattenedQueryParams(
          urlSearchParams,
          parameter[currentKey],
          `${key}${key !== "" ? "." : ""}${currentKey}`
        )
      );
    }
  } else {
    if (urlSearchParams.has(key)) {
      urlSearchParams.append(key, parameter);
    } else {
      urlSearchParams.set(key, parameter);
    }
  }
}
var setSearchParams = function(url, ...objects) {
  const searchParams = new URLSearchParams(url.search);
  setFlattenedQueryParams(searchParams, objects);
  url.search = searchParams.toString();
};
var serializeDataIfNeeded = function(value, requestOptions, configuration) {
  const nonString = typeof value !== "string";
  const needsSerialization = nonString && configuration && configuration.isJsonMime ? configuration.isJsonMime(requestOptions.headers["Content-Type"]) : nonString;
  return needsSerialization ? JSON.stringify(value !== void 0 ? value : {}) : value || "";
};
var toPathString = function(url) {
  return url.pathname + url.search + url.hash;
};
var createRequestFunction = function(axiosArgs, globalAxios37, BASE_PATH2, configuration) {
  return (axios3 = globalAxios37, basePath = BASE_PATH2) => {
    const axiosRequestArgs = {
      ...axiosArgs.options,
      url: ((configuration == null ? void 0 : configuration.basePath) || basePath) + axiosArgs.url
    };
    return axios3.request(axiosRequestArgs);
  };
};

// src/openapi/api/apikeys-api.ts
var APIKeysApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * Creates a new api_key under the active organization.
     * @summary Create Api Key
     * @param {APIKeyCreate} aPIKeyCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createApiKey: async (aPIKeyCreate, options = {}) => {
      assertParamExists("createApiKey", "aPIKeyCreate", aPIKeyCreate);
      const localVarPath = `/v2/api-key`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        aPIKeyCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes the api_key and all its related data.
     * @summary Delete Api Key
     * @param {string} apiKeyId The unique id of the API key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteApiKey: async (apiKeyId, options = {}) => {
      assertParamExists("deleteApiKey", "apiKeyId", apiKeyId);
      const localVarPath = `/v2/api-key/{api_key_id}`.replace(
        `{${"api_key_id"}}`,
        encodeURIComponent(String(apiKeyId))
      );
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Gets a single api_key matching the given api_key_id, if such api_key exists.
     * @summary Get Api Key
     * @param {string} apiKeyId The unique id of the API key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getApiKey: async (apiKeyId, options = {}) => {
      assertParamExists("getApiKey", "apiKeyId", apiKeyId);
      const localVarPath = `/v2/api-key/{api_key_id}`.replace(
        `{${"api_key_id"}}`,
        encodeURIComponent(String(apiKeyId))
      );
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Get Api Key Scope
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getApiKeyScope: async (options = {}) => {
      const localVarPath = `/v2/api-key/scope`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Get Environment Api Key
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEnvironmentApiKey: async (projId, envId, options = {}) => {
      assertParamExists("getEnvironmentApiKey", "projId", projId);
      assertParamExists("getEnvironmentApiKey", "envId", envId);
      const localVarPath = `/v2/api-key/{proj_id}/{env_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Lists all the api_keys under the active organization.
     * @summary List Api Keys
     * @param {MemberAccessObj} [objectType]
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listApiKeys: async (objectType, page, perPage, options = {}) => {
      const localVarPath = `/v2/api-key`;
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (objectType !== void 0) {
        localVarQueryParameter["object_type"] = objectType;
      }
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Rotates the API key of the PDP container with id `pdp_id`.  The rotation of the API key revokes the old API key and issues a new API key to the PDP.
     * @summary Rotate API Key
     * @param {string} apiKeyId The unique id of the API key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rotateApiKey: async (apiKeyId, options = {}) => {
      assertParamExists("rotateApiKey", "apiKeyId", apiKeyId);
      const localVarPath = `/v2/api-key/{api_key_id}/rotate-secret`.replace(
        `{${"api_key_id"}}`,
        encodeURIComponent(String(apiKeyId))
      );
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var APIKeysApiFp = function(configuration) {
  const localVarAxiosParamCreator = APIKeysApiAxiosParamCreator(configuration);
  return {
    /**
     * Creates a new api_key under the active organization.
     * @summary Create Api Key
     * @param {APIKeyCreate} aPIKeyCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createApiKey(aPIKeyCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createApiKey(aPIKeyCreate, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * Deletes the api_key and all its related data.
     * @summary Delete Api Key
     * @param {string} apiKeyId The unique id of the API key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteApiKey(apiKeyId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApiKey(apiKeyId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * Gets a single api_key matching the given api_key_id, if such api_key exists.
     * @summary Get Api Key
     * @param {string} apiKeyId The unique id of the API key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getApiKey(apiKeyId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getApiKey(apiKeyId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get Api Key Scope
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getApiKeyScope(options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getApiKeyScope(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get Environment Api Key
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEnvironmentApiKey(projId, envId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getEnvironmentApiKey(
        projId,
        envId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * Lists all the api_keys under the active organization.
     * @summary List Api Keys
     * @param {MemberAccessObj} [objectType]
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listApiKeys(objectType, page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listApiKeys(
        objectType,
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    },
    /**
     * Rotates the API key of the PDP container with id `pdp_id`.  The rotation of the API key revokes the old API key and issues a new API key to the PDP.
     * @summary Rotate API Key
     * @param {string} apiKeyId The unique id of the API key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async rotateApiKey(apiKeyId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.rotateApiKey(apiKeyId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios2, BASE_PATH, configuration);
    }
  };
};
var APIKeysApi = class extends BaseAPI {
  /**
   * Creates a new api_key under the active organization.
   * @summary Create Api Key
   * @param {APIKeysApiCreateApiKeyRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIKeysApi
   */
  createApiKey(requestParameters, options) {
    return APIKeysApiFp(this.configuration).createApiKey(requestParameters.aPIKeyCreate, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Deletes the api_key and all its related data.
   * @summary Delete Api Key
   * @param {APIKeysApiDeleteApiKeyRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIKeysApi
   */
  deleteApiKey(requestParameters, options) {
    return APIKeysApiFp(this.configuration).deleteApiKey(requestParameters.apiKeyId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Gets a single api_key matching the given api_key_id, if such api_key exists.
   * @summary Get Api Key
   * @param {APIKeysApiGetApiKeyRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIKeysApi
   */
  getApiKey(requestParameters, options) {
    return APIKeysApiFp(this.configuration).getApiKey(requestParameters.apiKeyId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Get Api Key Scope
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIKeysApi
   */
  getApiKeyScope(options) {
    return APIKeysApiFp(this.configuration).getApiKeyScope(options).then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Get Environment Api Key
   * @param {APIKeysApiGetEnvironmentApiKeyRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIKeysApi
   */
  getEnvironmentApiKey(requestParameters, options) {
    return APIKeysApiFp(this.configuration).getEnvironmentApiKey(requestParameters.projId, requestParameters.envId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Lists all the api_keys under the active organization.
   * @summary List Api Keys
   * @param {APIKeysApiListApiKeysRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIKeysApi
   */
  listApiKeys(requestParameters = {}, options) {
    return APIKeysApiFp(this.configuration).listApiKeys(
      requestParameters.objectType,
      requestParameters.page,
      requestParameters.perPage,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Rotates the API key of the PDP container with id `pdp_id`.  The rotation of the API key revokes the old API key and issues a new API key to the PDP.
   * @summary Rotate API Key
   * @param {APIKeysApiRotateApiKeyRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof APIKeysApi
   */
  rotateApiKey(requestParameters, options) {
    return APIKeysApiFp(this.configuration).rotateApiKey(requestParameters.apiKeyId, options).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/audit-elements-data-api.ts
import globalAxios3 from "axios";

// src/openapi/api/audit-logs-api.ts
import globalAxios4 from "axios";

// src/openapi/api/authentication-api.ts
import globalAxios5 from "axios";

// src/openapi/api/condition-set-rules-api.ts
import globalAxios6 from "axios";
var ConditionSetRulesApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * Grant permissions to a user set *on* a resource set.  If the permission is already granted, it is skipped.
     * @summary Assign Set Permissions
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ConditionSetRuleCreate} conditionSetRuleCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    assignSetPermissions: async (projId, envId, conditionSetRuleCreate, options = {}) => {
      assertParamExists("assignSetPermissions", "projId", projId);
      assertParamExists("assignSetPermissions", "envId", envId);
      assertParamExists("assignSetPermissions", "conditionSetRuleCreate", conditionSetRuleCreate);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/set_rules`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        conditionSetRuleCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Lists the condition set rules matching the filter. - If the `user_set` filter is present, will only return the permissions set of that user set. - If the `permission` filter is present, will only return the permissions sets that equals to the queried permission. - If the `resource_set` filter is present, will only return the permissions set of that resource set.
     * @summary List Set Permissions
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} [userSet] optional user set filter, will only return rules where the permission is granted to this user set
     * @param {string} [permission] optional permission filter, will only return condition set rules granting this permission
     * @param {string} [resourceSet] optional resource set filter, will only return rules where the permission is granted on this resource set
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listSetPermissions: async (projId, envId, userSet, permission, resourceSet, page, perPage, options = {}) => {
      assertParamExists("listSetPermissions", "projId", projId);
      assertParamExists("listSetPermissions", "envId", envId);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/set_rules`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (userSet !== void 0) {
        localVarQueryParameter["user_set"] = userSet;
      }
      if (permission !== void 0) {
        localVarQueryParameter["permission"] = permission;
      }
      if (resourceSet !== void 0) {
        localVarQueryParameter["resource_set"] = resourceSet;
      }
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Revokes permissions to a user set *on* a resource set.  If the permission is not granted, it is skipped.
     * @summary Unassign Set Permissions
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ConditionSetRuleRemove} conditionSetRuleRemove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unassignSetPermissions: async (projId, envId, conditionSetRuleRemove, options = {}) => {
      assertParamExists("unassignSetPermissions", "projId", projId);
      assertParamExists("unassignSetPermissions", "envId", envId);
      assertParamExists("unassignSetPermissions", "conditionSetRuleRemove", conditionSetRuleRemove);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/set_rules`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        conditionSetRuleRemove,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var ConditionSetRulesApiFp = function(configuration) {
  const localVarAxiosParamCreator = ConditionSetRulesApiAxiosParamCreator(configuration);
  return {
    /**
     * Grant permissions to a user set *on* a resource set.  If the permission is already granted, it is skipped.
     * @summary Assign Set Permissions
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ConditionSetRuleCreate} conditionSetRuleCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async assignSetPermissions(projId, envId, conditionSetRuleCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.assignSetPermissions(
        projId,
        envId,
        conditionSetRuleCreate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios6, BASE_PATH, configuration);
    },
    /**
     * Lists the condition set rules matching the filter. - If the `user_set` filter is present, will only return the permissions set of that user set. - If the `permission` filter is present, will only return the permissions sets that equals to the queried permission. - If the `resource_set` filter is present, will only return the permissions set of that resource set.
     * @summary List Set Permissions
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} [userSet] optional user set filter, will only return rules where the permission is granted to this user set
     * @param {string} [permission] optional permission filter, will only return condition set rules granting this permission
     * @param {string} [resourceSet] optional resource set filter, will only return rules where the permission is granted on this resource set
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listSetPermissions(projId, envId, userSet, permission, resourceSet, page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listSetPermissions(
        projId,
        envId,
        userSet,
        permission,
        resourceSet,
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios6, BASE_PATH, configuration);
    },
    /**
     * Revokes permissions to a user set *on* a resource set.  If the permission is not granted, it is skipped.
     * @summary Unassign Set Permissions
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ConditionSetRuleRemove} conditionSetRuleRemove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async unassignSetPermissions(projId, envId, conditionSetRuleRemove, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.unassignSetPermissions(
        projId,
        envId,
        conditionSetRuleRemove,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios6, BASE_PATH, configuration);
    }
  };
};
var ConditionSetRulesApi = class extends BaseAPI {
  /**
   * Grant permissions to a user set *on* a resource set.  If the permission is already granted, it is skipped.
   * @summary Assign Set Permissions
   * @param {ConditionSetRulesApiAssignSetPermissionsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConditionSetRulesApi
   */
  assignSetPermissions(requestParameters, options) {
    return ConditionSetRulesApiFp(this.configuration).assignSetPermissions(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.conditionSetRuleCreate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Lists the condition set rules matching the filter. - If the `user_set` filter is present, will only return the permissions set of that user set. - If the `permission` filter is present, will only return the permissions sets that equals to the queried permission. - If the `resource_set` filter is present, will only return the permissions set of that resource set.
   * @summary List Set Permissions
   * @param {ConditionSetRulesApiListSetPermissionsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConditionSetRulesApi
   */
  listSetPermissions(requestParameters, options) {
    return ConditionSetRulesApiFp(this.configuration).listSetPermissions(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.userSet,
      requestParameters.permission,
      requestParameters.resourceSet,
      requestParameters.page,
      requestParameters.perPage,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Revokes permissions to a user set *on* a resource set.  If the permission is not granted, it is skipped.
   * @summary Unassign Set Permissions
   * @param {ConditionSetRulesApiUnassignSetPermissionsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConditionSetRulesApi
   */
  unassignSetPermissions(requestParameters, options) {
    return ConditionSetRulesApiFp(this.configuration).unassignSetPermissions(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.conditionSetRuleRemove,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/condition-sets-api.ts
import globalAxios7 from "axios";
var ConditionSetsApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * Creates a new condition set (can be either a user set or a resource set).
     * @summary Create Condition Set
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ConditionSetCreate} conditionSetCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createConditionSet: async (projId, envId, conditionSetCreate, options = {}) => {
      assertParamExists("createConditionSet", "projId", projId);
      assertParamExists("createConditionSet", "envId", envId);
      assertParamExists("createConditionSet", "conditionSetCreate", conditionSetCreate);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/condition_sets`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        conditionSetCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes a condition set and all its related data. This includes any permissions granted to said condition set (i.e: any matching condition set rules).
     * @summary Delete Condition Set
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} conditionSetId Either the unique id of the condition set, or the URL-friendly key of the condition set (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteConditionSet: async (projId, envId, conditionSetId, options = {}) => {
      assertParamExists("deleteConditionSet", "projId", projId);
      assertParamExists("deleteConditionSet", "envId", envId);
      assertParamExists("deleteConditionSet", "conditionSetId", conditionSetId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/condition_sets/{condition_set_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"condition_set_id"}}`, encodeURIComponent(String(conditionSetId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Gets a single condition set, if such condition set exists.
     * @summary Get Condition Set
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} conditionSetId Either the unique id of the condition set, or the URL-friendly key of the condition set (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConditionSet: async (projId, envId, conditionSetId, options = {}) => {
      assertParamExists("getConditionSet", "projId", projId);
      assertParamExists("getConditionSet", "envId", envId);
      assertParamExists("getConditionSet", "conditionSetId", conditionSetId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/condition_sets/{condition_set_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"condition_set_id"}}`, encodeURIComponent(String(conditionSetId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Gets all ancestors (parent, parent of parent, and so on)
     * @summary Get Condition Set Ancestors
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} conditionSetId Either the unique id of the condition set, or the URL-friendly key of the condition set (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConditionSetAncestors: async (projId, envId, conditionSetId, page, perPage, options = {}) => {
      assertParamExists("getConditionSetAncestors", "projId", projId);
      assertParamExists("getConditionSetAncestors", "envId", envId);
      assertParamExists("getConditionSetAncestors", "conditionSetId", conditionSetId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/condition_sets/{condition_set_id}/ancestors`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"condition_set_id"}}`, encodeURIComponent(String(conditionSetId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Gets all descendants (children, children of children, and so on)
     * @summary Get Condition Set Descendants
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} conditionSetId Either the unique id of the condition set, or the URL-friendly key of the condition set (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConditionSetDescendants: async (projId, envId, conditionSetId, page, perPage, options = {}) => {
      assertParamExists("getConditionSetDescendants", "projId", projId);
      assertParamExists("getConditionSetDescendants", "envId", envId);
      assertParamExists("getConditionSetDescendants", "conditionSetId", conditionSetId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/condition_sets/{condition_set_id}/descendants`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"condition_set_id"}}`, encodeURIComponent(String(conditionSetId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Get Condition Set Possible Parents
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} conditionSetId Either the unique id of the condition set, or the URL-friendly key of the condition set (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConditionSetPossibleParents: async (projId, envId, conditionSetId, page, perPage, options = {}) => {
      assertParamExists("getConditionSetPossibleParents", "projId", projId);
      assertParamExists("getConditionSetPossibleParents", "envId", envId);
      assertParamExists("getConditionSetPossibleParents", "conditionSetId", conditionSetId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/condition_sets/{condition_set_id}/possible_parents`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"condition_set_id"}}`, encodeURIComponent(String(conditionSetId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Lists all condition sets matching a filter.
     * @summary List Condition Sets
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ConditionSetType} [type] if provided, will return only the condition sets of the specified type. e.g: only user sets.
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listConditionSets: async (projId, envId, type, page, perPage, options = {}) => {
      assertParamExists("listConditionSets", "projId", projId);
      assertParamExists("listConditionSets", "envId", envId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/condition_sets`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (type !== void 0) {
        localVarQueryParameter["type"] = type;
      }
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Partially updates a condition set. Fields that will be provided will be completely overwritten.
     * @summary Update Condition Set
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} conditionSetId Either the unique id of the condition set, or the URL-friendly key of the condition set (i.e: the \&quot;slug\&quot;).
     * @param {ConditionSetUpdate} conditionSetUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateConditionSet: async (projId, envId, conditionSetId, conditionSetUpdate, options = {}) => {
      assertParamExists("updateConditionSet", "projId", projId);
      assertParamExists("updateConditionSet", "envId", envId);
      assertParamExists("updateConditionSet", "conditionSetId", conditionSetId);
      assertParamExists("updateConditionSet", "conditionSetUpdate", conditionSetUpdate);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/condition_sets/{condition_set_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"condition_set_id"}}`, encodeURIComponent(String(conditionSetId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        conditionSetUpdate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var ConditionSetsApiFp = function(configuration) {
  const localVarAxiosParamCreator = ConditionSetsApiAxiosParamCreator(configuration);
  return {
    /**
     * Creates a new condition set (can be either a user set or a resource set).
     * @summary Create Condition Set
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ConditionSetCreate} conditionSetCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createConditionSet(projId, envId, conditionSetCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createConditionSet(
        projId,
        envId,
        conditionSetCreate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios7, BASE_PATH, configuration);
    },
    /**
     * Deletes a condition set and all its related data. This includes any permissions granted to said condition set (i.e: any matching condition set rules).
     * @summary Delete Condition Set
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} conditionSetId Either the unique id of the condition set, or the URL-friendly key of the condition set (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteConditionSet(projId, envId, conditionSetId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteConditionSet(
        projId,
        envId,
        conditionSetId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios7, BASE_PATH, configuration);
    },
    /**
     * Gets a single condition set, if such condition set exists.
     * @summary Get Condition Set
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} conditionSetId Either the unique id of the condition set, or the URL-friendly key of the condition set (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getConditionSet(projId, envId, conditionSetId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getConditionSet(
        projId,
        envId,
        conditionSetId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios7, BASE_PATH, configuration);
    },
    /**
     * Gets all ancestors (parent, parent of parent, and so on)
     * @summary Get Condition Set Ancestors
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} conditionSetId Either the unique id of the condition set, or the URL-friendly key of the condition set (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getConditionSetAncestors(projId, envId, conditionSetId, page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getConditionSetAncestors(
        projId,
        envId,
        conditionSetId,
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios7, BASE_PATH, configuration);
    },
    /**
     * Gets all descendants (children, children of children, and so on)
     * @summary Get Condition Set Descendants
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} conditionSetId Either the unique id of the condition set, or the URL-friendly key of the condition set (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getConditionSetDescendants(projId, envId, conditionSetId, page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getConditionSetDescendants(
        projId,
        envId,
        conditionSetId,
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios7, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get Condition Set Possible Parents
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} conditionSetId Either the unique id of the condition set, or the URL-friendly key of the condition set (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getConditionSetPossibleParents(projId, envId, conditionSetId, page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getConditionSetPossibleParents(
        projId,
        envId,
        conditionSetId,
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios7, BASE_PATH, configuration);
    },
    /**
     * Lists all condition sets matching a filter.
     * @summary List Condition Sets
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ConditionSetType} [type] if provided, will return only the condition sets of the specified type. e.g: only user sets.
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listConditionSets(projId, envId, type, page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listConditionSets(
        projId,
        envId,
        type,
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios7, BASE_PATH, configuration);
    },
    /**
     * Partially updates a condition set. Fields that will be provided will be completely overwritten.
     * @summary Update Condition Set
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} conditionSetId Either the unique id of the condition set, or the URL-friendly key of the condition set (i.e: the \&quot;slug\&quot;).
     * @param {ConditionSetUpdate} conditionSetUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateConditionSet(projId, envId, conditionSetId, conditionSetUpdate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateConditionSet(
        projId,
        envId,
        conditionSetId,
        conditionSetUpdate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios7, BASE_PATH, configuration);
    }
  };
};
var ConditionSetsApi = class extends BaseAPI {
  /**
   * Creates a new condition set (can be either a user set or a resource set).
   * @summary Create Condition Set
   * @param {ConditionSetsApiCreateConditionSetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConditionSetsApi
   */
  createConditionSet(requestParameters, options) {
    return ConditionSetsApiFp(this.configuration).createConditionSet(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.conditionSetCreate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Deletes a condition set and all its related data. This includes any permissions granted to said condition set (i.e: any matching condition set rules).
   * @summary Delete Condition Set
   * @param {ConditionSetsApiDeleteConditionSetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConditionSetsApi
   */
  deleteConditionSet(requestParameters, options) {
    return ConditionSetsApiFp(this.configuration).deleteConditionSet(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.conditionSetId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Gets a single condition set, if such condition set exists.
   * @summary Get Condition Set
   * @param {ConditionSetsApiGetConditionSetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConditionSetsApi
   */
  getConditionSet(requestParameters, options) {
    return ConditionSetsApiFp(this.configuration).getConditionSet(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.conditionSetId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Gets all ancestors (parent, parent of parent, and so on)
   * @summary Get Condition Set Ancestors
   * @param {ConditionSetsApiGetConditionSetAncestorsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConditionSetsApi
   */
  getConditionSetAncestors(requestParameters, options) {
    return ConditionSetsApiFp(this.configuration).getConditionSetAncestors(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.conditionSetId,
      requestParameters.page,
      requestParameters.perPage,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Gets all descendants (children, children of children, and so on)
   * @summary Get Condition Set Descendants
   * @param {ConditionSetsApiGetConditionSetDescendantsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConditionSetsApi
   */
  getConditionSetDescendants(requestParameters, options) {
    return ConditionSetsApiFp(this.configuration).getConditionSetDescendants(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.conditionSetId,
      requestParameters.page,
      requestParameters.perPage,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Get Condition Set Possible Parents
   * @param {ConditionSetsApiGetConditionSetPossibleParentsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConditionSetsApi
   */
  getConditionSetPossibleParents(requestParameters, options) {
    return ConditionSetsApiFp(this.configuration).getConditionSetPossibleParents(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.conditionSetId,
      requestParameters.page,
      requestParameters.perPage,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Lists all condition sets matching a filter.
   * @summary List Condition Sets
   * @param {ConditionSetsApiListConditionSetsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConditionSetsApi
   */
  listConditionSets(requestParameters, options) {
    return ConditionSetsApiFp(this.configuration).listConditionSets(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.type,
      requestParameters.page,
      requestParameters.perPage,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Partially updates a condition set. Fields that will be provided will be completely overwritten.
   * @summary Update Condition Set
   * @param {ConditionSetsApiUpdateConditionSetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConditionSetsApi
   */
  updateConditionSet(requestParameters, options) {
    return ConditionSetsApiFp(this.configuration).updateConditionSet(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.conditionSetId,
      requestParameters.conditionSetUpdate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/decision-logs-api.ts
import globalAxios8 from "axios";

// src/openapi/api/decision-logs-ingress-api.ts
import globalAxios9 from "axios";

// src/openapi/api/default-api.ts
import globalAxios10 from "axios";

// src/openapi/api/elements-configs-api.ts
import globalAxios11 from "axios";

// src/openapi/api/environments-api.ts
import globalAxios12 from "axios";

// src/openapi/api/implicit-grants-api.ts
import globalAxios13 from "axios";

// src/openapi/api/instructions-api.ts
import globalAxios14 from "axios";

// src/openapi/api/members-api.ts
import globalAxios15 from "axios";

// src/openapi/api/opaldata-api.ts
import globalAxios16 from "axios";

// src/openapi/api/organizations-api.ts
import globalAxios17 from "axios";

// src/openapi/api/policy-api.ts
import globalAxios18 from "axios";

// src/openapi/api/policy-decision-points-api.ts
import globalAxios19 from "axios";

// src/openapi/api/policy-git-repositories-api.ts
import globalAxios20 from "axios";

// src/openapi/api/projects-api.ts
import globalAxios21 from "axios";

// src/openapi/api/proxy-config-api.ts
import globalAxios22 from "axios";

// src/openapi/api/relationship-tuples-api.ts
import globalAxios23 from "axios";

// src/openapi/api/resource-action-groups-api.ts
import globalAxios24 from "axios";

// src/openapi/api/resource-actions-api.ts
import globalAxios25 from "axios";

// src/openapi/api/resource-attributes-api.ts
import globalAxios26 from "axios";

// src/openapi/api/resource-instances-api.ts
import globalAxios27 from "axios";

// src/openapi/api/resource-relations-api.ts
import globalAxios28 from "axios";

// src/openapi/api/resource-roles-api.ts
import globalAxios29 from "axios";

// src/openapi/api/resources-api.ts
import globalAxios30 from "axios";
var ResourcesApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * Creates a new resource (a type of object you may protect with permissions).
     * @summary Create Resource
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ResourceCreate} resourceCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createResource: async (projId, envId, resourceCreate, options = {}) => {
      assertParamExists("createResource", "projId", projId);
      assertParamExists("createResource", "envId", envId);
      assertParamExists("createResource", "resourceCreate", resourceCreate);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        resourceCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes the resource and all its related data.
     * @summary Delete Resource
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteResource: async (projId, envId, resourceId, options = {}) => {
      assertParamExists("deleteResource", "projId", projId);
      assertParamExists("deleteResource", "envId", envId);
      assertParamExists("deleteResource", "resourceId", resourceId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Gets a single resource, if such resource exists.
     * @summary Get Resource
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getResource: async (projId, envId, resourceId, options = {}) => {
      assertParamExists("getResource", "projId", projId);
      assertParamExists("getResource", "envId", envId);
      assertParamExists("getResource", "resourceId", resourceId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Lists all the resources defined in your schema.
     * @summary List Resources
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {boolean} [includeBuiltIn] Whether to include or exclude built-in resources, default is False
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {includeTotalCount} [includeTotalCount] Include the total count of resources in the response, default is False
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listResources: async (projId, envId, includeBuiltIn, page, perPage, includeTotalCount, options = {}) => {
      assertParamExists("listResources", "projId", projId);
      assertParamExists("listResources", "envId", envId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (includeBuiltIn !== void 0) {
        localVarQueryParameter["include_built_in"] = includeBuiltIn;
      }
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      if (includeTotalCount !== void 0) {
        localVarQueryParameter["include_total_count"] = includeTotalCount;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Completely replaces the resource definition.  - If the resource key is changed, all role and permissions assignments for the the resource will be revoked. - If the resource key is unchanged, but some actions are removed or renamed from the resource definition, role and permissions assignments for these actions will be revoked.  TODO: we need to decide if we are auto-revoking, or if we are rejecting the PUT completely while there are permissions that can be affected.
     * @summary Replace Resource
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {ResourceReplace} resourceReplace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    replaceResource: async (projId, envId, resourceId, resourceReplace, options = {}) => {
      assertParamExists("replaceResource", "projId", projId);
      assertParamExists("replaceResource", "envId", envId);
      assertParamExists("replaceResource", "resourceId", resourceId);
      assertParamExists("replaceResource", "resourceReplace", resourceReplace);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        resourceReplace,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Partially updates the resource definition. Fields that will be provided will be completely overwritten.
     * @summary Update Resource
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {ResourceUpdate} resourceUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateResource: async (projId, envId, resourceId, resourceUpdate, options = {}) => {
      assertParamExists("updateResource", "projId", projId);
      assertParamExists("updateResource", "envId", envId);
      assertParamExists("updateResource", "resourceId", resourceId);
      assertParamExists("updateResource", "resourceUpdate", resourceUpdate);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/resources/{resource_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"resource_id"}}`, encodeURIComponent(String(resourceId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        resourceUpdate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var ResourcesApiFp = function(configuration) {
  const localVarAxiosParamCreator = ResourcesApiAxiosParamCreator(configuration);
  return {
    /**
     * Creates a new resource (a type of object you may protect with permissions).
     * @summary Create Resource
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {ResourceCreate} resourceCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createResource(projId, envId, resourceCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createResource(
        projId,
        envId,
        resourceCreate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios30, BASE_PATH, configuration);
    },
    /**
     * Deletes the resource and all its related data.
     * @summary Delete Resource
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteResource(projId, envId, resourceId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteResource(
        projId,
        envId,
        resourceId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios30, BASE_PATH, configuration);
    },
    /**
     * Gets a single resource, if such resource exists.
     * @summary Get Resource
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getResource(projId, envId, resourceId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getResource(
        projId,
        envId,
        resourceId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios30, BASE_PATH, configuration);
    },
    /**
     * Lists all the resources defined in your schema.
     * @summary List Resources
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {boolean} [includeBuiltIn] Whether to include or exclude built-in resources, default is False
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {includeTotalCount} [includeTotalCount] Include the total count of resources in the response, default is False
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listResources(projId, envId, includeBuiltIn, page, perPage, includeTotalCount, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listResources(
        projId,
        envId,
        includeBuiltIn,
        page,
        perPage,
        includeTotalCount,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios30, BASE_PATH, configuration);
    },
    /**
     * Completely replaces the resource definition.  - If the resource key is changed, all role and permissions assignments for the the resource will be revoked. - If the resource key is unchanged, but some actions are removed or renamed from the resource definition, role and permissions assignments for these actions will be revoked.  TODO: we need to decide if we are auto-revoking, or if we are rejecting the PUT completely while there are permissions that can be affected.
     * @summary Replace Resource
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {ResourceReplace} resourceReplace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async replaceResource(projId, envId, resourceId, resourceReplace, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.replaceResource(
        projId,
        envId,
        resourceId,
        resourceReplace,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios30, BASE_PATH, configuration);
    },
    /**
     * Partially updates the resource definition. Fields that will be provided will be completely overwritten.
     * @summary Update Resource
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} resourceId Either the unique id of the resource, or the URL-friendly key of the resource (i.e: the \&quot;slug\&quot;).
     * @param {ResourceUpdate} resourceUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateResource(projId, envId, resourceId, resourceUpdate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateResource(
        projId,
        envId,
        resourceId,
        resourceUpdate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios30, BASE_PATH, configuration);
    }
  };
};
var ResourcesApi = class extends BaseAPI {
  /**
   * Creates a new resource (a type of object you may protect with permissions).
   * @summary Create Resource
   * @param {ResourcesApiCreateResourceRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  createResource(requestParameters, options) {
    return ResourcesApiFp(this.configuration).createResource(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceCreate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Deletes the resource and all its related data.
   * @summary Delete Resource
   * @param {ResourcesApiDeleteResourceRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  deleteResource(requestParameters, options) {
    return ResourcesApiFp(this.configuration).deleteResource(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Gets a single resource, if such resource exists.
   * @summary Get Resource
   * @param {ResourcesApiGetResourceRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  getResource(requestParameters, options) {
    return ResourcesApiFp(this.configuration).getResource(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Lists all the resources defined in your schema.
   * @summary List Resources
   * @param {ResourcesApiListResourcesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  listResources(requestParameters, options) {
    return ResourcesApiFp(this.configuration).listResources(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.includeBuiltIn,
      requestParameters.page,
      requestParameters.perPage,
      requestParameters.includeTotalCount,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Completely replaces the resource definition.  - If the resource key is changed, all role and permissions assignments for the the resource will be revoked. - If the resource key is unchanged, but some actions are removed or renamed from the resource definition, role and permissions assignments for these actions will be revoked.  TODO: we need to decide if we are auto-revoking, or if we are rejecting the PUT completely while there are permissions that can be affected.
   * @summary Replace Resource
   * @param {ResourcesApiReplaceResourceRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  replaceResource(requestParameters, options) {
    return ResourcesApiFp(this.configuration).replaceResource(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.resourceReplace,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Partially updates the resource definition. Fields that will be provided will be completely overwritten.
   * @summary Update Resource
   * @param {ResourcesApiUpdateResourceRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  updateResource(requestParameters, options) {
    return ResourcesApiFp(this.configuration).updateResource(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.resourceId,
      requestParameters.resourceUpdate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/role-assignments-api.ts
import globalAxios31 from "axios";
var RoleAssignmentsApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * Assigns a role to a user within a tenant.  The tenant defines the scope of the assignment. In other words, the role is effective only within the tenant.
     * @summary Assign Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {RoleAssignmentCreate} roleAssignmentCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    assignRole: async (projId, envId, roleAssignmentCreate, options = {}) => {
      assertParamExists("assignRole", "projId", projId);
      assertParamExists("assignRole", "envId", envId);
      assertParamExists("assignRole", "roleAssignmentCreate", roleAssignmentCreate);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/role_assignments`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        roleAssignmentCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Bulk Assign Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {Array<RoleAssignmentCreate>} roleAssignmentCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkAssignRole: async (projId, envId, roleAssignmentCreate, options = {}) => {
      assertParamExists("bulkAssignRole", "projId", projId);
      assertParamExists("bulkAssignRole", "envId", envId);
      assertParamExists("bulkAssignRole", "roleAssignmentCreate", roleAssignmentCreate);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/role_assignments/bulk`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        roleAssignmentCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Bulk Unassign Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {Array<RoleAssignmentRemove>} roleAssignmentRemove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkUnassignRole: async (projId, envId, roleAssignmentRemove, options = {}) => {
      assertParamExists("bulkUnassignRole", "projId", projId);
      assertParamExists("bulkUnassignRole", "envId", envId);
      assertParamExists("bulkUnassignRole", "roleAssignmentRemove", roleAssignmentRemove);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/role_assignments/bulk`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        roleAssignmentRemove,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Lists the role assignments defined within an environment.  - If the `user` filter is present, will only return the role assignments of that user (supports multiple). - If the `tenant` filter is present, will only return the role assignments in that tenant (supports multiple). - If the `role` filter is present, will only return role assignments that are granting that role (supports multiple). - If the `resource` filter is present, will only return role assignments for resource instances of that resource type. - If the `resource_instance` filter is present, will only return role assignments for that resource instance.  Providing both `tenant` and `resource_instance` filters will only return role assignments if the resource instance is in that tenant. If multiple tenants are received, the last tenant will be compared with the resource instance.
     * @summary List Role Assignments
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} [user] optional user(s) filter, will only return role assignments granted to this user(s).
     * @param {string} [role] optional role(s) filter, will only return role assignments granting this role(s).
     * @param {string} [tenant] optional tenant(s) filter, will only return role assignments granted in that tenant(s).
     * @param {string} [resource] optional resource **type** filter, will only return role assignments granted on that resource type.
     * @param {string} [resourceInstance] optional resource instance filter, will only return role assignments granted on that resource instance.
     * @param {boolean} [detailed] Whether to return full details about the user, tenant and role
     * @param {boolean} [includeTotalCount] If true, returns the list of role assignments and the total count.
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listRoleAssignments: async (projId, envId, user, role, tenant, resource, resourceInstance, detailed, includeTotalCount, page, perPage, options = {}) => {
      assertParamExists("listRoleAssignments", "projId", projId);
      assertParamExists("listRoleAssignments", "envId", envId);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/role_assignments`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (user !== void 0) {
        localVarQueryParameter["user"] = user;
      }
      if (role !== void 0) {
        localVarQueryParameter["role"] = role;
      }
      if (tenant !== void 0) {
        localVarQueryParameter["tenant"] = tenant;
      }
      if (resource !== void 0) {
        localVarQueryParameter["resource"] = resource;
      }
      if (resourceInstance !== void 0) {
        localVarQueryParameter["resource_instance"] = resourceInstance;
      }
      if (detailed !== void 0) {
        localVarQueryParameter["detailed"] = detailed;
      }
      if (includeTotalCount !== void 0) {
        localVarQueryParameter["include_total_count"] = includeTotalCount;
      }
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Unassigns a user role within a tenant.  The tenant defines the scope of the assignment. In other words, the role is effective only within the tenant.  If the role is not actually assigned, will return 404.
     * @summary Unassign Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {RoleAssignmentRemove} roleAssignmentRemove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unassignRole: async (projId, envId, roleAssignmentRemove, options = {}) => {
      assertParamExists("unassignRole", "projId", projId);
      assertParamExists("unassignRole", "envId", envId);
      assertParamExists("unassignRole", "roleAssignmentRemove", roleAssignmentRemove);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/role_assignments`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        roleAssignmentRemove,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var RoleAssignmentsApiFp = function(configuration) {
  const localVarAxiosParamCreator = RoleAssignmentsApiAxiosParamCreator(configuration);
  return {
    /**
     * Assigns a role to a user within a tenant.  The tenant defines the scope of the assignment. In other words, the role is effective only within the tenant.
     * @summary Assign Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {RoleAssignmentCreate} roleAssignmentCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async assignRole(projId, envId, roleAssignmentCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.assignRole(
        projId,
        envId,
        roleAssignmentCreate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios31, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Bulk Assign Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {Array<RoleAssignmentCreate>} roleAssignmentCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bulkAssignRole(projId, envId, roleAssignmentCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.bulkAssignRole(
        projId,
        envId,
        roleAssignmentCreate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios31, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Bulk Unassign Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {Array<RoleAssignmentRemove>} roleAssignmentRemove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bulkUnassignRole(projId, envId, roleAssignmentRemove, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.bulkUnassignRole(
        projId,
        envId,
        roleAssignmentRemove,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios31, BASE_PATH, configuration);
    },
    /**
     * Lists the role assignments defined within an environment.  - If the `user` filter is present, will only return the role assignments of that user (supports multiple). - If the `tenant` filter is present, will only return the role assignments in that tenant (supports multiple). - If the `role` filter is present, will only return role assignments that are granting that role (supports multiple). - If the `resource` filter is present, will only return role assignments for resource instances of that resource type. - If the `resource_instance` filter is present, will only return role assignments for that resource instance.  Providing both `tenant` and `resource_instance` filters will only return role assignments if the resource instance is in that tenant. If multiple tenants are received, the last tenant will be compared with the resource instance.
     * @summary List Role Assignments
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} [user] optional user(s) filter, will only return role assignments granted to this user(s).
     * @param {string} [role] optional role(s) filter, will only return role assignments granting this role(s).
     * @param {string} [tenant] optional tenant(s) filter, will only return role assignments granted in that tenant(s).
     * @param {string} [resource] optional resource **type** filter, will only return role assignments granted on that resource type.
     * @param {string} [resourceInstance] optional resource instance filter, will only return role assignments granted on that resource instance.
     * @param {boolean} [detailed] Whether to return full details about the user, tenant and role
     * @param {boolean} [includeTotalCount] If true, returns the list of role assignments and the total count.
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listRoleAssignments(projId, envId, user, role, tenant, resource, resourceInstance, detailed, includeTotalCount, page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listRoleAssignments(
        projId,
        envId,
        user,
        role,
        tenant,
        resource,
        resourceInstance,
        detailed,
        includeTotalCount,
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios31, BASE_PATH, configuration);
    },
    /**
     * Unassigns a user role within a tenant.  The tenant defines the scope of the assignment. In other words, the role is effective only within the tenant.  If the role is not actually assigned, will return 404.
     * @summary Unassign Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {RoleAssignmentRemove} roleAssignmentRemove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async unassignRole(projId, envId, roleAssignmentRemove, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.unassignRole(
        projId,
        envId,
        roleAssignmentRemove,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios31, BASE_PATH, configuration);
    }
  };
};
var RoleAssignmentsApi = class extends BaseAPI {
  /**
   * Assigns a role to a user within a tenant.  The tenant defines the scope of the assignment. In other words, the role is effective only within the tenant.
   * @summary Assign Role
   * @param {RoleAssignmentsApiAssignRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RoleAssignmentsApi
   */
  assignRole(requestParameters, options) {
    return RoleAssignmentsApiFp(this.configuration).assignRole(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.roleAssignmentCreate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Bulk Assign Role
   * @param {RoleAssignmentsApiBulkAssignRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RoleAssignmentsApi
   */
  bulkAssignRole(requestParameters, options) {
    return RoleAssignmentsApiFp(this.configuration).bulkAssignRole(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.roleAssignmentCreate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Bulk Unassign Role
   * @param {RoleAssignmentsApiBulkUnassignRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RoleAssignmentsApi
   */
  bulkUnassignRole(requestParameters, options) {
    return RoleAssignmentsApiFp(this.configuration).bulkUnassignRole(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.roleAssignmentRemove,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Lists the role assignments defined within an environment.  - If the `user` filter is present, will only return the role assignments of that user (supports multiple). - If the `tenant` filter is present, will only return the role assignments in that tenant (supports multiple). - If the `role` filter is present, will only return role assignments that are granting that role (supports multiple). - If the `resource` filter is present, will only return role assignments for resource instances of that resource type. - If the `resource_instance` filter is present, will only return role assignments for that resource instance.  Providing both `tenant` and `resource_instance` filters will only return role assignments if the resource instance is in that tenant. If multiple tenants are received, the last tenant will be compared with the resource instance.
   * @summary List Role Assignments
   * @param {RoleAssignmentsApiListRoleAssignmentsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RoleAssignmentsApi
   */
  listRoleAssignments(requestParameters, options) {
    return RoleAssignmentsApiFp(this.configuration).listRoleAssignments(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.user,
      requestParameters.role,
      requestParameters.tenant,
      requestParameters.resource,
      requestParameters.resourceInstance,
      requestParameters.detailed,
      requestParameters.includeTotalCount,
      requestParameters.page,
      requestParameters.perPage,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Unassigns a user role within a tenant.  The tenant defines the scope of the assignment. In other words, the role is effective only within the tenant.  If the role is not actually assigned, will return 404.
   * @summary Unassign Role
   * @param {RoleAssignmentsApiUnassignRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RoleAssignmentsApi
   */
  unassignRole(requestParameters, options) {
    return RoleAssignmentsApiFp(this.configuration).unassignRole(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.roleAssignmentRemove,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/roles-api.ts
import globalAxios32 from "axios";
var RolesApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * This endpoint is part of the role hierarchy feature.  Makes role with id `role_id` extend the role with id `parent_role_id`. In other words, `role_id` will automatically be assigned any permissions that are granted to `parent_role_id`.  We can say the `role_id` **extends** `parent_role_id` or **inherits** from `parent_role_id`.  If `role_id` is already an ancestor of `parent_role_id`, the request will fail with HTTP 400 to prevent a cycle in the role hierarchy.
     * @summary Add Parent Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {string} parentRoleId Either the unique id of the parent role, or the URL-friendly key of the parent role (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addParentRole: async (projId, envId, roleId, parentRoleId, options = {}) => {
      assertParamExists("addParentRole", "projId", projId);
      assertParamExists("addParentRole", "envId", envId);
      assertParamExists("addParentRole", "roleId", roleId);
      assertParamExists("addParentRole", "parentRoleId", parentRoleId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/roles/{role_id}/parents/{parent_role_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"role_id"}}`, encodeURIComponent(String(roleId))).replace(`{${"parent_role_id"}}`, encodeURIComponent(String(parentRoleId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Assign permissions to role.  If some of the permissions specified are already assigned, will skip them.
     * @summary Assign Permissions To Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {AddRolePermissions} addRolePermissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    assignPermissionsToRole: async (projId, envId, roleId, addRolePermissions, options = {}) => {
      assertParamExists("assignPermissionsToRole", "projId", projId);
      assertParamExists("assignPermissionsToRole", "envId", envId);
      assertParamExists("assignPermissionsToRole", "roleId", roleId);
      assertParamExists("assignPermissionsToRole", "addRolePermissions", addRolePermissions);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/roles/{role_id}/permissions`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        addRolePermissions,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Creates a new tenant role.
     * @summary Create Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {RoleCreate} roleCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRole: async (projId, envId, roleCreate, options = {}) => {
      assertParamExists("createRole", "projId", projId);
      assertParamExists("createRole", "envId", envId);
      assertParamExists("createRole", "roleCreate", roleCreate);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/roles`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        roleCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes a tenant role and all its related data. This includes any permissions granted to said role.
     * @summary Delete Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRole: async (projId, envId, roleId, options = {}) => {
      assertParamExists("deleteRole", "projId", projId);
      assertParamExists("deleteRole", "envId", envId);
      assertParamExists("deleteRole", "roleId", roleId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/roles/{role_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Gets a single tenant role, if such role exists.
     * @summary Get Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRole: async (projId, envId, roleId, options = {}) => {
      assertParamExists("getRole", "projId", projId);
      assertParamExists("getRole", "envId", envId);
      assertParamExists("getRole", "roleId", roleId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/roles/{role_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Lists all tenant roles.
     * @summary List Roles
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {boolean} [includeTotalCount] Include total count in response (default to false)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listRoles: async (projId, envId, page, perPage, includeTotalCount, options = {}) => {
      assertParamExists("listRoles", "projId", projId);
      assertParamExists("listRoles", "envId", envId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/roles`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      if (includeTotalCount !== void 0) {
        localVarQueryParameter["include_total_count"] = includeTotalCount;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * This endpoint is part of the role hierarchy feature.  Removes `parent_role_id` from the list of parent roles of role with id `role_id`. In other words, `role_id` will no longer be automatically assigned permissions that are granted to `parent_role_id`.  We can say the `role_id` **not longer extends** `parent_role_id` or **no longer inherits** from `parent_role_id`.
     * @summary Remove Parent Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {string} parentRoleId Either the unique id of the parent role, or the URL-friendly key of the parent role (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeParentRole: async (projId, envId, roleId, parentRoleId, options = {}) => {
      assertParamExists("removeParentRole", "projId", projId);
      assertParamExists("removeParentRole", "envId", envId);
      assertParamExists("removeParentRole", "roleId", roleId);
      assertParamExists("removeParentRole", "parentRoleId", parentRoleId);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/roles/{role_id}/parents/{parent_role_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"role_id"}}`, encodeURIComponent(String(roleId))).replace(`{${"parent_role_id"}}`, encodeURIComponent(String(parentRoleId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Remove permissions from role.  If some of the permissions specified are already unassigned, will skip them.
     * @summary Remove Permissions From Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {RemoveRolePermissions} removeRolePermissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removePermissionsFromRole: async (projId, envId, roleId, removeRolePermissions, options = {}) => {
      assertParamExists("removePermissionsFromRole", "projId", projId);
      assertParamExists("removePermissionsFromRole", "envId", envId);
      assertParamExists("removePermissionsFromRole", "roleId", roleId);
      assertParamExists(
        "removePermissionsFromRole",
        "removeRolePermissions",
        removeRolePermissions
      );
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/roles/{role_id}/permissions`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        removeRolePermissions,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Partially updates a tenant role. Fields that will be provided will be completely overwritten.
     * @summary Update Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {RoleUpdate} roleUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRole: async (projId, envId, roleId, roleUpdate, options = {}) => {
      assertParamExists("updateRole", "projId", projId);
      assertParamExists("updateRole", "envId", envId);
      assertParamExists("updateRole", "roleId", roleId);
      assertParamExists("updateRole", "roleUpdate", roleUpdate);
      const localVarPath = `/v2/schema/{proj_id}/{env_id}/roles/{role_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        roleUpdate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var RolesApiFp = function(configuration) {
  const localVarAxiosParamCreator = RolesApiAxiosParamCreator(configuration);
  return {
    /**
     * This endpoint is part of the role hierarchy feature.  Makes role with id `role_id` extend the role with id `parent_role_id`. In other words, `role_id` will automatically be assigned any permissions that are granted to `parent_role_id`.  We can say the `role_id` **extends** `parent_role_id` or **inherits** from `parent_role_id`.  If `role_id` is already an ancestor of `parent_role_id`, the request will fail with HTTP 400 to prevent a cycle in the role hierarchy.
     * @summary Add Parent Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {string} parentRoleId Either the unique id of the parent role, or the URL-friendly key of the parent role (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addParentRole(projId, envId, roleId, parentRoleId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addParentRole(
        projId,
        envId,
        roleId,
        parentRoleId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios32, BASE_PATH, configuration);
    },
    /**
     * Assign permissions to role.  If some of the permissions specified are already assigned, will skip them.
     * @summary Assign Permissions To Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {AddRolePermissions} addRolePermissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async assignPermissionsToRole(projId, envId, roleId, addRolePermissions, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.assignPermissionsToRole(
        projId,
        envId,
        roleId,
        addRolePermissions,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios32, BASE_PATH, configuration);
    },
    /**
     * Creates a new tenant role.
     * @summary Create Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {RoleCreate} roleCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createRole(projId, envId, roleCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createRole(
        projId,
        envId,
        roleCreate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios32, BASE_PATH, configuration);
    },
    /**
     * Deletes a tenant role and all its related data. This includes any permissions granted to said role.
     * @summary Delete Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteRole(projId, envId, roleId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRole(
        projId,
        envId,
        roleId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios32, BASE_PATH, configuration);
    },
    /**
     * Gets a single tenant role, if such role exists.
     * @summary Get Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRole(projId, envId, roleId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getRole(
        projId,
        envId,
        roleId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios32, BASE_PATH, configuration);
    },
    /**
     * Lists all tenant roles.
     * @summary List Roles
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {boolean} [includeTotalCount] Include total count in response (default to false)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listRoles(projId, envId, page, perPage, includeTotalCount, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listRoles(
        projId,
        envId,
        page,
        perPage,
        includeTotalCount,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios32, BASE_PATH, configuration);
    },
    /**
     * This endpoint is part of the role hierarchy feature.  Removes `parent_role_id` from the list of parent roles of role with id `role_id`. In other words, `role_id` will no longer be automatically assigned permissions that are granted to `parent_role_id`.  We can say the `role_id` **not longer extends** `parent_role_id` or **no longer inherits** from `parent_role_id`.
     * @summary Remove Parent Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {string} parentRoleId Either the unique id of the parent role, or the URL-friendly key of the parent role (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removeParentRole(projId, envId, roleId, parentRoleId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.removeParentRole(
        projId,
        envId,
        roleId,
        parentRoleId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios32, BASE_PATH, configuration);
    },
    /**
     * Remove permissions from role.  If some of the permissions specified are already unassigned, will skip them.
     * @summary Remove Permissions From Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {RemoveRolePermissions} removeRolePermissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removePermissionsFromRole(projId, envId, roleId, removeRolePermissions, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.removePermissionsFromRole(
        projId,
        envId,
        roleId,
        removeRolePermissions,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios32, BASE_PATH, configuration);
    },
    /**
     * Partially updates a tenant role. Fields that will be provided will be completely overwritten.
     * @summary Update Role
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} roleId Either the unique id of the role, or the URL-friendly key of the role (i.e: the \&quot;slug\&quot;).
     * @param {RoleUpdate} roleUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateRole(projId, envId, roleId, roleUpdate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateRole(
        projId,
        envId,
        roleId,
        roleUpdate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios32, BASE_PATH, configuration);
    }
  };
};
var RolesApi = class extends BaseAPI {
  /**
   * This endpoint is part of the role hierarchy feature.  Makes role with id `role_id` extend the role with id `parent_role_id`. In other words, `role_id` will automatically be assigned any permissions that are granted to `parent_role_id`.  We can say the `role_id` **extends** `parent_role_id` or **inherits** from `parent_role_id`.  If `role_id` is already an ancestor of `parent_role_id`, the request will fail with HTTP 400 to prevent a cycle in the role hierarchy.
   * @summary Add Parent Role
   * @param {RolesApiAddParentRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RolesApi
   */
  addParentRole(requestParameters, options) {
    return RolesApiFp(this.configuration).addParentRole(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.roleId,
      requestParameters.parentRoleId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Assign permissions to role.  If some of the permissions specified are already assigned, will skip them.
   * @summary Assign Permissions To Role
   * @param {RolesApiAssignPermissionsToRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RolesApi
   */
  assignPermissionsToRole(requestParameters, options) {
    return RolesApiFp(this.configuration).assignPermissionsToRole(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.roleId,
      requestParameters.addRolePermissions,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Creates a new tenant role.
   * @summary Create Role
   * @param {RolesApiCreateRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RolesApi
   */
  createRole(requestParameters, options) {
    return RolesApiFp(this.configuration).createRole(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.roleCreate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Deletes a tenant role and all its related data. This includes any permissions granted to said role.
   * @summary Delete Role
   * @param {RolesApiDeleteRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RolesApi
   */
  deleteRole(requestParameters, options) {
    return RolesApiFp(this.configuration).deleteRole(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.roleId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Gets a single tenant role, if such role exists.
   * @summary Get Role
   * @param {RolesApiGetRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RolesApi
   */
  getRole(requestParameters, options) {
    return RolesApiFp(this.configuration).getRole(requestParameters.projId, requestParameters.envId, requestParameters.roleId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Lists all tenant roles.
   * @summary List Roles
   * @param {RolesApiListRolesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RolesApi
   */
  listRoles(requestParameters, options) {
    return RolesApiFp(this.configuration).listRoles(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.page,
      requestParameters.perPage,
      requestParameters.includeTotalCount,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * This endpoint is part of the role hierarchy feature.  Removes `parent_role_id` from the list of parent roles of role with id `role_id`. In other words, `role_id` will no longer be automatically assigned permissions that are granted to `parent_role_id`.  We can say the `role_id` **not longer extends** `parent_role_id` or **no longer inherits** from `parent_role_id`.
   * @summary Remove Parent Role
   * @param {RolesApiRemoveParentRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RolesApi
   */
  removeParentRole(requestParameters, options) {
    return RolesApiFp(this.configuration).removeParentRole(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.roleId,
      requestParameters.parentRoleId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Remove permissions from role.  If some of the permissions specified are already unassigned, will skip them.
   * @summary Remove Permissions From Role
   * @param {RolesApiRemovePermissionsFromRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RolesApi
   */
  removePermissionsFromRole(requestParameters, options) {
    return RolesApiFp(this.configuration).removePermissionsFromRole(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.roleId,
      requestParameters.removeRolePermissions,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Partially updates a tenant role. Fields that will be provided will be completely overwritten.
   * @summary Update Role
   * @param {RolesApiUpdateRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RolesApi
   */
  updateRole(requestParameters, options) {
    return RolesApiFp(this.configuration).updateRole(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.roleId,
      requestParameters.roleUpdate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/tenants-api.ts
import globalAxios33 from "axios";
var TenantsApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * Creates a new tenant inside the Permit.io system.  If the tenant is already created: will return 200 instead of 201, and will return the existing tenant object in the response body.
     * @summary Create Tenant
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {TenantCreate} tenantCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTenant: async (projId, envId, tenantCreate, options = {}) => {
      assertParamExists("createTenant", "projId", projId);
      assertParamExists("createTenant", "envId", envId);
      assertParamExists("createTenant", "tenantCreate", tenantCreate);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/tenants`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        tenantCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes the tenant and all its related data.
     * @summary Delete Tenant
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} tenantId Either the unique id of the tenant, or the URL-friendly key of the tenant (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTenant: async (projId, envId, tenantId, options = {}) => {
      assertParamExists("deleteTenant", "projId", projId);
      assertParamExists("deleteTenant", "envId", envId);
      assertParamExists("deleteTenant", "tenantId", tenantId);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/tenants/{tenant_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"tenant_id"}}`, encodeURIComponent(String(tenantId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes a user under a tenant.
     * @summary Delete Tenant User
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} tenantId Either the unique id of the tenant, or the URL-friendly key of the tenant (i.e: the \&quot;slug\&quot;).
     * @param {string} userId Either the unique id of the user, or the URL-friendly key of the user (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTenantUser: async (projId, envId, tenantId, userId, options = {}) => {
      assertParamExists("deleteTenantUser", "projId", projId);
      assertParamExists("deleteTenantUser", "envId", envId);
      assertParamExists("deleteTenantUser", "tenantId", tenantId);
      assertParamExists("deleteTenantUser", "userId", userId);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/tenants/{tenant_id}/users/{user_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"tenant_id"}}`, encodeURIComponent(String(tenantId))).replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Gets a tenant, if such tenant exists. Otherwise returns 404.
     * @summary Get Tenant
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} tenantId Either the unique id of the tenant, or the URL-friendly key of the tenant (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTenant: async (projId, envId, tenantId, options = {}) => {
      assertParamExists("getTenant", "projId", projId);
      assertParamExists("getTenant", "envId", envId);
      assertParamExists("getTenant", "tenantId", tenantId);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/tenants/{tenant_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"tenant_id"}}`, encodeURIComponent(String(tenantId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary List Tenant Users
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} tenantId Either the unique id of the tenant, or the URL-friendly key of the tenant (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} [search] Text search for the email field
     * @param {string} [role] Match users with a specific role
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTenantUsers: async (projId, tenantId, envId, search, role, page, perPage, options = {}) => {
      assertParamExists("listTenantUsers", "projId", projId);
      assertParamExists("listTenantUsers", "tenantId", tenantId);
      assertParamExists("listTenantUsers", "envId", envId);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/tenants/{tenant_id}/users`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"tenant_id"}}`, encodeURIComponent(String(tenantId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (search !== void 0) {
        localVarQueryParameter["search"] = search;
      }
      if (role !== void 0) {
        localVarQueryParameter["role"] = role;
      }
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Lists all the tenants defined within an environment.
     * @summary List Tenants
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} [search] Text search for the tenant name or key
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listTenants: async (projId, envId, search, page, perPage, options = {}) => {
      assertParamExists("listTenants", "projId", projId);
      assertParamExists("listTenants", "envId", envId);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/tenants`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (search !== void 0) {
        localVarQueryParameter["search"] = search;
      }
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Partially updates the tenant definition. Fields that will be provided will be completely overwritten.
     * @summary Update Tenant
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} tenantId Either the unique id of the tenant, or the URL-friendly key of the tenant (i.e: the \&quot;slug\&quot;).
     * @param {TenantUpdate} tenantUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateTenant: async (projId, envId, tenantId, tenantUpdate, options = {}) => {
      assertParamExists("updateTenant", "projId", projId);
      assertParamExists("updateTenant", "envId", envId);
      assertParamExists("updateTenant", "tenantId", tenantId);
      assertParamExists("updateTenant", "tenantUpdate", tenantUpdate);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/tenants/{tenant_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"tenant_id"}}`, encodeURIComponent(String(tenantId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        tenantUpdate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var TenantsApiFp = function(configuration) {
  const localVarAxiosParamCreator = TenantsApiAxiosParamCreator(configuration);
  return {
    /**
     * Creates a new tenant inside the Permit.io system.  If the tenant is already created: will return 200 instead of 201, and will return the existing tenant object in the response body.
     * @summary Create Tenant
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {TenantCreate} tenantCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createTenant(projId, envId, tenantCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createTenant(
        projId,
        envId,
        tenantCreate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios33, BASE_PATH, configuration);
    },
    /**
     * Deletes the tenant and all its related data.
     * @summary Delete Tenant
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} tenantId Either the unique id of the tenant, or the URL-friendly key of the tenant (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteTenant(projId, envId, tenantId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTenant(
        projId,
        envId,
        tenantId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios33, BASE_PATH, configuration);
    },
    /**
     * Deletes a user under a tenant.
     * @summary Delete Tenant User
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} tenantId Either the unique id of the tenant, or the URL-friendly key of the tenant (i.e: the \&quot;slug\&quot;).
     * @param {string} userId Either the unique id of the user, or the URL-friendly key of the user (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteTenantUser(projId, envId, tenantId, userId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTenantUser(
        projId,
        envId,
        tenantId,
        userId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios33, BASE_PATH, configuration);
    },
    /**
     * Gets a tenant, if such tenant exists. Otherwise returns 404.
     * @summary Get Tenant
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} tenantId Either the unique id of the tenant, or the URL-friendly key of the tenant (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTenant(projId, envId, tenantId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getTenant(
        projId,
        envId,
        tenantId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios33, BASE_PATH, configuration);
    },
    /**
     *
     * @summary List Tenant Users
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} tenantId Either the unique id of the tenant, or the URL-friendly key of the tenant (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} [search] Text search for the email field
     * @param {string} [role] Match users with a specific role
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listTenantUsers(projId, tenantId, envId, search, role, page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listTenantUsers(
        projId,
        tenantId,
        envId,
        search,
        role,
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios33, BASE_PATH, configuration);
    },
    /**
     * Lists all the tenants defined within an environment.
     * @summary List Tenants
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} [search] Text search for the tenant name or key
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listTenants(projId, envId, search, page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listTenants(
        projId,
        envId,
        search,
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios33, BASE_PATH, configuration);
    },
    /**
     * Partially updates the tenant definition. Fields that will be provided will be completely overwritten.
     * @summary Update Tenant
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} tenantId Either the unique id of the tenant, or the URL-friendly key of the tenant (i.e: the \&quot;slug\&quot;).
     * @param {TenantUpdate} tenantUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateTenant(projId, envId, tenantId, tenantUpdate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateTenant(
        projId,
        envId,
        tenantId,
        tenantUpdate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios33, BASE_PATH, configuration);
    }
  };
};
var TenantsApi = class extends BaseAPI {
  /**
   * Creates a new tenant inside the Permit.io system.  If the tenant is already created: will return 200 instead of 201, and will return the existing tenant object in the response body.
   * @summary Create Tenant
   * @param {TenantsApiCreateTenantRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TenantsApi
   */
  createTenant(requestParameters, options) {
    return TenantsApiFp(this.configuration).createTenant(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.tenantCreate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Deletes the tenant and all its related data.
   * @summary Delete Tenant
   * @param {TenantsApiDeleteTenantRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TenantsApi
   */
  deleteTenant(requestParameters, options) {
    return TenantsApiFp(this.configuration).deleteTenant(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.tenantId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Deletes a user under a tenant.
   * @summary Delete Tenant User
   * @param {TenantsApiDeleteTenantUserRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TenantsApi
   */
  deleteTenantUser(requestParameters, options) {
    return TenantsApiFp(this.configuration).deleteTenantUser(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.tenantId,
      requestParameters.userId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Gets a tenant, if such tenant exists. Otherwise returns 404.
   * @summary Get Tenant
   * @param {TenantsApiGetTenantRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TenantsApi
   */
  getTenant(requestParameters, options) {
    return TenantsApiFp(this.configuration).getTenant(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.tenantId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary List Tenant Users
   * @param {TenantsApiListTenantUsersRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TenantsApi
   */
  listTenantUsers(requestParameters, options) {
    return TenantsApiFp(this.configuration).listTenantUsers(
      requestParameters.projId,
      requestParameters.tenantId,
      requestParameters.envId,
      requestParameters.search,
      requestParameters.role,
      requestParameters.page,
      requestParameters.perPage,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Lists all the tenants defined within an environment.
   * @summary List Tenants
   * @param {TenantsApiListTenantsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TenantsApi
   */
  listTenants(requestParameters, options) {
    return TenantsApiFp(this.configuration).listTenants(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.search,
      requestParameters.page,
      requestParameters.perPage,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Partially updates the tenant definition. Fields that will be provided will be completely overwritten.
   * @summary Update Tenant
   * @param {TenantsApiUpdateTenantRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TenantsApi
   */
  updateTenant(requestParameters, options) {
    return TenantsApiFp(this.configuration).updateTenant(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.tenantId,
      requestParameters.tenantUpdate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/user-attributes-api.ts
import globalAxios34 from "axios";

// src/openapi/api/users-api.ts
import globalAxios35 from "axios";
var UsersApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * Assigns a role to the user within the tenant.  The tenant defines the scope of the assignment. In other words, the role is effective only within the tenant.
     * @summary Assign Role To User
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} userId Either the unique id of the user, or the URL-friendly key of the user (i.e: the \&quot;slug\&quot;).
     * @param {UserRoleCreate} userRoleCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    assignRoleToUser: async (projId, envId, userId, userRoleCreate, options = {}) => {
      assertParamExists("assignRoleToUser", "projId", projId);
      assertParamExists("assignRoleToUser", "envId", envId);
      assertParamExists("assignRoleToUser", "userId", userId);
      assertParamExists("assignRoleToUser", "userRoleCreate", userRoleCreate);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/users/{user_id}/roles`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userRoleCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Creates a new user inside the Permit.io system, from that point forward you may run permission checks on that user.  If the user is already created: will return 200 instead of 201, and will return the existing user object in the response body.
     * @summary Create User
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {UserCreate} userCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUser: async (projId, envId, userCreate, options = {}) => {
      assertParamExists("createUser", "projId", projId);
      assertParamExists("createUser", "envId", envId);
      assertParamExists("createUser", "userCreate", userCreate);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/users`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Deletes the user and all its related data.
     * @summary Delete User
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} userId Either the unique id of the user, or the URL-friendly key of the user (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser: async (projId, envId, userId, options = {}) => {
      assertParamExists("deleteUser", "projId", projId);
      assertParamExists("deleteUser", "envId", envId);
      assertParamExists("deleteUser", "userId", userId);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/users/{user_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Gets a user, if such user exists. Otherwise returns 404.
     * @summary Get User
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} userId Either the unique id of the user, or the URL-friendly key of the user (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUser: async (projId, envId, userId, options = {}) => {
      assertParamExists("getUser", "projId", projId);
      assertParamExists("getUser", "envId", envId);
      assertParamExists("getUser", "userId", userId);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/users/{user_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Lists all the users defined within an environment.
     * @summary List Users
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} [search] Text search for the email field
     * @param {string} [role] Match users with a specific role
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listUsers: async (projId, envId, search, role, page, perPage, options = {}) => {
      assertParamExists("listUsers", "projId", projId);
      assertParamExists("listUsers", "envId", envId);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/users`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      if (search !== void 0) {
        localVarQueryParameter["search"] = search;
      }
      if (role !== void 0) {
        localVarQueryParameter["role"] = role;
      }
      if (page !== void 0) {
        localVarQueryParameter["page"] = page;
      }
      if (perPage !== void 0) {
        localVarQueryParameter["per_page"] = perPage;
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @summary Replace User
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} userId Either the unique id of the user, or the URL-friendly key of the user (i.e: the \&quot;slug\&quot;).
     * @param {UserCreate} userCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    replaceUser: async (projId, envId, userId, userCreate, options = {}) => {
      assertParamExists("replaceUser", "projId", projId);
      assertParamExists("replaceUser", "envId", envId);
      assertParamExists("replaceUser", "userId", userId);
      assertParamExists("replaceUser", "userCreate", userCreate);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/users/{user_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userCreate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Unassigns the role from the user within the tenant.  The tenant defines the scope of the assignment. In other words, the role is effective only within the tenant.  If the role is not actually assigned, will return 404.
     * @summary Unassign Role From User
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} userId Either the unique id of the user, or the URL-friendly key of the user (i.e: the \&quot;slug\&quot;).
     * @param {UserRoleRemove} userRoleRemove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unassignRoleFromUser: async (projId, envId, userId, userRoleRemove, options = {}) => {
      assertParamExists("unassignRoleFromUser", "projId", projId);
      assertParamExists("unassignRoleFromUser", "envId", envId);
      assertParamExists("unassignRoleFromUser", "userId", userId);
      assertParamExists("unassignRoleFromUser", "userRoleRemove", userRoleRemove);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/users/{user_id}/roles`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userRoleRemove,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Partially updates the user definition. Fields that will be provided will be completely overwritten.
     * @summary Update User
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} userId Either the unique id of the user, or the URL-friendly key of the user (i.e: the \&quot;slug\&quot;).
     * @param {UserUpdate} userUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUser: async (projId, envId, userId, userUpdate, options = {}) => {
      assertParamExists("updateUser", "projId", projId);
      assertParamExists("updateUser", "envId", envId);
      assertParamExists("updateUser", "userId", userId);
      assertParamExists("updateUser", "userUpdate", userUpdate);
      const localVarPath = `/v2/facts/{proj_id}/{env_id}/users/{user_id}`.replace(`{${"proj_id"}}`, encodeURIComponent(String(projId))).replace(`{${"env_id"}}`, encodeURIComponent(String(envId))).replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      await setBearerAuthToObject(localVarHeaderParameter, configuration);
      localVarHeaderParameter["Content-Type"] = "application/json";
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userUpdate,
        localVarRequestOptions,
        configuration
      );
      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var UsersApiFp = function(configuration) {
  const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration);
  return {
    /**
     * Assigns a role to the user within the tenant.  The tenant defines the scope of the assignment. In other words, the role is effective only within the tenant.
     * @summary Assign Role To User
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} userId Either the unique id of the user, or the URL-friendly key of the user (i.e: the \&quot;slug\&quot;).
     * @param {UserRoleCreate} userRoleCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async assignRoleToUser(projId, envId, userId, userRoleCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.assignRoleToUser(
        projId,
        envId,
        userId,
        userRoleCreate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios35, BASE_PATH, configuration);
    },
    /**
     * Creates a new user inside the Permit.io system, from that point forward you may run permission checks on that user.  If the user is already created: will return 200 instead of 201, and will return the existing user object in the response body.
     * @summary Create User
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {UserCreate} userCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createUser(projId, envId, userCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(
        projId,
        envId,
        userCreate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios35, BASE_PATH, configuration);
    },
    /**
     * Deletes the user and all its related data.
     * @summary Delete User
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} userId Either the unique id of the user, or the URL-friendly key of the user (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteUser(projId, envId, userId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(
        projId,
        envId,
        userId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios35, BASE_PATH, configuration);
    },
    /**
     * Gets a user, if such user exists. Otherwise returns 404.
     * @summary Get User
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} userId Either the unique id of the user, or the URL-friendly key of the user (i.e: the \&quot;slug\&quot;).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUser(projId, envId, userId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(
        projId,
        envId,
        userId,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios35, BASE_PATH, configuration);
    },
    /**
     * Lists all the users defined within an environment.
     * @summary List Users
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} [search] Text search for the email field
     * @param {string} [role] Match users with a specific role
     * @param {number} [page] Page number of the results to fetch, starting at 1.
     * @param {number} [perPage] The number of results per page (max 100).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listUsers(projId, envId, search, role, page, perPage, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listUsers(
        projId,
        envId,
        search,
        role,
        page,
        perPage,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios35, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Replace User
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} userId Either the unique id of the user, or the URL-friendly key of the user (i.e: the \&quot;slug\&quot;).
     * @param {UserCreate} userCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async replaceUser(projId, envId, userId, userCreate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.replaceUser(
        projId,
        envId,
        userId,
        userCreate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios35, BASE_PATH, configuration);
    },
    /**
     * Unassigns the role from the user within the tenant.  The tenant defines the scope of the assignment. In other words, the role is effective only within the tenant.  If the role is not actually assigned, will return 404.
     * @summary Unassign Role From User
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} userId Either the unique id of the user, or the URL-friendly key of the user (i.e: the \&quot;slug\&quot;).
     * @param {UserRoleRemove} userRoleRemove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async unassignRoleFromUser(projId, envId, userId, userRoleRemove, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.unassignRoleFromUser(
        projId,
        envId,
        userId,
        userRoleRemove,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios35, BASE_PATH, configuration);
    },
    /**
     * Partially updates the user definition. Fields that will be provided will be completely overwritten.
     * @summary Update User
     * @param {string} projId Either the unique id of the project, or the URL-friendly key of the project (i.e: the \&quot;slug\&quot;).
     * @param {string} envId Either the unique id of the environment, or the URL-friendly key of the environment (i.e: the \&quot;slug\&quot;).
     * @param {string} userId Either the unique id of the user, or the URL-friendly key of the user (i.e: the \&quot;slug\&quot;).
     * @param {UserUpdate} userUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateUser(projId, envId, userId, userUpdate, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(
        projId,
        envId,
        userId,
        userUpdate,
        options
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios35, BASE_PATH, configuration);
    }
  };
};
var UsersApi = class extends BaseAPI {
  /**
   * Assigns a role to the user within the tenant.  The tenant defines the scope of the assignment. In other words, the role is effective only within the tenant.
   * @summary Assign Role To User
   * @param {UsersApiAssignRoleToUserRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  assignRoleToUser(requestParameters, options) {
    return UsersApiFp(this.configuration).assignRoleToUser(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.userId,
      requestParameters.userRoleCreate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Creates a new user inside the Permit.io system, from that point forward you may run permission checks on that user.  If the user is already created: will return 200 instead of 201, and will return the existing user object in the response body.
   * @summary Create User
   * @param {UsersApiCreateUserRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  createUser(requestParameters, options) {
    return UsersApiFp(this.configuration).createUser(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.userCreate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Deletes the user and all its related data.
   * @summary Delete User
   * @param {UsersApiDeleteUserRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  deleteUser(requestParameters, options) {
    return UsersApiFp(this.configuration).deleteUser(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.userId,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Gets a user, if such user exists. Otherwise returns 404.
   * @summary Get User
   * @param {UsersApiGetUserRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  getUser(requestParameters, options) {
    return UsersApiFp(this.configuration).getUser(requestParameters.projId, requestParameters.envId, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Lists all the users defined within an environment.
   * @summary List Users
   * @param {UsersApiListUsersRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  listUsers(requestParameters, options) {
    return UsersApiFp(this.configuration).listUsers(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.search,
      requestParameters.role,
      requestParameters.page,
      requestParameters.perPage,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   *
   * @summary Replace User
   * @param {UsersApiReplaceUserRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  replaceUser(requestParameters, options) {
    return UsersApiFp(this.configuration).replaceUser(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.userId,
      requestParameters.userCreate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Unassigns the role from the user within the tenant.  The tenant defines the scope of the assignment. In other words, the role is effective only within the tenant.  If the role is not actually assigned, will return 404.
   * @summary Unassign Role From User
   * @param {UsersApiUnassignRoleFromUserRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  unassignRoleFromUser(requestParameters, options) {
    return UsersApiFp(this.configuration).unassignRoleFromUser(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.userId,
      requestParameters.userRoleRemove,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Partially updates the user definition. Fields that will be provided will be completely overwritten.
   * @summary Update User
   * @param {UsersApiUpdateUserRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  updateUser(requestParameters, options) {
    return UsersApiFp(this.configuration).updateUser(
      requestParameters.projId,
      requestParameters.envId,
      requestParameters.userId,
      requestParameters.userUpdate,
      options
    ).then((request) => request(this.axios, this.basePath));
  }
};

// src/openapi/api/users-elements-data-api.ts
import globalAxios36 from "axios";

// src/openapi/configuration.ts
var Configuration = class {
  constructor(param = {}) {
    this.apiKey = param.apiKey;
    this.username = param.username;
    this.password = param.password;
    this.accessToken = param.accessToken;
    this.basePath = param.basePath;
    this.baseOptions = param.baseOptions;
    this.formDataCtor = param.formDataCtor;
  }
  /**
   * Check if the given MIME is a JSON MIME.
   * JSON MIME examples:
   *   application/json
   *   application/json; charset=UTF8
   *   APPLICATION/JSON
   *   application/vnd.company+json
   * @param mime - MIME (Multipurpose Internet Mail Extensions)
   * @return True if the given MIME is JSON, false otherwise.
   */
  isJsonMime(mime) {
    const jsonMime = new RegExp(
      "^(application/json|[^;/ 	]+/[^;/ 	]+[+]json)[ 	]*(;.*)?$",
      "i"
    );
    return mime !== null && (jsonMime.test(mime) || mime.toLowerCase() === "application/json-patch+json");
  }
};

// src/api/base.ts
import axios from "axios";

// src/api/context.ts
var API_ACCESS_LEVELS = [
  "ORGANIZATION_LEVEL_API_KEY" /* ORGANIZATION_LEVEL_API_KEY */,
  "PROJECT_LEVEL_API_KEY" /* PROJECT_LEVEL_API_KEY */,
  "ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */
];
var ApiContextLevel = /* @__PURE__ */ ((ApiContextLevel2) => {
  ApiContextLevel2[ApiContextLevel2["WAIT_FOR_INIT"] = 0] = "WAIT_FOR_INIT";
  ApiContextLevel2[ApiContextLevel2["ORGANIZATION"] = 1] = "ORGANIZATION";
  ApiContextLevel2[ApiContextLevel2["PROJECT"] = 2] = "PROJECT";
  ApiContextLevel2[ApiContextLevel2["ENVIRONMENT"] = 3] = "ENVIRONMENT";
  return ApiContextLevel2;
})(ApiContextLevel || {});
var PermitContextError = class extends Error {
  constructor(message) {
    super(message);
  }
};

// src/api/base.ts
var PermitApiError = class extends Error {
  constructor(message, originalError) {
    super(message);
    this.originalError = originalError;
  }
  get formattedAxiosError() {
    var _a;
    return {
      code: this.originalError.code,
      message: this.message,
      error: (_a = this.originalError.response) == null ? void 0 : _a.data,
      status: this.originalError.status
    };
  }
  get request() {
    return this.originalError.request;
  }
  get response() {
    return this.originalError.response;
  }
};
var BasePermitApi = class {
  constructor(config, logger) {
    this.config = config;
    this.logger = logger;
    const version = process.env.npm_package_version ?? "unknown";
    this.openapiClientConfig = new Configuration({
      basePath: `${this.config.apiUrl}`,
      accessToken: this.config.token,
      baseOptions: {
        headers: {
          "X-Permit-SDK-Version": `node:${version}`
        }
      }
    });
    this.scopeApi = new APIKeysApi(this.openapiClientConfig, BASE_PATH, this.config.axiosInstance);
  }
  /**
   * Sets the API context and permitted access level based on the API key scope.
   */
  async setContextFromApiKey() {
    var _a, _b;
    try {
      this.logger.debug("Fetching api key scope");
      const response = await this.scopeApi.getApiKeyScope();
      if (response.data.organization_id !== void 0 && response.data.organization_id !== null) {
        this.config.apiContext._saveApiKeyAccessibleScope(
          response.data.organization_id,
          response.data.project_id,
          response.data.environment_id
        );
        if (response.data.project_id !== void 0 && response.data.project_id !== null) {
          if (response.data.environment_id !== void 0 && response.data.environment_id !== null) {
            this.logger.debug(`setting: environment-level api context`);
            this.config.apiContext.setEnvironmentLevelContext(
              response.data.organization_id,
              response.data.project_id,
              response.data.environment_id
            );
            return;
          }
          this.logger.debug(`setting: project-level api context`);
          this.config.apiContext.setProjectLevelContext(
            response.data.organization_id,
            response.data.project_id
          );
          return;
        }
        this.logger.debug(`setting: organization-level api context`);
        this.config.apiContext.setOrganizationLevelContext(response.data.organization_id);
        return;
      }
      throw new PermitContextError("could not set api context level");
    } catch (err) {
      if (axios.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.getApiKeyScope(), err: ${JSON.stringify(
            (_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data
          )}`
        );
      }
      throw new PermitContextError(
        "could not fetch the api key scope in order to set the api context level"
      );
    }
  }
  /**
   * Ensure that the API Key has the necessary permissions to successfully call the API endpoint.
   * Note that this check is not foolproof, and the API may still throw 401.
   * @param requiredAccessLevel The required API Key Access level for the endpoint.
   * @throws PermitContextError If the currently set API key access level does not match the required access level.
   */
  async ensureAccessLevel(requiredAccessLevel) {
    if (this.config.apiContext.contextLevel === 0 /* WAIT_FOR_INIT */ || this.config.apiContext.permittedAccessLevel === "WAIT_FOR_INIT" /* WAIT_FOR_INIT */) {
      await this.setContextFromApiKey();
    }
    if (requiredAccessLevel !== this.config.apiContext.permittedAccessLevel) {
      if (API_ACCESS_LEVELS.indexOf(requiredAccessLevel) < API_ACCESS_LEVELS.indexOf(this.config.apiContext.permittedAccessLevel)) {
        throw new PermitContextError(
          `You're trying to use an SDK method that requires an API Key with access level: ${requiredAccessLevel}, however the SDK is running with an API key with level ${this.config.apiContext.permittedAccessLevel}.`
        );
      }
    }
  }
  /**
   * Ensure that the API context matches the required endpoint context.
   * @param requiredContext The required API context level for the endpoint.
   * @throws PermitContextError If the currently set API context level does not match the required context level.
   */
  async ensureContext(requiredContext) {
    if (this.config.apiContext.contextLevel === 0 /* WAIT_FOR_INIT */ || this.config.apiContext.permittedAccessLevel === "WAIT_FOR_INIT" /* WAIT_FOR_INIT */) {
      await this.setContextFromApiKey();
    }
    if (this.config.apiContext.contextLevel < requiredContext || this.config.apiContext.contextLevel === 0 /* WAIT_FOR_INIT */) {
      throw new PermitContextError(
        `You're trying to use an SDK method that requires an API context of ${ApiContextLevel[requiredContext]}, however the SDK is running in a less specific context level: ${ApiContextLevel[this.config.apiContext.contextLevel]}.`
      );
    }
  }
  handleApiError(err) {
    var _a, _b, _c;
    if (axios.isAxiosError(err)) {
      const logMessage = `Got error status code: ${(_a = err.response) == null ? void 0 : _a.status}, err: ${JSON.stringify(
        (_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data
      )}`;
      const apiMessage = (_c = err.response) == null ? void 0 : _c.data.message;
      this.logger.error(logMessage);
      throw new PermitApiError(apiMessage, err);
    } else {
      throw err;
    }
  }
};

// src/api/deprecated.ts
var DeprecatedApiClient = class extends BasePermitApi {
  /**
   * Creates an instance of DeprecatedApiClient.
   * @param config - The configuration object for the Permit SDK.
   * @param logger - The logger object for logging.
   */
  constructor(config, logger) {
    super(config, logger);
    this._users = new UsersApi(this.openapiClientConfig, BASE_PATH, this.config.axiosInstance);
    this._tenants = new TenantsApi(this.openapiClientConfig, BASE_PATH, this.config.axiosInstance);
    this._roles = new RolesApi(this.openapiClientConfig, BASE_PATH, this.config.axiosInstance);
    this._conditionSets = new ConditionSetsApi(
      this.openapiClientConfig,
      BASE_PATH,
      this.config.axiosInstance
    );
    this._conditionSetRules = new ConditionSetRulesApi(
      this.openapiClientConfig,
      BASE_PATH,
      this.config.axiosInstance
    );
    this._roleAssignments = new RoleAssignmentsApi(
      this.openapiClientConfig,
      BASE_PATH,
      this.config.axiosInstance
    );
    this._resources = new ResourcesApi(
      this.openapiClientConfig,
      BASE_PATH,
      this.config.axiosInstance
    );
  }
  /**
   * Retrieves a list of users.
   * @returns A promise that resolves to an array of UserRead objects representing the users.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.users.list()
   */
  async listUsers() {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._users.listUsers({
        ...this.config.apiContext.environmentContext
      });
      this.logger.debug(`[${response.status}] permit.api.listUsers()`);
      return response.data.data;
    } catch (err) {
      if (axios2.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.getUser(), err: ${JSON.stringify(
            (_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data
          )}`
        );
      }
      throw err;
    }
  }
  /**
   * Retrieves a list of roles.
   * @returns A promise that resolves to an array of RoleRead objects representing the roles.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.roles.list()
   */
  async listRoles() {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._roles.listRoles({
        ...this.config.apiContext.environmentContext
      });
      this.logger.debug(`[${response.status}] permit.api.listRoles()`);
      return response.data;
    } catch (err) {
      if (axios2.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.listRoles(), err: ${JSON.stringify(
            (_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data
          )}`
        );
      }
      throw err;
    }
  }
  /**
   * Retrieves a list of condition sets.
   * @param type - The type of the condition set, either `userset` or `resourceset`.
   * @param page - The page number.
   * @param perPage - The number of items per page.
   * @returns A promise that resolves to an array of ConditionSetRead objects representing the condition sets.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.conditionSets.list()
   */
  async listConditionSets(type, page, perPage) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._conditionSets.listConditionSets({
        ...this.config.apiContext.environmentContext,
        type,
        page,
        perPage
      });
      this.logger.debug(`[${response.status}] permit.api.listRoles()`);
      return response.data;
    } catch (err) {
      if (axios2.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.listRoles(), err: ${JSON.stringify(
            (_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data
          )}`
        );
      }
      throw err;
    }
  }
  /**
   * Retrieves a list of condition set rules.
   * @param page - The page number.
   * @param perPage - The number of items per page.
   * @returns A promise that resolves to an array of ConditionSetRuleRead objects representing the condition set rules.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.conditionSetRules.list()
   */
  async listConditionSetsRules(page, perPage) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._conditionSetRules.listSetPermissions({
        ...this.config.apiContext.environmentContext,
        page,
        perPage
      });
      this.logger.debug(`[${response.status}] permit.api.listRoles()`);
      return response.data;
    } catch (err) {
      if (axios2.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.listRoles(), err: ${JSON.stringify(
            (_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data
          )}`
        );
      }
      throw err;
    }
  }
  /**
   * Retrieves a user by ID or key
   * @param userId - The ID or the key of the user.
   * @returns A promise that resolves to a UserRead object representing the user.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.users.get()
   */
  async getUser(userId) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._users.getUser({
        ...this.config.apiContext.environmentContext,
        userId
      });
      this.logger.debug(`[${response.status}] permit.api.getUser(${userId})`);
      return response.data;
    } catch (err) {
      if (axios2.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.getUser(${userId}), err: ${JSON.stringify(
            (_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data
          )}`
        );
      }
      throw err;
    }
  }
  /**
   * Retrieves a tenant by ID or key.
   * @param tenantId - The ID or the key of the tenant.
   * @returns A promise that resolves to a TenantRead object representing the tenant.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.tenants.get()
   */
  async getTenant(tenantId) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._tenants.getTenant({
        ...this.config.apiContext.environmentContext,
        tenantId
      });
      this.logger.debug(`[${response.status}] permit.api.getTenant(${tenantId})`);
      return response.data;
    } catch (err) {
      if (axios2.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.getTenant(${tenantId}), err: ${JSON.stringify(
            (_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data
          )}`
        );
      }
      throw err;
    }
  }
  /**
   * Retrieves a list of tenants.
   * @param page - The page number.
   * @returns A promise that resolves to an array of TenantRead objects representing the tenants.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.tenants.list()
   */
  async listTenants(page) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._tenants.listTenants({
        ...this.config.apiContext.environmentContext,
        page
      });
      this.logger.debug(`[${response.status}] permit.api.listTenants(${page ?? ""})`);
      return response.data;
    } catch (err) {
      if (axios2.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.listTenants(${page ?? ""}), err: ${JSON.stringify(
            (_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data
          )}`
        );
      }
      throw err;
    }
  }
  /**
   * Retrieves a role by ID or key.
   * @param roleId - The ID or the key of the role.
   * @returns A promise that resolves to a RoleRead object representing the role.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.roles.get()
   */
  async getRole(roleId) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._roles.getRole({
        ...this.config.apiContext.environmentContext,
        roleId
      });
      this.logger.debug(`[${response.status}] permit.api.getRole(${roleId})`);
      return response.data;
    } catch (err) {
      if (axios2.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.getRole(${roleId}), err: ${JSON.stringify(
            (_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data
          )}`
        );
      }
      throw err;
    }
  }
  /**
   * Retrieves the assigned roles for a user (either in a single tenant or in all tenants).
   * @param user - The ID or key of the user.
   * @param tenant - The ID or key of the tenant, optional. If provided, only roles assigned within this tenant will be returned.
   * @returns A promise that resolves to an array of RoleAssignmentRead objects representing the assigned roles.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.users.getAssignedRoles()
   */
  async getAssignedRoles(user, tenant) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._roleAssignments.listRoleAssignments({
        ...this.config.apiContext.environmentContext,
        user,
        tenant
      });
      this.logger.debug(
        `[${response.status}] permit.api.getAssignedRoles(${user}, ${tenant ?? "all tenants"})`
      );
      return response.data;
    } catch (err) {
      if (axios2.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.getAssignedRoles(${user}, ${tenant ?? "all tenants"}), err: ${JSON.stringify((_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data)}`
        );
      }
      throw err;
    }
  }
  /**
   * Creates a new resource.
   * @param resource - The resource to create.
   * @returns A promise that resolves to a ResourceRead object representing the created resource.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.resources.create()
   */
  async createResource(resource) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._resources.createResource({
        ...this.config.apiContext.environmentContext,
        resourceCreate: resource
      });
      this.logger.debug(
        `[${response.status}] permit.api.createResource(${JSON.stringify(resource)})`
      );
      return response.data;
    } catch (err) {
      if (axios2.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.createResource(${JSON.stringify(
            resource
          )}), err: ${JSON.stringify((_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data)}`
        );
      }
      throw err;
    }
  }
  /**
   * Updates an existing resource.
   * @param resourceId - The ID or key of the resource to update.
   * @param resource - The updated resource data.
   * @returns A promise that resolves to a ResourceRead object representing the updated resource.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.resources.update()
   */
  async updateResource(resourceId, resource) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._resources.updateResource({
        ...this.config.apiContext.environmentContext,
        resourceId,
        resourceUpdate: resource
      });
      this.logger.debug(
        `[${response.status}] permit.api.updateResource(${resourceId}, ${JSON.stringify(
          resource
        )})`
      );
      return response.data;
    } catch (err) {
      if (axios2.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.updateResource(${resourceId}, ${JSON.stringify(
            resource
          )}), err: ${JSON.stringify((_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data)}`
        );
      }
      throw err;
    }
  }
  /**
   * Deletes a resource.
   * @param resourceId - The ID or key of the resource to delete.
   * @returns A promise that resolves when the resource is deleted.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.resources.delete()
   */
  async deleteResource(resourceId) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._resources.deleteResource({
        ...this.config.apiContext.environmentContext,
        resourceId
      });
      this.logger.debug(`[${response.status}] permit.api.deleteResource(${resourceId})`);
      return response;
    } catch (err) {
      if (axios2.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.deleteResource(${resourceId}), err: ${JSON.stringify((_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data)}`
        );
      }
      throw err;
    }
  }
  /**
   * Creates a new user.
   * @param user - The user to create.
   * @returns A promise that resolves to a UserRead object representing the created user.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.users.create()
   */
  async createUser(user) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._users.createUser({
        ...this.config.apiContext.environmentContext,
        userCreate: user
      });
      this.logger.debug(`[${response.status}] permit.api.createUser(${JSON.stringify(user)})`);
      return response.data;
    } catch (err) {
      if (axios2.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.createUser(${JSON.stringify(
            user
          )}), err: ${JSON.stringify((_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data)}`
        );
      }
      throw err;
    }
  }
  /**
   * Creates or Updates in place a user.
   * @param user - The user to create or update.
   * @returns A promise that resolves to a UserRead object representing the synced user.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.users.sync()
   */
  async syncUser(user) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._users.replaceUser({
        ...this.config.apiContext.environmentContext,
        userId: user.key,
        userCreate: user
      });
      this.logger.debug(`[${response.status}] permit.api.syncUser(${JSON.stringify(user)})`);
      return response.data;
    } catch (err) {
      if (axios2.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.syncUser(${JSON.stringify(
            user
          )}), err: ${JSON.stringify((_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data)}`
        );
      }
      throw err;
    }
  }
  /**
   * Updates an existing user.
   * @param userId - The ID or key of the user to update.
   * @param user - The updated user data.
   * @returns A promise that resolves to a UserRead object representing the updated user.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.users.update()
   */
  async updateUser(userId, user) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._users.updateUser({
        ...this.config.apiContext.environmentContext,
        userId,
        userUpdate: user
      });
      this.logger.debug(`[${response.status}] permit.api.updateUser(${JSON.stringify(user)})`);
      return response.data;
    } catch (err) {
      if (axios2.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.updateUser(${JSON.stringify(
            user
          )}), err: ${JSON.stringify((_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data)}`
        );
      }
      throw err;
    }
  }
  /**
   * Deletes a user.
   * @param userId - The ID or key of the user to delete.
   * @returns A promise that resolves when the user is deleted.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.users.delete()
   */
  async deleteUser(userId) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._users.deleteUser({
        ...this.config.apiContext.environmentContext,
        userId
        // user id or key
      });
      this.logger.debug(`[${response.status}] permit.api.deleteUser(${userId})`);
      return response;
    } catch (err) {
      if (axios2.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.deleteUser(${userId}), err: ${JSON.stringify(
            (_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data
          )}`
        );
      }
      throw err;
    }
  }
  /**
   * Creates a new tenant.
   * @param tenant - The tenant to create.
   * @returns A promise that resolves to a TenantRead object representing the created tenant.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.tenants.create()
   */
  async createTenant(tenant) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._tenants.createTenant({
        ...this.config.apiContext.environmentContext,
        tenantCreate: tenant
      });
      this.logger.debug(`[${response.status}] permit.api.createTenant(${JSON.stringify(tenant)})`);
      return response.data;
    } catch (err) {
      if (axios2.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.createTenant(${JSON.stringify(
            tenant
          )}), err: ${JSON.stringify((_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data)}`
        );
      }
      throw err;
    }
  }
  /**
   * Updates an existing tenant.
   * @param tenantId - The ID or key of the tenant to update.
   * @param tenant - The updated tenant data.
   * @returns A promise that resolves to a TenantRead object representing the updated tenant.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.tenants.update()
   */
  async updateTenant(tenantId, tenant) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._tenants.updateTenant({
        ...this.config.apiContext.environmentContext,
        tenantId,
        tenantUpdate: tenant
      });
      this.logger.debug(
        `[${response.status}] permit.api.updateTenant(${tenantId}, ${JSON.stringify(tenant)})`
      );
      return response.data;
    } catch (err) {
      if (axios2.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.updateTenant(${tenantId}, ${JSON.stringify(
            tenant
          )}), err: ${JSON.stringify((_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data)}`
        );
      }
      throw err;
    }
  }
  /**
   * Deletes a tenant.
   * @param tenantId - The ID or key of the tenant to delete.
   * @returns A promise that resolves when the tenant is deleted.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.tenants.delete()
   */
  async deleteTenant(tenantId) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._tenants.deleteTenant({
        ...this.config.apiContext.environmentContext,
        tenantId
      });
      this.logger.debug(`[${response.status}] permit.api.deleteTenant(${tenantId})`);
      return response;
    } catch (err) {
      if (axios2.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.deleteTenant(${tenantId}), err: ${JSON.stringify(
            (_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data
          )}`
        );
      }
      throw err;
    }
  }
  /**
   * Creates a new role.
   * @param role - The role to create.
   * @returns A promise that resolves to a RoleRead object representing the created role.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.roles.create()
   */
  async createRole(role) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._roles.createRole({
        ...this.config.apiContext.environmentContext,
        roleCreate: role
      });
      this.logger.debug(`[${response.status}] permit.api.createRole(${JSON.stringify(role)})`);
      return response.data;
    } catch (err) {
      if (axios2.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.createRole(${JSON.stringify(
            role
          )}), err: ${JSON.stringify((_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data)}`
        );
      }
      throw err;
    }
  }
  /**
   * Updates an existing role.
   * @param roleId - The ID or key of the role to update.
   * @param role - The updated role data.
   * @returns A promise that resolves to a RoleRead object representing the updated role.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.roles.update()
   */
  async updateRole(roleId, role) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._roles.updateRole({
        ...this.config.apiContext.environmentContext,
        roleId,
        roleUpdate: role
      });
      this.logger.debug(
        `[${response.status}] permit.api.updateRole(${roleId}, ${JSON.stringify(role)})`
      );
      return response.data;
    } catch (err) {
      if (axios2.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.updateRole(${roleId}, ${JSON.stringify(
            role
          )}), err: ${JSON.stringify((_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data)}`
        );
      }
      throw err;
    }
  }
  /**
   * Deletes a role.
   * @param roleId - The ID or key of the role to delete.
   * @returns A promise that resolves when the role is deleted.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.roles.delete()
   */
  async deleteRole(roleId) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._roles.deleteRole({
        ...this.config.apiContext.environmentContext,
        roleId
      });
      this.logger.debug(`[${response.status}] permit.api.deleteRole(${roleId})`);
      return response;
    } catch (err) {
      if (axios2.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.deleteRole(${roleId}), err: ${JSON.stringify(
            (_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data
          )}`
        );
      }
      throw err;
    }
  }
  /**
   * Assigns a role to a user.
   * @param assignedRole - The role assignment data.
   * @returns A promise that resolves to a RoleAssignmentRead object representing the assigned role.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.users.assignRole()
   */
  async assignRole(assignedRole) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._roleAssignments.assignRole({
        ...this.config.apiContext.environmentContext,
        roleAssignmentCreate: assignedRole
      });
      this.logger.debug(
        `[${response.status}] permit.api.assignRole(${JSON.stringify(assignedRole)})`
      );
      return response.data;
    } catch (err) {
      if (axios2.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.assignRole(${JSON.stringify(
            assignedRole
          )}), err: ${JSON.stringify((_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data)}`
        );
      }
      throw err;
    }
  }
  /**
   * Unassigns a role from a user.
   * @param removedRole - The role unassignment data.
   * @returns A promise that resolves when the role is unassigned.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.users.unassignRole()
   */
  async unassignRole(removedRole) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._roleAssignments.unassignRole({
        ...this.config.apiContext.environmentContext,
        roleAssignmentRemove: removedRole
      });
      this.logger.debug(
        `[${response.status}] permit.api.unassignRole(${JSON.stringify(removedRole)})`
      );
      return response;
    } catch (err) {
      if (axios2.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.unassignRole(${JSON.stringify(
            removedRole
          )}), err: ${JSON.stringify((_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data)}`
        );
      }
      throw err;
    }
  }
  /**
   * Creates a new condition set.
   * @param conditionSet - The condition set to create.
   * @returns A promise that resolves to a ConditionSetRead object representing the created condition set.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.conditionSets.create()
   */
  async createConditionSet(conditionSet) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._conditionSets.createConditionSet({
        ...this.config.apiContext.environmentContext,
        conditionSetCreate: conditionSet
      });
      this.logger.debug(
        `[${response.status}] permit.api.createConditionSet(${JSON.stringify(conditionSet)})`
      );
      return response.data;
    } catch (err) {
      if (axios2.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.createConditionSet(${JSON.stringify(
            conditionSet
          )}), err: ${JSON.stringify((_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data)}`
        );
      }
      throw err;
    }
  }
  /**
   * Updates an existing condition set.
   * @param conditionSetId - The ID or key of the condition set to update.
   * @param conditionSet - The updated condition set data.
   * @returns A promise that resolves to a ConditionSetRead object representing the updated condition set.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.conditionSets.update()
   */
  async updateConditionSet(conditionSetId, conditionSet) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._conditionSets.updateConditionSet({
        ...this.config.apiContext.environmentContext,
        conditionSetId,
        conditionSetUpdate: conditionSet
      });
      this.logger.debug(
        `[${response.status}] permit.api.updateConditionSet(${conditionSetId}, ${JSON.stringify(
          conditionSet
        )})`
      );
      return response.data;
    } catch (err) {
      if (axios2.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.updateConditionSet(${conditionSetId}, ${JSON.stringify(
            conditionSet
          )}), err: ${JSON.stringify((_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data)}`
        );
      }
      throw err;
    }
  }
  /**
   * Deletes a condition set.
   * @param conditionSetId - The ID or key of the condition set to delete.
   * @returns A promise that resolves when the condition set is deleted.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.conditionSets.delete()
   */
  async deleteConditionSet(conditionSetId) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._conditionSets.deleteConditionSet({
        ...this.config.apiContext.environmentContext,
        conditionSetId
      });
      this.logger.debug(`[${response.status}] permit.api.deleteConditionSet(${conditionSetId})`);
      return response;
    } catch (err) {
      if (axios2.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.deleteConditionSet(${conditionSetId}), err: ${JSON.stringify(
            (_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data
          )}`
        );
      }
      throw err;
    }
  }
  /**
   * Creates a condition set rule (i.e: grants permission to a userset to act on a resourceset).
   * @param conditionSetRule - The condition set rule data.
   * @returns A promise that resolves to a ConditionSetRuleRead object representing the assigned condition set rule.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.conditionSetRules.create()
   */
  async assignConditionSetRule(conditionSetRule) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._conditionSetRules.assignSetPermissions({
        ...this.config.apiContext.environmentContext,
        conditionSetRuleCreate: conditionSetRule
      });
      this.logger.debug(
        `[${response.status}] permit.api.createConditionSetRule(${JSON.stringify(
          conditionSetRule
        )})`
      );
      return response.data;
    } catch (err) {
      if (axios2.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.createConditionSetRule(${JSON.stringify(
            conditionSetRule
          )}), err: ${JSON.stringify((_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data)}`
        );
      }
      throw err;
    }
  }
  /**
   * Removes a condition set rule (i.e: unassigns permission from a userset to act on a resourceset).
   * @param conditionSetRuleId - The ID or key of the condition set rule to remove.
   * @returns A promise that resolves when the condition set rule is deleted.
   * @throws {@link PermitApiError} If the API returns an error HTTP status code.
   * @throws {@link PermitContextError} If the configured {@link ApiContext} does not match the required endpoint context.
   * @deprecated replaced with permit.api.conditionSetRules.delete()
   */
  async unassignConditionSetRule(conditionSetRule) {
    var _a, _b;
    await this.ensureAccessLevel("ENVIRONMENT_LEVEL_API_KEY" /* ENVIRONMENT_LEVEL_API_KEY */);
    await this.ensureContext(3 /* ENVIRONMENT */);
    try {
      const response = await this._conditionSetRules.unassignSetPermissions({
        ...this.config.apiContext.environmentContext,
        conditionSetRuleRemove: conditionSetRule
      });
      this.logger.debug(
        `[${response.status}] permit.api.deleteConditionSetRule(${JSON.stringify(
          conditionSetRule
        )})`
      );
      return response;
    } catch (err) {
      if (axios2.isAxiosError(err)) {
        this.logger.error(
          `[${(_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status}] permit.api.deleteConditionSetRule(${JSON.stringify(
            conditionSetRule
          )}), err: ${JSON.stringify((_b = err == null ? void 0 : err.response) == null ? void 0 : _b.data)}`
        );
      }
      throw err;
    }
  }
  getMethods() {
    return {
      listUsers: this.listUsers.bind(this),
      listRoles: this.listRoles.bind(this),
      listConditionSets: this.listConditionSets.bind(this),
      listConditionSetsRules: this.listConditionSetsRules.bind(this),
      updateUser: this.updateUser.bind(this),
      getUser: this.getUser.bind(this),
      getTenant: this.getTenant.bind(this),
      getRole: this.getRole.bind(this),
      getAssignedRoles: this.getAssignedRoles.bind(this),
      createResource: this.createResource.bind(this),
      updateResource: this.updateResource.bind(this),
      deleteResource: this.deleteResource.bind(this),
      createUser: this.createUser.bind(this),
      syncUser: this.syncUser.bind(this),
      deleteUser: this.deleteUser.bind(this),
      createTenant: this.createTenant.bind(this),
      updateTenant: this.updateTenant.bind(this),
      deleteTenant: this.deleteTenant.bind(this),
      listTenants: this.listTenants.bind(this),
      createRole: this.createRole.bind(this),
      updateRole: this.updateRole.bind(this),
      deleteRole: this.deleteRole.bind(this),
      assignRole: this.assignRole.bind(this),
      unassignRole: this.unassignRole.bind(this),
      createConditionSet: this.createConditionSet.bind(this),
      updateConditionSet: this.updateConditionSet.bind(this),
      deleteConditionSet: this.deleteConditionSet.bind(this),
      assignConditionSetRule: this.assignConditionSetRule.bind(this),
      unassignConditionSetRule: this.unassignConditionSetRule.bind(this)
    };
  }
};
export {
  DeprecatedApiClient
};
//# sourceMappingURL=deprecated.mjs.map